// xg - http://alteredqualia.com/xg

function getHttpRequest(e, t, a) {
  var r = {
    load: function (e) {
      t(i, e);
    },
    progress: function (e) {
      a(i, e);
    },
  },
    i = new XMLHttpRequest();
  addListeners(i, r), i.open("GET", e, !0), i.send(null);
}
function getJsonRequest(e, t) {
  getHttpRequest(
    e,
    function (e) {
      t(JSON.parse(e.responseText));
    },
    function () { }
  );
}
function addListeners(e, t) {
  for (var a in t) e.addEventListener(a, t[a]);
}
export var XG = XG || { VERSION: "0" };
(XG.elementIndexUintAvailable = !1),
  (XG.CullFaceNone = 0),
  (XG.CullFaceBack = 1),
  (XG.CullFaceFront = 2),
  (XG.CullFaceFrontBack = 3),
  (XG.FrontFaceDirectionCW = 0),
  (XG.FrontFaceDirectionCCW = 1),
  (XG.BasicShadowMap = 0),
  (XG.PCFSoftShadowMap = 1),
  (XG.PCFSoftHQShadowMap = 2),
  (XG.FrontSide = 0),
  (XG.BackSide = 1),
  (XG.DoubleSide = 2),
  (XG.NoBlending = 0),
  (XG.NormalBlending = 1),
  (XG.AdditiveBlending = 2),
  (XG.SubtractiveBlending = 3),
  (XG.MultiplyBlending = 4),
  (XG.CustomBlending = 5),
  (XG.LegacyNormalBlending = 6),
  (XG.AddEquation = 32774),
  (XG.SubtractEquation = 32778),
  (XG.ReverseSubtractEquation = 32779),
  (XG.ZeroFactor = 0),
  (XG.OneFactor = 1),
  (XG.SrcColorFactor = 768),
  (XG.OneMinusSrcColorFactor = 769),
  (XG.SrcAlphaFactor = 770),
  (XG.OneMinusSrcAlphaFactor = 771),
  (XG.DstAlphaFactor = 772),
  (XG.OneMinusDstAlphaFactor = 773),
  (XG.DstColorFactor = 774),
  (XG.OneMinusDstColorFactor = 775),
  (XG.SrcAlphaSaturateFactor = 776),
  (XG.MultiplyOperation = 0),
  (XG.MixOperation = 1),
  (XG.AddOperation = 2),
  (XG.RepeatWrapping = 10497),
  (XG.ClampToEdgeWrapping = 33071),
  (XG.MirroredRepeatWrapping = 33648),
  (XG.NearestFilter = 9728),
  (XG.LinearFilter = 9729),
  (XG.NearestMipMapNearestFilter = 9984),
  (XG.LinearMipMapNearestFilter = 9985),
  (XG.NearestMipMapLinearFilter = 9986),
  (XG.LinearMipMapLinearFilter = 9987),
  (XG.ByteType = 5120),
  (XG.UnsignedByteType = 5121),
  (XG.ShortType = 5122),
  (XG.UnsignedShortType = 5123),
  (XG.IntType = 5124),
  (XG.UnsignedIntType = 5125),
  (XG.FloatType = 5126),
  (XG.HalfFloatType2 = 5131),
  (XG.HalfFloatType1 = 36193),
  (XG.UnsignedShort4444Type = 32819),
  (XG.UnsignedShort5551Type = 32820),
  (XG.UnsignedShort565Type = 33635),
  (XG.DepthComponentFormat = 6402),
  (XG.AlphaFormat = 6406),
  (XG.RGBFormat = 6407),
  (XG.RGBAFormat = 6408),
  (XG.LuminanceFormat = 6409),
  (XG.LuminanceAlphaFormat = 6410),
  (XG.RED = 6403),
  (XG.RGB8 = 32849),
  (XG.RGBA8 = 32856),
  (XG.RGB10_A2 = 32857),
  (XG.RGB10_A2UI = 36975),
  (XG.UNSIGNED_INT_2_10_10_10_REV = 33640),
  (XG.INT_2_10_10_10_REV = 36255),
  (XG.DEPTH_COMPONENT24 = 33190),
  (XG.SRGB = 35904),
  (XG.SRGB8 = 35905),
  (XG.SRGB8_ALPHA8 = 35907),
  (XG.RGBA32F = 34836),
  (XG.RGB32F = 34837),
  (XG.RGBA16F = 34842),
  (XG.RGB16F = 34843),
  (XG.R11F_G11F_B10F = 35898),
  (XG.UNSIGNED_INT_10F_11F_11F_REV = 35899),
  (XG.RGB9_E5 = 35901),
  (XG.UNSIGNED_INT_5_9_9_9_REV = 35902),
  (XG.RGBA32UI = 36208),
  (XG.RGB32UI = 36209),
  (XG.RGBA16UI = 36214),
  (XG.RGB16UI = 36215),
  (XG.RGBA8UI = 36220),
  (XG.RGB8UI = 36221),
  (XG.RGBA32I = 36226),
  (XG.RGB32I = 36227),
  (XG.RGBA16I = 36232),
  (XG.RGB16I = 36233),
  (XG.RGBA8I = 36238),
  (XG.RGB8I = 36239),
  (XG.RED_INTEGER = 36244),
  (XG.RGB_INTEGER = 36248),
  (XG.RGBA_INTEGER = 36249),
  (XG.DEPTH_COMPONENT32F = 36012),
  (XG.DEPTH32F_STENCIL8 = 36013),
  (XG.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269),
  (XG.UNSIGNED_INT_24_8 = 34042),
  (XG.DEPTH24_STENCIL8 = 35056),
  (XG.RG = 33319),
  (XG.RG_INTEGER = 33320),
  (XG.R8 = 33321),
  (XG.RG8 = 33323),
  (XG.R16F = 33325),
  (XG.R32F = 33326),
  (XG.RG16F = 33327),
  (XG.RG32F = 33328),
  (XG.R8I = 33329),
  (XG.R8UI = 33330),
  (XG.R16I = 33331),
  (XG.R16UI = 33332),
  (XG.R32I = 33333),
  (XG.R32UI = 33334),
  (XG.RG8I = 33335),
  (XG.RG8UI = 33336),
  (XG.RG16I = 33337),
  (XG.RG16UI = 33338),
  (XG.RG32I = 33339),
  (XG.RG32UI = 33340),
  (XG.RGB_S3TC_DXT1_Format = 33776),
  (XG.RGBA_S3TC_DXT1_Format = 33777),
  (XG.RGBA_S3TC_DXT3_Format = 33778),
  (XG.RGBA_S3TC_DXT5_Format = 33779),
  (XG.RGB_PVRTC_4BPPV1_Format = 35840),
  (XG.RGB_PVRTC_2BPPV1_Format = 35841),
  (XG.RGBA_PVRTC_4BPPV1_Format = 35842),
  (XG.RGBA_PVRTC_2BPPV1_Format = 35843),
  (XG.RGB_ETC1_Format = 36196),
  (XG.RGB_ATC_Format = 35986),
  (XG.RGBA_ATC_EXPLICIT_ALPHA_Format = 35987),
  (XG.RGBA_ATC_INTERPOLATED_ALPHA_Format = 34798),
  (XG.NoOperator = 0),
  (XG.SimpleOperator = 1),
  (XG.LinearOperator = 2),
  (XG.ReinhardOperator = 3),
  (XG.FilmicOperator = 4),
  (XG.Filmic2015Operator = 5),
  (XG.UnchartedOperator = 6),
  (XG.LumaReinhardOperator = 7),
  (XG.WhitePreservingReinhardOperator = 8),
  (XG.PhotographicOperator = 9),
  (XG.SimpleBRDF = 0),
  (XG.BlinnPhongBRDF = 1),
  (XG.GGXBRDF = 2),
  (XG.xyzOrder = 0),
  (XG.yxzOrder = 1),
  (XG.zxyOrder = 2),
  (XG.zyxOrder = 3),
  (XG.yzxOrder = 4),
  (XG.xzyOrder = 5),
  (XG.DisplaceByNormal = 0),
  (XG.DisplaceByPosition = 1),
  (XG.rgba8Encoding = 0),
  (XG.rgbm8Encoding = 1),
  (XG.rgba16fEncoding = 2),
  (XG.rgba32fEncoding = 3),
  (XG.paramTypedArrayToXG = function (e) {
    var t;
    return (
      e instanceof Float32Array
        ? (t = XG.FloatType)
        : e instanceof Uint32Array
          ? (t = XG.UnsignedIntType)
          : e instanceof Uint16Array
            ? (t = XG.UnsignedShortType)
            : e instanceof Uint8Array
              ? (t = XG.UnsignedByteType)
              : e instanceof Int32Array
                ? (t = XG.IntType)
                : e instanceof Int16Array
                  ? (t = XG.ShortType)
                  : e instanceof Int8Array && (t = XG.ByteType),
      t
    );
  }),
  (XG.paramXGToTypedArray = function (e) {
    var t;
    return (
      e === XG.FloatType
        ? (t = Float32Array)
        : e === XG.UnsignedIntType
          ? (t = Uint32Array)
          : e === XG.UnsignedShortType
            ? (t = Uint16Array)
            : e === XG.UnsignedByteType
              ? (t = Uint8Array)
              : e === XG.IntType
                ? (t = Int32Array)
                : e === XG.ShortType
                  ? (t = Int16Array)
                  : e === XG.ByteType && (t = Int8Array),
      t
    );
  }),
  (XG.Projector = function () {
    var e = new XG.Matrix4();
    (this.projectVector = function (t, a) {
      return (
        a.matrixWorldInverse.getInverse(a.matrixWorld),
        e.multiply(a.projectionMatrix, a.matrixWorldInverse),
        e.multiplyVector3(t),
        t
      );
    }),
      (this.unprojectVector = function (t, a) {
        return (
          a.projectionMatrixInverse.getInverse(a.projectionMatrix),
          e.multiply(a.matrixWorld, a.projectionMatrixInverse),
          e.multiplyVector3(t),
          t
        );
      });
  }),
  (XG.Color = function (e) {
    return void 0 !== e && this.set(e), this;
  }),
  (XG.Color.prototype = {
    constructor: XG.Color,
    r: 1,
    g: 1,
    b: 1,
    copy: function (e) {
      return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
    },
    copyGammaToLinear: function (e) {
      return (
        (this.r = e.r * e.r), (this.g = e.g * e.g), (this.b = e.b * e.b), this
      );
    },
    copyLinearToGamma: function (e) {
      return (
        (this.r = Math.sqrt(e.r)),
        (this.g = Math.sqrt(e.g)),
        (this.b = Math.sqrt(e.b)),
        this
      );
    },
    copyTonemapped: function (e, t, a, r) {
      function i(e) {
        return (
          (e * (o * e + s * n) + l * h) / (e * (o * e + n) + l * d) - h / d
        );
      }
      var o = 0.15,
        n = 0.5,
        s = 0.1,
        l = 0.2,
        h = 0.02,
        d = 0.3,
        c = 11.2,
        u = 1 / 2.2;
      switch (((this.r = e.r * a), (this.g = e.g * a), (this.b = e.b * a), t)) {
        case XG.SimpleOperator:
          (this.r = Math.sqrt(this.r)),
            (this.g = Math.sqrt(this.g)),
            (this.b = Math.sqrt(this.b));
          break;
        case XG.LinearOperator:
          (this.r = Math.pow(this.r, u)),
            (this.g = Math.pow(this.g, u)),
            (this.b = Math.pow(this.b, u));
          break;
        case XG.ReinhardOperator:
          (this.r = this.r / (1 + this.r)),
            (this.g = this.g / (1 + this.g)),
            (this.b = this.b / (1 + this.b)),
            (this.r = Math.pow(this.r, u)),
            (this.g = Math.pow(this.g, u)),
            (this.b = Math.pow(this.b, u));
          break;
        case XG.FilmicOperator:
          var f = Math.max(0, this.r - 0.004),
            p = Math.max(0, this.g - 0.004),
            m = Math.max(0, this.b - 0.004);
          (this.r = (f * (6.2 * f + 0.5)) / (f * (6.2 * f + 1.7) + 0.06)),
            (this.g = (p * (6.2 * p + 0.5)) / (p * (6.2 * p + 1.7) + 0.06)),
            (this.b = (m * (6.2 * m + 0.5)) / (m * (6.2 * m + 1.7) + 0.06));
          break;
        case XG.Filmic2015Operator:
          var v = this.r,
            g = this.g,
            S = this.b,
            x = r,
            G = 1.425 * v + 0.05,
            M = 1.425 * g + 0.05,
            y = 1.425 * S + 0.05,
            w = 1.425 * x + 0.05,
            _ = (v * G + 0.004) / (v * (G + 0.55) + 0.0491) - 0.0821,
            X = (g * M + 0.004) / (g * (M + 0.55) + 0.0491) - 0.0821,
            D = (S * y + 0.004) / (S * (y + 0.55) + 0.0491) - 0.0821,
            T = (x * w + 0.004) / (x * (w + 0.55) + 0.0491) - 0.0821;
          (this.r = _ / T),
            (this.g = X / T),
            (this.b = D / T),
            (this.r = Math.pow(this.r, u)),
            (this.g = Math.pow(this.g, u)),
            (this.b = Math.pow(this.b, u));
          break;
        case XG.UnchartedOperator:
          var C = 2,
            A = i(C * this.r),
            P = i(C * this.g),
            L = i(C * this.b),
            b = 1 / i(c * r);
          (this.r = A * b),
            (this.g = P * b),
            (this.b = L * b),
            (this.r = Math.pow(this.r, u)),
            (this.g = Math.pow(this.g, u)),
            (this.b = Math.pow(this.b, u));
      }
      return this;
    },
    convertGammaToLinear: function () {
      var e = this.r,
        t = this.g,
        a = this.b;
      return (this.r = e * e), (this.g = t * t), (this.b = a * a), this;
    },
    convertLinearToGamma: function () {
      return (
        (this.r = Math.sqrt(this.r)),
        (this.g = Math.sqrt(this.g)),
        (this.b = Math.sqrt(this.b)),
        this
      );
    },
    set: function (e) {
      switch (typeof e) {
        case "number":
          this.setHex(e);
          break;
        case "string":
          this.setStyle(e);
      }
    },
    setRGB: function (e, t, a) {
      return (this.r = e), (this.g = t), (this.b = a), this;
    },
    setHSV: function (e, t, a) {
      var r, i, o, n, s;
      return (
        0 === a
          ? (this.r = this.g = this.b = 0)
          : ((r = Math.floor(6 * e)),
            (i = 6 * e - r),
            (o = a * (1 - t)),
            (n = a * (1 - t * i)),
            (s = a * (1 - t * (1 - i))),
            0 === r
              ? ((this.r = a), (this.g = s), (this.b = o))
              : 1 === r
                ? ((this.r = n), (this.g = a), (this.b = o))
                : 2 === r
                  ? ((this.r = o), (this.g = a), (this.b = s))
                  : 3 === r
                    ? ((this.r = o), (this.g = n), (this.b = a))
                    : 4 === r
                      ? ((this.r = s), (this.g = o), (this.b = a))
                      : 5 === r && ((this.r = a), (this.g = o), (this.b = n))),
        this
      );
    },
    adjustHSV: function (e, t, a) {
      var r = XG.__hsv;
      this.getHSV(r),
        (r.h = XG.Math.clamp(r.h + e, 0, 1)),
        (r.s = XG.Math.clamp(r.s + t, 0, 1)),
        (r.v = XG.Math.clamp(r.v + a, 0, 1)),
        this.setHSV(r.h, r.s, r.v);
    },
    getHex: function () {
      return (
        ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
      );
    },
    setHex: function (e) {
      return (
        (e = Math.floor(e)),
        (this.r = ((e >> 16) & 255) / 255),
        (this.g = ((e >> 8) & 255) / 255),
        (this.b = (255 & e) / 255),
        this
      );
    },
    getHexString: function () {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getStyle: function () {
      return (
        "rgb(" +
        ((255 * this.r) | 0) +
        "," +
        ((255 * this.g) | 0) +
        "," +
        ((255 * this.b) | 0) +
        ")"
      );
    },
    setStyle: function (e) {
      if (/^rgb\((\d+),(\d+),(\d+)\)$/i.test(e)) {
        var t = /^rgb\((\d+),(\d+),(\d+)\)$/i.exec(e);
        return (
          (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
          (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
          (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
          this
        );
      }
      if (/^rgb\((\d+)\%,(\d+)\%,(\d+)\%\)$/i.test(e)) {
        var t = /^rgb\((\d+)\%,(\d+)\%,(\d+)\%\)$/i.exec(e);
        return (
          (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
          (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
          (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
          this
        );
      }
      if (/^\#([0-9a-f]{6})$/i.test(e)) {
        var t = /^\#([0-9a-f]{6})$/i.exec(e);
        return this.setHex(parseInt(t[1], 16)), this;
      }
      if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(e)) {
        var t = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(e);
        return (
          this.setHex(parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3], 16)),
          this
        );
      }
      return /^(\w+)$/i.test(e)
        ? (this.setHex(XG.ColorKeywords[e]), this)
        : void 0;
    },
    getHSV: function (e) {
      var t,
        a,
        r = this.r,
        i = this.g,
        o = this.b,
        n = Math.max(Math.max(r, i), o),
        s = Math.min(Math.min(r, i), o),
        l = n;
      if (s === n) (t = 0), (a = 0);
      else {
        var h = n - s;
        (a = h / n),
          (t =
            r === n
              ? (i - o) / h
              : i === n
                ? 2 + (o - r) / h
                : 4 + (r - i) / h),
          (t /= 6),
          0 > t && (t += 1),
          t > 1 && (t -= 1);
      }
      return (
        void 0 === e && (e = { h: 0, s: 0, v: 0 }),
        (e.h = t),
        (e.s = a),
        (e.v = l),
        e
      );
    },
    copyIntoArray: function (e, t) {
      void 0 === t && (t = 0),
        (e[t] = this.r),
        (e[t + 1] = this.g),
        (e[t + 2] = this.b);
    },
    lerpSelf: function (e, t) {
      return (
        (this.r += (e.r - this.r) * t),
        (this.g += (e.g - this.g) * t),
        (this.b += (e.b - this.b) * t),
        this
      );
    },
    clone: function () {
      return new XG.Color().setRGB(this.r, this.g, this.b);
    },
  }),
  (XG.ColorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  }),
  (XG.__hsv = { h: 0, s: 0, v: 0 }),
  (XG.Math = {
    clamp: function (e, t, a) {
      return t > e ? t : e > a ? a : e;
    },
    clampBottom: function (e, t) {
      return t > e ? t : e;
    },
    mapLinear: function (e, t, a, r, i) {
      return r + ((e - t) * (i - r)) / (a - t);
    },
    randomFloat16: function () {
      return (65280 * Math.random() + 255 * Math.random()) / 65535;
    },
    randomInt: function (e, t) {
      return e + Math.floor(Math.random() * (t - e + 1));
    },
    randomFloat: function (e, t) {
      return e + Math.random() * (t - e);
    },
    randomFloatSpread: function (e) {
      return e * (0.5 - Math.random());
    },
    sign: function (e) {
      return 0 > e ? -1 : e > 0 ? 1 : 0;
    },
    degToRad: function (e) {
      return e * XG.Math.__d2r;
    },
    radToDeg: function (e) {
      return e * XG.Math.__r2d;
    },
    focalLengthToFov: function (e, t) {
      return 2 * Math.atan((0.5 * t) / e);
    },
    fovToFocalLength: function (e, t) {
      return (0.5 * t) / Math.tan(0.5 * e);
    },
    stopToFstop: function (e) {
      return Math.pow(Math.SQRT2, e);
    },
    mapSquareToDisk: function (e, t, a, r, i) {
      var o,
        n,
        s = XG.Math.__pi4;
      e > -t
        ? e > t
          ? ((o = e), (n = s * (t / e)))
          : ((o = t), (n = s * (2 - e / t)))
        : t > e
          ? ((o = -e), (n = s * (4 + t / e)))
          : ((o = -t), (n = 0 !== t ? s * (6 - e / t) : 0)),
        void 0 !== i &&
        (o *=
          Math.cos(Math.PI / i) /
          Math.cos(
            n -
            ((2 * Math.PI) / i) *
            Math.floor((i * n + Math.PI) / (2 * Math.PI))
          ));
      var l = o * Math.cos(n),
        h = o * Math.sin(n);
      return (
        void 0 === a && (a = []),
        void 0 === r && (r = 0),
        (a[r] = l),
        (a[r + 1] = h),
        a
      );
    },
    generateConcentricCircleSamples: function (e, t) {
      for (
        var a = new Array(e * e * 2), r = 0.5 * (e - 1), i = 0, o = -r;
        r >= o;
        o++
      )
        for (var n = -r; r >= n; n++) {
          var s = o / r,
            l = n / r;
          XG.Math.mapSquareToDisk(s, l, a, i, t), (i += 2);
        }
      return a;
    },
    generatePoissonDiscSamples: function (e) {
      for (
        var t = new Array(2 * e),
        a = 1 / e,
        r = 1 - a / 2,
        i = 2.399963229728653,
        o = 0,
        n = 0,
        s = 0;
        e > s;
        s++
      ) {
        var l = Math.sqrt(1 - r),
          h = Math.cos(o) * l,
          d = Math.sin(o) * l;
        (t[n] = h), (t[n + 1] = d), (r -= a), (o += i), (n += 2);
      }
      return t;
    },
    isPowerOfTwo: function (e) {
      return 0 !== e && 0 === (e & (e - 1));
    },
    computeHaltonSeq: function (e, t) {
      for (var a = 0, r = 1, i = t; i > 0;)
        (r /= e), (a += r * (i % e)), (i = Math.floor(i / e));
      return a;
    },
    generateHalton_2_3: function (e) {
      for (var t = [], a = 0, r = e / 2; a != r; a++) {
        var i = XG.Math.computeHaltonSeq(2, a + 1) - 0.5,
          o = XG.Math.computeHaltonSeq(3, a + 1) - 0.5;
        (t[2 * a] = i), (t[2 * a + 1] = o);
      }
      return t;
    },
    convertHalfToFloat: function (e) {
      var t = (32768 & e) >> 15,
        a = (31744 & e) >> 10,
        r = 1023 & e;
      return 0 === a
        ? (t ? -1 : 1) * Math.pow(2, -14) * (r / Math.pow(2, 10))
        : 31 == a
          ? r
            ? 0 / 0
            : (t ? -1 : 1) * (1 / 0)
          : (t ? -1 : 1) * Math.pow(2, a - 15) * (1 + r / Math.pow(2, 10));
    },
  }),
  (XG.Math.__d2r = Math.PI / 180),
  (XG.Math.__r2d = 180 / Math.PI),
  (XG.Math.__pi4 = 0.25 * Math.PI),
  (XG.Quaternion = function (e, t, a, r) {
    (this.data = new Float32Array(4)),
      (this.data[0] = void 0 !== e ? e : 0),
      (this.data[1] = void 0 !== t ? t : 0),
      (this.data[2] = void 0 !== a ? a : 0),
      (this.data[3] = void 0 !== r ? r : 1);
  }),
  (XG.Quaternion.prototype = {
    constructor: XG.Quaternion,
    set: function (e, t, a, r) {
      var i = this.data;
      return (i[0] = e), (i[1] = t), (i[2] = a), (i[3] = r), this;
    },
    setX: function (e) {
      return (this.data[0] = e), this;
    },
    setY: function (e) {
      return (this.data[1] = e), this;
    },
    setZ: function (e) {
      return (this.data[2] = e), this;
    },
    setW: function (e) {
      return (this.data[3] = e), this;
    },
    set x(e) {
      this.data[0] = e;
    },
    set y(e) {
      this.data[1] = e;
    },
    set z(e) {
      this.data[2] = e;
    },
    set w(e) {
      this.data[3] = e;
    },
    get x() {
      return this.data[0];
    },
    get y() {
      return this.data[1];
    },
    get z() {
      return this.data[2];
    },
    get w() {
      return this.data[3];
    },
    copy: function (e) {
      return this.data.set(e.data), this;
    },
    copyIntoArray: function (e, t) {
      void 0 === t && (t = 0), e.set(this.data, t);
    },
    setFromEuler: function (e, t) {
      var a = this.data,
        r = e.data,
        i = Math.cos(r[0] / 2),
        o = Math.cos(r[1] / 2),
        n = Math.cos(r[2] / 2),
        s = Math.sin(r[0] / 2),
        l = Math.sin(r[1] / 2),
        h = Math.sin(r[2] / 2);
      return (
        0 === t || void 0 === t
          ? ((a[0] = s * o * n + i * l * h),
            (a[1] = i * l * n - s * o * h),
            (a[2] = i * o * h + s * l * n),
            (a[3] = i * o * n - s * l * h))
          : 1 === t
            ? ((a[0] = s * o * n + i * l * h),
              (a[1] = i * l * n - s * o * h),
              (a[2] = i * o * h - s * l * n),
              (a[3] = i * o * n + s * l * h))
            : 2 === t
              ? ((a[0] = s * o * n - i * l * h),
                (a[1] = i * l * n + s * o * h),
                (a[2] = i * o * h + s * l * n),
                (a[3] = i * o * n - s * l * h))
              : 3 === t
                ? ((a[0] = s * o * n - i * l * h),
                  (a[1] = i * l * n + s * o * h),
                  (a[2] = i * o * h - s * l * n),
                  (a[3] = i * o * n + s * l * h))
                : 4 === t
                  ? ((a[0] = s * o * n + i * l * h),
                    (a[1] = i * l * n + s * o * h),
                    (a[2] = i * o * h - s * l * n),
                    (a[3] = i * o * n - s * l * h))
                  : 5 === t &&
                  ((a[0] = s * o * n - i * l * h),
                    (a[1] = i * l * n - s * o * h),
                    (a[2] = i * o * h + s * l * n),
                    (a[3] = i * o * n + s * l * h)),
        this
      );
    },
    setFromAxisAngle: function (e, t) {
      var a = this.data,
        r = e.data,
        i = t / 2,
        o = Math.sin(i);
      return (
        (a[0] = r[0] * o),
        (a[1] = r[1] * o),
        (a[2] = r[2] * o),
        (a[3] = Math.cos(i)),
        this
      );
    },
    setFromRotationMatrix: function (e) {
      var t,
        a = this.data,
        r = e.elements,
        i = r[0],
        o = r[4],
        n = r[8],
        s = r[1],
        l = r[5],
        h = r[9],
        d = r[2],
        c = r[6],
        u = r[10],
        f = i + l + u;
      return (
        f > 0
          ? ((t = 0.5 / Math.sqrt(f + 1)),
            (a[0] = (c - h) * t),
            (a[1] = (n - d) * t),
            (a[2] = (s - o) * t),
            (a[3] = 0.25 / t))
          : i > l && i > u
            ? ((t = 2 * Math.sqrt(1 + i - l - u)),
              (a[0] = 0.25 * t),
              (a[1] = (o + s) / t),
              (a[2] = (n + d) / t),
              (a[3] = (c - h) / t))
            : l > u
              ? ((t = 2 * Math.sqrt(1 + l - i - u)),
                (a[0] = (o + s) / t),
                (a[1] = 0.25 * t),
                (a[2] = (h + c) / t),
                (a[3] = (n - d) / t))
              : ((t = 2 * Math.sqrt(1 + u - i - l)),
                (a[0] = (n + d) / t),
                (a[1] = (h + c) / t),
                (a[2] = 0.25 * t),
                (a[3] = (s - o) / t)),
        this
      );
    },
    inverse: function () {
      return this.conjugate().normalize(), this;
    },
    conjugate: function () {
      var e = this.data;
      return (e[0] *= -1), (e[1] *= -1), (e[2] *= -1), this;
    },
    lengthSq: function () {
      var e = this.data;
      return e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3];
    },
    length: function () {
      var e = this.data;
      return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3]);
    },
    normalize: function () {
      var e = this.data,
        t = this.length();
      return (
        0 === t
          ? ((e[0] = 0), (e[1] = 0), (e[2] = 0), (e[3] = 1))
          : ((t = 1 / t),
            (e[0] = e[0] * t),
            (e[1] = e[1] * t),
            (e[2] = e[2] * t),
            (e[3] = e[3] * t)),
        this
      );
    },
    multiply: function (e, t) {
      return this.copy(e), this.multiplySelf(t);
    },
    multiplySelf: function (e) {
      var t = this.data,
        a = e.data,
        r = t[0],
        i = t[1],
        o = t[2],
        n = t[3],
        s = a[0],
        l = a[1],
        h = a[2],
        d = a[3];
      return (
        (t[0] = r * d + n * s + i * h - o * l),
        (t[1] = i * d + n * l + o * s - r * h),
        (t[2] = o * d + n * h + r * l - i * s),
        (t[3] = n * d - r * s - i * l - o * h),
        this
      );
    },
    multiplyVector3: function (e, t) {
      t || (t = e);
      var a = this.data,
        r = e.data,
        i = t.data,
        o = r[0],
        n = r[1],
        s = r[2],
        l = a[0],
        h = a[1],
        d = a[2],
        c = a[3],
        u = c * o + h * s - d * n,
        f = c * n + d * o - l * s,
        p = c * s + l * n - h * o,
        m = -l * o - h * n - d * s;
      return (
        (i[0] = u * c + m * -l + f * -d - p * -h),
        (i[1] = f * c + m * -h + p * -l - u * -d),
        (i[2] = p * c + m * -d + u * -h - f * -l),
        t
      );
    },
    slerpSelf: function (e, t) {
      var a = this.data,
        r = e.data,
        i = a[0],
        o = a[1],
        n = a[2],
        s = a[3],
        l = r[0],
        h = r[1],
        d = r[2],
        c = r[3],
        u = s * c + i * l + o * h + n * d;
      if (
        (0 > u
          ? ((a[0] = -l), (a[1] = -h), (a[2] = -d), (a[3] = -c), (u = -u))
          : this.copy(e),
          u >= 1)
      )
        return (a[0] = i), (a[1] = o), (a[2] = n), (a[3] = s), this;
      var f = Math.sqrt(1 - u * u);
      if (Math.abs(f) < 0.001)
        return (
          (a[0] = 0.5 * (i + a[0])),
          (a[1] = 0.5 * (o + a[1])),
          (a[2] = 0.5 * (n + a[2])),
          (a[3] = 0.5 * (s + a[3])),
          this
        );
      var p = Math.atan2(f, u),
        m = Math.sin((1 - t) * p) / f,
        v = Math.sin(t * p) / f;
      return (
        (a[0] = i * m + a[0] * v),
        (a[1] = o * m + a[1] * v),
        (a[2] = n * m + a[2] * v),
        (a[3] = s * m + a[3] * v),
        this
      );
    },
    equals: function (e) {
      var t = this.data,
        a = e.data;
      return a[0] === t[0] && a[1] === t[1] && a[2] === t[2] && a[3] === t[3];
    },
    clone: function () {
      return new XG.Quaternion().copy(this);
    },
  }),
  (XG.Quaternion.slerp = function (e, t, a, r) {
    return a.copy(e).slerpSelf(t, r);
  }),
  (XG.Vector2 = function (e, t) {
    (this.data = new Float32Array(2)),
      (this.data[0] = void 0 !== e ? e : 0),
      (this.data[1] = void 0 !== t ? t : 0);
  }),
  (XG.Vector2.prototype = {
    constructor: XG.Vector2,
    set: function (e, t) {
      var a = this.data;
      return (a[0] = e), (a[1] = t), this;
    },
    setX: function (e) {
      return (this.data[0] = e), this;
    },
    setY: function (e) {
      return (this.data[1] = e), this;
    },
    set x(e) {
      this.data[0] = e;
    },
    set y(e) {
      this.data[1] = e;
    },
    get x() {
      return this.data[0];
    },
    get y() {
      return this.data[1];
    },
    copy: function (e) {
      return this.data.set(e.data), this;
    },
    copyIntoArray: function (e, t) {
      void 0 === t && (t = 0), e.set(this.data, t);
    },
    addScalar: function (e) {
      var t = this.data;
      return (t[0] += e), (t[1] += e), this;
    },
    add: function (e, t) {
      var a = this.data,
        r = e.data,
        i = t.data;
      return (a[0] = r[0] + i[0]), (a[1] = r[1] + i[1]), this;
    },
    addSelf: function (e) {
      var t = this.data,
        a = e.data;
      return (t[0] += a[0]), (t[1] += a[1]), this;
    },
    sub: function (e, t) {
      var a = this.data,
        r = e.data,
        i = t.data;
      return (a[0] = r[0] - i[0]), (a[1] = r[1] - i[1]), this;
    },
    subSelf: function (e) {
      var t = this.data,
        a = e.data;
      return (t[0] -= a[0]), (t[1] -= a[1]), this;
    },
    multiplyScalar: function (e) {
      var t = this.data;
      return (t[0] *= e), (t[1] *= e), this;
    },
    divideScalar: function (e) {
      var t = this.data;
      return (
        0 !== e ? ((t[0] /= e), (t[1] /= e)) : ((t[0] = 0), (t[1] = 0)), this
      );
    },
    negate: function () {
      return this.multiplyScalar(-1);
    },
    dot: function (e) {
      var t = this.data,
        a = e.data;
      return t[0] * a[0] + t[1] * a[1];
    },
    lengthSq: function () {
      var e = this.data;
      return e[0] * e[0] + e[1] * e[1];
    },
    length: function () {
      var e = this.data;
      return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
    },
    normalize: function () {
      return this.divideScalar(this.length());
    },
    distanceTo: function (e) {
      return Math.sqrt(this.distanceToSquared(e));
    },
    distanceToSquared: function (e) {
      var t = this.data,
        a = e.data,
        r = t[0] - a[0],
        i = t[1] - a[1];
      return r * r + i * i;
    },
    setLength: function (e) {
      var t = this.length();
      return 0 !== t && e !== t && this.multiplyScalar(e / t), this;
    },
    lerpSelf: function (e, t) {
      var a = this.data,
        r = e.data;
      return (a[0] += (r[0] - a[0]) * t), (a[1] += (r[1] - a[1]) * t), this;
    },
    equals: function (e) {
      var t = this.data,
        a = e.data;
      return a[0] === t[0] && a[1] === t[1];
    },
    clone: function () {
      return new XG.Vector2().copy(this);
    },
  }),
  (XG.Vector3 = function (e, t, a) {
    (this.data = new Float32Array(3)),
      (this.data[0] = void 0 !== e ? e : 0),
      (this.data[1] = void 0 !== t ? t : 0),
      (this.data[2] = void 0 !== a ? a : 0);
  }),
  (XG.Vector3.prototype = {
    constructor: XG.Vector3,
    set: function (e, t, a) {
      var r = this.data;
      return (r[0] = e), (r[1] = t), (r[2] = a), this;
    },
    setX: function (e) {
      return (this.data[0] = e), this;
    },
    setY: function (e) {
      return (this.data[1] = e), this;
    },
    setZ: function (e) {
      return (this.data[2] = e), this;
    },
    set x(e) {
      this.data[0] = e;
    },
    set y(e) {
      this.data[1] = e;
    },
    set z(e) {
      this.data[2] = e;
    },
    get x() {
      return this.data[0];
    },
    get y() {
      return this.data[1];
    },
    get z() {
      return this.data[2];
    },
    copy: function (e) {
      return this.data.set(e.data), this;
    },
    copyIntoArray: function (e, t) {
      void 0 === t && (t = 0), e.set(this.data, t);
    },
    add: function (e, t) {
      var a = this.data,
        r = e.data,
        i = t.data;
      return (
        (a[0] = r[0] + i[0]), (a[1] = r[1] + i[1]), (a[2] = r[2] + i[2]), this
      );
    },
    addSelf: function (e) {
      var t = this.data,
        a = e.data;
      return (t[0] += a[0]), (t[1] += a[1]), (t[2] += a[2]), this;
    },
    addScalar: function (e) {
      var t = this.data;
      return (t[0] += e), (t[1] += e), (t[2] += e), this;
    },
    sub: function (e, t) {
      var a = this.data,
        r = e.data,
        i = t.data;
      return (
        (a[0] = r[0] - i[0]), (a[1] = r[1] - i[1]), (a[2] = r[2] - i[2]), this
      );
    },
    subSelf: function (e) {
      var t = this.data,
        a = e.data;
      return (t[0] -= a[0]), (t[1] -= a[1]), (t[2] -= a[2]), this;
    },
    multiply: function (e, t) {
      var a = this.data,
        r = e.data,
        i = t.data;
      return (
        (a[0] = r[0] * i[0]), (a[1] = r[1] * i[1]), (a[2] = r[2] * i[2]), this
      );
    },
    multiplySelf: function (e) {
      var t = this.data,
        a = e.data;
      return (t[0] *= a[0]), (t[1] *= a[1]), (t[2] *= a[2]), this;
    },
    multiplyScalar: function (e) {
      var t = this.data;
      return (t[0] *= e), (t[1] *= e), (t[2] *= e), this;
    },
    divideSelf: function (e) {
      var t = this.data,
        a = e.data;
      return (t[0] /= a[0]), (t[1] /= a[1]), (t[2] /= a[2]), this;
    },
    divideScalar: function (e) {
      var t = this.data;
      return (
        0 !== e
          ? ((t[0] /= e), (t[1] /= e), (t[2] /= e))
          : ((t[0] = 0), (t[1] = 0), (t[2] = 0)),
        this
      );
    },
    negate: function () {
      return this.multiplyScalar(-1);
    },
    dot: function (e) {
      var t = this.data,
        a = e.data;
      return t[0] * a[0] + t[1] * a[1] + t[2] * a[2];
    },
    lengthSq: function () {
      var e = this.data;
      return e[0] * e[0] + e[1] * e[1] + e[2] * e[2];
    },
    length: function () {
      var e = this.data;
      return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
    },
    lengthManhattan: function () {
      var e = this.data;
      return Math.abs(e[0]) + Math.abs(e[1]) + Math.abs(e[2]);
    },
    normalize: function () {
      return this.divideScalar(this.length());
    },
    setLength: function (e) {
      var t = this.length();
      return 0 !== t && e !== t && this.multiplyScalar(e / t), this;
    },
    cross: function (e, t) {
      var a = this.data,
        r = e.data,
        i = t.data;
      return (
        (a[0] = r[1] * i[2] - r[2] * i[1]),
        (a[1] = r[2] * i[0] - r[0] * i[2]),
        (a[2] = r[0] * i[1] - r[1] * i[0]),
        this
      );
    },
    crossSelf: function (e) {
      var t = this.data,
        a = e.data,
        r = t[0],
        i = t[1],
        o = t[2];
      return (
        (t[0] = i * a[2] - o * a[1]),
        (t[1] = o * a[0] - r * a[2]),
        (t[2] = r * a[1] - i * a[0]),
        this
      );
    },
    minSelf: function (e) {
      var t = this.data,
        a = e.data;
      return (
        (t[0] = Math.min(t[0], a[0])),
        (t[1] = Math.min(t[1], a[1])),
        (t[2] = Math.min(t[2], a[2])),
        this
      );
    },
    maxSelf: function (e) {
      var t = this.data,
        a = e.data;
      return (
        (t[0] = Math.max(t[0], a[0])),
        (t[1] = Math.max(t[1], a[1])),
        (t[2] = Math.max(t[2], a[2])),
        this
      );
    },
    angleTo: function (e) {
      return Math.acos(this.dot(e) / this.length() / e.length());
    },
    distanceTo: function (e) {
      return Math.sqrt(this.distanceToSquared(e));
    },
    distanceToSquared: function (e) {
      var t = this.data,
        a = e.data,
        r = t[0] - a[0],
        i = t[1] - a[1],
        o = t[2] - a[2];
      return r * r + i * i + o * o;
    },
    getPositionFromMatrix: function (e) {
      var t = this.data;
      return (
        (t[0] = e.elements[12]),
        (t[1] = e.elements[13]),
        (t[2] = e.elements[14]),
        this
      );
    },
    setEulerFromRotationMatrix: function (e, t) {
      var a = this.data,
        r = XG.Math.clamp,
        i = e.elements,
        o = i[0],
        n = i[4],
        s = i[8],
        l = i[1],
        h = i[5],
        d = i[9],
        c = i[2],
        u = i[6],
        f = i[10];
      return (
        0 === t || void 0 === t
          ? ((a[1] = Math.asin(r(s, -1, 1))),
            Math.abs(s) < 0.99999
              ? ((a[0] = Math.atan2(-d, f)), (a[2] = Math.atan2(-n, o)))
              : ((a[0] = Math.atan2(u, h)), (a[2] = 0)))
          : 1 === t
            ? ((a[0] = Math.asin(-r(d, -1, 1))),
              Math.abs(d) < 0.99999
                ? ((a[1] = Math.atan2(s, f)), (a[2] = Math.atan2(l, h)))
                : ((a[1] = Math.atan2(-c, o)), (a[2] = 0)))
            : 2 === t
              ? ((a[0] = Math.asin(r(u, -1, 1))),
                Math.abs(u) < 0.99999
                  ? ((a[1] = Math.atan2(-c, f)), (a[2] = Math.atan2(-n, h)))
                  : ((a[1] = 0), (a[2] = Math.atan2(l, o))))
              : 3 === t
                ? ((a[1] = Math.asin(-r(c, -1, 1))),
                  Math.abs(c) < 0.99999
                    ? ((a[0] = Math.atan2(u, f)), (a[2] = Math.atan2(l, o)))
                    : ((a[0] = 0), (a[2] = Math.atan2(-n, h))))
                : 4 === t
                  ? ((a[2] = Math.asin(r(l, -1, 1))),
                    Math.abs(l) < 0.99999
                      ? ((a[0] = Math.atan2(-d, h)), (a[1] = Math.atan2(-c, o)))
                      : ((a[0] = 0), (a[1] = Math.atan2(s, f))))
                  : 5 === t &&
                  ((a[2] = Math.asin(-r(n, -1, 1))),
                    Math.abs(n) < 0.99999
                      ? ((a[0] = Math.atan2(u, h)), (a[1] = Math.atan2(s, o)))
                      : ((a[0] = Math.atan2(-d, f)), (a[1] = 0))),
        this
      );
    },
    setEulerFromQuaternion: function (e, t) {
      var a = XG.Math.clamp,
        r = this.data,
        i = e.data[0],
        o = e.data[1],
        n = e.data[2],
        s = e.data[3],
        l = i * i,
        h = o * o,
        d = n * n,
        c = s * s;
      return (
        0 === t || void 0 === t
          ? ((r[0] = Math.atan2(2 * (i * s - o * n), c - l - h + d)),
            (r[1] = Math.asin(a(2 * (i * n + o * s), -1, 1))),
            (r[2] = Math.atan2(2 * (n * s - i * o), c + l - h - d)))
          : 1 === t
            ? ((r[0] = Math.asin(a(2 * (i * s - o * n), -1, 1))),
              (r[1] = Math.atan2(2 * (i * n + o * s), c - l - h + d)),
              (r[2] = Math.atan2(2 * (i * o + n * s), c - l + h - d)))
            : 2 === t
              ? ((r[0] = Math.asin(a(2 * (i * s + o * n), -1, 1))),
                (r[1] = Math.atan2(2 * (o * s - n * i), c - l - h + d)),
                (r[2] = Math.atan2(2 * (n * s - i * o), c - l + h - d)))
              : 3 === t
                ? ((r[0] = Math.atan2(2 * (i * s + n * o), c - l - h + d)),
                  (r[1] = Math.asin(a(2 * (o * s - i * n), -1, 1))),
                  (r[2] = Math.atan2(2 * (i * o + n * s), c + l - h - d)))
                : 4 === t
                  ? ((r[0] = Math.atan2(2 * (i * s - n * o), c - l + h - d)),
                    (r[1] = Math.atan2(2 * (o * s - i * n), c + l - h - d)),
                    (r[2] = Math.asin(a(2 * (i * o + n * s), -1, 1))))
                  : 5 === t &&
                  ((r[0] = Math.atan2(2 * (i * s + o * n), c - l + h - d)),
                    (r[1] = Math.atan2(2 * (i * n + o * s), c + l - h - d)),
                    (r[2] = Math.asin(a(2 * (n * s - i * o), -1, 1)))),
        this
      );
    },
    getScaleFromMatrix: function (e) {
      var t = this.data,
        a = this.set(e.elements[0], e.elements[1], e.elements[2]).length(),
        r = this.set(e.elements[4], e.elements[5], e.elements[6]).length(),
        i = this.set(e.elements[8], e.elements[9], e.elements[10]).length();
      return (t[0] = a), (t[1] = r), (t[2] = i), this;
    },
    projectOnVector: function (e) {
      var t = XG.Vector3.__v1;
      t.copy(e), t.normalize();
      var a = this.dot(t);
      return this.copy(t), this.multiplyScalar(a), this;
    },
    reflect: function (e) {
      var t = XG.Vector3.__v2;
      return (
        t.copy(this),
        t.projectOnVector(e),
        t.multiplyScalar(2),
        this.sub(t, this),
        this
      );
    },
    equals: function (e) {
      var t = this.data,
        a = e.data;
      return a[0] === t[0] && a[1] === t[1] && a[2] === t[2];
    },
    clone: function () {
      return new XG.Vector3().copy(this);
    },
  }),
  (XG.Vector3.xAxis = new XG.Vector3(1, 0, 0)),
  (XG.Vector3.yAxis = new XG.Vector3(0, 1, 0)),
  (XG.Vector3.zAxis = new XG.Vector3(0, 0, 1)),
  (XG.Vector3.__v1 = new XG.Vector3()),
  (XG.Vector3.__v2 = new XG.Vector3()),
  (XG.Vector4 = function (e, t, a, r) {
    (this.data = new Float32Array(4)),
      (this.data[0] = void 0 !== e ? e : 0),
      (this.data[1] = void 0 !== t ? t : 0),
      (this.data[2] = void 0 !== a ? a : 0),
      (this.data[3] = void 0 !== r ? r : 1);
  }),
  (XG.Vector4.prototype = {
    constructor: XG.Vector4,
    set: function (e, t, a, r) {
      var i = this.data;
      return (i[0] = e), (i[1] = t), (i[2] = a), (i[3] = r), this;
    },
    setRGBA: function (e, t) {
      var a = this.data;
      return (a[0] = e.r), (a[1] = e.g), (a[2] = e.b), (a[3] = t), this;
    },
    setRGBAGamma: function (e, t) {
      var a = this.data,
        r = e.r,
        i = e.g,
        o = e.b;
      return (a[0] = r * r), (a[1] = i * i), (a[2] = o * o), (a[3] = t), this;
    },
    setX: function (e) {
      return (this.data[0] = e), this;
    },
    setY: function (e) {
      return (this.data[1] = e), this;
    },
    setZ: function (e) {
      return (this.data[2] = e), this;
    },
    setW: function (e) {
      return (this.data[3] = e), this;
    },
    set x(e) {
      this.data[0] = e;
    },
    set y(e) {
      this.data[1] = e;
    },
    set z(e) {
      this.data[2] = e;
    },
    set w(e) {
      this.data[3] = e;
    },
    get x() {
      return this.data[0];
    },
    get y() {
      return this.data[1];
    },
    get z() {
      return this.data[2];
    },
    get w() {
      return this.data[3];
    },
    copy: function (e) {
      return this.data.set(e.data), this;
    },
    copyIntoArray: function (e, t) {
      void 0 === t && (t = 0), e.set(this.data, t);
    },
    addScalar: function (e) {
      var t = this.data;
      return (t[0] += e), (t[1] += e), (t[2] += e), (t[3] += e), this;
    },
    add: function (e, t) {
      var a = this.data,
        r = e.data,
        i = t.data;
      return (
        (a[0] = r[0] + i[0]),
        (a[1] = r[1] + i[1]),
        (a[2] = r[2] + i[2]),
        (a[3] = r[3] + i[3]),
        this
      );
    },
    addSelf: function (e) {
      var t = this.data,
        a = e.data;
      return (
        (t[0] += a[0]), (t[1] += a[1]), (t[2] += a[2]), (t[3] += a[3]), this
      );
    },
    sub: function (e, t) {
      var a = this.data,
        r = e.data,
        i = t.data;
      return (
        (a[0] = r[0] - i[0]),
        (a[1] = r[1] - i[1]),
        (a[2] = r[2] - i[2]),
        (a[3] = r[3] - i[3]),
        this
      );
    },
    subSelf: function (e) {
      var t = this.data,
        a = e.data;
      return (
        (t[0] -= a[0]), (t[1] -= a[1]), (t[2] -= a[2]), (t[3] -= a[3]), this
      );
    },
    multiplyScalar: function (e) {
      var t = this.data;
      return (t[0] *= e), (t[1] *= e), (t[2] *= e), (t[3] *= e), this;
    },
    divideScalar: function (e) {
      var t = this.data;
      return (
        0 !== e
          ? ((t[0] /= e), (t[1] /= e), (t[2] /= e), (t[3] /= e))
          : ((t[0] = 0), (t[1] = 0), (t[2] = 0), (t[3] = 0)),
        this
      );
    },
    negate: function () {
      return this.multiplyScalar(-1);
    },
    dot: function (e) {
      var t = this.data,
        a = e.data;
      return t[0] * a[0] + t[1] * a[1] + t[2] * a[2] + t[3] * a[3];
    },
    lengthSq: function () {
      var e = this.data;
      return e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3];
    },
    length: function () {
      var e = this.data;
      return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3]);
    },
    lengthManhattan: function () {
      var e = this.data;
      return Math.abs(e[0]) + Math.abs(e[1]) + Math.abs(e[2]) + Math.abs(e[3]);
    },
    normalize: function () {
      return this.divideScalar(this.length());
    },
    setLength: function (e) {
      var t = this.length();
      return 0 !== t && e !== t && this.multiplyScalar(e / t), this;
    },
    lerpSelf: function (e, t) {
      var a = this.data,
        r = e.data;
      return (
        (a[0] += (r[0] - a[0]) * t),
        (a[1] += (r[1] - a[1]) * t),
        (a[2] += (r[2] - a[2]) * t),
        (a[3] += (r[3] - a[3]) * t),
        this
      );
    },
    equals: function (e) {
      var t = this.data,
        a = e.data;
      return a[0] === t[0] && a[1] === t[1] && a[2] === t[2] && a[3] === t[3];
    },
    clone: function () {
      return new XG.Vector4().copy(this);
    },
    setAxisAngleFromQuaternion: function (e) {
      var t = e.data[0],
        a = e.data[1],
        r = e.data[2],
        i = e.data[3];
      this.data[3] = 2 * Math.acos(i);
      var o = Math.sqrt(1 - i * i);
      return (
        1e-4 > o
          ? ((this.data[0] = 1), (this.data[1] = 0), (this.data[2] = 0))
          : ((this.data[0] = t / o),
            (this.data[1] = a / o),
            (this.data[2] = r / o)),
        this
      );
    },
    setAxisAngleFromRotationMatrix: function (e) {
      var t,
        a,
        r,
        i,
        o = 0.01,
        n = 0.1,
        s = e.elements,
        l = s[0],
        h = s[4],
        d = s[8],
        c = s[1],
        u = s[5],
        f = s[9],
        p = s[2],
        m = s[6],
        v = s[10];
      if (Math.abs(h - c) < o && Math.abs(d - p) < o && Math.abs(f - m) < o) {
        if (
          Math.abs(h + c) < n &&
          Math.abs(d + p) < n &&
          Math.abs(f + m) < n &&
          Math.abs(l + u + v - 3) < n
        )
          return this.set(1, 0, 0, 0), this;
        t = Math.PI;
        var g = (l + 1) / 2,
          S = (u + 1) / 2,
          x = (v + 1) / 2,
          G = (h + c) / 4,
          M = (d + p) / 4,
          y = (f + m) / 4;
        return (
          g > S && g > x
            ? o > g
              ? ((a = 0), (r = 0.707106781), (i = 0.707106781))
              : ((a = Math.sqrt(g)), (r = G / a), (i = M / a))
            : S > x
              ? o > S
                ? ((a = 0.707106781), (r = 0), (i = 0.707106781))
                : ((r = Math.sqrt(S)), (a = G / r), (i = y / r))
              : o > x
                ? ((a = 0.707106781), (r = 0.707106781), (i = 0))
                : ((i = Math.sqrt(x)), (a = M / i), (r = y / i)),
          this.set(a, r, i, t),
          this
        );
      }
      var w = Math.sqrt(
        (m - f) * (m - f) + (d - p) * (d - p) + (c - h) * (c - h)
      );
      return (
        Math.abs(w) < 0.001 && (w = 1),
        (this.data[0] = (m - f) / w),
        (this.data[1] = (d - p) / w),
        (this.data[2] = (c - h) / w),
        (this.data[3] = Math.acos((l + u + v - 1) / 2)),
        this
      );
    },
  }),
  (XG.Matrix3 = function (e, t, a, r, i, o, n, s, l) {
    (this.elements = new Float32Array(9)),
      this.set(
        void 0 !== e ? e : 1,
        t || 0,
        a || 0,
        r || 0,
        void 0 !== i ? i : 1,
        o || 0,
        n || 0,
        s || 0,
        void 0 !== l ? l : 1
      );
  }),
  (XG.Matrix3.prototype = {
    constructor: XG.Matrix3,
    set: function (e, t, a, r, i, o, n, s, l) {
      var h = this.elements;
      return (
        (h[0] = e),
        (h[3] = t),
        (h[6] = a),
        (h[1] = r),
        (h[4] = i),
        (h[7] = o),
        (h[2] = n),
        (h[5] = s),
        (h[8] = l),
        this
      );
    },
    identity: function () {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    },
    copy: function (e) {
      return this.elements.set(e.elements), this;
    },
    multiplyVector3: function (e) {
      var t = this.elements,
        a = e.data,
        r = a[0],
        i = a[1],
        o = a[2];
      return (
        (a[0] = t[0] * r + t[3] * i + t[6] * o),
        (a[1] = t[1] * r + t[4] * i + t[7] * o),
        (a[2] = t[2] * r + t[5] * i + t[8] * o),
        e
      );
    },
    multiplyVector3Array: function (e, t, a) {
      var r = XG.Matrix3.__v1,
        i = r.data;
      void 0 === t && (t = 0), void 0 === a && (a = e.length);
      for (var o = t; a > o; o += 3)
        (i[0] = e[o]),
          (i[1] = e[o + 1]),
          (i[2] = e[o + 2]),
          this.multiplyVector3(r),
          e.set(i, o);
      return e;
    },
    multiplyScalar: function (e) {
      var t = this.elements;
      return (
        (t[0] *= e),
        (t[3] *= e),
        (t[6] *= e),
        (t[1] *= e),
        (t[4] *= e),
        (t[7] *= e),
        (t[2] *= e),
        (t[5] *= e),
        (t[8] *= e),
        this
      );
    },
    getInverse: function (e) {
      var t = e.elements,
        a = this.elements;
      (a[0] = t[10] * t[5] - t[6] * t[9]),
        (a[1] = -t[10] * t[1] + t[2] * t[9]),
        (a[2] = t[6] * t[1] - t[2] * t[5]),
        (a[3] = -t[10] * t[4] + t[6] * t[8]),
        (a[4] = t[10] * t[0] - t[2] * t[8]),
        (a[5] = -t[6] * t[0] + t[2] * t[4]),
        (a[6] = t[9] * t[4] - t[5] * t[8]),
        (a[7] = -t[9] * t[0] + t[1] * t[8]),
        (a[8] = t[5] * t[0] - t[1] * t[4]);
      var r = t[0] * a[0] + t[1] * a[3] + t[2] * a[6];
      return 0 === r
        ? (console.warn(
          "Matrix3.getInverse(): can't invert matrix, determinant is 0"
        ),
          this.identity(),
          this)
        : (this.multiplyScalar(1 / r), this);
    },
    transpose: function () {
      var e,
        t = this.elements;
      return (
        (e = t[1]),
        (t[1] = t[3]),
        (t[3] = e),
        (e = t[2]),
        (t[2] = t[6]),
        (t[6] = e),
        (e = t[5]),
        (t[5] = t[7]),
        (t[7] = e),
        this
      );
    },
    transposeIntoArray: function (e) {
      var t = this.elements;
      return (
        (e[0] = t[0]),
        (e[1] = t[3]),
        (e[2] = t[6]),
        (e[3] = t[1]),
        (e[4] = t[4]),
        (e[5] = t[7]),
        (e[6] = t[2]),
        (e[7] = t[5]),
        (e[8] = t[8]),
        this
      );
    },
    getNormalMatrix: function (e) {
      return this.getInverse(e).transpose(), this;
    },
    clone: function () {
      return new XG.Matrix3().copy(this);
    },
  }),
  (XG.Matrix3.__v1 = new XG.Vector3()),
  (XG.Matrix4 = function (e, t, a, r, i, o, n, s, l, h, d, c, u, f, p, m) {
    (this.elements = new Float32Array(16)),
      this.set(
        void 0 !== e ? e : 1,
        t || 0,
        a || 0,
        r || 0,
        i || 0,
        void 0 !== o ? o : 1,
        n || 0,
        s || 0,
        l || 0,
        h || 0,
        void 0 !== d ? d : 1,
        c || 0,
        u || 0,
        f || 0,
        p || 0,
        void 0 !== m ? m : 1
      );
  }),
  (XG.Matrix4.prototype = {
    constructor: XG.Matrix4,
    set: function (e, t, a, r, i, o, n, s, l, h, d, c, u, f, p, m) {
      var v = this.elements;
      return (
        (v[0] = e),
        (v[4] = t),
        (v[8] = a),
        (v[12] = r),
        (v[1] = i),
        (v[5] = o),
        (v[9] = n),
        (v[13] = s),
        (v[2] = l),
        (v[6] = h),
        (v[10] = d),
        (v[14] = c),
        (v[3] = u),
        (v[7] = f),
        (v[11] = p),
        (v[15] = m),
        this
      );
    },
    identity: function () {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    copy: function (e) {
      return this.elements.set(e.elements), this;
    },
    setRotationFromEuler: function (e, t) {
      var a = this.elements,
        r = e.data,
        i = r[0],
        o = r[1],
        n = r[2],
        s = Math.cos(i),
        l = Math.sin(i),
        h = Math.cos(o),
        d = Math.sin(o),
        c = Math.cos(n),
        u = Math.sin(n);
      if (0 === t || void 0 === t) {
        var f = s * c,
          p = s * u,
          m = l * c,
          v = l * u;
        (a[0] = h * c),
          (a[4] = -h * u),
          (a[8] = d),
          (a[1] = p + m * d),
          (a[5] = f - v * d),
          (a[9] = -l * h),
          (a[2] = v - f * d),
          (a[6] = m + p * d),
          (a[10] = s * h);
      } else if (1 === t) {
        var g = h * c,
          S = h * u,
          x = d * c,
          G = d * u;
        (a[0] = g + G * l),
          (a[4] = x * l - S),
          (a[8] = s * d),
          (a[1] = s * u),
          (a[5] = s * c),
          (a[9] = -l),
          (a[2] = S * l - x),
          (a[6] = G + g * l),
          (a[10] = s * h);
      } else if (2 === t) {
        var g = h * c,
          S = h * u,
          x = d * c,
          G = d * u;
        (a[0] = g - G * l),
          (a[4] = -s * u),
          (a[8] = x + S * l),
          (a[1] = S + x * l),
          (a[5] = s * c),
          (a[9] = G - g * l),
          (a[2] = -s * d),
          (a[6] = l),
          (a[10] = s * h);
      } else if (3 === t) {
        var f = s * c,
          p = s * u,
          m = l * c,
          v = l * u;
        (a[0] = h * c),
          (a[4] = m * d - p),
          (a[8] = f * d + v),
          (a[1] = h * u),
          (a[5] = v * d + f),
          (a[9] = p * d - m),
          (a[2] = -d),
          (a[6] = l * h),
          (a[10] = s * h);
      } else if (4 === t) {
        var M = s * h,
          y = s * d,
          w = l * h,
          _ = l * d;
        (a[0] = h * c),
          (a[4] = _ - M * u),
          (a[8] = w * u + y),
          (a[1] = u),
          (a[5] = s * c),
          (a[9] = -l * c),
          (a[2] = -d * c),
          (a[6] = y * u + w),
          (a[10] = M - _ * u);
      } else if (5 === t) {
        var M = s * h,
          y = s * d,
          w = l * h,
          _ = l * d;
        (a[0] = h * c),
          (a[4] = -u),
          (a[8] = d * c),
          (a[1] = M * u + _),
          (a[5] = s * c),
          (a[9] = y * u - w),
          (a[2] = w * u - y),
          (a[6] = l * c),
          (a[10] = _ * u + M);
      }
      return this;
    },
    setRotationFromQuaternion: function (e) {
      var t = this.elements,
        a = e.data,
        r = a[0],
        i = a[1],
        o = a[2],
        n = a[3],
        s = r + r,
        l = i + i,
        h = o + o,
        d = r * s,
        c = r * l,
        u = r * h,
        f = i * l,
        p = i * h,
        m = o * h,
        v = n * s,
        g = n * l,
        S = n * h;
      return (
        (t[0] = 1 - (f + m)),
        (t[4] = c - S),
        (t[8] = u + g),
        (t[1] = c + S),
        (t[5] = 1 - (d + m)),
        (t[9] = p - v),
        (t[2] = u - g),
        (t[6] = p + v),
        (t[10] = 1 - (d + f)),
        this
      );
    },
    lookAt: function (e, t, a) {
      var r = this.elements,
        i = XG.Matrix4.__v1,
        o = XG.Matrix4.__v2,
        n = XG.Matrix4.__v3;
      n.sub(e, t).normalize(),
        0 === n.length() && (n.data[2] = 1),
        i.cross(a, n).normalize(),
        0 === i.length() && ((n.data[0] += 1e-4), i.cross(a, n).normalize()),
        o.cross(n, i);
      var s = i.data,
        l = o.data,
        h = n.data;
      return (
        (r[0] = s[0]),
        (r[4] = l[0]),
        (r[8] = h[0]),
        (r[1] = s[1]),
        (r[5] = l[1]),
        (r[9] = h[1]),
        (r[2] = s[2]),
        (r[6] = l[2]),
        (r[10] = h[2]),
        this
      );
    },
    addSelf: function (e) {
      var t = this.elements,
        a = e.elements;
      return (
        (t[0] += a[0]),
        (t[4] += a[4]),
        (t[8] += a[8]),
        (t[12] += a[12]),
        (t[1] += a[1]),
        (t[5] += a[5]),
        (t[9] += a[9]),
        (t[13] += a[13]),
        (t[2] += a[2]),
        (t[6] += a[6]),
        (t[10] += a[10]),
        (t[14] += a[14]),
        (t[3] += a[3]),
        (t[7] += a[7]),
        (t[11] += a[11]),
        (t[15] += a[15]),
        this
      );
    },
    multiply: function (e, t) {
      var a = e.elements,
        r = t.elements,
        i = this.elements,
        o = a[0],
        n = a[4],
        s = a[8],
        l = a[12],
        h = a[1],
        d = a[5],
        c = a[9],
        u = a[13],
        f = a[2],
        p = a[6],
        m = a[10],
        v = a[14],
        g = a[3],
        S = a[7],
        x = a[11],
        G = a[15],
        M = r[0],
        y = r[4],
        w = r[8],
        _ = r[12],
        X = r[1],
        D = r[5],
        T = r[9],
        C = r[13],
        A = r[2],
        P = r[6],
        L = r[10],
        b = r[14],
        E = r[3],
        F = r[7],
        R = r[11],
        U = r[15];
      return (
        (i[0] = o * M + n * X + s * A + l * E),
        (i[4] = o * y + n * D + s * P + l * F),
        (i[8] = o * w + n * T + s * L + l * R),
        (i[12] = o * _ + n * C + s * b + l * U),
        (i[1] = h * M + d * X + c * A + u * E),
        (i[5] = h * y + d * D + c * P + u * F),
        (i[9] = h * w + d * T + c * L + u * R),
        (i[13] = h * _ + d * C + c * b + u * U),
        (i[2] = f * M + p * X + m * A + v * E),
        (i[6] = f * y + p * D + m * P + v * F),
        (i[10] = f * w + p * T + m * L + v * R),
        (i[14] = f * _ + p * C + m * b + v * U),
        (i[3] = g * M + S * X + x * A + G * E),
        (i[7] = g * y + S * D + x * P + G * F),
        (i[11] = g * w + S * T + x * L + G * R),
        (i[15] = g * _ + S * C + x * b + G * U),
        this
      );
    },
    multiplySelf: function (e) {
      return this.multiply(this, e);
    },
    multiplyToArray: function (e, t, a) {
      return this.multiply(e, t), a.set(this.elements), this;
    },
    multiplyScalar: function (e) {
      var t = this.elements;
      return (
        (t[0] *= e),
        (t[4] *= e),
        (t[8] *= e),
        (t[12] *= e),
        (t[1] *= e),
        (t[5] *= e),
        (t[9] *= e),
        (t[13] *= e),
        (t[2] *= e),
        (t[6] *= e),
        (t[10] *= e),
        (t[14] *= e),
        (t[3] *= e),
        (t[7] *= e),
        (t[11] *= e),
        (t[15] *= e),
        this
      );
    },
    multiplyVector3: function (e) {
      var t = this.elements,
        a = e.data,
        r = a[0],
        i = a[1],
        o = a[2],
        n = 1 / (t[3] * r + t[7] * i + t[11] * o + t[15]);
      return (
        (a[0] = (t[0] * r + t[4] * i + t[8] * o + t[12]) * n),
        (a[1] = (t[1] * r + t[5] * i + t[9] * o + t[13]) * n),
        (a[2] = (t[2] * r + t[6] * i + t[10] * o + t[14]) * n),
        e
      );
    },
    multiplyVector4: function (e) {
      var t = this.elements,
        a = e.data,
        r = a[0],
        i = a[1],
        o = a[2],
        n = a[3];
      return (
        (a[0] = t[0] * r + t[4] * i + t[8] * o + t[12] * n),
        (a[1] = t[1] * r + t[5] * i + t[9] * o + t[13] * n),
        (a[2] = t[2] * r + t[6] * i + t[10] * o + t[14] * n),
        (a[3] = t[3] * r + t[7] * i + t[11] * o + t[15] * n),
        e
      );
    },
    multiplyVector3Array: function (e, t, a) {
      var r = XG.Matrix4.__v1,
        i = r.data;
      void 0 === t && (t = 0), void 0 === a && (a = e.length);
      for (var o = t; a > o; o += 3)
        (i[0] = e[o]),
          (i[1] = e[o + 1]),
          (i[2] = e[o + 2]),
          this.multiplyVector3(r),
          e.set(i, o);
      return e;
    },
    rotateAxis: function (e) {
      var t = this.elements,
        a = e.data,
        r = a[0],
        i = a[1],
        o = a[2];
      return (
        (a[0] = r * t[0] + i * t[4] + o * t[8]),
        (a[1] = r * t[1] + i * t[5] + o * t[9]),
        (a[2] = r * t[2] + i * t[6] + o * t[10]),
        e.normalize(),
        e
      );
    },
    determinant: function () {
      var e = this.elements,
        t = e[0],
        a = e[4],
        r = e[8],
        i = e[12],
        o = e[1],
        n = e[5],
        s = e[9],
        l = e[13],
        h = e[2],
        d = e[6],
        c = e[10],
        u = e[14],
        f = e[3],
        p = e[7],
        m = e[11],
        v = e[15];
      return (
        f *
        (+i * s * d -
          r * l * d -
          i * n * c +
          a * l * c +
          r * n * u -
          a * s * u) +
        p *
        (+t * s * u -
          t * l * c +
          i * o * c -
          r * o * u +
          r * l * h -
          i * s * h) +
        m *
        (+t * l * d -
          t * n * u -
          i * o * d +
          a * o * u +
          i * n * h -
          a * l * h) +
        v *
        (-r * n * h -
          t * s * d +
          t * n * c +
          r * o * d -
          a * o * c +
          a * s * h)
      );
    },
    transpose: function () {
      var e,
        t = this.elements;
      return (
        (e = t[1]),
        (t[1] = t[4]),
        (t[4] = e),
        (e = t[2]),
        (t[2] = t[8]),
        (t[8] = e),
        (e = t[6]),
        (t[6] = t[9]),
        (t[9] = e),
        (e = t[3]),
        (t[3] = t[12]),
        (t[12] = e),
        (e = t[7]),
        (t[7] = t[13]),
        (t[13] = e),
        (e = t[11]),
        (t[11] = t[14]),
        (t[14] = e),
        this
      );
    },
    flattenToArray: function (e) {
      return e.set(this.elements), e;
    },
    flattenToArrayOffset: function (e, t) {
      return e.set(this.elements, t), e;
    },
    getPosition: function () {
      var e = this.elements;
      return XG.Matrix4.__v1.set(e[12], e[13], e[14]);
    },
    setPosition: function (e) {
      return this.elements.set(e.data, 12), this;
    },
    setPositionXYZ: function (e, t, a) {
      var r = this.elements;
      return (r[12] = e), (r[13] = t), (r[14] = a), this;
    },
    getColumnX: function () {
      var e = this.elements;
      return XG.Matrix4.__v1.set(e[0], e[1], e[2]);
    },
    getColumnY: function () {
      var e = this.elements;
      return XG.Matrix4.__v1.set(e[4], e[5], e[6]);
    },
    getColumnZ: function () {
      var e = this.elements;
      return XG.Matrix4.__v1.set(e[8], e[9], e[10]);
    },
    getInverse: function (e) {
      var t = this.elements,
        a = e.elements,
        r = a[0],
        i = a[4],
        o = a[8],
        n = a[12],
        s = a[1],
        l = a[5],
        h = a[9],
        d = a[13],
        c = a[2],
        u = a[6],
        f = a[10],
        p = a[14],
        m = a[3],
        v = a[7],
        g = a[11],
        S = a[15];
      (t[0] =
        h * p * v - d * f * v + d * u * g - l * p * g - h * u * S + l * f * S),
        (t[4] =
          n * f * v -
          o * p * v -
          n * u * g +
          i * p * g +
          o * u * S -
          i * f * S),
        (t[8] =
          o * d * v -
          n * h * v +
          n * l * g -
          i * d * g -
          o * l * S +
          i * h * S),
        (t[12] =
          n * h * u -
          o * d * u -
          n * l * f +
          i * d * f +
          o * l * p -
          i * h * p),
        (t[1] =
          d * f * m -
          h * p * m -
          d * c * g +
          s * p * g +
          h * c * S -
          s * f * S),
        (t[5] =
          o * p * m -
          n * f * m +
          n * c * g -
          r * p * g -
          o * c * S +
          r * f * S),
        (t[9] =
          n * h * m -
          o * d * m -
          n * s * g +
          r * d * g +
          o * s * S -
          r * h * S),
        (t[13] =
          o * d * c -
          n * h * c +
          n * s * f -
          r * d * f -
          o * s * p +
          r * h * p),
        (t[2] =
          l * p * m -
          d * u * m +
          d * c * v -
          s * p * v -
          l * c * S +
          s * u * S),
        (t[6] =
          n * u * m -
          i * p * m -
          n * c * v +
          r * p * v +
          i * c * S -
          r * u * S),
        (t[10] =
          i * d * m -
          n * l * m +
          n * s * v -
          r * d * v -
          i * s * S +
          r * l * S),
        (t[14] =
          n * l * c -
          i * d * c -
          n * s * u +
          r * d * u +
          i * s * p -
          r * l * p),
        (t[3] =
          h * u * m -
          l * f * m -
          h * c * v +
          s * f * v +
          l * c * g -
          s * u * g),
        (t[7] =
          i * f * m -
          o * u * m +
          o * c * v -
          r * f * v -
          i * c * g +
          r * u * g),
        (t[11] =
          o * l * m -
          i * h * m -
          o * s * v +
          r * h * v +
          i * s * g -
          r * l * g),
        (t[15] =
          i * h * c -
          o * l * c +
          o * s * u -
          r * h * u -
          i * s * f +
          r * l * f);
      var x = a[0] * t[0] + a[1] * t[4] + a[2] * t[8] + a[3] * t[12];
      if (0 === x) {
        var G = "Matrix4.getInverse(): can't invert matrix, determinant is 0";
        return console.warn(G), this.identity(), this;
      }
      return this.multiplyScalar(1 / x), this;
    },
    compose: function (e, t, a) {
      var r = this.elements;
      (r[3] = 0),
        (r[7] = 0),
        (r[11] = 0),
        (r[15] = 1),
        this.setRotationFromQuaternion(t);
      var i = a.data,
        o = i[0],
        n = i[1],
        s = i[2];
      return (
        (r[0] *= o),
        (r[1] *= o),
        (r[2] *= o),
        (r[4] *= n),
        (r[5] *= n),
        (r[6] *= n),
        (r[8] *= s),
        (r[9] *= s),
        (r[10] *= s),
        r.set(e.data, 12),
        this
      );
    },
    decompose: function (e, t, a) {
      var r = this.elements,
        i = XG.Matrix4.__v1,
        o = XG.Matrix4.__v2,
        n = XG.Matrix4.__v3;
      i.set(r[0], r[1], r[2]),
        o.set(r[4], r[5], r[6]),
        n.set(r[8], r[9], r[10]),
        (e = e instanceof XG.Vector3 ? e : new XG.Vector3()),
        (t = t instanceof XG.Quaternion ? t : new XG.Quaternion()),
        (a = a instanceof XG.Vector3 ? a : new XG.Vector3());
      var s = a.data,
        l = e.data;
      (s[0] = i.length()),
        (s[1] = o.length()),
        (s[2] = n.length()),
        (l[0] = r[12]),
        (l[1] = r[13]),
        (l[2] = r[14]);
      var h = XG.Matrix4.__m1;
      return (
        h.copy(this),
        (h.elements[0] /= s[0]),
        (h.elements[1] /= s[0]),
        (h.elements[2] /= s[0]),
        (h.elements[4] /= s[1]),
        (h.elements[5] /= s[1]),
        (h.elements[6] /= s[1]),
        (h.elements[8] /= s[2]),
        (h.elements[9] /= s[2]),
        (h.elements[10] /= s[2]),
        t.setFromRotationMatrix(h),
        [e, t, a]
      );
    },
    extractPosition: function (e) {
      var t = this.elements,
        a = e.elements;
      return (t[12] = a[12]), (t[13] = a[13]), (t[14] = a[14]), this;
    },
    extractRotation: function (e) {
      var t = this.elements,
        a = e.elements,
        r = XG.Matrix4.__v1,
        i = 1 / r.set(a[0], a[1], a[2]).length(),
        o = 1 / r.set(a[4], a[5], a[6]).length(),
        n = 1 / r.set(a[8], a[9], a[10]).length();
      return (
        (t[0] = a[0] * i),
        (t[1] = a[1] * i),
        (t[2] = a[2] * i),
        (t[4] = a[4] * o),
        (t[5] = a[5] * o),
        (t[6] = a[6] * o),
        (t[8] = a[8] * n),
        (t[9] = a[9] * n),
        (t[10] = a[10] * n),
        this
      );
    },
    translate: function (e) {
      var t = this.elements,
        a = e.data,
        r = a[0],
        i = a[1],
        o = a[2];
      return (
        (t[12] = t[0] * r + t[4] * i + t[8] * o + t[12]),
        (t[13] = t[1] * r + t[5] * i + t[9] * o + t[13]),
        (t[14] = t[2] * r + t[6] * i + t[10] * o + t[14]),
        (t[15] = t[3] * r + t[7] * i + t[11] * o + t[15]),
        this
      );
    },
    rotateX: function (e) {
      var t = this.elements,
        a = t[4],
        r = t[5],
        i = t[6],
        o = t[7],
        n = t[8],
        s = t[9],
        l = t[10],
        h = t[11],
        d = Math.cos(e),
        c = Math.sin(e);
      return (
        (t[4] = d * a + c * n),
        (t[5] = d * r + c * s),
        (t[6] = d * i + c * l),
        (t[7] = d * o + c * h),
        (t[8] = d * n - c * a),
        (t[9] = d * s - c * r),
        (t[10] = d * l - c * i),
        (t[11] = d * h - c * o),
        this
      );
    },
    rotateY: function (e) {
      var t = this.elements,
        a = t[0],
        r = t[1],
        i = t[2],
        o = t[3],
        n = t[8],
        s = t[9],
        l = t[10],
        h = t[11],
        d = Math.cos(e),
        c = Math.sin(e);
      return (
        (t[0] = d * a - c * n),
        (t[1] = d * r - c * s),
        (t[2] = d * i - c * l),
        (t[3] = d * o - c * h),
        (t[8] = d * n + c * a),
        (t[9] = d * s + c * r),
        (t[10] = d * l + c * i),
        (t[11] = d * h + c * o),
        this
      );
    },
    rotateZ: function (e) {
      var t = this.elements,
        a = t[0],
        r = t[1],
        i = t[2],
        o = t[3],
        n = t[4],
        s = t[5],
        l = t[6],
        h = t[7],
        d = Math.cos(e),
        c = Math.sin(e);
      return (
        (t[0] = d * a + c * n),
        (t[1] = d * r + c * s),
        (t[2] = d * i + c * l),
        (t[3] = d * o + c * h),
        (t[4] = d * n - c * a),
        (t[5] = d * s - c * r),
        (t[6] = d * l - c * i),
        (t[7] = d * h - c * o),
        this
      );
    },
    rotateByAxis: function (e, t) {
      var a = this.elements,
        r = e.data,
        i = r[0],
        o = r[1],
        n = r[2];
      if (1 === i && 0 === o && 0 === n) return this.rotateX(t);
      if (0 === i && 1 === o && 0 === n) return this.rotateY(t);
      if (0 === i && 0 === o && 1 === n) return this.rotateZ(t);
      var s = Math.sqrt(i * i + o * o + n * n);
      (i /= s), (o /= s), (n /= s);
      var l = i * i,
        h = o * o,
        d = n * n,
        c = Math.cos(t),
        u = Math.sin(t),
        f = 1 - c,
        p = i * o * f,
        m = i * n * f,
        v = o * n * f,
        g = i * u,
        S = o * u,
        x = n * u,
        G = l + (1 - l) * c,
        M = p + x,
        y = m - S,
        w = p - x,
        _ = h + (1 - h) * c,
        X = v + g,
        D = m + S,
        T = v - g,
        C = d + (1 - d) * c,
        A = a[0],
        P = a[1],
        L = a[2],
        b = a[3],
        E = a[4],
        F = a[5],
        R = a[6],
        U = a[7],
        I = a[8],
        N = a[9],
        B = a[10],
        O = a[11];
      return (
        (a[0] = G * A + M * E + y * I),
        (a[1] = G * P + M * F + y * N),
        (a[2] = G * L + M * R + y * B),
        (a[3] = G * b + M * U + y * O),
        (a[4] = w * A + _ * E + X * I),
        (a[5] = w * P + _ * F + X * N),
        (a[6] = w * L + _ * R + X * B),
        (a[7] = w * b + _ * U + X * O),
        (a[8] = D * A + T * E + C * I),
        (a[9] = D * P + T * F + C * N),
        (a[10] = D * L + T * R + C * B),
        (a[11] = D * b + T * U + C * O),
        this
      );
    },
    scale: function (e) {
      var t = this.elements,
        a = e.data,
        r = a[0],
        i = a[1],
        o = a[2];
      return (
        (t[0] *= r),
        (t[4] *= i),
        (t[8] *= o),
        (t[1] *= r),
        (t[5] *= i),
        (t[9] *= o),
        (t[2] *= r),
        (t[6] *= i),
        (t[10] *= o),
        (t[3] *= r),
        (t[7] *= i),
        (t[11] *= o),
        this
      );
    },
    getMaxScaleOnAxis: function () {
      var e = this.elements,
        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
        a = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
        r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
      return Math.sqrt(Math.max(t, Math.max(a, r)));
    },
    makeTranslation: function (e) {
      return (
        this.set(
          1,
          0,
          0,
          e.data[0],
          0,
          1,
          0,
          e.data[1],
          0,
          0,
          1,
          e.data[2],
          0,
          0,
          0,
          1
        ),
        this
      );
    },
    makeRotationX: function (e) {
      var t = Math.cos(e),
        a = Math.sin(e);
      return this.set(1, 0, 0, 0, 0, t, -a, 0, 0, a, t, 0, 0, 0, 0, 1), this;
    },
    makeRotationY: function (e) {
      var t = Math.cos(e),
        a = Math.sin(e);
      return this.set(t, 0, a, 0, 0, 1, 0, 0, -a, 0, t, 0, 0, 0, 0, 1), this;
    },
    makeRotationZ: function (e) {
      var t = Math.cos(e),
        a = Math.sin(e);
      return this.set(t, -a, 0, 0, a, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    makeRotationAxis: function (e, t) {
      var a = e.data,
        r = Math.cos(t),
        i = Math.sin(t),
        o = 1 - r,
        n = a[0],
        s = a[1],
        l = a[2],
        h = o * n,
        d = o * s;
      return (
        this.set(
          h * n + r,
          h * s - i * l,
          h * l + i * s,
          0,
          h * s + i * l,
          d * s + r,
          d * l - i * n,
          0,
          h * l - i * s,
          d * l + i * n,
          o * l * l + r,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    },
    makeScale: function (e) {
      var t = e.data;
      return (
        this.set(t[0], 0, 0, 0, 0, t[1], 0, 0, 0, 0, t[2], 0, 0, 0, 0, 1), this
      );
    },
    makeFrustum: function (e, t, a, r, i, o) {
      var n = this.elements,
        s = (2 * i) / (t - e),
        l = (2 * i) / (r - a),
        h = (t + e) / (t - e),
        d = (r + a) / (r - a),
        c = -(o + i) / (o - i),
        u = (-2 * o * i) / (o - i);
      return (
        (n[0] = s),
        (n[4] = 0),
        (n[8] = h),
        (n[12] = 0),
        (n[1] = 0),
        (n[5] = l),
        (n[9] = d),
        (n[13] = 0),
        (n[2] = 0),
        (n[6] = 0),
        (n[10] = c),
        (n[14] = u),
        (n[3] = 0),
        (n[7] = 0),
        (n[11] = -1),
        (n[15] = 0),
        this
      );
    },
    makePerspective: function (e, t, a, r) {
      var i = a * Math.tan(XG.Math.degToRad(0.5 * e)),
        o = -i,
        n = o * t,
        s = i * t;
      return this.makeFrustum(n, s, o, i, a, r);
    },
    makePerspectiveOffset: function (e, t, a, r, i, o, n, s) {
      var l = Math.tan(XG.Math.degToRad(0.5 * e)),
        h = l * t,
        d = h / (0.5 * n),
        c = l / (0.5 * s),
        u = d * i,
        f = c * o,
        p = r,
        m = a,
        v = (u - h) * m,
        g = (u + h) * m,
        S = (f - l) * m,
        x = (f + l) * m;
      return this.makeFrustum(v, g, S, x, m, p);
    },
    makeOrthographic: function (e, t, a, r, i, o) {
      var n = this.elements,
        s = t - e,
        l = a - r,
        h = o - i,
        d = (t + e) / s,
        c = (a + r) / l,
        u = (o + i) / h;
      return (
        (n[0] = 2 / s),
        (n[4] = 0),
        (n[8] = 0),
        (n[12] = -d),
        (n[1] = 0),
        (n[5] = 2 / l),
        (n[9] = 0),
        (n[13] = -c),
        (n[2] = 0),
        (n[6] = 0),
        (n[10] = -2 / h),
        (n[14] = -u),
        (n[3] = 0),
        (n[7] = 0),
        (n[11] = 0),
        (n[15] = 1),
        this
      );
    },
    clone: function () {
      return new XG.Matrix4().copy(this);
    },
  }),
  (XG.Matrix4.__v1 = new XG.Vector3()),
  (XG.Matrix4.__v2 = new XG.Vector3()),
  (XG.Matrix4.__v3 = new XG.Vector3()),
  (XG.Matrix4.__m1 = new XG.Matrix4()),
  (XG.Matrix4.__m2 = new XG.Matrix4()),
  (XG.Frustum = function () {
    (this.planes = [
      new XG.Plane(),
      new XG.Plane(),
      new XG.Plane(),
      new XG.Plane(),
      new XG.Plane(),
      new XG.Plane(),
    ]),
      (this.tmpVec = new XG.Vector3());
  }),
  (XG.Frustum.prototype.setFromMatrix = function (e) {
    var t = this.planes,
      a = e.elements,
      r = a[0],
      i = a[1],
      o = a[2],
      n = a[3],
      s = a[4],
      l = a[5],
      h = a[6],
      d = a[7],
      c = a[8],
      u = a[9],
      f = a[10],
      p = a[11],
      m = a[12],
      v = a[13],
      g = a[14],
      S = a[15];
    t[0].setComponents(n - r, d - s, p - c, S - m),
      t[1].setComponents(n + r, d + s, p + c, S + m),
      t[2].setComponents(n + i, d + l, p + u, S + v),
      t[3].setComponents(n - i, d - l, p - u, S - v),
      t[4].setComponents(n - o, d - h, p - f, S - g),
      t[5].setComponents(n + o, d + h, p + f, S + g);
    for (var x = 0; 6 > x; x++) t[x].normalize();
  }),
  (XG.Frustum.prototype.contains = function (e, t) {
    for (
      var a = this.planes,
      r = e.matrixWorld,
      i = r.getPosition(),
      o = -t.boundingSphere.radius * r.getMaxScaleOnAxis(),
      n = 0,
      s = 0;
      6 > s;
      s++
    )
      if (((n = a[s].distanceToPoint(i)), o >= n)) return !1;
    return !0;
  }),
  (XG.Frustum.prototype.containsInstance = function (e, t, a) {
    var r = this.planes,
      i = e.matrixWorld,
      o = -t.boundingSphere.radius * i.getMaxScaleOnAxis(),
      n = t.attributes.offset.array,
      s = 3 * a,
      l = n[s],
      h = n[s + 1],
      d = n[s + 2],
      c = this.tmpVec;
    c.set(l, h, d), e.localToWorld(c);
    for (var u = 0, f = 0; 6 > f; f++)
      if (((u = r[f].distanceToPoint(c)), o >= u)) return !1;
    return !0;
  }),
  (XG.Plane = function (e, t) {
    (this.normal = void 0 !== e ? e.clone() : XG.Vector3.xAxis.clone()),
      (this.constant = void 0 !== t ? t : 0);
  }),
  (XG.Plane.prototype = {
    constructor: XG.Plane,
    set: function (e, t) {
      return this.normal.copy(e), (this.constant = t), this;
    },
    setComponents: function (e, t, a, r) {
      return this.normal.set(e, t, a), (this.constant = r), this;
    },
    setFromNormalAndCoplanarPoint: function (e, t) {
      return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
    },
    setFromCoplanarPoints: (function () {
      var e = new XG.Vector3(),
        t = new XG.Vector3();
      return function (a, r, i) {
        var o = e.sub(i, r).crossSelf(t.sub(a, r)).normalize();
        return this.setFromNormalAndCoplanarPoint(o, a), this;
      };
    })(),
    intersectLine: (function () {
      var e = new XG.Vector3();
      return function (t, a, r) {
        var i = r || new XG.Vector3(),
          o = e.sub(a, t),
          n = this.normal.dot(o);
        if (0 === n) return 0 === this.distanceToPoint(t) ? i.copy(t) : void 0;
        var s = -(t.dot(this.normal) + this.constant) / n;
        return i.copy(o).multiplyScalar(s).addSelf(t);
      };
    })(),
    intersectLineSegment: (function () {
      var e = new XG.Vector3();
      return function (t, a, r) {
        var i = r || new XG.Vector3(),
          o = e.sub(a, t),
          n = this.normal.dot(o);
        if (0 === n) return 0 === this.distanceToPoint(t) ? i.copy(t) : void 0;
        var s = -(t.dot(this.normal) + this.constant) / n;
        return 0 > s || s > 1 ? void 0 : i.copy(o).multiplyScalar(s).addSelf(t);
      };
    })(),
    copy: function (e) {
      return this.normal.copy(e.normal), (this.constant = e.constant), this;
    },
    normalize: function () {
      var e = 1 / this.normal.length();
      return this.normal.multiplyScalar(e), (this.constant *= e), this;
    },
    distanceToPoint: function (e) {
      return this.normal.dot(e) + this.constant;
    },
    coplanarPoint: function (e) {
      var t = e || new XG.Vector3();
      return t.copy(this.normal), t.multiplyScalar(-this.constant), t;
    },
    applyMatrix4: function (e, t) {
      var a = XG.Plane.__v1,
        r = XG.Plane.__v2;
      t = t || XG.Plane.__m1.getNormalMatrix(e);
      var i = a.copy(this.normal);
      t.multiplyVector3(i);
      var o = this.coplanarPoint(r);
      return (
        e.multiplyVector3(o), this.setFromNormalAndCoplanarPoint(i, o), this
      );
    },
    clone: function () {
      return new XG.Plane().copy(this);
    },
  }),
  (XG.Plane.__v1 = new XG.Vector3()),
  (XG.Plane.__v2 = new XG.Vector3()),
  (XG.Plane.__m1 = new XG.Matrix3()),
  (XG.Box3 = function (e, t) {
    (this.min = void 0 !== e ? e.clone() : new XG.Vector3(1 / 0, 1 / 0, 1 / 0)),
      (this.max =
        void 0 !== t
          ? t.clone()
          : new XG.Vector3(-(1 / 0), -(1 / 0), -(1 / 0)));
  }),
  (XG.Box3.prototype = {
    constructor: XG.Box3,
    set: function (e, t) {
      return this.min.copy(e), this.max.copy(t), this;
    },
    copy: function (e) {
      return this.min.copy(e.min), this.max.copy(e.max), this;
    },
    add: function (e) {
      this.min.minSelf(e.min), this.max.maxSelf(e.max);
    },
    clone: function () {
      return new XG.Box3().copy(this);
    },
  }),
  (XG.Sphere = function (e, t) {
    (this.center = void 0 === e ? new XG.Vector3() : e.clone()),
      (this.radius = void 0 === t ? 0 : t);
  }),
  (XG.Sphere.prototype = {
    constructor: XG.Sphere,
    set: function (e, t) {
      return this.center.copy(e), (this.radius = t), this;
    },
    copy: function (e) {
      return this.center.copy(e.center), (this.radius = e.radius), this;
    },
    containsPoint: function (e) {
      return e.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function (e) {
      return e.distanceTo(this.center) - this.radius;
    },
    clone: function () {
      return new XG.Sphere().copy(this);
    },
  }),
  (XG.Clock = function (e) {
    (this.autoStart = void 0 !== e ? e : !0),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }),
  (XG.Clock.prototype.start = function () {
    (this.startTime = Date.now()),
      (this.oldTime = this.startTime),
      (this.running = !0);
  }),
  (XG.Clock.prototype.stop = function () {
    this.getElapsedTime(), (this.running = !1);
  }),
  (XG.Clock.prototype.getElapsedTime = function () {
    return this.getDelta(), this.elapsedTime;
  }),
  (XG.Clock.prototype.getDelta = function () {
    var e = 0;
    if ((this.autoStart && !this.running && this.start(), this.running)) {
      var t = Date.now();
      (e = 0.001 * (t - this.oldTime)),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }),
  (XG.Animation = function (e, t) {
    (this.id = XG.AnimationIdCount++),
      (this.root = e),
      (this.data = t),
      (this.hierarchy = []),
      (this.boneIndexMap = {});
    for (var a = 0; a < e.bones.length; a++) {
      var r = e.bones[a];
      this.hierarchy.push(r), (this.boneIndexMap[r.name] = a);
    }
    this.initData(t),
      (this.currentTime = 0),
      (this.timeScale = 1),
      (this.weight = 1),
      (this.direction = 1),
      (this.directionBackwards = !1),
      (this.isPlaying = !1),
      (this.isPaused = !0),
      (this.loop = !0);
  }),
  (XG.Animation.prototype.play = function (e, t) {
    if (this.isPlaying === !1) {
      (this.isPlaying = !0),
        (this.loop = void 0 !== e ? e : !0),
        (this.currentTime = void 0 !== t ? t : 0);
      var a,
        r,
        i = this.hierarchy.length;
      for (a = 0; i > a; a++) {
        (r = this.hierarchy[a]),
          (r.useQuaternion = !0),
          (r.matrixAutoUpdate = !0),
          void 0 === r.animationCache && (r.animationCache = {});
        var o;
        void 0 === r.animationCache[this.id]
          ? ((r.animationCache[this.id] = {}),
            (o = r.animationCache[this.id]),
            (o.prevKey = { pos: 0, rot: 0, scl: 0 }),
            (o.nextKey = { pos: 0, rot: 0, scl: 0 }),
            (o.originalMatrix = r instanceof XG.Bone ? r.skinMatrix : r.matrix),
            (o.oldPosition = new XG.Vector3()),
            (o.oldQuaternion = new XG.Quaternion()),
            (o.oldScale = new XG.Vector3()))
          : (o = r.animationCache[this.id]);
        var n = o.prevKey,
          s = o.nextKey;
        (n.pos = this.data.hierarchy[a].keys[0]),
          (n.rot = this.data.hierarchy[a].keys[0]),
          (n.scl = this.data.hierarchy[a].keys[0]),
          this.directionBackwards
            ? ((s.pos = this.getPrevKeyWith("pos", a, -1)),
              (s.rot = this.getPrevKeyWith("rot", a, -1)),
              (s.scl = this.getPrevKeyWith("scl", a, -1)))
            : ((s.pos = this.getNextKeyWith("pos", a, 1)),
              (s.rot = this.getNextKeyWith("rot", a, 1)),
              (s.scl = this.getNextKeyWith("scl", a, 1)));
      }
      this.update(0);
    }
    this.isPaused = !1;
  }),
  (XG.Animation.prototype.setWeight = function (e) {
    this.weight = e;
  }),
  (XG.Animation.prototype.setDirectionForward = function () {
    (this.direction = 1), (this.directionBackwards = !1);
  }),
  (XG.Animation.prototype.setDirectionBackward = function () {
    (this.direction = -1), (this.directionBackwards = !0);
  }),
  (XG.Animation.prototype.pause = function () {
    this.isPaused = !this.isPaused;
  }),
  (XG.Animation.prototype.stop = function () {
    (this.isPlaying = !1), (this.isPaused = !1);
  }),
  (XG.Animation.prototype.update = function (e) {
    if (this.isPlaying !== !1 && !this.isPaused) {
      var t,
        a,
        r,
        i,
        o,
        n,
        s,
        l,
        h,
        d,
        c,
        u,
        f = ["pos", "rot", "scl"],
        p = this.currentTime + e * this.timeScale * this.direction,
        m = p % this.data.length;
      this.directionBackwards && 0 > m && (m += this.data.length);
      var v = m;
      this.currentTime = m;
      for (var g = 0, S = this.hierarchy.length; S > g; g++) {
        (l = this.hierarchy[g]),
          (h = l.animationCache[this.id]),
          (l.matrixAutoUpdate = !1),
          l.firstAnimationFlag ||
          (h.oldPosition.copy(l.position),
            h.oldQuaternion.copy(l.quaternion),
            h.oldScale.copy(l.scale));
        for (var x = 0; 3 > x; x++) {
          if (
            ((t = f[x]),
              (n = h.prevKey[t]),
              (s = h.nextKey[t]),
              this.directionBackwards)
          ) {
            if (s.time > p) {
              if (v > p) {
                if (!this.loop) return void this.stop();
                var G = this.data.hierarchy[g].keys;
                for (
                  n = this.data.hierarchy[g].keys[G.length - 1],
                  s = this.getPrevKeyWith(t, g, -1);
                  s.time > v;

                )
                  (n = s), (s = this.getPrevKeyWith(t, g, s.index - 1));
              } else
                do (n = s), (s = this.getPrevKeyWith(t, g, s.index - 1));
                while (s.time > v);
              (h.prevKey[t] = n), (h.nextKey[t] = s);
            }
            a = (n.time - v) / (n.time - s.time);
          } else {
            if (s.time <= p) {
              if (p > v) {
                if (!this.loop) return void this.stop();
                for (
                  n = this.data.hierarchy[g].keys[0],
                  s = this.getNextKeyWith(t, g, 1);
                  s.time < v;

                )
                  (n = s), (s = this.getNextKeyWith(t, g, s.index + 1));
              } else
                do (n = s), (s = this.getNextKeyWith(t, g, s.index + 1));
                while (s.time < v);
              (h.prevKey[t] = n), (h.nextKey[t] = s);
            }
            a = (v - n.time) / (s.time - n.time);
          }
          (i = n[t]),
            (o = s[t]),
            (0 > a || a > 1) &&
            (console.log(
              "XG.Animation.update: Warning! Scale out of bounds:" +
              a +
              " on bone " +
              g
            ),
              (a = 0 > a ? 0 : 1)),
            "pos" === t
              ? ((r = l.position),
                (d = i[0] + (o[0] - i[0]) * a),
                (c = i[1] + (o[1] - i[1]) * a),
                (u = i[2] + (o[2] - i[2]) * a),
                r.set(d, c, u))
              : "rot" === t
                ? XG.Quaternion.slerp(i, o, l.quaternion, a)
                : "scl" === t &&
                ((r = l.scale),
                  (d = i[0] + (o[0] - i[0]) * a),
                  (c = i[1] + (o[1] - i[1]) * a),
                  (u = i[2] + (o[2] - i[2]) * a),
                  r.set(d, c, u));
        }
        l.firstAnimationFlag ||
          (l.position.multiplyScalar(this.weight),
            h.oldPosition.multiplyScalar(1 - this.weight),
            l.position.addSelf(h.oldPosition),
            l.quaternion.slerpSelf(h.oldQuaternion, 1 - this.weight),
            l.scale.multiplyScalar(this.weight),
            h.oldScale.multiplyScalar(1 - this.weight),
            l.scale.addSelf(h.oldScale)),
          l.updateMatrix(),
          (l.firstAnimationFlag = !1);
      }
    }
  }),
  (XG.Animation.prototype.getNextKeyWith = function (e, t, a) {
    var r = this.data.hierarchy[t].keys;
    for (a %= r.length; a < r.length; a++) if (void 0 !== r[a][e]) return r[a];
    return this.data.hierarchy[t].keys[0];
  }),
  (XG.Animation.prototype.getPrevKeyWith = function (e, t, a) {
    var r = this.data.hierarchy[t].keys;
    for (a = a >= 0 ? a : a + r.length; a >= 0; a--)
      if (void 0 !== r[a][e]) return r[a];
    return this.data.hierarchy[t].keys[r.length - 1];
  }),
  (XG.Animation.prototype.initData = function (e) {
    if (e.initialized !== !0) {
      for (var t = e.hierarchy, a = 0; a < t.length; a++) {
        for (var r = t[a], i = 0; i < r.keys.length; i++)
          if (
            (r.keys[i].time < 0 && (r.keys[i].time = 0),
              void 0 !== r.keys[i].rot &&
              !(r.keys[i].rot instanceof XG.Quaternion))
          ) {
            var o = r.keys[i].rot;
            r.keys[i].rot = new XG.Quaternion(o[0], o[1], o[2], o[3]);
          }
        for (var i = 1; i < r.keys.length; i++)
          r.keys[i].time === r.keys[i - 1].time && (r.keys.splice(i, 1), i--);
        for (var i = 0; i < r.keys.length; i++) r.keys[i].index = i;
      }
      e.initialized = !0;
    }
  }),
  (XG.Animation.prototype.findRoot = function () {
    for (var e, t = this.data.hierarchy, a = 0, r = t.length; r > a; a++) {
      var i = t[a];
      if (-1 === i.parent) {
        e = i;
        break;
      }
    }
    return e;
  }),
  (XG.Animation.prototype.offsetPositionKeysForBone = function (e, t) {
    for (
      var a = this.boneIndexMap[e],
      r = this.data.hierarchy[a].keys,
      i = 0,
      o = r.length;
      o > i;
      i++
    ) {
      var n = r[i],
        s = n.pos;
      void 0 !== s && ((s[0] += t.x), (s[1] += t.y), (s[2] += t.z));
    }
  }),
  (XG.Animation.prototype.offsetRotationKeysForBone = function (e, t) {
    for (
      var a = this.boneIndexMap[e],
      r = this.data.hierarchy[a].keys,
      i = 0,
      o = r.length;
      o > i;
      i++
    ) {
      var n = r[i],
        s = n.rot;
      void 0 !== s && s.multiplySelf(t);
    }
  }),
  (XG.Animation.prototype.setKeysComponentValue = function (e, t, a, r) {
    for (var i = 0, o = e.keys.length; o > i; i++) {
      var n = e.keys[i];
      n[t] && (n[t][a] = r);
    }
  }),
  (XG.Animation.prototype.copyKeysToBoneRange = function (e, t, a) {
    for (var r = this.data.hierarchy, i = e.data.hierarchy, o = t; a > o; o++)
      for (var n = i[o], s = r[o], l = 0, h = n.keys.length; h > l; l++) {
        var d = n.keys[l];
        s.keys[l] = d;
      }
  }),
  (XG.AnimationIdCount = 0),
  (XG.Geometry = function () {
    (this.id = XG.GeometryIdCount++),
      (this.attributes = {}),
      (this.attributesList = []),
      (this.virtualAttributes = {}),
      (this.virtualAttributesList = []),
      (this.numPrimitives = 0),
      (this.numVertices = 0),
      (this.numInstances = 0),
      (this.numVisibleInstances = 0),
      (this.instanceCulled = !0),
      (this.dynamic = !1),
      (this.offsets = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.morphTargets = []),
      (this.morphColors = []),
      (this.tmpVecA = new XG.Vector3()),
      (this.tmpVecB = new XG.Vector3()),
      (this.tmpVecC = new XG.Vector3()),
      (this.tmpVecD = new XG.Vector3()),
      (this.tmpVecE = new XG.Vector3());
  }),
  (XG.Geometry.prototype = {
    constructor: XG.Geometry,
    addIndex: function (e, t, a) {
      var r = new t(this.numPrimitives * a);
      this.addAttributeArray(e, r, a);
    },
    addAttribute: function (e, t, a) {
      var r = new t(this.numVertices * a);
      this.addAttributeArray(e, r, a);
    },
    addInstancedAttribute: function (e, t, a, r) {
      var i = new t(this.numInstances * a);
      this.addAttributeArray(e, i, a, r);
    },
    addVirtualAttribute: function (e) {
      var t = { name: e, mapped: null };
      (this.virtualAttributes[e] = t), this.virtualAttributesList.push(t);
    },
    addUnattachedAttribute: function (e, t, a) {
      var r = new t(this.numVertices * a),
        i = {
          name: e,
          itemSize: a,
          numItems: r.length,
          array: r,
          buffer: null,
          type: XG.paramTypedArrayToXG(r),
          typeSize: r.BYTES_PER_ELEMENT,
          needsUpdate: !0,
          attached: !1,
          divisor: 0,
        };
      (this.attributes[e] = i), this.attributesList.push(i);
    },
    addAttributeArray: function (e, t, a, r) {
      void 0 === r && (r = 0);
      var i = {
        name: e,
        itemSize: a,
        numItems: t.length,
        array: t,
        buffer: null,
        type: XG.paramTypedArrayToXG(t),
        typeSize: t.BYTES_PER_ELEMENT,
        needsUpdate: !0,
        attached: !0,
        divisor: r,
      };
      (this.attributes[e] = i), this.attributesList.push(i);
    },
    removeAttribute: function (e) {
      if (void 0 === this.attributes[e])
        return void console.warn(
          "Geometry.removeAttribute(): attribute [" + e + "] not found."
        );
      for (var t = [], a = 0, r = this.attributesList.length; r > a; a++) {
        var i = this.attributesList[a];
        i.name !== e && t.push(i);
      }
      (this.attributesList = t),
        (this.attributes[e] = null),
        delete this.attributes[e];
    },
    setAttributeValue: function (e, t, a, r) {
      var i = this.attributes[e];
      if (i) {
        if (
          (void 0 === a && (a = 0),
            void 0 === r && (r = i.array.length),
            t instanceof XG.Color ||
            t instanceof XG.Vector2 ||
            t instanceof XG.Vector3 ||
            t instanceof XG.Vector4 ||
            t instanceof XG.Quaternion)
        )
          for (var o = a; r > o; o += i.itemSize) t.copyIntoArray(i.array, o);
        i.needsUpdate = !0;
      }
    },
    applyMatrix: function (e) {
      var t, a;
      if (
        (this.attributes.position && (t = this.attributes.position.array),
          this.attributes.normal && (a = this.attributes.normal.array),
          void 0 !== t &&
          (e.multiplyVector3Array(t),
            (this.attributes.position.needsUpdate = !0)),
          void 0 !== a)
      ) {
        var r = new XG.Matrix3();
        r.getInverse(e).transpose(),
          r.multiplyVector3Array(a),
          this.normalizeAttribute("normal"),
          (this.attributes.normal.needsUpdate = !0);
      }
    },
    computeBoundingBox: function () {
      null === this.boundingBox && (this.boundingBox = new XG.Box3());
      var e = this.attributes.position.array;
      if (e) {
        var t,
          a,
          r,
          i = this.boundingBox,
          o = i.min.data,
          n = i.max.data;
        e.length >= 3 &&
          ((o[0] = n[0] = e[0]), (o[1] = n[1] = e[1]), (o[2] = n[2] = e[2]));
        for (var s = 3, l = e.length; l > s; s += 3)
          (t = e[s]),
            (a = e[s + 1]),
            (r = e[s + 2]),
            t < o[0] ? (o[0] = t) : t > n[0] && (n[0] = t),
            a < o[1] ? (o[1] = a) : a > n[1] && (n[1] = a),
            r < o[2] ? (o[2] = r) : r > n[2] && (n[2] = r);
      }
      (void 0 === e || 0 === e.length) &&
        (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0));
    },
    computeBoundingSphere: function () {
      null === this.boundingSphere && (this.boundingSphere = new XG.Sphere());
      var e = this.attributes.position.array;
      if (e) {
        for (var t, a, r, i, o = 0, n = 0, s = e.length; s > n; n += 3)
          (a = e[n]),
            (r = e[n + 1]),
            (i = e[n + 2]),
            (t = a * a + r * r + i * i),
            t > o && (o = t);
        this.boundingSphere.radius = Math.sqrt(o);
      }
    },
    computeVertexNormals: function () {
      this.computeNormals("position", "normal");
    },
    computeNormals: function (e, t) {
      if (this.attributes[e]) {
        var a,
          r,
          i,
          o,
          n = this.attributes[e].array.length;
        if (void 0 === this.attributes[t])
          this.addAttributeArray(t, new Float32Array(n), 3);
        else
          for (a = 0, r = this.attributes[t].array.length; r > a; a++)
            this.attributes[t].array[a] = 0;
        var s,
          l,
          h,
          d,
          c,
          u,
          f,
          p,
          m,
          v,
          g,
          S,
          x,
          G,
          M,
          y = this.attributes[e].array,
          w = this.attributes[t].array,
          _ = this.tmpVecA,
          X = this.tmpVecB,
          D = this.tmpVecC,
          T = this.tmpVecD,
          C = this.tmpVecE,
          A = T.data;
        if (this.attributes.index) {
          var P = this.attributes.index.array,
            L = this.offsets;
          for (i = 0, o = L.length; o > i; ++i) {
            var b = L[i].start,
              E = L[i].count,
              F = L[i].index;
            for (a = b, r = b + E; r > a; a += 3)
              (s = F + P[a]),
                (l = F + P[a + 1]),
                (h = F + P[a + 2]),
                (f = 3 * s),
                (p = f + 1),
                (m = f + 2),
                (v = 3 * l),
                (g = v + 1),
                (S = v + 2),
                (x = 3 * h),
                (G = x + 1),
                (M = x + 2),
                (d = y[f]),
                (c = y[p]),
                (u = y[m]),
                _.set(d, c, u),
                (d = y[v]),
                (c = y[g]),
                (u = y[S]),
                X.set(d, c, u),
                (d = y[x]),
                (c = y[G]),
                (u = y[M]),
                D.set(d, c, u),
                T.sub(D, X),
                C.sub(_, X),
                T.crossSelf(C),
                (w[f] += A[0]),
                (w[p] += A[1]),
                (w[m] += A[2]),
                (w[v] += A[0]),
                (w[g] += A[1]),
                (w[S] += A[2]),
                (w[x] += A[0]),
                (w[G] += A[1]),
                (w[M] += A[2]);
          }
        } else
          for (a = 0, r = y.length; r > a; a += 9)
            (d = y[a]),
              (c = y[a + 1]),
              (u = y[a + 2]),
              _.set(d, c, u),
              (d = y[a + 3]),
              (c = y[a + 4]),
              (u = y[a + 5]),
              X.set(d, c, u),
              (d = y[a + 6]),
              (c = y[a + 7]),
              (u = y[a + 8]),
              D.set(d, c, u),
              T.sub(D, X),
              C.sub(_, X),
              T.crossSelf(C),
              (w[a] = A[0]),
              (w[a + 1] = A[1]),
              (w[a + 2] = A[2]),
              (w[a + 3] = A[0]),
              (w[a + 4] = A[1]),
              (w[a + 5] = A[2]),
              (w[a + 6] = A[0]),
              (w[a + 7] = A[1]),
              (w[a + 8] = A[2]);
        var R;
        for (a = 0, r = w.length; r > a; a += 3)
          (d = w[a]),
            (c = w[a + 1]),
            (u = w[a + 2]),
            (R = 1 / Math.sqrt(d * d + c * c + u * u)),
            (w[a] *= R),
            (w[a + 1] *= R),
            (w[a + 2] *= R);
        this.attributes[t].needsUpdate = !0;
      }
    },
    normalizeAttribute: function (e, t, a) {
      var r = this.attributes[e];
      if (r) {
        var i = r.array;
        void 0 === t && (t = 0), void 0 === a && (a = i.length);
        for (var o, n, s, l, h = t; a > h; h += 3)
          (o = i[h]),
            (n = i[h + 1]),
            (s = i[h + 2]),
            (l = 1 / Math.sqrt(o * o + n * n + s * s)),
            (i[h] *= l),
            (i[h + 1] *= l),
            (i[h + 2] *= l);
      }
    },
    scaleAttribute: function (e, t, a, r, i, o) {
      var n = this.attributes[e];
      if (n) {
        var s = n.array,
          l = n.itemSize;
        void 0 === i && (i = 0), void 0 === o && (o = s.length);
        for (var h = i; o > h; h += l)
          (s[h] *= t),
            l > 1 && void 0 !== a && (s[h + 1] *= a),
            l > 2 && void 0 !== r && (s[h + 2] *= r);
      }
    },
    computeMorphNormals: function () {
      for (var e = 0, t = this.morphTargets.length; t > e; e++) {
        var a = "mp_" + e,
          r = "mn_" + e;
        this.computeNormals(a, r);
      }
    },
    computeCenters: function () {
      function e(e, t, a) {
        (o[3 * e] = 1),
          (o[3 * e + 1] = 0),
          (o[3 * e + 2] = 0),
          (o[3 * t] = 0),
          (o[3 * t + 1] = 1),
          (o[3 * t + 2] = 0),
          (o[3 * a] = 0),
          (o[3 * a + 1] = 0),
          (o[3 * a + 2] = 1);
      }
      if (void 0 === this.attributes.position)
        return void console.warn(
          "Missing required attributes (position) in Geometry.computeCenters()"
        );
      var t = this.attributes.position.array,
        a = t.length / 3;
      void 0 === this.attributes.center &&
        this.addAttributeArray("center", new Float32Array(3 * a), 3);
      var r,
        i,
        o = this.attributes.center.array;
      if (this.attributes.index) {
        var n,
          s,
          l,
          h,
          d,
          c = this.attributes.index.array,
          u = this.offsets;
        for (n = 0, s = u.length; s > n; ++n) {
          var f = u[n].start,
            p = u[n].count,
            m = u[n].index;
          for (r = f, i = f + p; i > r; r += 3)
            (l = m + c[r]), (h = m + c[r + 1]), (d = m + c[r + 2]), e(l, h, d);
        }
      } else
        for (r = 0, i = o.length; i > r; r += 9)
          (o[r] = 1),
            (o[r + 1] = 0),
            (o[r + 2] = 0),
            (o[r + 3] = 0),
            (o[r + 4] = 1),
            (o[r + 5] = 0),
            (o[r + 6] = 0),
            (o[r + 7] = 0),
            (o[r + 8] = 1);
    },
    computeTangents: function () {
      function e(e, t, a) {
        (c = r[3 * e]),
          (u = r[3 * e + 1]),
          (f = r[3 * e + 2]),
          (p = r[3 * t]),
          (m = r[3 * t + 1]),
          (v = r[3 * t + 2]),
          (g = r[3 * a]),
          (S = r[3 * a + 1]),
          (x = r[3 * a + 2]),
          (G = o[2 * e]),
          (M = o[2 * e + 1]),
          (y = o[2 * t]),
          (w = o[2 * t + 1]),
          (_ = o[2 * a]),
          (X = o[2 * a + 1]),
          (D = p - c),
          (T = g - c),
          (C = m - u),
          (A = S - u),
          (P = v - f),
          (L = x - f),
          (b = y - G),
          (E = _ - G),
          (F = w - M),
          (R = X - M),
          (U = 1 / (b * R - E * F)),
          H.set((R * D - F * T) * U, (R * C - F * A) * U, (R * P - F * L) * U),
          W.set((b * T - E * D) * U, (b * A - E * C) * U, (b * L - E * P) * U),
          l[e].addSelf(H),
          l[t].addSelf(H),
          l[a].addSelf(H),
          h[e].addSelf(W),
          h[t].addSelf(W),
          h[a].addSelf(W);
      }
      function t(e) {
        (re[0] = i[3 * e]),
          (re[1] = i[3 * e + 1]),
          (re[2] = i[3 * e + 2]),
          ae.copy(te),
          (Q = l[e]),
          $.copy(Q),
          $.subSelf(te.multiplyScalar(te.dot(Q))).normalize(),
          ee.cross(ae, Q),
          (J = ee.dot(h[e])),
          (Z = 0 > J ? -1 : 1),
          (s[4 * e] = ie[0]),
          (s[4 * e + 1] = ie[1]),
          (s[4 * e + 2] = ie[2]),
          (s[4 * e + 3] = Z);
      }
      if (
        void 0 === this.attributes.index ||
        void 0 === this.attributes.position ||
        void 0 === this.attributes.normal ||
        void 0 === this.attributes.uv
      )
        return void console.warn(
          "Missing required attributes (index, position, normal or uv) in Geometry.computeTangents()"
        );
      var a = this.attributes.index.array,
        r = this.attributes.position.array,
        i = this.attributes.normal.array,
        o = this.attributes.uv.array,
        n = r.length / 3;
      void 0 === this.attributes.tangent &&
        this.addAttributeArray("tangent", new Float32Array(4 * n), 4);
      for (
        var s = this.attributes.tangent.array, l = [], h = [], d = 0;
        n > d;
        d++
      )
        (l[d] = new XG.Vector3()), (h[d] = new XG.Vector3());
      var c,
        u,
        f,
        p,
        m,
        v,
        g,
        S,
        x,
        G,
        M,
        y,
        w,
        _,
        X,
        D,
        T,
        C,
        A,
        P,
        L,
        b,
        E,
        F,
        R,
        U,
        I,
        N,
        B,
        O,
        V,
        k,
        z,
        H = new XG.Vector3(),
        W = new XG.Vector3(),
        j = this.offsets;
      for (B = 0, O = j.length; O > B; ++B) {
        var q = j[B].start,
          Y = j[B].count,
          K = j[B].index;
        for (I = q, N = q + Y; N > I; I += 3)
          (V = K + a[I]), (k = K + a[I + 1]), (z = K + a[I + 2]), e(V, k, z);
      }
      var Z,
        Q,
        J,
        $ = new XG.Vector3(),
        ee = new XG.Vector3(),
        te = new XG.Vector3(),
        ae = new XG.Vector3(),
        re = te.data,
        ie = $.data;
      for (B = 0, O = j.length; O > B; ++B) {
        var q = j[B].start,
          Y = j[B].count,
          K = j[B].index;
        for (I = q, N = q + Y; N > I; I += 3)
          (V = K + a[I]),
            (k = K + a[I + 1]),
            (z = K + a[I + 2]),
            t(V),
            t(k),
            t(z);
      }
      this.attributes.tangent.needsUpdate = !0;
    },
    unrollIndices: function () {
      function e(e, t, r) {
        (S = a[3 * e]),
          (x = a[3 * e + 1]),
          (G = a[3 * e + 2]),
          (M = a[3 * t]),
          (y = a[3 * t + 1]),
          (w = a[3 * t + 2]),
          (_ = a[3 * r]),
          (X = a[3 * r + 1]),
          (D = a[3 * r + 2]),
          (i[9 * z] = S),
          (i[9 * z + 1] = x),
          (i[9 * z + 2] = G),
          (i[9 * z + 3] = M),
          (i[9 * z + 4] = y),
          (i[9 * z + 5] = w),
          (i[9 * z + 6] = _),
          (i[9 * z + 7] = X),
          (i[9 * z + 8] = D),
          o &&
          ((T = o[3 * e]),
            (C = o[3 * e + 1]),
            (A = o[3 * e + 2]),
            (P = o[3 * t]),
            (L = o[3 * t + 1]),
            (b = o[3 * t + 2]),
            (E = o[3 * r]),
            (F = o[3 * r + 1]),
            (R = o[3 * r + 2]),
            (s[9 * z] = T),
            (s[9 * z + 1] = C),
            (s[9 * z + 2] = A),
            (s[9 * z + 3] = P),
            (s[9 * z + 4] = L),
            (s[9 * z + 5] = b),
            (s[9 * z + 6] = E),
            (s[9 * z + 7] = F),
            (s[9 * z + 8] = R)),
          l &&
          ((U = l[2 * e]),
            (I = l[2 * e + 1]),
            (N = l[2 * t]),
            (B = l[2 * t + 1]),
            (O = l[2 * r]),
            (V = l[2 * r + 1]),
            (d[6 * z] = U),
            (d[6 * z + 1] = I),
            (d[6 * z + 2] = N),
            (d[6 * z + 3] = B),
            (d[6 * z + 4] = O),
            (d[6 * z + 5] = V)),
          (z += 1);
      }
      if (
        void 0 === this.attributes.index ||
        void 0 === this.attributes.position
      )
        return void console.warn(
          "Missing required attributes (index or position) in Geometry.unrollIndices()"
        );
      var t = 3 * this.numPrimitives,
        a = this.attributes.position.array,
        r = XG.paramXGToTypedArray(this.attributes.position.type),
        i = new r(t * this.attributes.position.itemSize);
      if (this.attributes.normal)
        var o = this.attributes.normal.array,
          n = XG.paramXGToTypedArray(this.attributes.normal.type),
          s = new n(t * this.attributes.normal.itemSize);
      if (this.attributes.uv)
        var l = this.attributes.uv.array,
          h = XG.paramXGToTypedArray(this.attributes.uv.type),
          d = new h(t * this.attributes.uv.itemSize);
      var c,
        u,
        f,
        p,
        m,
        v,
        g,
        S,
        x,
        G,
        M,
        y,
        w,
        _,
        X,
        D,
        T,
        C,
        A,
        P,
        L,
        b,
        E,
        F,
        R,
        U,
        I,
        N,
        B,
        O,
        V,
        k = this.attributes.index.array,
        z = 0,
        H = this.offsets;
      for (f = 0, p = H.length; p > f; ++f) {
        var W = H[f].start,
          j = H[f].count,
          q = H[f].index;
        for (c = W, u = W + j; u > c; c += 3)
          (m = q + k[c]), (v = q + k[c + 1]), (g = q + k[c + 2]), e(m, v, g);
      }
      (this.attributes.position.array = i),
        (this.attributes.position.numItems = i.length),
        (this.attributes.position.needsUpdate = !0),
        this.attributes.normal &&
        ((this.attributes.normal.array = s),
          (this.attributes.normal.numItems = s.length),
          (this.attributes.normal.needsUpdate = !0)),
        this.attributes.uv &&
        ((this.attributes.uv.array = d),
          (this.attributes.uv.numItems = d.length),
          (this.attributes.uv.needsUpdate = !0)),
        (this.offsets = []),
        (this.numVertices = t),
        this.removeAttribute("index");
    },
    mergeBatch: function (e, t) {
      e.length !== t.length &&
        console.warn(
          "XG.Geometry.mergeBatch: geometries and transforms arrays don't have the same sizes"
        );
      var a = Math.min(e.length, t.length),
        r = e.slice(0),
        i = t.slice(0);
      0 !== this.attributesList.length &&
        (r.unshift(this), i.unshift(new XG.Matrix4()));
      for (var o = {}, n = 0, s = 0, l = 0; a > l; l++) {
        for (var h = r[l], d = 0, c = h.attributesList.length; c > d; d++) {
          var u = h.attributesList[d],
            f = u.name,
            p = u.type,
            m = u.array,
            v = u.itemSize;
          void 0 === o[f] &&
            (o[f] = { size: 0, type: p, array: null, offset: 0, itemSize: v }),
            (o[f].size += m.length);
        }
        (n += h.numVertices), (s += h.numPrimitives);
      }
      for (var f in o) {
        var u = o[f],
          g = XG.paramXGToTypedArray(u.type);
        "index" === f &&
          n > 65535 &&
          (XG.elementIndexUintAvailable
            ? (g = Uint32Array)
            : console.warn(
              "XG.Geometry.mergeBatch: too many vertices for new merged indexed geometry"
            )),
          (u.array = new g(u.size));
      }
      for (var S, x = 0, l = 0; a > l; l++) {
        for (
          var h = r[l], G = i[l], d = 0, c = h.attributesList.length;
          c > d;
          d++
        ) {
          var u = h.attributesList[d],
            f = u.name,
            p = u.type,
            m = u.array,
            M = o[f],
            y = M.array,
            w = M.offset;
          if (
            "index" === f &&
            M.type === XG.UnsignedIntType &&
            p === XG.UnsignedShortType
          )
            for (var _ = 0, X = m.length; X > _; _++) y[w + _] = m[_];
          else y.set(m, w);
          var D = w,
            T = w + m.length;
          if (
            ("position" === f && G.multiplyVector3Array(y, D, T),
              "normal" === f &&
              (void 0 === S && (S = new XG.Matrix3()),
                S.getInverse(G).transpose(),
                S.multiplyVector3Array(y, D, T)),
              "index" === f)
          )
            for (var _ = D; T > _; _++) y[_] += x;
          M.offset += m.length;
        }
        x += h.attributes.position.array.length / 3;
      }
      if (0 === this.attributesList.length) {
        for (var f in o) {
          var u = o[f];
          this.addAttributeArray(f, u.array, u.itemSize);
        }
        this.offsets[0] = { start: 0, index: 0, count: 3 * s };
      } else {
        for (var d = 0, c = this.attributesList.length; c > d; d++) {
          var C = this.attributesList[d],
            f = C.name,
            u = o[f];
          (C.array = u.array),
            (C.numItems = u.array.length),
            (C.needsUpdate = !0);
        }
        this.offsets[0].count = 3 * s;
      }
      this.normalizeAttribute("normal"),
        (this.numVertices = n),
        (this.numPrimitives = s);
    },
    merge: function (e, t) {
      if (
        ((this.numVertices += e.numVertices),
          (this.numPrimitives += e.numPrimitives),
          0 === this.attributesList.length)
      ) {
        this.attributes = {};
        for (var a = 0, r = e.attributesList.length; r > a; a++) {
          var i = e.attributesList[a],
            o = i.name,
            n = i.array,
            s = i.itemSize,
            l = i.type,
            h = XG.paramXGToTypedArray(i.type),
            d = new h(n);
          this.addAttributeArray(o, d, s);
        }
        this.offsets = [];
        var c = e.offsets;
        for (a = 0, r = c.length; r > a; a++) {
          var u = c[a].start,
            f = c[a].index,
            p = c[a].count;
          this.offsets[a] = { start: u, index: f, count: p };
        }
        return void this.applyMatrix(t);
      }
      var m = this.attributes.position.array.length / 3,
        v = e.attributes.position.array.length / 3,
        g = Uint16Array;
      m + v > 65535 &&
        this.attributes.index &&
        (XG.elementIndexUintAvailable
          ? (g = Uint32Array)
          : console.warn(
            "XG.Geometry.merge: too many vertices for new merged indexed geometry"
          ));
      for (
        var S = this.attributes.position ? m : 0,
        x = 0,
        a = 0,
        r = this.attributesList.length;
        r > a;
        a++
      ) {
        var G = this.attributesList[a],
          o = G.name,
          n = G.array,
          l = G.type,
          s = G.itemSize,
          M = e.attributes[o],
          y = M.array;
        if (void 0 !== M)
          if (
            (M.itemSize === s && M.type === l) ||
            ("index" === o && M.itemSize === s)
          ) {
            var w = n.length,
              _ = n.length + y.length,
              h = XG.paramXGToTypedArray(l);
            if ("index" === o && h !== g) {
              for (var X = new g(_), D = 0; w > D; D++) X[D] = n[D];
              for (D = w; _ > D; D++) X[D] = y[D - w];
              (G.type = XG.paramTypedArrayToXG(X)),
                (G.typeSize = X.BYTES_PER_ELEMENT);
            } else {
              var X = new h(_);
              X.set(n, 0), X.set(y, w);
            }
            if ("index" === o) {
              x = y.length / 3;
              for (var D = w; _ > D; D++) X[D] += S;
            }
            if (
              t &&
              ("position" === o && t.multiplyVector3Array(X, w), "normal" === o)
            ) {
              var T = new XG.Matrix3();
              T.getInverse(t).transpose(), T.multiplyVector3Array(X, w);
            }
            (G.array = X),
              (G.numItems = _),
              (G.needsUpdate = !0),
              t && "normal" === o && this.normalizeAttribute("normal", w);
          } else
            console.warn(
              "XG.Geometry.merge: incompatible attribute [" + o + "]"
            );
        else console.warn("XG.Geometry.merge: missing attribute [" + o + "]");
      }
      this.offsets.length > 0 && (this.offsets[0].count += 3 * x);
    },
  }),
  (XG.Geometry.prototype.clone = function () {
    for (
      var e = new XG.Geometry(),
      t = this.attributesList,
      a = e.attributesList,
      r = e.attributes,
      i = 0,
      o = t.length;
      o > i;
      ++i
    ) {
      var n = t[i],
        s = {
          name: n.name,
          itemSize: n.itemSize,
          numItems: n.numItems,
          array: n.array.slice(0),
          buffer: null,
          type: n.type,
          typeSize: n.typeSize,
          needsUpdate: !0,
          attached: n.attached,
          divisor: n.divisor,
        };
      (a[i] = s), (r[s.name] = s);
    }
    for (
      var l = this.virtualAttributesList,
      h = e.virtualAttributesList,
      d = e.virtualAttributes,
      i = 0,
      o = l.length;
      o > i;
      ++i
    ) {
      var n = l[i],
        s = { name: n.name, mapped: n.mapped };
      (h[i] = s), (d[s.name] = s);
    }
    (e.numPrimitives = this.numPrimitives),
      (e.numVertices = this.numVertices),
      (e.numInstances = this.numInstances),
      (e.numVisibleInstances = this.numVisibleInstances),
      (e.instanceCulled = this.instanceCulled),
      (e.dynamic = this.dynamic);
    for (var c = this.offsets, u = e.offsets, i = 0, o = c.length; o > i; ++i) {
      var f = c[i].start,
        p = c[i].count,
        m = c[i].index;
      u.push({ start: f, count: p, index: m });
    }
    this.boundingBox && (e.boundingBox = this.boundingBox.clone()),
      this.boundingSphere && (e.boundingSphere = this.boundingSphere.clone());
    for (
      var v = this.morphTargets, g = e.morphTargets, i = 0, o = v.length;
      o > i;
      ++i
    ) {
      var S = v[i],
        x = { name: S.name, index: S.index };
      g[i] = x;
    }
    for (
      var G = this.morphColors, M = e.morphColors, i = 0, o = G.length;
      o > i;
      ++i
    ) {
      var y = G[i],
        w = { name: y.name, index: y.index, faceColors: y.faceColors };
      M[i] = w;
    }
    return d.color.mapped && (d.color.mapped = a[M[0].index]), e;
  }),
  (XG.GeometryIdCount = 0),
  (XG.PlaneGeometry = function (e, t) {
    XG.Geometry.call(this),
      (this.width = e),
      (this.height = t),
      (this.numPrimitives = 2),
      (this.numVertices = 4),
      this.addIndex("index", Uint16Array, 3),
      this.addAttribute("position", Float32Array, 3),
      this.addAttribute("normal", Float32Array, 3),
      this.addAttribute("uv", Float32Array, 2);
    var a = this.attributes.index.array,
      r = this.attributes.position.array,
      i = this.attributes.normal.array,
      o = this.attributes.uv.array,
      n = 0.5 * this.width,
      s = 0.5 * this.height;
    (r[0] = -n),
      (r[1] = -s),
      (r[2] = 0),
      (r[3] = n),
      (r[4] = -s),
      (r[5] = 0),
      (r[6] = n),
      (r[7] = s),
      (r[8] = 0),
      (r[9] = -n),
      (r[10] = s),
      (r[11] = 0),
      (i[0] = 0),
      (i[1] = 0),
      (i[2] = 1),
      (i[3] = 0),
      (i[4] = 0),
      (i[5] = 1),
      (i[6] = 0),
      (i[7] = 0),
      (i[8] = 1),
      (i[9] = 0),
      (i[10] = 0),
      (i[11] = 1),
      (o[0] = 0),
      (o[1] = 0),
      (o[2] = 1),
      (o[3] = 0),
      (o[4] = 1),
      (o[5] = 1),
      (o[6] = 0),
      (o[7] = 1),
      (a[0] = 0),
      (a[1] = 1),
      (a[2] = 3),
      (a[3] = 1),
      (a[4] = 2),
      (a[5] = 3),
      this.offsets.push({ start: 0, index: 0, count: a.length });
  }),
  (XG.PlaneGeometry.prototype = Object.create(XG.Geometry.prototype)),
  (XG.TriangleGeometry = function (e, t) {
    XG.Geometry.call(this),
      (this.numPrimitives = 1),
      (this.numVertices = 3),
      this.addAttribute("position", Float32Array, 3),
      this.addAttribute("uv", Float32Array, 2);
    var a = this.attributes.position.array,
      r = this.attributes.uv.array;
    (a[0] = e[0][0]),
      (a[1] = e[0][1]),
      (a[2] = e[0][2]),
      (a[3] = e[1][0]),
      (a[4] = e[1][1]),
      (a[5] = e[1][2]),
      (a[6] = e[2][0]),
      (a[7] = e[2][1]),
      (a[8] = e[2][2]),
      (r[0] = t[0][0]),
      (r[1] = t[0][1]),
      (r[2] = t[1][0]),
      (r[3] = t[1][1]),
      (r[4] = t[2][0]),
      (r[5] = t[2][1]);
  }),
  (XG.TriangleGeometry.prototype = Object.create(XG.Geometry.prototype)),
  (XG.HeightfieldGeometry = function (e, t, a, r, i) {
    XG.Geometry.call(this),
      (this.width = e),
      (this.length = t),
      (this.widthSegments = a || 1),
      (this.lengthSegments = r || 1),
      (this.numPrimitives = this.widthSegments * this.lengthSegments * 2),
      (this.numVertices = (this.widthSegments + 1) * (this.lengthSegments + 1));
    var o = Uint16Array;
    this.numVertices > 65536 &&
      (XG.elementIndexUintAvailable
        ? (o = Uint32Array)
        : console.warn(
          "XG.HeightfieldGeometry: too many vertices for 16 bit indices"
        )),
      this.addIndex("index", o, 3),
      this.addAttribute("position", Float32Array, 3),
      this.addAttribute("normal", Float32Array, 3),
      this.addAttribute("uv", Float32Array, 2);
    for (
      var n = this.attributes.index.array,
      s = this.attributes.position.array,
      l = this.attributes.uv.array,
      h = 0.5 * this.width,
      d = 0.5 * this.length,
      c = this.width / this.widthSegments,
      u = this.length / this.lengthSegments,
      f = 0,
      p = 0,
      m = 0,
      v = 0;
      v < this.lengthSegments + 1;
      v++
    )
      for (var g = 0; g < this.widthSegments + 1; g++) {
        var S = g * c - h,
          x = v * u - d,
          G = 0;
        void 0 !== i && ((G = i[m]), (m += 1)),
          (s[f] = S),
          (s[f + 1] = G),
          (s[f + 2] = x),
          (f += 3);
        var M = g / this.widthSegments,
          y = v / this.lengthSegments;
        (l[p] = M), (l[p + 1] = y), (p += 2);
      }
    for (
      var w = 0, _ = this.widthSegments + 1, v = 0;
      v < this.lengthSegments;
      v++
    )
      for (var g = 0; g < this.widthSegments; g++) {
        var X = g + _ * v,
          D = g + _ * (v + 1),
          T = g + 1 + _ * (v + 1),
          C = g + 1 + _ * v;
        (n[w] = X),
          (n[w + 1] = D),
          (n[w + 2] = C),
          (n[w + 3] = D),
          (n[w + 4] = T),
          (n[w + 5] = C),
          (w += 6);
      }
    this.offsets.push({ start: 0, index: 0, count: n.length }),
      this.computeVertexNormals();
  }),
  (XG.HeightfieldGeometry.prototype = Object.create(XG.Geometry.prototype)),
  (XG.BoxGeometry = function (e, t, a, r) {
    XG.Geometry.call(this),
      (this.width = e),
      (this.height = t),
      (this.depth = a);
    var i =
      void 0 !== r ? r : { px: !0, py: !0, pz: !0, nx: !0, ny: !0, nz: !0 },
      o = 0;
    i.px && (o += 2),
      i.nx && (o += 2),
      i.py && (o += 2),
      i.ny && (o += 2),
      i.pz && (o += 2),
      i.nz && (o += 2),
      (this.numPrimitives = o),
      (this.numVertices = 2 * o),
      this.addIndex("index", Uint16Array, 3),
      this.addAttribute("position", Float32Array, 3),
      this.addAttribute("normal", Float32Array, 3),
      this.addAttribute("uv", Float32Array, 2);
    var n = this.attributes.index.array,
      s = this.attributes.position.array,
      l = this.attributes.normal.array,
      h = this.attributes.uv.array,
      d = this.width / 2,
      c = this.height / 2,
      u = this.depth / 2,
      f = 0,
      p = 0,
      m = 0,
      v = 0,
      g = function (e, t, a, r, i, o, d, c, u, g, S, x, G, M, y) {
        (s[f] = r),
          (s[f + 1] = i),
          (s[f + 2] = o),
          (s[f + 3] = d),
          (s[f + 4] = c),
          (s[f + 5] = u),
          (s[f + 6] = g),
          (s[f + 7] = S),
          (s[f + 8] = x),
          (s[f + 9] = G),
          (s[f + 10] = M),
          (s[f + 11] = y),
          (l[f] = e),
          (l[f + 1] = t),
          (l[f + 2] = a),
          (l[f + 3] = e),
          (l[f + 4] = t),
          (l[f + 5] = a),
          (l[f + 6] = e),
          (l[f + 7] = t),
          (l[f + 8] = a),
          (l[f + 9] = e),
          (l[f + 10] = t),
          (l[f + 11] = a),
          (h[p] = 0),
          (h[p + 1] = 0),
          (h[p + 2] = 1),
          (h[p + 3] = 0),
          (h[p + 4] = 1),
          (h[p + 5] = 1),
          (h[p + 6] = 0),
          (h[p + 7] = 1),
          (n[m] = v),
          (n[m + 1] = v + 1),
          (n[m + 2] = v + 3),
          (n[m + 3] = v + 1),
          (n[m + 4] = v + 2),
          (n[m + 5] = v + 3),
          (f += 12),
          (p += 8),
          (m += 6),
          (v += 4);
      };
    i.px && g(1, 0, 0, d, -c, u, d, -c, -u, d, c, -u, d, c, u),
      i.nx && g(-1, 0, 0, -d, -c, -u, -d, -c, u, -d, c, u, -d, c, -u),
      i.py && g(0, 1, 0, -d, c, u, d, c, u, d, c, -u, -d, c, -u),
      i.ny && g(0, -1, 0, d, -c, u, -d, -c, u, -d, -c, -u, d, -c, -u),
      i.pz && g(0, 0, 1, -d, -c, u, d, -c, u, d, c, u, -d, c, u),
      i.nz && g(0, 0, -1, d, -c, -u, -d, -c, -u, -d, c, -u, d, c, -u),
      this.offsets.push({ start: 0, index: 0, count: n.length });
  }),
  (XG.BoxGeometry.prototype = Object.create(XG.Geometry.prototype)),
  (XG.SphereGeometry = function (e, t, a, r, i, o, n) {
    XG.Geometry.call(this),
      (this.radius = e || 50),
      (this.widthSegments = Math.max(3, Math.floor(t) || 8)),
      (this.heightSegments = Math.max(2, Math.floor(a) || 6)),
      (r = void 0 !== r ? r : 0),
      (i = void 0 !== i ? i : 2 * Math.PI),
      (o = void 0 !== o ? o : 0),
      (n = void 0 !== n ? n : Math.PI),
      (this.numPrimitives = this.heightSegments * this.widthSegments * 2),
      (this.numVertices = (this.heightSegments + 1) * (this.widthSegments + 1));
    var s = Uint16Array;
    this.numVertices > 65536 &&
      (XG.elementIndexUintAvailable
        ? (s = Uint32Array)
        : console.warn(
          "XG.SphereGeometry: too many vertices for 16 bit indices"
        )),
      this.addIndex("index", s, 3),
      this.addAttribute("position", Float32Array, 3),
      this.addAttribute("normal", Float32Array, 3),
      this.addAttribute("uv", Float32Array, 2);
    var l,
      h,
      d = this.attributes.index.array,
      c = this.attributes.position.array,
      u = this.attributes.normal.array,
      f = this.attributes.uv.array,
      p = 0,
      m = 0,
      v = new XG.Vector3();
    for (h = 0; h <= this.heightSegments; h++)
      for (l = 0; l <= this.widthSegments; l++) {
        var g = l / this.widthSegments,
          S = h / this.heightSegments,
          x = -this.radius * Math.cos(r + g * i) * Math.sin(o + S * n),
          G = this.radius * Math.cos(o + S * n),
          M = this.radius * Math.sin(r + g * i) * Math.sin(o + S * n);
        (c[p] = x),
          (c[p + 1] = G),
          (c[p + 2] = M),
          v.set(x, G, M).normalize(),
          (u[p] = v.data[0]),
          (u[p + 1] = v.data[1]),
          (u[p + 2] = v.data[2]),
          (p += 3),
          (f[m] = g),
          (f[m + 1] = 1 - S),
          (m += 2);
      }
    for (p = 0, h = 0; h < this.heightSegments; h++)
      for (l = 0; l < this.widthSegments; l++) {
        var y = h * (this.widthSegments + 1) + (l + 1),
          w = h * (this.widthSegments + 1) + l,
          _ = (h + 1) * (this.widthSegments + 1) + l,
          X = (h + 1) * (this.widthSegments + 1) + (l + 1);
        (d[p] = y),
          (d[p + 1] = w),
          (d[p + 2] = X),
          (d[p + 3] = w),
          (d[p + 4] = _),
          (d[p + 5] = X),
          (p += 6);
      }
    this.offsets.push({ start: 0, index: 0, count: d.length }),
      (this.boundingSphere = new XG.Sphere(new XG.Vector3(), e));
  }),
  (XG.SphereGeometry.prototype = Object.create(XG.Geometry.prototype)),
  (XG.CylinderGeometry = function (e, t, a, r, i, o) {
    XG.Geometry.call(this),
      (e = void 0 !== e ? e : 20),
      (t = void 0 !== t ? t : 20),
      (a = void 0 !== a ? a : 100);
    var n = a / 2,
      s = r || 8,
      l = i || 1,
      h = e > 0 && !o,
      d = t > 0 && !o;
    (this.numPrimitives = l * s * 2 + s * (1 * h + 1 * d)),
      (this.numVertices = (l + 1) * (s + 1) + (2 * s + 1) * (1 * h + 1 * d)),
      this.addIndex("index", Uint16Array, 3),
      this.addAttribute("position", Float32Array, 3),
      this.addAttribute("normal", Float32Array, 3),
      this.addAttribute("uv", Float32Array, 2);
    var c,
      u,
      f = this.attributes.index.array,
      p = this.attributes.position.array,
      m = this.attributes.normal.array,
      v = this.attributes.uv.array,
      g = 0,
      S = 0,
      x = 0;
    for (u = 0; l >= u; u++) {
      var G = u / l,
        M = G * (t - e) + e;
      for (c = 0; s >= c; c++) {
        var y = c / s,
          w = M * Math.sin(y * Math.PI * 2),
          _ = -G * a + n,
          X = M * Math.cos(y * Math.PI * 2);
        (p[g] = w),
          (p[g + 1] = _),
          (p[g + 2] = X),
          (g += 3),
          (v[x] = y),
          (v[x + 1] = 1 - G),
          (x += 2);
      }
    }
    var D,
      T,
      C,
      A,
      P,
      L,
      b,
      E,
      F = (t - e) / a,
      R = new XG.Vector3(),
      U = new XG.Vector3();
    for (S = 0, c = 0; s > c; c++)
      for (
        0 !== e
          ? ((b = c), (E = c + 1))
          : ((b = s + 1 + c), (E = s + 1 + (c + 1))),
        b *= 3,
        E *= 3,
        D = p[b],
        T = p[b + 1],
        C = p[b + 2],
        A = p[E],
        P = p[E + 1],
        L = p[E + 2],
        R.set(D, T, C),
        U.set(A, P, L),
        R.setY(
          Math.sqrt(R.data[0] * R.data[0] + R.data[2] * R.data[2]) * F
        ).normalize(),
        U.setY(
          Math.sqrt(U.data[0] * U.data[0] + U.data[2] * U.data[2]) * F
        ).normalize(),
        u = 0;
        l > u;
        u++
      ) {
        var I = u * (s + 1) + c,
          N = (u + 1) * (s + 1) + c,
          B = (u + 1) * (s + 1) + (c + 1),
          O = u * (s + 1) + (c + 1);
        (f[S] = I),
          (f[S + 1] = N),
          (f[S + 2] = O),
          (f[S + 3] = N),
          (f[S + 4] = B),
          (f[S + 5] = O),
          (S += 6),
          (m[3 * I] = R.data[0]),
          (m[3 * I + 1] = R.data[1]),
          (m[3 * I + 2] = R.data[2]),
          (m[3 * N] = R.data[0]),
          (m[3 * N + 1] = R.data[1]),
          (m[3 * N + 2] = R.data[2]),
          (m[3 * B] = U.data[0]),
          (m[3 * B + 1] = U.data[1]),
          (m[3 * B + 2] = U.data[2]),
          (m[3 * O] = U.data[0]),
          (m[3 * O + 1] = U.data[1]),
          (m[3 * O + 2] = U.data[2]);
      }
    if (!o && e > 0) {
      var B = g / 3;
      for (
        p[g] = 0,
        p[g + 1] = n,
        p[g + 2] = 0,
        m[g] = 0,
        m[g + 1] = 1,
        m[g + 2] = 0,
        g += 3,
        v[x] = 0.5,
        v[x + 1] = 0.5,
        x += 2,
        c = 0;
        s > c;
        c++
      ) {
        var I = g / 3,
          N = I + 1;
        (D = 3 * c),
          (A = 3 * (c + 1)),
          (p[g] = p[D]),
          (p[g + 1] = p[D + 1]),
          (p[g + 2] = p[D + 2]),
          (p[g + 3] = p[A]),
          (p[g + 4] = p[A + 1]),
          (p[g + 5] = p[A + 2]),
          (m[g] = 0),
          (m[g + 1] = 1),
          (m[g + 2] = 0),
          (m[g + 3] = 0),
          (m[g + 4] = 1),
          (m[g + 5] = 0),
          (g += 6),
          (f[S] = I),
          (f[S + 1] = N),
          (f[S + 2] = B),
          (S += 3);
        var V = c / s,
          k = (c + 1) / s;
        (v[x] = V), (v[x + 1] = 1), (v[x + 2] = k), (v[x + 3] = 1), (x += 4);
      }
    }
    if (!o && t > 0) {
      var B = g / 3;
      for (
        p[g] = 0,
        p[g + 1] = -n,
        p[g + 2] = 0,
        m[g] = 0,
        m[g + 1] = -1,
        m[g + 2] = 0,
        g += 3,
        v[x] = 0.5,
        v[x + 1] = 0.5,
        x += 2,
        c = 0;
        s > c;
        c++
      ) {
        var I = g / 3,
          N = I + 1;
        (D = 3 * (c + 1 + u * (s + 1))),
          (A = 3 * (c + u * (s + 1))),
          (p[g] = p[D]),
          (p[g + 1] = p[D + 1]),
          (p[g + 2] = p[D + 2]),
          (p[g + 3] = p[A]),
          (p[g + 4] = p[A + 1]),
          (p[g + 5] = p[A + 2]),
          (m[g] = 0),
          (m[g + 1] = -1),
          (m[g + 2] = 0),
          (m[g + 3] = 0),
          (m[g + 4] = -1),
          (m[g + 5] = 0),
          (g += 6),
          (f[S] = I),
          (f[S + 1] = N),
          (f[S + 2] = B),
          (S += 3);
        var V = c / s,
          k = (c + 1) / s;
        (v[x] = V), (v[x + 1] = 0), (v[x + 2] = k), (v[x + 3] = 0), (x += 4);
      }
    }
    this.offsets.push({ start: 0, index: 0, count: f.length });
  }),
  (XG.CylinderGeometry.prototype = Object.create(XG.Geometry.prototype)),
  (XG.CapsuleGeometry = function (e, t, a) {
    XG.Geometry.call(this);
    var r = new XG.CylinderGeometry(e, e, t, a, 1, !0),
      i = new XG.SphereGeometry(
        e,
        a,
        0.5 * a,
        0,
        2 * Math.PI,
        0,
        0.5 * Math.PI
      ),
      o = new XG.Vector3(0, 0.5 * t, 0),
      n = new XG.Vector3(0, 0.5 * -t, 0),
      s = new XG.Matrix4();
    s.makeTranslation(o);
    var l = new XG.Matrix4();
    l.makeRotationX(Math.PI);
    var h = new XG.Matrix4();
    h.makeTranslation(n),
      h.multiplySelf(l),
      r.merge(i, s),
      r.merge(i, h),
      r.computeBoundingSphere(),
      (this.attributes = r.attributes),
      (this.attributesList = r.attributesList),
      (this.virtualAttributes = r.virtualAttributes),
      (this.virtualAttributesList = r.virtualAttributesList),
      (this.numPrimitives = r.numPrimitives),
      (this.numVertices = r.numVertices),
      (this.offsets = r.offsets),
      (this.boundingBox = r.boundingBox),
      (this.boundingSphere = r.boundingSphere);
  }),
  (XG.CapsuleGeometry.prototype = Object.create(XG.Geometry.prototype)),
  (XG.RandomGeometry = function (e) {
    XG.Geometry.call(this),
      void 0 === e && (e = {}),
      (this.shape = void 0 !== e.shape ? e.shape : "sphere"),
      (this.customCallback =
        void 0 !== e.callback ? e.callback : function () { }),
      (this.radius = void 0 !== e.radius ? e.radius : 1),
      (this.width = void 0 !== e.width ? e.width : 1),
      (this.height = void 0 !== e.height ? e.height : 1),
      (this.depth = void 0 !== e.depth ? e.depth : 1),
      (this.useSeed = void 0 !== e.useSeed ? e.useSeed : !1),
      (this.seed = void 0 !== e.seed ? e.seed : Math.random()),
      (this.numPrimitives = 0),
      (this.numVertices = void 0 !== e.vertices ? e.vertices : 1e3),
      this.addAttribute("position", Float32Array, 3),
      this.refresh(this.seed);
  }),
  (XG.RandomGeometry.prototype = Object.create(XG.Geometry.prototype)),
  (XG.RandomGeometry.prototype.refresh = function (e) {
    this.seed = e;
    var t = this.attributes.position.array,
      a = this.radius,
      r = this.width,
      i = this.height,
      o = this.depth;
    if (this.useSeed) {
      Math.seedrandom(this.seed);
      var n = Math.srandom;
    } else var n = Math.random;
    var s,
      l = function (e) {
        var t = 2 * n() - 1,
          r = n() * Math.PI * 2,
          i = Math.sqrt(1 - t * t);
        (e.x = a * i * Math.cos(r)), (e.y = a * i * Math.sin(r)), (e.z = a * t);
      },
      h = function (e) {
        for (var t = 0, r = 0.5, i = u; i; r *= 0.5, i >>= 1) 1 & i && (t += r);
        t = 2 * t - 1;
        var o = (u + 0.5) / f,
          n = 2 * o * Math.PI,
          s = Math.sqrt(1 - t * t);
        (e.x = a * s * Math.cos(n)),
          (e.y = a * s * Math.sin(n)),
          (e.z = a * t),
          (u += 1);
      },
      d = function (e) {
        var t = (n() - 0.5) * a,
          r = (n() - 0.5) * a,
          i = (n() - 0.5) * a,
          o = n() * a,
          s = 1 / Math.sqrt(t * t + r * r + i * i);
        (e.x = o * t * s), (e.y = o * r * s), (e.z = o * i * s);
      },
      c = function (e) {
        (e.x = (n() - 0.5) * r),
          (e.y = (n() - 0.5) * i),
          (e.z = (n() - 0.5) * o);
      };
    "sphereSurface" === this.shape
      ? (s = l)
      : "sphereHammersley" === this.shape
        ? (s = h)
        : "sphere" === this.shape
          ? (s = d)
          : "box" === this.shape
            ? (s = c)
            : "custom" === this.shape && (s = this.customCallback);
    for (
      var u = 0,
      f = this.numVertices,
      p = 0,
      m = { x: 0, y: 0, z: 0 },
      v = 0,
      g = this.numVertices;
      g > v;
      v++
    )
      s(m), (t[p] = m.x), (t[p + 1] = m.y), (t[p + 2] = m.z), (p += 3);
    this.attributes.position.needsUpdate = !0;
  }),
  (XG.SpriteGeometry = function (e) {
    XG.Geometry.call(this),
      (this.numSprites = e),
      (this.numPrimitives = 2 * e),
      (this.numVertices = 4 * e);
    var t = Uint16Array;
    this.numVertices > 65536 &&
      (t = XG.elementIndexUintAvailable ? Uint32Array : null),
      null === t &&
      console.error(
        "XG.SpriteGeometry: 32 bit indices not supported (geometry has",
        e,
        "sprites)"
      ),
      this.addIndex("index", t, 3),
      this.addAttribute("position", Float32Array, 3),
      this.addAttribute("offset", Float32Array, 3),
      this.addAttribute("color", Float32Array, 3),
      this.addAttribute("uv", Float32Array, 2),
      this.addAttribute("scale", Float32Array, 2);
    for (
      var a = this.attributes.index.array,
      r = this.attributes.position.array,
      i = this.attributes.offset.array,
      o = this.attributes.color.array,
      n = this.attributes.uv.array,
      s = this.attributes.scale.array,
      l = 0,
      h = 0,
      d = 0,
      c = 0,
      u = function () {
        var e = 0,
          t = 0,
          u = 0,
          f = 1,
          p = 1,
          m = 1,
          v = 1,
          g = 1,
          S = 0,
          x = 0,
          G = 1,
          M = 0,
          y = 1,
          w = 1,
          _ = 0,
          X = 1;
        (r[l] = -0.5),
          (r[l + 1] = -0.5),
          (r[l + 2] = 0),
          (r[l + 3] = 0.5),
          (r[l + 4] = -0.5),
          (r[l + 5] = 0),
          (r[l + 6] = 0.5),
          (r[l + 7] = 0.5),
          (r[l + 8] = 0),
          (r[l + 9] = -0.5),
          (r[l + 10] = 0.5),
          (r[l + 11] = 0),
          (i[l] = e),
          (i[l + 1] = t),
          (i[l + 2] = u),
          (i[l + 3] = e),
          (i[l + 4] = t),
          (i[l + 5] = u),
          (i[l + 6] = e),
          (i[l + 7] = t),
          (i[l + 8] = u),
          (i[l + 9] = e),
          (i[l + 10] = t),
          (i[l + 11] = u),
          (o[l] = f),
          (o[l + 1] = p),
          (o[l + 2] = m),
          (o[l + 3] = f),
          (o[l + 4] = p),
          (o[l + 5] = m),
          (o[l + 6] = f),
          (o[l + 7] = p),
          (o[l + 8] = m),
          (o[l + 9] = f),
          (o[l + 10] = p),
          (o[l + 11] = m),
          (s[c] = v),
          (s[c + 1] = g),
          (s[c + 2] = v),
          (s[c + 3] = g),
          (s[c + 4] = v),
          (s[c + 5] = g),
          (s[c + 6] = v),
          (s[c + 7] = g),
          (n[c] = S),
          (n[c + 1] = x),
          (n[c + 2] = G),
          (n[c + 3] = M),
          (n[c + 4] = y),
          (n[c + 5] = w),
          (n[c + 6] = _),
          (n[c + 7] = X),
          (a[d] = h),
          (a[d + 1] = h + 1),
          (a[d + 2] = h + 2),
          (a[d + 3] = h),
          (a[d + 4] = h + 2),
          (a[d + 5] = h + 3),
          (l += 12),
          (c += 8),
          (d += 6),
          (h += 4);
      },
      f = 0;
      f < this.numSprites;
      f++
    )
      u();
    this.offsets.push({ start: 0, index: 0, count: a.length });
  }),
  (XG.SpriteGeometry.prototype = Object.create(XG.Geometry.prototype)),
  (XG.SpriteGeometry.prototype.setSpritePosition = function (e, t, a, r) {
    var i = this.attributes.offset.array,
      o = 12 * e;
    (i[o] = t),
      (i[o + 1] = a),
      (i[o + 2] = r),
      (i[o + 3] = t),
      (i[o + 4] = a),
      (i[o + 5] = r),
      (i[o + 6] = t),
      (i[o + 7] = a),
      (i[o + 8] = r),
      (i[o + 9] = t),
      (i[o + 10] = a),
      (i[o + 11] = r);
  }),
  (XG.SpriteGeometry.prototype.setSpriteColor = function (e, t, a, r) {
    var i = this.attributes.color.array,
      o = 12 * e;
    (i[o] = t),
      (i[o + 1] = a),
      (i[o + 2] = r),
      (i[o + 3] = t),
      (i[o + 4] = a),
      (i[o + 5] = r),
      (i[o + 6] = t),
      (i[o + 7] = a),
      (i[o + 8] = r),
      (i[o + 9] = t),
      (i[o + 10] = a),
      (i[o + 11] = r);
  }),
  (XG.SpriteGeometry.prototype.setSpriteScale = function (e, t, a) {
    var r = this.attributes.scale.array,
      i = 8 * e;
    (r[i] = t),
      (r[i + 1] = a),
      (r[i + 2] = t),
      (r[i + 3] = a),
      (r[i + 4] = t),
      (r[i + 5] = a),
      (r[i + 6] = t),
      (r[i + 7] = a);
  }),
  (XG.SpriteGeometry.prototype.setSpriteUV = function (
    e,
    t,
    a,
    r,
    i,
    o,
    n,
    s,
    l
  ) {
    var h = this.attributes.uv.array,
      d = 8 * e;
    (h[d] = t),
      (h[d + 1] = a),
      (h[d + 2] = o),
      (h[d + 3] = n),
      (h[d + 4] = s),
      (h[d + 5] = l),
      (h[d + 6] = r),
      (h[d + 7] = i);
  }),
  (XG.SpriteGeometry.prototype.computeBoundingSphere = function () {
    null === this.boundingSphere && (this.boundingSphere = new XG.Sphere());
    var e = this.attributes.position.array,
      t = this.attributes.offset.array,
      a = this.attributes.scale.array;
    if (e) {
      for (
        var r,
        i,
        o,
        n,
        s,
        l,
        h,
        d,
        c,
        u,
        f,
        p,
        m = 0,
        v = 0,
        g = 0,
        S = e.length;
        S > v;
        v += 3, g += 2
      )
        (s = e[v]),
          (l = e[v + 1]),
          (h = e[v + 2]),
          (d = t[v]),
          (c = t[v + 1]),
          (u = t[v + 2]),
          (f = a[g]),
          (p = a[g + 1]),
          (i = s * f + d),
          (o = l * p + c),
          (n = h + u),
          (r = i * i + o * o + n * n),
          r > m && (m = r);
      this.boundingSphere.radius = Math.sqrt(m);
    }
  }),
  (XG.SpriteGeometry.prototype.setSpriteTexture = function (e, t, a) {
    var r = a.width,
      i = a.height,
      o = t.width,
      n = t.height,
      s = t.x,
      l = t.y,
      h = s / r,
      d = (i - l) / i,
      c = (s + o) / r,
      u = (i - (l + n)) / i,
      f = (s + o) / r,
      p = (i - l) / i,
      m = s / r,
      v = (i - (l + n)) / i,
      g = o,
      S = n,
      x = this.attributes.scale.array,
      G = 8 * e,
      M = x[G],
      y = x[G + 1];
    (M = g * M),
      (y = S * y),
      this.setSpriteUV(e, m, v, h, d, c, u, f, p),
      this.setSpriteScale(e, M, y);
  }),
  (XG.SpriteGeometry.prototype.setText = function (e, t, a, r, i, o) {
    void 0 === i && (i = {});
    for (
      var n = void 0 !== i.wordWrap ? i.wordWrap : !0,
      s = void 0 !== i.charWrap ? i.charWrap : !1,
      l = void 0 !== i.color ? i.color : new XG.Color(16777215),
      h = i.font,
      d = i.lineLength,
      c = i.lineHeight,
      u = i.fontSize,
      f = Math.min(e.length, this.numSprites),
      p = c * h.base * u,
      m = { width: h.width, height: h.height, base: h.base },
      v = function (e) {
        return (
          " " === e ||
          "	" === e ||
          "\n" === e ||
          "\r" === e ||
          "\f" === e ||
          "" === e ||
          null === e
        );
      },
      g = function (t, a) {
        for (var r = a, i = t, o = e[i], n = e[i + 1]; f > i && !v(o);) {
          var s = o.charCodeAt(0),
            l = h.chars[s],
            d = v(n) || void 0 === n;
          if (void 0 === l) r += S;
          else {
            var c = l.xadvance * u,
              p = l.xoffset * u;
            if (d) {
              var m = l.width * u;
              r += p + m;
            } else r += p + c;
          }
          (i += 1), (o = e[i]), (n = e[i + 1]);
        }
        return r;
      },
      S = h.base,
      x = 0,
      G = 0,
      M = !0,
      y = null,
      w = 1 / 0,
      _ = 1 / 0,
      X = -(1 / 0),
      D = -(1 / 0),
      T = 0;
      f > T;
      T++
    ) {
      var C = e[T];
      if ("\n" !== C) {
        var A = C.charCodeAt(0),
          P = h.chars[A];
        if (void 0 !== P) {
          if (n && (M = v(y) && !v(C))) {
            var L = g(T, x);
            L > d && ((G -= p), (x = 0));
          }
          var b = P.width * u,
            E = P.height * u,
            F = P.xadvance * u,
            R = P.xoffset * u,
            U = P.yoffset * u;
          if (s) {
            var I = x + R + b;
            I > d && ((G -= p), (x = 0));
          }
          var N = t + 0.5 * b + x + R,
            B = a + 0.5 * E + G + U - E,
            O = r;
          this.setSpriteScale(T, u, u),
            this.setSpritePosition(T, N, B, O),
            this.setSpriteTexture(T, P, m),
            this.setSpriteColor(T, l.r, l.g, l.b);
          var V = x + R,
            k = V + b,
            z = G + U,
            H = z - E;
          w > V && (w = V),
            k > X && (X = k),
            _ > z && (_ = z),
            H > D && (D = H),
            (x += F),
            (y = C);
        } else (x += S * u), (y = C), this.setSpriteScale(T, 0, 0);
      } else (G -= p), (x = 0), (y = C), this.setSpriteScale(T, 0, 0);
    }
    return (
      void 0 === o &&
      (o = {
        width: 0,
        height: 0,
        minx: 1 / 0,
        maxx: -(1 / 0),
        miny: 1 / 0,
        maxy: -(1 / 0),
      }),
      (o.width = X - w),
      (o.height = D - _),
      (o.minx = w),
      (o.miny = _),
      (o.maxx = X),
      (o.maxy = D),
      o
    );
  }),
  (XG.GeometryUtils = {
    align: function (e, t) {
      for (var a = new XG.Box3(), r = 0, i = e.length; i > r; r++) {
        var o = e[r];
        o.computeBoundingBox(), a.add(o.boundingBox);
      }
      var n = t(a),
        s = new XG.Matrix4();
      s.makeTranslation(n);
      for (var r = 0, i = e.length; i > r; r++) {
        var o = e[r];
        o.applyMatrix(s);
      }
    },
    center: function (e) {
      XG.GeometryUtils.align(e, function (e) {
        var t = e.min.clone();
        return t.addSelf(e.max), t.multiplyScalar(-0.5), t;
      });
    },
    floor: function (e) {
      XG.GeometryUtils.align(e, function (e) {
        var t = new XG.Vector3(0, -e.min.y, 0);
        return t;
      });
    },
    generateTerrainHeights: function (e, t, a, r) {
      if (void 0 !== r) {
        Math.seedrandom(r);
        var i = Math.srandom;
      } else var i = Math.random;
      for (
        var o = function (t, a, r) {
          var i = a * s + t;
          e[i] = r;
        },
        n = function (t, a) {
          var r = a * s + t;
          return e[r];
        },
        s = t + 1,
        l = t;
        l >= 2;
        l /= 2
      ) {
        var h = l / 2;
        a /= 2;
        for (var d = 0; t > d; d += l)
          for (var c = 0; t > c; c += l) {
            var u = n(d, c) + n(d + l, c) + n(d, c + l) + n(d + l, c + l);
            (u /= 4), (u += 2 * a * i() - a), o(d + h, c + h, u);
          }
        for (var d = 0; t > d; d += h)
          for (var c = (d + h) % l; t > c; c += l) {
            var u =
              n((d - h + s) % s, c) +
              n((d + h) % s, c) +
              n(d, (c + h) % s) +
              n(d, (c - h + s) % s);
            (u /= 4),
              (u += 2 * a * i() - a),
              o(d, c, u),
              0 === d && o(t, c, u),
              0 === c && o(d, t, u);
          }
      }
    },
    getTerrainHeightsRange: function (e) {
      for (var t = 1 / 0, a = -(1 / 0), r = 0, i = e.length; i > r; r++) {
        var o = e[r];
        t > o && (t = o), o > a && (a = o);
      }
      return { min: t, max: a };
    },
    offsetTerrainHeights: function (e, t) {
      for (var a = 0, r = e.length; r > a; a++) e[a] += t;
    },
    centerTerrainHeights: function (e) {
      var t = XG.GeometryUtils.getTerrainHeightsRange(e),
        a = (t.min + t.max) * -0.5;
      XG.GeometryUtils.offsetTerrainHeights(e, a);
    },
    floorTerrainHeights: function (e) {
      var t = XG.GeometryUtils.getTerrainHeightsRange(e),
        a = -t.min;
      XG.GeometryUtils.offsetTerrainHeights(e, a);
    },
    blendTerrainHeights: function (e, t, a, r) {
      for (var i = 0, o = e.length; o > i; i++) {
        var n = e[i],
          s = t[i],
          l = Math.floor(i / a),
          h = i % a,
          d = r(h, l);
        e[i] = d * n + (1 - d) * s;
      }
    },
    addParticleAttributes: function (e) {
      e.addAttribute("velocitySpinStart", Float32Array, 4),
        e.addAttribute("accelerationSpinSpeed", Float32Array, 4),
        e.addAttribute("startSizeEndSizeStartTimeLifeTime", Float32Array, 4);
    },
    setParticleAttributes: function (e, t) {
      var a = e.attributes.velocitySpinStart.array,
        r = e.attributes.accelerationSpinSpeed.array,
        i = e.attributes.startSizeEndSizeStartTimeLifeTime.array,
        o = { x: 0, y: 0, z: 0 },
        n = { x: 0, y: 0, z: 0 },
        s = { start: 0, speed: 0 },
        l = { start: 0, end: 0 },
        h = { start: 0, life: 0 },
        d = { velocity: o, acceleration: n, spin: s, size: l, time: h };
      (a.length !== r.length ||
        a.length !== i.length ||
        i.length !== r.length) &&
        console.error(
          "XG.GeometryUtils.setParticleAttributes: attributes lengths mismatch"
        );
      for (var c = 0, u = a.length; u > c; c += 4)
        t(d),
          (a[c] = o.x),
          (a[c + 1] = o.y),
          (a[c + 2] = o.z),
          (a[c + 3] = s.start),
          (r[c] = n.x),
          (r[c + 1] = n.y),
          (r[c + 2] = n.z),
          (r[c + 3] = s.speed),
          (i[c] = l.start),
          (i[c + 1] = l.end),
          (i[c + 2] = h.start),
          (i[c + 3] = h.life);
    },
  }),
  (XG.Node = function () {
    (this.id = XG.NodeIdCount++),
      (this.name = ""),
      (this.properties = {}),
      (this.parent = void 0),
      (this.children = []),
      (this.transformChildren = !0),
      (this.position = new XG.Vector3()),
      (this.rotation = new XG.Vector3()),
      (this.scale = new XG.Vector3(1, 1, 1)),
      (this.up = new XG.Vector3(0, 1, 0)),
      (this.eulerOrder = XG.Node.defaultEulerOrder),
      (this.renderDepth = null),
      (this.rotationAutoUpdate = !0),
      (this.matrix = new XG.Matrix4()),
      (this.matrixWorld = new XG.Matrix4()),
      (this.matrixAutoUpdate = !0),
      (this.matrixWorldNeedsUpdate = !0),
      (this.quaternion = new XG.Quaternion()),
      (this.useQuaternion = !1),
      (this.visible = !0),
      (this.enabled = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0);
  }),
  (XG.Node.prototype = {
    constructor: XG.Node,
    applyMatrix: function (e) {
      this.matrix.multiply(e, this.matrix),
        this.scale.getScaleFromMatrix(this.matrix);
      var t = new XG.Matrix4().extractRotation(this.matrix);
      this.rotation.setEulerFromRotationMatrix(t, this.eulerOrder),
        this.position.getPositionFromMatrix(this.matrix);
    },
    translate: function (e, t) {
      this.matrix.rotateAxis(t), this.position.addSelf(t.multiplyScalar(e));
    },
    translateX: function (e) {
      this.translate(e, XG.Vector3.xAxis.clone());
    },
    translateY: function (e) {
      this.translate(e, XG.Vector3.yAxis.clone());
    },
    translateZ: function (e) {
      this.translate(e, XG.Vector3.zAxis.clone());
    },
    localToWorld: function (e) {
      return this.matrixWorld.multiplyVector3(e);
    },
    worldToLocal: function (e) {
      return XG.Node.__m1.getInverse(this.matrixWorld).multiplyVector3(e);
    },
    lookAt: function (e) {
      this.matrix.lookAt(e, this.position, this.up),
        this.rotationAutoUpdate &&
        (this.useQuaternion === !1
          ? this.rotation.setEulerFromRotationMatrix(
            this.matrix,
            this.eulerOrder
          )
          : this.quaternion.copy(this.matrix.decompose()[1]));
    },
    add: function (e) {
      if (e === this)
        return void console.warn(
          "XG.Node.add: A node can't be added as a child of itself."
        );
      if (e instanceof XG.Node) {
        void 0 !== e.parent && e.parent.remove(e),
          (e.parent = this),
          this.children.push(e);
        var t = this.getTopParent();
        void 0 !== t && t instanceof XG.Scene && t.__addNode(e);
      }
    },
    remove: function (e) {
      var t = this.children.indexOf(e);
      if (-1 !== t) {
        (e.parent = void 0), this.children.splice(t, 1);
        var a = this.getTopParent();
        void 0 !== a && a instanceof XG.Scene && a.__removeNode(e);
      }
    },
    // still debugging
    removeAll: function () {
      for(var t = this.children.length - 1; t >=0; t--){
        this.children.splice(t, 1);
        }
        this.getTopParent().__removeNode(this);
      },
    traverse: function (e) {
      e(this);
      for (var t = this.children, a = 0, r = t.length; r > a; a++)
        t[a].traverse(e);
    },
    getChildByName: function (e, t) {
      for (var a = 0, r = this.children.length; r > a; a++) {
        var i = this.children[a];
        if (i.name === e) return i;
        if (t === !0 && ((i = i.getChildByName(e, t)), void 0 !== i)) return i;
      }
      return void 0;
    },
    getDescendants: function (e) {
      void 0 === e && (e = []), Array.prototype.push.apply(e, this.children);
      for (var t = 0, a = this.children.length; a > t; t++)
        this.children[t].getDescendants(e);
      return e;
    },
    getTopParent: function () {
      for (var e = this; void 0 !== e.parent;) e = e.parent;
      return e;
    },
    updateMatrix: function () {
      this.useQuaternion === !1 &&
        this.quaternion.setFromEuler(this.rotation, this.eulerOrder),
        this.matrix.compose(this.position, this.quaternion, this.scale),
        (this.matrixWorldNeedsUpdate = !0);
    },
    updateMatrixWorld: function (e) {
      this.matrixAutoUpdate === !0 && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate === !0 || e === !0) &&
        (this.parent && this.parent.transformChildren
          ? this.matrixWorld.multiply(this.parent.matrixWorld, this.matrix)
          : this.matrixWorld.copy(this.matrix),
          (this.matrixWorldNeedsUpdate = !1),
          (e = !0));
      for (var t = this.children, a = 0, r = t.length; r > a; a++)
        t[a].updateMatrixWorld(e);
    },
    clone: function (e) {
      void 0 === e && (e = new XG.Node()),
        (e.name = this.name),
        e.up.copy(this.up),
        e.position.copy(this.position),
        e.rotation instanceof XG.Vector3 && e.rotation.copy(this.rotation),
        (e.eulerOrder = this.eulerOrder),
        e.scale.copy(this.scale),
        (e.renderDepth = this.renderDepth),
        (e.rotationAutoUpdate = this.rotationAutoUpdate),
        e.matrix.copy(this.matrix),
        e.matrixWorld.copy(this.matrixWorld),
        (e.matrixAutoUpdate = this.matrixAutoUpdate),
        (e.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate),
        e.quaternion.copy(this.quaternion),
        (e.useQuaternion = this.useQuaternion),
        (e.visible = this.visible),
        (e.castShadow = this.castShadow),
        (e.receiveShadow = this.receiveShadow),
        (e.frustumCulled = this.frustumCulled);
      for (var t = 0; t < this.children.length; t++) {
        var a = this.children[t];
        e.add(a.clone());
      }
      return e;
    },
  }),
  (XG.Node.__m1 = new XG.Matrix4()),
  (XG.Node.defaultEulerOrder = XG.xyzOrder),
  (XG.NodeIdCount = 0),
  (XG.Bone = function (e) {
    XG.Node.call(this), (this.skin = e), (this.skinMatrix = new XG.Matrix4());
  }),
  (XG.Bone.prototype = Object.create(XG.Node.prototype)),
  (XG.Bone.prototype.update = function (e, t) {
    this.matrixAutoUpdate && (t |= this.updateMatrix()),
      (t || this.matrixWorldNeedsUpdate) &&
      (e
        ? this.skinMatrix.multiply(e, this.matrix)
        : this.skinMatrix.copy(this.matrix),
        (this.matrixWorldNeedsUpdate = !1),
        (t = !0));
    for (var a = 0, r = this.children.length; r > a; a++)
      this.children[a].update(this.skinMatrix, t);
  }),
  (XG.Scene = function () {
    XG.Node.call(this),
      (this.fog = null),
      (this.heightFog = null),
      (this.matrixAutoUpdate = !1),
      (this.transformChildren = !1),
      (this.__objects = []),
      (this.__lights = []),
      (this.__objectsAdded = []),
      (this.__objectsRemoved = []);
  }),
  (XG.Scene.prototype = Object.create(XG.Node.prototype)),
  (XG.Scene.prototype.__addNode = function (e) {
    if (e instanceof XG.Light)
      -1 === this.__lights.indexOf(e) && this.__lights.push(e),
        e.target && void 0 === e.target.parent && this.add(e.target);
    else if (
      !(e instanceof XG.Camera || e instanceof XG.Bone) &&
      -1 === this.__objects.indexOf(e)
    ) {
      this.__objects.push(e), this.__objectsAdded.push(e);
      var t = this.__objectsRemoved.indexOf(e);
      -1 !== t && this.__objectsRemoved.splice(t, 1);
    }
    for (var a = 0; a < e.children.length; a++) this.__addNode(e.children[a]);
  }),
  (XG.Scene.prototype.__removeNode = function (e) {
    if (e instanceof XG.Light) {
      var t = this.__lights.indexOf(e);
      -1 !== t && this.__lights.splice(t, 1);
    } else if (!(e instanceof XG.Camera)) {
      var t = this.__objects.indexOf(e);
      // console.log("obj index " + t);
      if (-1 !== t) {
        // console.log("obj splice before: " + this.__objects);
        this.__objects.splice(t, 1);
        // console.log("obj splice after: " + this.__objects);
        this.__objectsRemoved.push(e);
        // console.log("child splice before: " + this.children);
        // this.children.splice(this.children.indexOf(e), 1);
        // console.log("child splice after: " + this.children);
        var a = this.__objectsAdded.indexOf(e);
        -1 !== a && this.__objectsAdded.splice(a, 1);
      }
    }
    for (var r = 0; r < e.children.length; r++)
      this.__removeNode(e.children[r]);
  }),
  (XG.Gyroscope = function () {
    XG.Node.call(this);
  }),
  (XG.Gyroscope.prototype = Object.create(XG.Node.prototype)),
  (XG.Gyroscope.prototype.updateMatrixWorld = function (e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
      (this.parent
        ? (this.matrixWorld.multiply(this.parent.matrixWorld, this.matrix),
          this.matrixWorld.decompose(
            this.translationWorld,
            this.rotationWorld,
            this.scaleWorld
          ),
          this.matrix.decompose(
            this.translationObject,
            this.rotationObject,
            this.scaleObject
          ),
          this.matrixWorld.compose(
            this.translationWorld,
            this.rotationObject,
            this.scaleWorld
          ))
        : this.matrixWorld.copy(this.matrix),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    for (var t = 0, a = this.children.length; a > t; t++)
      this.children[t].updateMatrixWorld(e);
  }),
  (XG.Gyroscope.prototype.translationWorld = new XG.Vector3()),
  (XG.Gyroscope.prototype.translationObject = new XG.Vector3()),
  (XG.Gyroscope.prototype.rotationWorld = new XG.Quaternion()),
  (XG.Gyroscope.prototype.rotationObject = new XG.Quaternion()),
  (XG.Gyroscope.prototype.scaleWorld = new XG.Vector3()),
  (XG.Gyroscope.prototype.scaleObject = new XG.Vector3()),
  (XG.Mesh = function (e, t) {
    XG.Node.call(this),
      (this.geometries =
        e instanceof Array ? e : e instanceof XG.Geometry ? [e] : []),
      (this.materials =
        t instanceof Array ? t : t instanceof XG.Material ? [t] : []);
    for (var a = 0, r = this.geometries.length; r > a; a++) {
      var i = this.geometries[a];
      null === i.boundingSphere && i.computeBoundingSphere();
    }
  }),
  (XG.Mesh.prototype = Object.create(XG.Node.prototype)),
  (XG.Mesh.prototype.clone = function (e) {
    return (
      void 0 === e && (e = new XG.Mesh(this.geometries, this.materials)),
      XG.Node.prototype.clone.call(this, e),
      e
    );
  }),
  (XG.MorphMesh = function (e, t) {
    XG.Mesh.call(this, e, t),
      (this.animationsMap = {}),
      (this.animationsList = []);
    var a = this.geometries[0],
      r = a.morphTargets.length,
      i = "__default",
      o = 0,
      n = r - 1,
      s = r / 1;
    this.createAnimation(i, o, n, s),
      this.setAnimationWeight(i, 1),
      (this.morphTargetInfluences = new Float32Array(a.morphTargets.length));
  }),
  (XG.MorphMesh.prototype = Object.create(XG.Mesh.prototype)),
  (XG.MorphMesh.prototype.createAnimation = function (e, t, a, r) {
    var i = {
      startFrame: t,
      endFrame: a,
      length: a - t + 1,
      fps: r,
      duration: (a - t) / r,
      lastFrame: 0,
      currentFrame: 0,
      active: !1,
      time: 0,
      direction: 1,
      weight: 1,
      directionBackwards: !1,
      mirroredLoop: !1,
    };
    (this.animationsMap[e] = i), this.animationsList.push(i);
  }),
  (XG.MorphMesh.prototype.autoCreateAnimations = function (e) {
    for (
      var t,
      a = /([a-z]+)(\d+)/,
      r = {},
      i = this.geometries[0],
      o = 0,
      n = i.morphTargets.length;
      n > o;
      o++
    ) {
      var s = i.morphTargets[o],
        l = s.name.match(a);
      if (l && l.length > 1) {
        var h = l[1];
        r[h] || (r[h] = { start: 1 / 0, end: -(1 / 0) });
        var d = r[h];
        o < d.start && (d.start = o), o > d.end && (d.end = o), t || (t = h);
      }
    }
    for (var h in r) {
      var d = r[h];
      this.createAnimation(h, d.start, d.end, e);
    }
    this.firstAnimation = t;
  }),
  (XG.MorphMesh.prototype.setAnimationDirectionForward = function (e) {
    var t = this.animationsMap[e];
    t && ((t.direction = 1), (t.directionBackwards = !1));
  }),
  (XG.MorphMesh.prototype.setAnimationDirectionBackward = function (e) {
    var t = this.animationsMap[e];
    t && ((t.direction = -1), (t.directionBackwards = !0));
  }),
  (XG.MorphMesh.prototype.setAnimationFPS = function (e, t) {
    var a = this.animationsMap[e];
    a && ((a.fps = t), (a.duration = (a.end - a.start) / a.fps));
  }),
  (XG.MorphMesh.prototype.setAnimationDuration = function (e, t) {
    var a = this.animationsMap[e];
    a && ((a.duration = t), (a.fps = (a.end - a.start) / a.duration));
  }),
  (XG.MorphMesh.prototype.setAnimationWeight = function (e, t) {
    var a = this.animationsMap[e];
    a && (a.weight = t);
  }),
  (XG.MorphMesh.prototype.setAnimationTime = function (e, t) {
    var a = this.animationsMap[e];
    a && (a.time = t);
  }),
  (XG.MorphMesh.prototype.getAnimationTime = function (e) {
    var t = 0,
      a = this.animationsMap[e];
    return a && (t = a.time), t;
  }),
  (XG.MorphMesh.prototype.getAnimationDuration = function (e) {
    var t = -1,
      a = this.animationsMap[e];
    return a && (t = a.duration), t;
  }),
  (XG.MorphMesh.prototype.playAnimation = function (e) {
    var t = this.animationsMap[e];
    t
      ? ((t.time = 0), (t.active = !0))
      : console.warn("animation[" + e + "] undefined");
  }),
  (XG.MorphMesh.prototype.stopAnimation = function (e) {
    var t = this.animationsMap[e];
    t && (t.active = !1);
  }),
  (XG.MorphMesh.prototype.update = function (e) {
    for (var t = 0, a = this.animationsList.length; a > t; t++) {
      var r = this.animationsList[t];
      if (r.active) {
        var i = r.duration / r.length;
        (r.time += r.direction * e),
          r.mirroredLoop
            ? (r.time > r.duration || r.time < 0) &&
            ((r.direction *= -1),
              r.time > r.duration &&
              ((r.time = r.duration), (r.directionBackwards = !0)),
              r.time < 0 && ((r.time = 0), (r.directionBackwards = !1)))
            : ((r.time = r.time % r.duration),
              r.time < 0 && (r.time += r.duration));
        var o =
          r.startFrame +
          XG.Math.clamp(Math.floor(r.time / i), 0, r.length - 1),
          n = r.weight;
        o !== r.currentFrame &&
          ((this.morphTargetInfluences[r.lastFrame] = 0),
            (this.morphTargetInfluences[r.currentFrame] = 1 * n),
            (this.morphTargetInfluences[o] = 0),
            (r.lastFrame = r.currentFrame),
            (r.currentFrame = o));
        var s = (r.time % i) / i;
        r.directionBackwards && (s = 1 - s),
          (this.morphTargetInfluences[r.currentFrame] = s * n),
          (this.morphTargetInfluences[r.lastFrame] = (1 - s) * n);
      }
    }
  }),
  (XG.MD2Character = function () {
    function e(e, t) {
      for (var r = [], i = 0; i < t.length; i++)
        (r[i] = XG.ImageUtils.loadTexture(e + t[i], a)), (r[i].name = t[i]);
      return r;
    }
    function t(e, t) {
      var a = new XG.PhongMaterial({
        color: 16777215,
        specular: 1118481,
        shininess: 50,
        map: t,
        morphTargets: !0,
        morphNormals: !0,
        metal: !0,
      });
      a.wrapAround = !0;
      for (var r = [], o = 0, n = e.length; n > o; o++) r[o] = a;
      var s = new XG.MorphMesh(e, r);
      return (
        s.rotation.setY(-Math.PI / 2), s.autoCreateAnimations(i.animationFPS), s
      );
    }
    function a() {
      (i.loadCounter -= 1), 0 === i.loadCounter && i.onLoadComplete();
    }
    function r(e) {
      return 1 === e ? 1 : -Math.pow(2, -10 * e) + 1;
    }
    var i = this;
    (this.scale = 1),
      (this.animationFPS = 6),
      (this.transitionFrames = 15),
      (this.maxSpeed = 275),
      (this.maxReverseSpeed = -275),
      (this.frontAcceleration = 600),
      (this.backAcceleration = 600),
      (this.frontDecceleration = 600),
      (this.angularSpeed = 2.5),
      (this.root = new XG.Node()),
      (this.meshBody = null),
      (this.meshWeapon = null),
      (this.controls = null),
      (this.skinsBody = []),
      (this.skinsWeapon = []),
      (this.weapons = []),
      (this.currentSkin = void 0),
      (this.onLoadComplete = function () { }),
      (this.meshes = []),
      (this.animations = {}),
      (this.loadCounter = 0),
      (this.speed = 0),
      (this.bodyOrientation = 0),
      (this.walkSpeed = this.maxSpeed),
      (this.crouchSpeed = 0.5 * this.maxSpeed),
      (this.activeAnimation = null),
      (this.oldAnimation = null),
      (this.enableShadows = function (e) {
        for (var t = 0; t < this.meshes.length; t++)
          (this.meshes[t].castShadow = e), (this.meshes[t].receiveShadow = e);
      }),
      (this.setVisible = function (e) {
        for (var t = 0; t < this.meshes.length; t++)
          (this.meshes[t].visible = e), (this.meshes[t].visible = e);
      }),
      (this.shareParts = function (e) {
        (this.animations = e.animations),
          (this.walkSpeed = e.walkSpeed),
          (this.crouchSpeed = e.crouchSpeed),
          (this.skinsBody = e.skinsBody),
          (this.skinsWeapon = e.skinsWeapon);
        var a = t(e.meshBody.geometries, this.skinsBody[0]);
        a.scale.set(this.scale, this.scale, this.scale),
          (this.root.position.data[1] = e.root.position.data[1]),
          this.root.add(a),
          (this.meshBody = a),
          this.meshes.push(a);
        for (var r = 0; r < e.weapons.length; r++) {
          var i = t(e.weapons[r].geometries, this.skinsWeapon[r]);
          i.scale.set(this.scale, this.scale, this.scale),
            (i.visible = !1),
            (i.name = e.weapons[r].name),
            this.root.add(i),
            (this.weapons[r] = i),
            (this.meshWeapon = i),
            this.meshes.push(i);
        }
      }),
      (this.loadParts = function (r) {
        (this.animations = r.animations),
          (this.walkSpeed = r.walkSpeed),
          (this.crouchSpeed = r.crouchSpeed),
          (this.loadCounter = 2 * r.weapons.length + r.skins.length + 1);
        for (var o = [], n = 0; n < r.weapons.length; n++)
          o[n] = r.weapons[n][1];
        (this.skinsBody = e(r.baseUrl + "skins/", r.skins)),
          (this.skinsWeapon = e(r.baseUrl + "skins/", o));
        var s = new XG.JSONLoader();
        s.load(r.baseUrl + r.body, function (e) {
          for (var r = 0, o = e.length; o > r; r++) {
            var n = e[r];
            n.computeBoundingBox();
          }
          i.root.position.data[1] = -i.scale * n.boundingBox.min.data[1];
          var s = t(n, i.skinsBody[0]);
          s.scale.multiplyScalar(i.scale),
            i.root.add(s),
            (i.meshBody = s),
            i.meshes.push(s),
            a();
        });
        for (
          var l = function (e, r) {
            return function (o) {
              var n = t(o, i.skinsWeapon[e]);
              n.scale.set(i.scale, i.scale, i.scale),
                (n.visible = !1),
                (n.name = r),
                i.root.add(n),
                (i.weapons[e] = n),
                (i.meshWeapon = n),
                i.meshes.push(n),
                a();
            };
          },
          n = 0;
          n < r.weapons.length;
          n++
        )
          s.load(r.baseUrl + r.weapons[n][0], l(n, r.weapons[n][0]));
      }),
      (this.setPlaybackRate = function (e) {
        this.meshBody &&
          (this.meshBody.duration = this.meshBody.baseDuration / e),
          this.meshWeapon &&
          (this.meshWeapon.duration = this.meshWeapon.baseDuration / e);
      }),
      (this.setSkin = function (e) {
        if (this.meshBody) {
          for (var t = 0, a = this.meshBody.materials.length; a > t; t++) {
            var r = this.meshBody.materials[t];
            r.map = this.skinsBody[e];
          }
          this.currentSkin = e;
        }
      }),
      (this.setWeapon = function (e) {
        for (var t = 0; t < this.weapons.length; t++)
          this.weapons[t].visible = !1;
        var a = this.weapons[e];
        a &&
          ((a.visible = !0),
            (this.meshWeapon = a),
            this.activeAnimation &&
            (a.playAnimation(this.activeAnimation),
              this.meshWeapon.setAnimationTime(
                this.activeAnimation,
                this.meshBody.getAnimationTime(this.activeAnimation)
              )));
      }),
      (this.setAnimation = function (e) {
        e !== this.activeAnimation &&
          e &&
          (this.meshBody &&
            (this.meshBody.setAnimationWeight(e, 0),
              this.meshBody.playAnimation(e),
              (this.oldAnimation = this.activeAnimation),
              (this.activeAnimation = e),
              (this.blendCounter = this.transitionFrames)),
            this.meshWeapon &&
            (this.meshWeapon.setAnimationWeight(e, 0),
              this.meshWeapon.playAnimation(e)));
      }),
      (this.update = function (e) {
        this.controls && this.updateMovementModel(e),
          this.animations &&
          (this.updateBehaviors(e), this.updateAnimations(e));
      }),
      (this.updateAnimations = function (e) {
        var t = 1;
        this.blendCounter > 0 &&
          ((t =
            (this.transitionFrames - this.blendCounter) /
            this.transitionFrames),
            (this.blendCounter -= 1)),
          this.meshBody &&
          (this.meshBody.update(e),
            this.meshBody.setAnimationWeight(this.activeAnimation, t),
            this.meshBody.setAnimationWeight(this.oldAnimation, 1 - t)),
          this.meshWeapon &&
          (this.meshWeapon.update(e),
            this.meshWeapon.setAnimationWeight(this.activeAnimation, t),
            this.meshWeapon.setAnimationWeight(this.oldAnimation, 1 - t));
      }),
      (this.updateBehaviors = function () {
        var e,
          t,
          a = this.controls,
          r = this.animations;
        a.crouch
          ? ((e = r.crouchMove), (t = r.crouchIdle))
          : ((e = r.move), (t = r.idle)),
          a.jump && ((e = r.jump), (t = r.jump)),
          a.attack &&
          (a.crouch
            ? ((e = r.crouchAttack), (t = r.crouchAttack))
            : ((e = r.attack), (t = r.attack))),
          (a.moveForward || a.moveBackward || a.moveLeft || a.moveRight) &&
          this.activeAnimation !== e &&
          this.setAnimation(e),
          Math.abs(this.speed) < 0.2 * this.maxSpeed &&
          !(a.moveLeft || a.moveRight || a.moveForward || a.moveBackward) &&
          this.activeAnimation !== t &&
          this.setAnimation(t),
          a.moveForward &&
          (this.meshBody &&
            (this.meshBody.setAnimationDirectionForward(this.activeAnimation),
              this.meshBody.setAnimationDirectionForward(this.oldAnimation)),
            this.meshWeapon &&
            (this.meshWeapon.setAnimationDirectionForward(
              this.activeAnimation
            ),
              this.meshWeapon.setAnimationDirectionForward(this.oldAnimation))),
          a.moveBackward &&
          (this.meshBody &&
            (this.meshBody.setAnimationDirectionBackward(
              this.activeAnimation
            ),
              this.meshBody.setAnimationDirectionBackward(this.oldAnimation)),
            this.meshWeapon &&
            (this.meshWeapon.setAnimationDirectionBackward(
              this.activeAnimation
            ),
              this.meshWeapon.setAnimationDirectionBackward(
                this.oldAnimation
              )));
      }),
      (this.updateMovementModel = function (e) {
        var t = this.controls;
        (this.maxSpeed = t.crouch ? this.crouchSpeed : this.walkSpeed),
          (this.maxReverseSpeed = -this.maxSpeed),
          t.moveForward &&
          (this.speed = XG.Math.clamp(
            this.speed + e * this.frontAcceleration,
            this.maxReverseSpeed,
            this.maxSpeed
          )),
          t.moveBackward &&
          (this.speed = XG.Math.clamp(
            this.speed - e * this.backAcceleration,
            this.maxReverseSpeed,
            this.maxSpeed
          ));
        var a = 1;
        if (
          (t.moveLeft &&
            ((this.bodyOrientation += e * this.angularSpeed),
              (this.speed = XG.Math.clamp(
                this.speed + a * e * this.frontAcceleration,
                this.maxReverseSpeed,
                this.maxSpeed
              ))),
            t.moveRight &&
            ((this.bodyOrientation -= e * this.angularSpeed),
              (this.speed = XG.Math.clamp(
                this.speed + a * e * this.frontAcceleration,
                this.maxReverseSpeed,
                this.maxSpeed
              ))),
            !t.moveForward && !t.moveBackward)
        )
          if (this.speed > 0) {
            var i = r(this.speed / this.maxSpeed);
            this.speed = XG.Math.clamp(
              this.speed - i * e * this.frontDecceleration,
              0,
              this.maxSpeed
            );
          } else {
            var i = r(this.speed / this.maxReverseSpeed);
            this.speed = XG.Math.clamp(
              this.speed + i * e * this.backAcceleration,
              this.maxReverseSpeed,
              0
            );
          }
        var o = this.speed * e;
        (this.root.position.data[0] += Math.sin(this.bodyOrientation) * o),
          (this.root.position.data[2] += Math.cos(this.bodyOrientation) * o),
          (this.root.rotation.data[1] = this.bodyOrientation);
      });
  }),
  (XG.SkinnedCharacter = function (e) {
    function t(e) {
      return 1 === e ? 1 : -Math.pow(2, -10 * e) + 1;
    }
    (this.config = e),
      (this.transitionFrames = 15),
      (this.controls = null),
      (this.root = new XG.Node()),
      (this.meshes = []),
      (this.animations = {}),
      (this.speed = 0),
      (this.bodyOrientation = 0),
      (this.activeAnimation = null),
      (this.oldAnimation = null),
      (this.animations = e.animations),
      (this.walkSpeed = void 0 !== e.walkSpeed ? e.walkSpeed : 275),
      (this.crouchSpeed = void 0 !== e.crouchSpeed ? e.crouchSpeed : 137.5),
      (this.angularSpeed = void 0 !== e.angularSpeed ? e.angularSpeed : 2.5),
      (this.frontAcceleration =
        void 0 !== e.frontAcceleration ? e.frontAcceleration : 600),
      (this.frontDecceleration =
        void 0 !== e.frontDecceleration ? e.frontDecceleration : 600),
      (this.backAcceleration =
        void 0 !== e.backAcceleration ? e.backAcceleration : 600),
      (this.maxSpeed = this.walkSpeed),
      (this.maxReverseSpeed = -this.maxSpeed),
      (this.addMesh = function (e) {
        this.root.add(e), this.meshes.push(e);
      }),
      (this.enableShadows = function (e) {
        for (var t = 0; t < this.meshes.length; t++) {
          var a = this.meshes[t];
          (a.castShadow = e), (a.receiveShadow = e);
        }
      }),
      (this.setVisible = function (e) {
        for (var t = 0; t < this.meshes.length; t++) {
          var a = this.meshes[t];
          (a.visible = e), (a.visible = e);
        }
      }),
      (this.setAnimation = function (e) {
        if (e !== this.activeAnimation && e)
          for (var t = 0, a = this.meshes.length; a > t; t++) {
            var r = this.meshes[t];
            r.setAnimationWeight(e, 0),
              r.playAnimation(e),
              (this.oldAnimation = this.activeAnimation),
              (this.activeAnimation = e),
              (this.blendCounter = this.transitionFrames);
          }
      }),
      (this.update = function (e) {
        this.controls && this.updateMovementModel(e),
          this.animations &&
          (this.updateBehaviors(e), this.updateAnimations(e));
      }),
      (this.updateAnimations = function (e) {
        var t = 1;
        this.blendCounter > 0 &&
          ((t =
            (this.transitionFrames - this.blendCounter) /
            this.transitionFrames),
            (this.blendCounter -= 1));
        for (var a = 0, r = this.meshes.length; r > a; a++) {
          var i = this.meshes[a];
          i.setAnimationWeight(this.activeAnimation, t),
            i.setAnimationWeight(this.oldAnimation, 1 - t),
            i.update(e);
        }
      }),
      (this.updateBehaviors = function () {
        var e,
          t,
          a = this.controls,
          r = this.animations;
        if (
          (a.crouch
            ? ((e = r.crouchMove), (t = r.crouchIdle))
            : ((e = r.move), (t = r.idle)),
            a.jump && ((e = r.jump), (t = r.jump)),
            a.attack &&
            (a.crouch
              ? ((e = r.crouchAttack), (t = r.crouchAttack))
              : ((e = r.attack), (t = r.attack))),
            (a.moveForward || a.moveBackward || a.moveLeft || a.moveRight) &&
            this.activeAnimation !== e &&
            this.setAnimation(e),
            Math.abs(this.speed) < 0.2 * this.maxSpeed &&
            !(a.moveLeft || a.moveRight || a.moveForward || a.moveBackward) &&
            this.activeAnimation !== t &&
            this.setAnimation(t),
            a.moveForward)
        )
          for (var i = 0, o = this.meshes.length; o > i; i++) {
            var n = this.meshes[i];
            n.setAnimationDirectionForward(this.activeAnimation),
              n.setAnimationDirectionForward(this.oldAnimation);
          }
        if (a.moveBackward)
          for (var i = 0, o = this.meshes.length; o > i; i++) {
            var n = this.meshes[i];
            n.setAnimationDirectionBackward(this.activeAnimation),
              n.setAnimationDirectionBackward(this.oldAnimation);
          }
      }),
      (this.updateMovementModel = function (e) {
        var a = this.controls;
        (this.maxSpeed = a.crouch ? this.crouchSpeed : this.walkSpeed),
          (this.maxReverseSpeed = -this.maxSpeed),
          a.moveForward &&
          (this.speed = XG.Math.clamp(
            this.speed + e * this.frontAcceleration,
            this.maxReverseSpeed,
            this.maxSpeed
          )),
          a.moveBackward &&
          (this.speed = XG.Math.clamp(
            this.speed - e * this.backAcceleration,
            this.maxReverseSpeed,
            this.maxSpeed
          ));
        var r = 1;
        if (
          (a.moveLeft &&
            ((this.bodyOrientation += e * this.angularSpeed),
              (this.speed = XG.Math.clamp(
                this.speed + r * e * this.frontAcceleration,
                this.maxReverseSpeed,
                this.maxSpeed
              ))),
            a.moveRight &&
            ((this.bodyOrientation -= e * this.angularSpeed),
              (this.speed = XG.Math.clamp(
                this.speed + r * e * this.frontAcceleration,
                this.maxReverseSpeed,
                this.maxSpeed
              ))),
            !a.moveForward && !a.moveBackward)
        )
          if (this.speed > 0) {
            var i = t(this.speed / this.maxSpeed);
            this.speed = XG.Math.clamp(
              this.speed - i * e * this.frontDecceleration,
              0,
              this.maxSpeed
            );
          } else {
            var i = t(this.speed / this.maxReverseSpeed);
            this.speed = XG.Math.clamp(
              this.speed + i * e * this.backAcceleration,
              this.maxReverseSpeed,
              0
            );
          }
        var o = this.speed * e;
        (this.root.position.data[0] += Math.sin(this.bodyOrientation) * o),
          (this.root.position.data[2] += Math.cos(this.bodyOrientation) * o),
          (this.root.rotation.data[1] = this.bodyOrientation);
      });
  }),
  (XG.SkinnedMesh = function (e, t, a) {
    XG.Mesh.call(this, e, t),
      (this.useVertexTexture = void 0 !== a ? a : !0),
      (this.animations = {}),
      (this.animationsList = []),
      (this.identityMatrix = new XG.Matrix4()),
      (this.bones = []),
      (this.boneMatrices = []),
      (this.boneMap = []);
    var r = this.geometries[0];
    if (r) {
      var i = r.bones,
        o = r.animations;
      if (i) {
        var n, s, l, h, d, c;
        for (n = 0; n < i.length; n++)
          (l = i[n]),
            (h = l.pos),
            (d = l.rotq),
            (c = l.scl),
            (s = this.addBone()),
            (s.name = l.name),
            s.position.set(h[0], h[1], h[2]),
            s.quaternion.set(d[0], d[1], d[2], d[3]),
            (s.useQuaternion = !0),
            void 0 !== c ? s.scale.set(c[0], c[1], c[2]) : s.scale.set(1, 1, 1);
        for (n = 0; n < this.bones.length; n++)
          (l = i[n]),
            (s = this.bones[n]),
            -1 === l.parent ? this.add(s) : this.bones[l.parent].add(s),
            (s.properties.index = n),
            (this.boneMap[s.name] = s);
        var u = this.bones.length;
        if (this.useVertexTexture) {
          var f;
          (f = u > 256 ? 64 : u > 64 ? 32 : u > 16 ? 16 : 8),
            (this.boneTextureWidth = f),
            (this.boneTextureHeight = f),
            (this.boneMatrices = new Float32Array(
              this.boneTextureWidth * this.boneTextureHeight * 4
            )),
            (this.boneTexture = new XG.DataTexture(
              this.boneMatrices,
              this.boneTextureWidth,
              this.boneTextureHeight,
              XG.RGBAFormat,
              XG.FloatType
            )),
            (this.boneTexture.minFilter = XG.NearestFilter),
            (this.boneTexture.magFilter = XG.NearestFilter),
            (this.boneTexture.generateMipmaps = !1),
            (this.boneTexture.flipY = !1);
        } else this.boneMatrices = new Float32Array(16 * u);
        this.pose();
      }
      if (o)
        for (var p = 0, m = o.length; m > p; p++) {
          var v = o[p],
            g = new XG.Animation(this, v);
          (this.animations[v.name] = g), this.animationsList.push(g);
        }
    }
  }),
  (XG.SkinnedMesh.prototype = Object.create(XG.Mesh.prototype)),
  (XG.SkinnedMesh.prototype.playAnimation = function (e) {
    void 0 !== this.animations[e] && this.animations[e].play();
  }),
  (XG.SkinnedMesh.prototype.stopAnimation = function (e) {
    void 0 !== this.animations[e] && this.animations[e].stop();
  }),
  (XG.SkinnedMesh.prototype.pauseAnimation = function (e) {
    void 0 !== this.animations[e] && this.animations[e].pause();
  }),
  (XG.SkinnedMesh.prototype.setAnimationWeight = function (e, t) {
    void 0 !== this.animations[e] && this.animations[e].setWeight(t);
  }),
  (XG.SkinnedMesh.prototype.setAnimationDirectionForward = function (e) {
    void 0 !== this.animations[e] && this.animations[e].setDirectionForward();
  }),
  (XG.SkinnedMesh.prototype.setAnimationDirectionBackward = function (e) {
    void 0 !== this.animations[e] && this.animations[e].setDirectionBackward();
  }),
  (XG.SkinnedMesh.prototype.update = function (e) {
    for (var t = this.bones, a = 0, r = t.length; r > a; a++) {
      var i = t[a];
      i.firstAnimationFlag = !0;
    }
    for (var a = 0, r = this.animationsList.length; r > a; a++) {
      var o = this.animationsList[a];
      o.update(e);
    }
  }),
  (XG.SkinnedMesh.prototype.addBone = function (e) {
    return void 0 === e && (e = new XG.Bone(this)), this.bones.push(e), e;
  }),
  (XG.SkinnedMesh.prototype.getBone = function (e) {
    var t = this.boneMap[e];
    return t;
  }),
  (XG.SkinnedMesh.prototype.updateMatrixWorld = function (e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
      (this.parent
        ? this.matrixWorld.multiply(this.parent.matrixWorld, this.matrix)
        : this.matrixWorld.copy(this.matrix),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    for (var t = 0, a = this.children.length; a > t; t++) {
      var r = this.children[t];
      r instanceof XG.Bone
        ? r.update(this.identityMatrix, !1)
        : r.updateMatrixWorld(!0);
    }
    if (void 0 == this.boneInverses) {
      this.boneInverses = [];
      for (var i = 0, o = this.bones.length; o > i; i++) {
        var n = new XG.Matrix4();
        n.getInverse(this.bones[i].skinMatrix), this.boneInverses.push(n);
      }
    }
    for (var i = 0, o = this.bones.length; o > i; i++)
      XG.SkinnedMesh.offsetMatrix.multiply(
        this.bones[i].skinMatrix,
        this.boneInverses[i]
      ),
        XG.SkinnedMesh.offsetMatrix.flattenToArrayOffset(
          this.boneMatrices,
          16 * i
        );
    this.useVertexTexture && (this.boneTexture.needsUpdate = !0);
  }),
  (XG.SkinnedMesh.prototype.pose = function () {
    this.updateMatrixWorld(!0);
    for (var e, t, a, r, i, o = 0, n = this.geometries.length; n > o; o++)
      for (
        var s = this.geometries[o],
        l = s.attributes.skinWeight.array,
        h = 0,
        d = l.length;
        d > h;
        h += 4
      )
        (e = l[h]),
          (t = l[h + 1]),
          (a = l[h + 2]),
          (r = l[h + 3]),
          (i = 1 / (Math.abs(e) + Math.abs(t) + Math.abs(a) + Math.abs(r))),
          i !== 1 / 0
            ? ((l[h] *= i), (l[h + 1] *= i), (l[h + 2] *= i), (l[h + 3] *= i))
            : (l[h] = 1);
  }),
  (XG.SkinnedMesh.prototype.clone = function (e) {
    return (
      void 0 === e &&
      (e = new XG.SkinnedMesh(
        this.geometries,
        this.materials,
        this.useVertexTexture
      )),
      XG.Mesh.prototype.clone.call(this, e),
      e
    );
  }),
  (XG.SkinnedMesh.offsetMatrix = new XG.Matrix4()),
  (XG.TriangleStrip = function (e, t) {
    XG.Mesh.call(this, e, t);
  }),
  (XG.TriangleStrip.prototype = Object.create(XG.Mesh.prototype)),
  (XG.TriangleStrip.prototype.clone = function (e) {
    return (
      void 0 === e &&
      (e = new XG.TriangleStrip(this.geometries, this.materials)),
      XG.Mesh.prototype.clone.call(this, e),
      e
    );
  }),
  (XG.Particles = function (e, t) {
    XG.Node.call(this),
      (this.geometries =
        e instanceof Array ? e : e instanceof XG.Geometry ? [e] : []),
      (this.materials =
        t instanceof Array ? t : t instanceof XG.Material ? [t] : []);
    for (var a = 0, r = this.geometries.length; r > a; a++) {
      var i = this.geometries[a];
      null === i.boundingSphere && i.computeBoundingSphere();
    }
    (this.sortParticles = !1), (this.frustumCulled = !1);
  }),
  (XG.Particles.prototype = Object.create(XG.Node.prototype)),
  (XG.Particles.prototype.clone = function (e) {
    return (
      void 0 === e && (e = new XG.Particles(this.geometries, this.materials)),
      (e.sortParticles = this.sortParticles),
      (e.frustumCulled = this.frustumCulled),
      XG.Node.prototype.clone.call(this, e),
      e
    );
  }),
  (XG.ImmediateRenderObject = function () {
    XG.Node.call(this),
      (this.boundingSphere = new XG.Sphere()),
      (this.render = function () { });
  }),
  (XG.ImmediateRenderObject.prototype = Object.create(XG.Node.prototype)),
  (XG.MarchingCubes = function (e, t, a, r) {
    XG.ImmediateRenderObject.call(this),
      (this.materials = [t]),
      (this.boundingSphere.radius = 1),
      (this.enableUvs = void 0 !== a ? a : !1),
      (this.enableColors = void 0 !== r ? r : !1),
      (this.init = function (e) {
        (this.resolution = e),
          (this.isolation = 80),
          (this.size = e),
          (this.size2 = this.size * this.size),
          (this.size3 = this.size2 * this.size),
          (this.halfsize = this.size / 2),
          (this.delta = 2 / this.size),
          (this.yd = this.size),
          (this.zd = this.size2),
          (this.field = new Float32Array(this.size3)),
          (this.normal_cache = new Float32Array(3 * this.size3)),
          (this.vlist = new Float32Array(36)),
          (this.nlist = new Float32Array(36)),
          (this.firstDraw = !0),
          (this.maxCount = 4096),
          (this.count = 0),
          (this.hasPositions = !1),
          (this.hasNormals = !1),
          (this.hasColors = !1),
          (this.hasUvs = !1),
          (this.positionArray = new Float32Array(3 * this.maxCount)),
          (this.normalArray = new Float32Array(3 * this.maxCount)),
          this.enableUvs &&
          (this.uvArray = new Float32Array(2 * this.maxCount)),
          this.enableColors &&
          (this.colorArray = new Float32Array(3 * this.maxCount));
      }),
      (this.lerp = function (e, t, a) {
        return e + (t - e) * a;
      }),
      (this.VIntX = function (e, t, a, r, i, o, n, s, l, h) {
        var d = (i - l) / (h - l),
          c = this.normal_cache;
        (t[r] = o + d * this.delta),
          (t[r + 1] = n),
          (t[r + 2] = s),
          (a[r] = this.lerp(c[e], c[e + 3], d)),
          (a[r + 1] = this.lerp(c[e + 1], c[e + 4], d)),
          (a[r + 2] = this.lerp(c[e + 2], c[e + 5], d));
      }),
      (this.VIntY = function (e, t, a, r, i, o, n, s, l, h) {
        var d = (i - l) / (h - l),
          c = this.normal_cache;
        (t[r] = o), (t[r + 1] = n + d * this.delta), (t[r + 2] = s);
        var u = e + 3 * this.yd;
        (a[r] = this.lerp(c[e], c[u], d)),
          (a[r + 1] = this.lerp(c[e + 1], c[u + 1], d)),
          (a[r + 2] = this.lerp(c[e + 2], c[u + 2], d));
      }),
      (this.VIntZ = function (e, t, a, r, i, o, n, s, l, h) {
        var d = (i - l) / (h - l),
          c = this.normal_cache;
        (t[r] = o), (t[r + 1] = n), (t[r + 2] = s + d * this.delta);
        var u = e + 3 * this.zd;
        (a[r] = this.lerp(c[e], c[u], d)),
          (a[r + 1] = this.lerp(c[e + 1], c[u + 1], d)),
          (a[r + 2] = this.lerp(c[e + 2], c[u + 2], d));
      }),
      (this.compNorm = function (e) {
        var t = 3 * e;
        0 === this.normal_cache[t] &&
          ((this.normal_cache[t] = this.field[e - 1] - this.field[e + 1]),
            (this.normal_cache[t + 1] =
              this.field[e - this.yd] - this.field[e + this.yd]),
            (this.normal_cache[t + 2] =
              this.field[e - this.zd] - this.field[e + this.zd]));
      }),
      (this.polygonize = function (e, t, a, r, i, o) {
        var n = r + 1,
          s = r + this.yd,
          l = r + this.zd,
          h = n + this.yd,
          d = n + this.zd,
          c = r + this.yd + this.zd,
          u = n + this.yd + this.zd,
          f = 0,
          p = this.field[r],
          m = this.field[n],
          v = this.field[s],
          g = this.field[h],
          S = this.field[l],
          x = this.field[d],
          G = this.field[c],
          M = this.field[u];
        i > p && (f |= 1),
          i > m && (f |= 2),
          i > v && (f |= 8),
          i > g && (f |= 4),
          i > S && (f |= 16),
          i > x && (f |= 32),
          i > G && (f |= 128),
          i > M && (f |= 64);
        var y = XG.edgeTable[f];
        if (0 === y) return 0;
        var w = this.delta,
          _ = e + w,
          X = t + w,
          D = a + w;
        1 & y &&
          (this.compNorm(r),
            this.compNorm(n),
            this.VIntX(3 * r, this.vlist, this.nlist, 0, i, e, t, a, p, m)),
          2 & y &&
          (this.compNorm(n),
            this.compNorm(h),
            this.VIntY(3 * n, this.vlist, this.nlist, 3, i, _, t, a, m, g)),
          4 & y &&
          (this.compNorm(s),
            this.compNorm(h),
            this.VIntX(3 * s, this.vlist, this.nlist, 6, i, e, X, a, v, g)),
          8 & y &&
          (this.compNorm(r),
            this.compNorm(s),
            this.VIntY(3 * r, this.vlist, this.nlist, 9, i, e, t, a, p, v)),
          16 & y &&
          (this.compNorm(l),
            this.compNorm(d),
            this.VIntX(3 * l, this.vlist, this.nlist, 12, i, e, t, D, S, x)),
          32 & y &&
          (this.compNorm(d),
            this.compNorm(u),
            this.VIntY(3 * d, this.vlist, this.nlist, 15, i, _, t, D, x, M)),
          64 & y &&
          (this.compNorm(c),
            this.compNorm(u),
            this.VIntX(3 * c, this.vlist, this.nlist, 18, i, e, X, D, G, M)),
          128 & y &&
          (this.compNorm(l),
            this.compNorm(c),
            this.VIntY(3 * l, this.vlist, this.nlist, 21, i, e, t, D, S, G)),
          256 & y &&
          (this.compNorm(r),
            this.compNorm(l),
            this.VIntZ(3 * r, this.vlist, this.nlist, 24, i, e, t, a, p, S)),
          512 & y &&
          (this.compNorm(n),
            this.compNorm(d),
            this.VIntZ(3 * n, this.vlist, this.nlist, 27, i, _, t, a, m, x)),
          1024 & y &&
          (this.compNorm(h),
            this.compNorm(u),
            this.VIntZ(3 * h, this.vlist, this.nlist, 30, i, _, X, a, g, M)),
          2048 & y &&
          (this.compNorm(s),
            this.compNorm(c),
            this.VIntZ(3 * s, this.vlist, this.nlist, 33, i, e, X, a, v, G)),
          (f <<= 4);
        for (var T, C, A, P = 0, L = 0; -1 != XG.triTable[f + L];)
          (T = f + L),
            (C = T + 1),
            (A = T + 2),
            this.posnormtriv(
              this.vlist,
              this.nlist,
              3 * XG.triTable[T],
              3 * XG.triTable[C],
              3 * XG.triTable[A],
              o
            ),
            (L += 3),
            P++;
        return P;
      }),
      (this.posnormtriv = function (e, t, a, r, i, o) {
        var n = 3 * this.count;
        if (
          ((this.positionArray[n] = e[a]),
            (this.positionArray[n + 1] = e[a + 1]),
            (this.positionArray[n + 2] = e[a + 2]),
            (this.positionArray[n + 3] = e[r]),
            (this.positionArray[n + 4] = e[r + 1]),
            (this.positionArray[n + 5] = e[r + 2]),
            (this.positionArray[n + 6] = e[i]),
            (this.positionArray[n + 7] = e[i + 1]),
            (this.positionArray[n + 8] = e[i + 2]),
            (this.normalArray[n] = t[a]),
            (this.normalArray[n + 1] = t[a + 1]),
            (this.normalArray[n + 2] = t[a + 2]),
            (this.normalArray[n + 3] = t[r]),
            (this.normalArray[n + 4] = t[r + 1]),
            (this.normalArray[n + 5] = t[r + 2]),
            (this.normalArray[n + 6] = t[i]),
            (this.normalArray[n + 7] = t[i + 1]),
            (this.normalArray[n + 8] = t[i + 2]),
            this.enableUvs)
        ) {
          var s = 2 * this.count;
          (this.uvArray[s] = e[a]),
            (this.uvArray[s + 1] = e[a + 2]),
            (this.uvArray[s + 2] = e[r]),
            (this.uvArray[s + 3] = e[r + 2]),
            (this.uvArray[s + 4] = e[i]),
            (this.uvArray[s + 5] = e[i + 2]);
        }
        this.enableColors &&
          ((this.colorArray[n] = e[a]),
            (this.colorArray[n + 1] = e[a + 1]),
            (this.colorArray[n + 2] = e[a + 2]),
            (this.colorArray[n + 3] = e[r]),
            (this.colorArray[n + 4] = e[r + 1]),
            (this.colorArray[n + 5] = e[r + 2]),
            (this.colorArray[n + 6] = e[i]),
            (this.colorArray[n + 7] = e[i + 1]),
            (this.colorArray[n + 8] = e[i + 2])),
          (this.count += 3),
          this.count >= this.maxCount - 3 &&
          ((this.hasPositions = !0),
            (this.hasNormals = !0),
            this.enableUvs && (this.hasUvs = !0),
            this.enableColors && (this.hasColors = !0),
            o(this));
      }),
      (this.begin = function () {
        (this.count = 0),
          (this.hasPositions = !1),
          (this.hasNormals = !1),
          (this.hasUvs = !1),
          (this.hasColors = !1);
      }),
      (this.end = function (e) {
        if (0 !== this.count) {
          for (var t = 3 * this.count; t < this.positionArray.length; t++)
            this.positionArray[t] = 0;
          (this.hasPositions = !0),
            (this.hasNormals = !0),
            this.enableUvs && (this.hasUvs = !0),
            this.enableColors && (this.hasColors = !0),
            e(this);
        }
      }),
      (this.addBall = function (e, t, a, r, i) {
        var o = this.size * Math.sqrt(r / i),
          n = a * this.size,
          s = t * this.size,
          l = e * this.size,
          h = Math.floor(n - o);
        1 > h && (h = 1);
        var d = Math.floor(n + o);
        d > this.size - 1 && (d = this.size - 1);
        var c = Math.floor(s - o);
        1 > c && (c = 1);
        var u = Math.floor(s + o);
        u > this.size - 1 && (u = this.size - 1);
        var f = Math.floor(l - o);
        1 > f && (f = 1);
        var p = Math.floor(l + o);
        p > this.size - 1 && (p = this.size - 1);
        var m, v, g, S, x, G, M, y, w, _, X;
        for (g = h; d > g; g++)
          for (
            x = this.size2 * g, y = g / this.size - a, w = y * y, v = c;
            u > v;
            v++
          )
            for (
              S = x + this.size * v, M = v / this.size - t, _ = M * M, m = f;
              p > m;
              m++
            )
              (G = m / this.size - e),
                (X = r / (1e-6 + G * G + _ + w) - i),
                X > 0 && (this.field[S + m] += X);
      }),
      (this.addPlaneX = function (e, t) {
        var a,
          r,
          i,
          o,
          n,
          s,
          l,
          h = this.size,
          d = this.yd,
          c = this.zd,
          u = this.field,
          f = h * Math.sqrt(e / t);
        for (f > h && (f = h), a = 0; f > a; a++)
          if (((s = a / h), (o = s * s), (n = e / (1e-4 + o) - t), n > 0))
            for (r = 0; h > r; r++)
              for (l = a + r * d, i = 0; h > i; i++) u[c * i + l] += n;
      }),
      (this.addPlaneY = function (e, t) {
        var a,
          r,
          i,
          o,
          n,
          s,
          l,
          h,
          d = this.size,
          c = this.yd,
          u = this.zd,
          f = this.field,
          p = d * Math.sqrt(e / t);
        for (p > d && (p = d), r = 0; p > r; r++)
          if (((s = r / d), (o = s * s), (n = e / (1e-4 + o) - t), n > 0))
            for (l = r * c, a = 0; d > a; a++)
              for (h = l + a, i = 0; d > i; i++) f[u * i + h] += n;
      }),
      (this.addPlaneZ = function (e, t) {
        var a,
          r,
          i,
          o,
          n,
          s,
          l,
          h,
          d = this.size,
          c = this.yd,
          u = this.zd,
          f = this.field,
          p = d * Math.sqrt(e / t);
        for (p > d && (p = d), i = 0; p > i; i++)
          if (((s = i / d), (o = s * s), (n = e / (1e-4 + o) - t), n > 0))
            for (l = u * i, r = 0; d > r; r++)
              for (h = l + r * c, a = 0; d > a; a++) f[h + a] += n;
      }),
      (this.reset = function () {
        var e;
        for (e = 0; e < this.size3; e++)
          (this.normal_cache[3 * e] = 0), (this.field[e] = 0);
      }),
      (this.render = function (e) {
        this.begin();
        var t,
          a,
          r,
          i,
          o,
          n,
          s,
          l,
          h,
          d = this.size - 2;
        for (i = 1; d > i; i++)
          for (
            h = this.size2 * i, s = (i - this.halfsize) / this.halfsize, r = 1;
            d > r;
            r++
          )
            for (
              l = h + this.size * r,
              n = (r - this.halfsize) / this.halfsize,
              a = 1;
              d > a;
              a++
            )
              (o = (a - this.halfsize) / this.halfsize),
                (t = l + a),
                this.polygonize(o, n, s, t, this.isolation, e);
        this.end(e);
      }),
      this.init(e);
  }),
  (XG.MarchingCubes.prototype = Object.create(
    XG.ImmediateRenderObject.prototype
  )),
  (XG.edgeTable = new Int32Array([
    0,
    265,
    515,
    778,
    1030,
    1295,
    1541,
    1804,
    2060,
    2309,
    2575,
    2822,
    3082,
    3331,
    3593,
    3840,
    400,
    153,
    915,
    666,
    1430,
    1183,
    1941,
    1692,
    2460,
    2197,
    2975,
    2710,
    3482,
    3219,
    3993,
    3728,
    560,
    825,
    51,
    314,
    1590,
    1855,
    1077,
    1340,
    2620,
    2869,
    2111,
    2358,
    3642,
    3891,
    3129,
    3376,
    928,
    681,
    419,
    170,
    1958,
    1711,
    1445,
    1196,
    2988,
    2725,
    2479,
    2214,
    4010,
    3747,
    3497,
    3232,
    1120,
    1385,
    1635,
    1898,
    102,
    367,
    613,
    876,
    3180,
    3429,
    3695,
    3942,
    2154,
    2403,
    2665,
    2912,
    1520,
    1273,
    2035,
    1786,
    502,
    255,
    1013,
    764,
    3580,
    3317,
    4095,
    3830,
    2554,
    2291,
    3065,
    2800,
    1616,
    1881,
    1107,
    1370,
    598,
    863,
    85,
    348,
    3676,
    3925,
    3167,
    3414,
    2650,
    2899,
    2137,
    2384,
    1984,
    1737,
    1475,
    1226,
    966,
    719,
    453,
    204,
    4044,
    3781,
    3535,
    3270,
    3018,
    2755,
    2505,
    2240,
    2240,
    2505,
    2755,
    3018,
    3270,
    3535,
    3781,
    4044,
    204,
    453,
    719,
    966,
    1226,
    1475,
    1737,
    1984,
    2384,
    2137,
    2899,
    2650,
    3414,
    3167,
    3925,
    3676,
    348,
    85,
    863,
    598,
    1370,
    1107,
    1881,
    1616,
    2800,
    3065,
    2291,
    2554,
    3830,
    4095,
    3317,
    3580,
    764,
    1013,
    255,
    502,
    1786,
    2035,
    1273,
    1520,
    2912,
    2665,
    2403,
    2154,
    3942,
    3695,
    3429,
    3180,
    876,
    613,
    367,
    102,
    1898,
    1635,
    1385,
    1120,
    3232,
    3497,
    3747,
    4010,
    2214,
    2479,
    2725,
    2988,
    1196,
    1445,
    1711,
    1958,
    170,
    419,
    681,
    928,
    3376,
    3129,
    3891,
    3642,
    2358,
    2111,
    2869,
    2620,
    1340,
    1077,
    1855,
    1590,
    314,
    51,
    825,
    560,
    3728,
    3993,
    3219,
    3482,
    2710,
    2975,
    2197,
    2460,
    1692,
    1941,
    1183,
    1430,
    666,
    915,
    153,
    400,
    3840,
    3593,
    3331,
    3082,
    2822,
    2575,
    2309,
    2060,
    1804,
    1541,
    1295,
    1030,
    778,
    515,
    265,
    0,
  ])),
  (XG.triTable = new Int32Array([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    8,
    3,
    9,
    8,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    1,
    2,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    2,
    10,
    0,
    2,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    8,
    3,
    2,
    10,
    8,
    10,
    9,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    11,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    2,
    8,
    11,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    0,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    11,
    2,
    1,
    9,
    11,
    9,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    10,
    1,
    11,
    10,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    10,
    1,
    0,
    8,
    10,
    8,
    11,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    9,
    0,
    3,
    11,
    9,
    11,
    10,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    8,
    10,
    10,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    3,
    0,
    7,
    3,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    1,
    9,
    4,
    7,
    1,
    7,
    3,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    4,
    7,
    3,
    0,
    4,
    1,
    2,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    2,
    10,
    9,
    0,
    2,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    10,
    9,
    2,
    9,
    7,
    2,
    7,
    3,
    7,
    9,
    4,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    7,
    3,
    11,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    4,
    7,
    11,
    2,
    4,
    2,
    0,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    1,
    8,
    4,
    7,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    11,
    9,
    4,
    11,
    9,
    11,
    2,
    9,
    2,
    1,
    -1,
    -1,
    -1,
    -1,
    3,
    10,
    1,
    3,
    11,
    10,
    7,
    8,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    11,
    10,
    1,
    4,
    11,
    1,
    0,
    4,
    7,
    11,
    4,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    8,
    9,
    0,
    11,
    9,
    11,
    10,
    11,
    0,
    3,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    11,
    4,
    11,
    9,
    9,
    11,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    0,
    8,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    5,
    4,
    1,
    5,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    5,
    4,
    8,
    3,
    5,
    3,
    1,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    9,
    5,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    8,
    1,
    2,
    10,
    4,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    2,
    10,
    5,
    4,
    2,
    4,
    0,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    10,
    5,
    3,
    2,
    5,
    3,
    5,
    4,
    3,
    4,
    8,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    2,
    0,
    8,
    11,
    4,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    5,
    4,
    0,
    1,
    5,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    1,
    5,
    2,
    5,
    8,
    2,
    8,
    11,
    4,
    8,
    5,
    -1,
    -1,
    -1,
    -1,
    10,
    3,
    11,
    10,
    1,
    3,
    9,
    5,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    5,
    0,
    8,
    1,
    8,
    10,
    1,
    8,
    11,
    10,
    -1,
    -1,
    -1,
    -1,
    5,
    4,
    0,
    5,
    0,
    11,
    5,
    11,
    10,
    11,
    0,
    3,
    -1,
    -1,
    -1,
    -1,
    5,
    4,
    8,
    5,
    8,
    10,
    10,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    8,
    5,
    7,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    3,
    0,
    9,
    5,
    3,
    5,
    7,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    7,
    8,
    0,
    1,
    7,
    1,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    5,
    3,
    3,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    8,
    9,
    5,
    7,
    10,
    1,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    1,
    2,
    9,
    5,
    0,
    5,
    3,
    0,
    5,
    7,
    3,
    -1,
    -1,
    -1,
    -1,
    8,
    0,
    2,
    8,
    2,
    5,
    8,
    5,
    7,
    10,
    5,
    2,
    -1,
    -1,
    -1,
    -1,
    2,
    10,
    5,
    2,
    5,
    3,
    3,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    9,
    5,
    7,
    8,
    9,
    3,
    11,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    7,
    9,
    7,
    2,
    9,
    2,
    0,
    2,
    7,
    11,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    11,
    0,
    1,
    8,
    1,
    7,
    8,
    1,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    11,
    2,
    1,
    11,
    1,
    7,
    7,
    1,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    8,
    8,
    5,
    7,
    10,
    1,
    3,
    10,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    5,
    7,
    0,
    5,
    0,
    9,
    7,
    11,
    0,
    1,
    0,
    10,
    11,
    10,
    0,
    -1,
    11,
    10,
    0,
    11,
    0,
    3,
    10,
    5,
    0,
    8,
    0,
    7,
    5,
    7,
    0,
    -1,
    11,
    10,
    5,
    7,
    11,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    1,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    8,
    3,
    1,
    9,
    8,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    5,
    2,
    6,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    5,
    1,
    2,
    6,
    3,
    0,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    6,
    5,
    9,
    0,
    6,
    0,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    9,
    8,
    5,
    8,
    2,
    5,
    2,
    6,
    3,
    2,
    8,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    11,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    0,
    8,
    11,
    2,
    0,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    2,
    3,
    11,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    6,
    1,
    9,
    2,
    9,
    11,
    2,
    9,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    6,
    3,
    11,
    6,
    5,
    3,
    5,
    1,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    11,
    0,
    11,
    5,
    0,
    5,
    1,
    5,
    11,
    6,
    -1,
    -1,
    -1,
    -1,
    3,
    11,
    6,
    0,
    3,
    6,
    0,
    6,
    5,
    0,
    5,
    9,
    -1,
    -1,
    -1,
    -1,
    6,
    5,
    9,
    6,
    9,
    11,
    11,
    9,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    6,
    4,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    3,
    0,
    4,
    7,
    3,
    6,
    5,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    0,
    5,
    10,
    6,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    5,
    1,
    9,
    7,
    1,
    7,
    3,
    7,
    9,
    4,
    -1,
    -1,
    -1,
    -1,
    6,
    1,
    2,
    6,
    5,
    1,
    4,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    5,
    5,
    2,
    6,
    3,
    0,
    4,
    3,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    7,
    9,
    0,
    5,
    0,
    6,
    5,
    0,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    7,
    3,
    9,
    7,
    9,
    4,
    3,
    2,
    9,
    5,
    9,
    6,
    2,
    6,
    9,
    -1,
    3,
    11,
    2,
    7,
    8,
    4,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    6,
    4,
    7,
    2,
    4,
    2,
    0,
    2,
    7,
    11,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    4,
    7,
    8,
    2,
    3,
    11,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    9,
    2,
    1,
    9,
    11,
    2,
    9,
    4,
    11,
    7,
    11,
    4,
    5,
    10,
    6,
    -1,
    8,
    4,
    7,
    3,
    11,
    5,
    3,
    5,
    1,
    5,
    11,
    6,
    -1,
    -1,
    -1,
    -1,
    5,
    1,
    11,
    5,
    11,
    6,
    1,
    0,
    11,
    7,
    11,
    4,
    0,
    4,
    11,
    -1,
    0,
    5,
    9,
    0,
    6,
    5,
    0,
    3,
    6,
    11,
    6,
    3,
    8,
    4,
    7,
    -1,
    6,
    5,
    9,
    6,
    9,
    11,
    4,
    7,
    9,
    7,
    11,
    9,
    -1,
    -1,
    -1,
    -1,
    10,
    4,
    9,
    6,
    4,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    10,
    6,
    4,
    9,
    10,
    0,
    8,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    0,
    1,
    10,
    6,
    0,
    6,
    4,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    3,
    1,
    8,
    1,
    6,
    8,
    6,
    4,
    6,
    1,
    10,
    -1,
    -1,
    -1,
    -1,
    1,
    4,
    9,
    1,
    2,
    4,
    2,
    6,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    8,
    1,
    2,
    9,
    2,
    4,
    9,
    2,
    6,
    4,
    -1,
    -1,
    -1,
    -1,
    0,
    2,
    4,
    4,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    3,
    2,
    8,
    2,
    4,
    4,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    4,
    9,
    10,
    6,
    4,
    11,
    2,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    2,
    2,
    8,
    11,
    4,
    9,
    10,
    4,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    3,
    11,
    2,
    0,
    1,
    6,
    0,
    6,
    4,
    6,
    1,
    10,
    -1,
    -1,
    -1,
    -1,
    6,
    4,
    1,
    6,
    1,
    10,
    4,
    8,
    1,
    2,
    1,
    11,
    8,
    11,
    1,
    -1,
    9,
    6,
    4,
    9,
    3,
    6,
    9,
    1,
    3,
    11,
    6,
    3,
    -1,
    -1,
    -1,
    -1,
    8,
    11,
    1,
    8,
    1,
    0,
    11,
    6,
    1,
    9,
    1,
    4,
    6,
    4,
    1,
    -1,
    3,
    11,
    6,
    3,
    6,
    0,
    0,
    6,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    4,
    8,
    11,
    6,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    10,
    6,
    7,
    8,
    10,
    8,
    9,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    7,
    3,
    0,
    10,
    7,
    0,
    9,
    10,
    6,
    7,
    10,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    7,
    1,
    10,
    7,
    1,
    7,
    8,
    1,
    8,
    0,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    7,
    10,
    7,
    1,
    1,
    7,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    6,
    1,
    6,
    8,
    1,
    8,
    9,
    8,
    6,
    7,
    -1,
    -1,
    -1,
    -1,
    2,
    6,
    9,
    2,
    9,
    1,
    6,
    7,
    9,
    0,
    9,
    3,
    7,
    3,
    9,
    -1,
    7,
    8,
    0,
    7,
    0,
    6,
    6,
    0,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    3,
    2,
    6,
    7,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    11,
    10,
    6,
    8,
    10,
    8,
    9,
    8,
    6,
    7,
    -1,
    -1,
    -1,
    -1,
    2,
    0,
    7,
    2,
    7,
    11,
    0,
    9,
    7,
    6,
    7,
    10,
    9,
    10,
    7,
    -1,
    1,
    8,
    0,
    1,
    7,
    8,
    1,
    10,
    7,
    6,
    7,
    10,
    2,
    3,
    11,
    -1,
    11,
    2,
    1,
    11,
    1,
    7,
    10,
    6,
    1,
    6,
    7,
    1,
    -1,
    -1,
    -1,
    -1,
    8,
    9,
    6,
    8,
    6,
    7,
    9,
    1,
    6,
    11,
    6,
    3,
    1,
    3,
    6,
    -1,
    0,
    9,
    1,
    11,
    6,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    8,
    0,
    7,
    0,
    6,
    3,
    11,
    0,
    11,
    6,
    0,
    -1,
    -1,
    -1,
    -1,
    7,
    11,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    8,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    1,
    9,
    8,
    3,
    1,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    1,
    2,
    6,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    3,
    0,
    8,
    6,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    9,
    0,
    2,
    10,
    9,
    6,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    11,
    7,
    2,
    10,
    3,
    10,
    8,
    3,
    10,
    9,
    8,
    -1,
    -1,
    -1,
    -1,
    7,
    2,
    3,
    6,
    2,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    0,
    8,
    7,
    6,
    0,
    6,
    2,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    7,
    6,
    2,
    3,
    7,
    0,
    1,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    2,
    1,
    8,
    6,
    1,
    9,
    8,
    8,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    10,
    7,
    6,
    10,
    1,
    7,
    1,
    3,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    7,
    6,
    1,
    7,
    10,
    1,
    8,
    7,
    1,
    0,
    8,
    -1,
    -1,
    -1,
    -1,
    0,
    3,
    7,
    0,
    7,
    10,
    0,
    10,
    9,
    6,
    10,
    7,
    -1,
    -1,
    -1,
    -1,
    7,
    6,
    10,
    7,
    10,
    8,
    8,
    10,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    8,
    4,
    11,
    8,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    6,
    11,
    3,
    0,
    6,
    0,
    4,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    6,
    11,
    8,
    4,
    6,
    9,
    0,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    4,
    6,
    9,
    6,
    3,
    9,
    3,
    1,
    11,
    3,
    6,
    -1,
    -1,
    -1,
    -1,
    6,
    8,
    4,
    6,
    11,
    8,
    2,
    10,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    3,
    0,
    11,
    0,
    6,
    11,
    0,
    4,
    6,
    -1,
    -1,
    -1,
    -1,
    4,
    11,
    8,
    4,
    6,
    11,
    0,
    2,
    9,
    2,
    10,
    9,
    -1,
    -1,
    -1,
    -1,
    10,
    9,
    3,
    10,
    3,
    2,
    9,
    4,
    3,
    11,
    3,
    6,
    4,
    6,
    3,
    -1,
    8,
    2,
    3,
    8,
    4,
    2,
    4,
    6,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    4,
    2,
    4,
    6,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    0,
    2,
    3,
    4,
    2,
    4,
    6,
    4,
    3,
    8,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    4,
    1,
    4,
    2,
    2,
    4,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    1,
    3,
    8,
    6,
    1,
    8,
    4,
    6,
    6,
    10,
    1,
    -1,
    -1,
    -1,
    -1,
    10,
    1,
    0,
    10,
    0,
    6,
    6,
    0,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    6,
    3,
    4,
    3,
    8,
    6,
    10,
    3,
    0,
    3,
    9,
    10,
    9,
    3,
    -1,
    10,
    9,
    4,
    6,
    10,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    5,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    4,
    9,
    5,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    0,
    1,
    5,
    4,
    0,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    7,
    6,
    8,
    3,
    4,
    3,
    5,
    4,
    3,
    1,
    5,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    10,
    1,
    2,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    11,
    7,
    1,
    2,
    10,
    0,
    8,
    3,
    4,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    7,
    6,
    11,
    5,
    4,
    10,
    4,
    2,
    10,
    4,
    0,
    2,
    -1,
    -1,
    -1,
    -1,
    3,
    4,
    8,
    3,
    5,
    4,
    3,
    2,
    5,
    10,
    5,
    2,
    11,
    7,
    6,
    -1,
    7,
    2,
    3,
    7,
    6,
    2,
    5,
    4,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    0,
    8,
    6,
    0,
    6,
    2,
    6,
    8,
    7,
    -1,
    -1,
    -1,
    -1,
    3,
    6,
    2,
    3,
    7,
    6,
    1,
    5,
    0,
    5,
    4,
    0,
    -1,
    -1,
    -1,
    -1,
    6,
    2,
    8,
    6,
    8,
    7,
    2,
    1,
    8,
    4,
    8,
    5,
    1,
    5,
    8,
    -1,
    9,
    5,
    4,
    10,
    1,
    6,
    1,
    7,
    6,
    1,
    3,
    7,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    10,
    1,
    7,
    6,
    1,
    0,
    7,
    8,
    7,
    0,
    9,
    5,
    4,
    -1,
    4,
    0,
    10,
    4,
    10,
    5,
    0,
    3,
    10,
    6,
    10,
    7,
    3,
    7,
    10,
    -1,
    7,
    6,
    10,
    7,
    10,
    8,
    5,
    4,
    10,
    4,
    8,
    10,
    -1,
    -1,
    -1,
    -1,
    6,
    9,
    5,
    6,
    11,
    9,
    11,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    6,
    11,
    0,
    6,
    3,
    0,
    5,
    6,
    0,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    8,
    0,
    5,
    11,
    0,
    1,
    5,
    5,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    6,
    11,
    3,
    6,
    3,
    5,
    5,
    3,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    9,
    5,
    11,
    9,
    11,
    8,
    11,
    5,
    6,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    3,
    0,
    6,
    11,
    0,
    9,
    6,
    5,
    6,
    9,
    1,
    2,
    10,
    -1,
    11,
    8,
    5,
    11,
    5,
    6,
    8,
    0,
    5,
    10,
    5,
    2,
    0,
    2,
    5,
    -1,
    6,
    11,
    3,
    6,
    3,
    5,
    2,
    10,
    3,
    10,
    5,
    3,
    -1,
    -1,
    -1,
    -1,
    5,
    8,
    9,
    5,
    2,
    8,
    5,
    6,
    2,
    3,
    8,
    2,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    6,
    9,
    6,
    0,
    0,
    6,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    5,
    8,
    1,
    8,
    0,
    5,
    6,
    8,
    3,
    8,
    2,
    6,
    2,
    8,
    -1,
    1,
    5,
    6,
    2,
    1,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    3,
    6,
    1,
    6,
    10,
    3,
    8,
    6,
    5,
    6,
    9,
    8,
    9,
    6,
    -1,
    10,
    1,
    0,
    10,
    0,
    6,
    9,
    5,
    0,
    5,
    6,
    0,
    -1,
    -1,
    -1,
    -1,
    0,
    3,
    8,
    5,
    6,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    5,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    5,
    10,
    7,
    5,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    5,
    10,
    11,
    7,
    5,
    8,
    3,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    11,
    7,
    5,
    10,
    11,
    1,
    9,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    7,
    5,
    10,
    11,
    7,
    9,
    8,
    1,
    8,
    3,
    1,
    -1,
    -1,
    -1,
    -1,
    11,
    1,
    2,
    11,
    7,
    1,
    7,
    5,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    1,
    2,
    7,
    1,
    7,
    5,
    7,
    2,
    11,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    5,
    9,
    2,
    7,
    9,
    0,
    2,
    2,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    7,
    5,
    2,
    7,
    2,
    11,
    5,
    9,
    2,
    3,
    2,
    8,
    9,
    8,
    2,
    -1,
    2,
    5,
    10,
    2,
    3,
    5,
    3,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    2,
    0,
    8,
    5,
    2,
    8,
    7,
    5,
    10,
    2,
    5,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    1,
    5,
    10,
    3,
    5,
    3,
    7,
    3,
    10,
    2,
    -1,
    -1,
    -1,
    -1,
    9,
    8,
    2,
    9,
    2,
    1,
    8,
    7,
    2,
    10,
    2,
    5,
    7,
    5,
    2,
    -1,
    1,
    3,
    5,
    3,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    7,
    0,
    7,
    1,
    1,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    3,
    9,
    3,
    5,
    5,
    3,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    8,
    7,
    5,
    9,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    8,
    4,
    5,
    10,
    8,
    10,
    11,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    0,
    4,
    5,
    11,
    0,
    5,
    10,
    11,
    11,
    3,
    0,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    8,
    4,
    10,
    8,
    10,
    11,
    10,
    4,
    5,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    4,
    10,
    4,
    5,
    11,
    3,
    4,
    9,
    4,
    1,
    3,
    1,
    4,
    -1,
    2,
    5,
    1,
    2,
    8,
    5,
    2,
    11,
    8,
    4,
    5,
    8,
    -1,
    -1,
    -1,
    -1,
    0,
    4,
    11,
    0,
    11,
    3,
    4,
    5,
    11,
    2,
    11,
    1,
    5,
    1,
    11,
    -1,
    0,
    2,
    5,
    0,
    5,
    9,
    2,
    11,
    5,
    4,
    5,
    8,
    11,
    8,
    5,
    -1,
    9,
    4,
    5,
    2,
    11,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    5,
    10,
    3,
    5,
    2,
    3,
    4,
    5,
    3,
    8,
    4,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    2,
    5,
    2,
    4,
    4,
    2,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    10,
    2,
    3,
    5,
    10,
    3,
    8,
    5,
    4,
    5,
    8,
    0,
    1,
    9,
    -1,
    5,
    10,
    2,
    5,
    2,
    4,
    1,
    9,
    2,
    9,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    5,
    8,
    5,
    3,
    3,
    5,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    4,
    5,
    1,
    0,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    5,
    8,
    5,
    3,
    9,
    0,
    5,
    0,
    3,
    5,
    -1,
    -1,
    -1,
    -1,
    9,
    4,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    11,
    7,
    4,
    9,
    11,
    9,
    10,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    4,
    9,
    7,
    9,
    11,
    7,
    9,
    10,
    11,
    -1,
    -1,
    -1,
    -1,
    1,
    10,
    11,
    1,
    11,
    4,
    1,
    4,
    0,
    7,
    4,
    11,
    -1,
    -1,
    -1,
    -1,
    3,
    1,
    4,
    3,
    4,
    8,
    1,
    10,
    4,
    7,
    4,
    11,
    10,
    11,
    4,
    -1,
    4,
    11,
    7,
    9,
    11,
    4,
    9,
    2,
    11,
    9,
    1,
    2,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    4,
    9,
    11,
    7,
    9,
    1,
    11,
    2,
    11,
    1,
    0,
    8,
    3,
    -1,
    11,
    7,
    4,
    11,
    4,
    2,
    2,
    4,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    7,
    4,
    11,
    4,
    2,
    8,
    3,
    4,
    3,
    2,
    4,
    -1,
    -1,
    -1,
    -1,
    2,
    9,
    10,
    2,
    7,
    9,
    2,
    3,
    7,
    7,
    4,
    9,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    7,
    9,
    7,
    4,
    10,
    2,
    7,
    8,
    7,
    0,
    2,
    0,
    7,
    -1,
    3,
    7,
    10,
    3,
    10,
    2,
    7,
    4,
    10,
    1,
    10,
    0,
    4,
    0,
    10,
    -1,
    1,
    10,
    2,
    8,
    7,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    1,
    4,
    1,
    7,
    7,
    1,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    1,
    4,
    1,
    7,
    0,
    8,
    1,
    8,
    7,
    1,
    -1,
    -1,
    -1,
    -1,
    4,
    0,
    3,
    7,
    4,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    8,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    8,
    10,
    11,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    9,
    3,
    9,
    11,
    11,
    9,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    10,
    0,
    10,
    8,
    8,
    10,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    1,
    10,
    11,
    3,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    11,
    1,
    11,
    9,
    9,
    11,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    9,
    3,
    9,
    11,
    1,
    2,
    9,
    2,
    11,
    9,
    -1,
    -1,
    -1,
    -1,
    0,
    2,
    11,
    8,
    0,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    2,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    8,
    2,
    8,
    10,
    10,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    2,
    0,
    9,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    8,
    2,
    8,
    10,
    0,
    1,
    8,
    1,
    10,
    8,
    -1,
    -1,
    -1,
    -1,
    1,
    10,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    3,
    8,
    9,
    1,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    9,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    3,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
  ])),
  (XG.Camera = function () {
    XG.Node.call(this),
      (this.matrixWorldInverse = new XG.Matrix4()),
      (this.projectionMatrix = new XG.Matrix4()),
      (this.projectionMatrixInverse = new XG.Matrix4());
  }),
  (XG.Camera.prototype = Object.create(XG.Node.prototype)),
  (XG.Camera.prototype.lookAt = function (e) {
    this.matrix.lookAt(this.position, e, this.up),
      this.rotationAutoUpdate === !0 &&
      (this.useQuaternion === !1
        ? this.rotation.setEulerFromRotationMatrix(
          this.matrix,
          this.eulerOrder
        )
        : this.quaternion.copy(this.matrix.decompose()[1]));
  }),
  (XG.Camera.prototype.clone = function (e) {
    return (
      void 0 === e && (e = new XG.Camera()),
      XG.Node.prototype.clone.call(this, e),
      e.matrixWorldInverse.copy(this.matrixWorldInverse),
      e.projectionMatrix.copy(this.projectionMatrix),
      e.projectionMatrixInverse.copy(this.projectionMatrixInverse),
      e
    );
  }),
  (XG.OrthographicCamera = function (e, t, a, r, i, o) {
    XG.Camera.call(this),
      (this.left = e),
      (this.right = t),
      (this.top = a),
      (this.bottom = r),
      (this.near = void 0 !== i ? i : 0.1),
      (this.far = void 0 !== o ? o : 2e3),
      this.updateProjectionMatrix();
  }),
  (XG.OrthographicCamera.prototype = Object.create(XG.Camera.prototype)),
  (XG.OrthographicCamera.prototype.updateProjectionMatrix = function () {
    this.projectionMatrix.makeOrthographic(
      this.left,
      this.right,
      this.top,
      this.bottom,
      this.near,
      this.far
    );
  }),
  (XG.OrthographicCamera.prototype.clone = function (e) {
    return (
      void 0 === e && (e = new XG.OrthographicCamera()),
      XG.Camera.prototype.clone.call(this, e),
      (e.left = this.left),
      (e.right = this.right),
      (e.top = this.top),
      (e.bottom = this.bottom),
      (e.near = this.near),
      (e.far = this.far),
      e
    );
  }),
  (XG.PerspectiveCamera = function (e, t, a, r) {
    XG.Camera.call(this),
      (this.fov = void 0 !== e ? e : 50),
      (this.aspect = void 0 !== t ? t : 1),
      (this.near = void 0 !== a ? a : 0.1),
      (this.far = void 0 !== r ? r : 2e3),
      this.updateProjectionMatrix();
  }),
  (XG.PerspectiveCamera.prototype = Object.create(XG.Camera.prototype)),
  (XG.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
    this.projectionMatrix.makePerspective(
      this.fov,
      this.aspect,
      this.near,
      this.far
    );
  }),
  (XG.PerspectiveCamera.prototype.jitter = function (e, t, a, r) {
    this.projectionMatrix.makePerspectiveOffset(
      this.fov,
      this.aspect,
      this.near,
      this.far,
      e,
      t,
      a,
      r
    );
  }),
  (XG.PerspectiveCamera.prototype.clone = function (e) {
    return (
      void 0 === e && (e = new XG.PerspectiveCamera()),
      XG.Camera.prototype.clone.call(this, e),
      (e.fov = this.fov),
      (e.aspect = this.aspect),
      (e.near = this.near),
      (e.far = this.far),
      e
    );
  }),
  (XG.CubeCamera = function (e, t) {
    XG.Node.call(this);
    var a = 90,
      r = 1,
      i = new XG.PerspectiveCamera(a, r, e, t);
    i.up.set(0, -1, 0), i.lookAt(new XG.Vector3(1, 0, 0)), this.add(i);
    var o = new XG.PerspectiveCamera(a, r, e, t);
    o.up.set(0, -1, 0), o.lookAt(new XG.Vector3(-1, 0, 0)), this.add(o);
    var n = new XG.PerspectiveCamera(a, r, e, t);
    n.up.set(0, 0, 1), n.lookAt(new XG.Vector3(0, 1, 0)), this.add(n);
    var s = new XG.PerspectiveCamera(a, r, e, t);
    s.up.set(0, 0, -1), s.lookAt(new XG.Vector3(0, -1, 0)), this.add(s);
    var l = new XG.PerspectiveCamera(a, r, e, t);
    l.up.set(0, -1, 0), l.lookAt(new XG.Vector3(0, 0, 1)), this.add(l);
    var h = new XG.PerspectiveCamera(a, r, e, t);
    h.up.set(0, -1, 0),
      h.lookAt(new XG.Vector3(0, 0, -1)),
      this.add(h),
      (this.px = i),
      (this.nx = o),
      (this.py = n),
      (this.ny = s),
      (this.pz = l),
      (this.nz = h);
  }),
  (XG.CubeCamera.prototype = Object.create(XG.Node.prototype)),
  (XG.Light = function (e) {
    XG.Node.call(this), (this.color = new XG.Color(e));
  }),
  (XG.Light.prototype = Object.create(XG.Node.prototype)),
  (XG.AreaLight = function (e, t) {
    XG.Light.call(this, e),
      (this.normal = new XG.Vector3(0, -1, 0)),
      (this.right = new XG.Vector3(1, 0, 0)),
      (this.intensity = void 0 !== t ? t : 1),
      (this.width = 1),
      (this.height = 1),
      (this.constantAttenuation = 1.5),
      (this.linearAttenuation = 0.5),
      (this.quadraticAttenuation = 0.1),
      (this.texture = null),
      (this.castShadow = !1),
      (this.onlyShadow = !1),
      (this.shadowCameraNear = 50),
      (this.shadowCameraFar = 5e3),
      (this.shadowCameraFov = 90),
      (this.shadowCameraLeft = -500),
      (this.shadowCameraRight = 500),
      (this.shadowCameraTop = 500),
      (this.shadowCameraBottom = -500),
      (this.shadowCameraOrtho = !1),
      (this.shadowCameraVisible = !1),
      (this.shadowBias = 0),
      (this.shadowDarkness = 0.5),
      (this.shadowMapWidth = 512),
      (this.shadowMapHeight = 512);
  }),
  (XG.AreaLight.prototype = Object.create(XG.Light.prototype)),
  (XG.PolyLight = function (e, t) {
    XG.Light.call(this, e),
      (this.normal = new XG.Vector3(0, 0, -1)),
      (this.right = new XG.Vector3(1, 0, 0)),
      (this.intensity = void 0 !== t ? t : 1),
      (this.width = 1),
      (this.height = 1),
      (this.twoSided = 0),
      (this.texture = null),
      (this.textureBias = 0),
      (this.castShadow = !1),
      (this.onlyShadow = !1),
      (this.shadowCameraNear = 50),
      (this.shadowCameraFar = 5e3),
      (this.shadowCameraFov = 90),
      (this.shadowCameraLeft = -500),
      (this.shadowCameraRight = 500),
      (this.shadowCameraTop = 500),
      (this.shadowCameraBottom = -500),
      (this.shadowCameraOrtho = !1),
      (this.shadowCameraVisible = !1),
      (this.shadowBias = 0),
      (this.shadowDarkness = 0.5),
      (this.shadowMapWidth = 512),
      (this.shadowMapHeight = 512);
  }),
  (XG.PolyLight.ltcMatData = [
    2e-4,
    -0,
    1,
    -0,
    504e-6,
    -0,
    1,
    -0,
    0.002016,
    -0,
    1,
    -0,
    0.004535,
    -0,
    1,
    -0,
    0.008063,
    -0,
    1,
    -0,
    0.012598,
    -0,
    1,
    -0,
    0.018141,
    -0,
    1,
    -0,
    0.024692,
    -0,
    1,
    -0,
    0.032252,
    -0,
    1,
    -0,
    0.040821,
    -0,
    1,
    -0,
    0.0504,
    -0,
    1,
    -0,
    0.060989,
    -0,
    1,
    -0,
    0.072591,
    -0,
    1,
    -0,
    0.085206,
    -0,
    1,
    -0,
    0.098836,
    -0,
    1,
    -0,
    0.113483,
    -0,
    1,
    -0,
    0.129147,
    -0,
    1,
    -0,
    0.145828,
    -0,
    1,
    -0,
    0.163499,
    -0,
    1,
    -0,
    0.181972,
    -0,
    1,
    -0,
    0.199498,
    -0,
    1,
    -0,
    0.220031,
    -0,
    1,
    -0,
    0.241588,
    -0,
    1,
    -0,
    0.26412,
    -0,
    1,
    -0,
    0.287521,
    -0,
    1,
    -0,
    0.311478,
    -0,
    1,
    -0,
    0.335127,
    -0,
    1,
    -0,
    0.359811,
    -0,
    1,
    -0,
    0.386446,
    -0,
    1,
    -0,
    0.413161,
    -0,
    1,
    -0,
    0.439142,
    -0,
    1,
    -0,
    0.467039,
    -0,
    1,
    -0,
    0.49517,
    -0,
    1,
    -0,
    0.522324,
    -0,
    1,
    -0,
    0.551482,
    -0,
    1,
    -0,
    0.579621,
    -0,
    1,
    -0,
    0.608255,
    -0,
    1,
    -0,
    0.636515,
    -0,
    1,
    -0,
    0.664835,
    -0,
    1,
    -0,
    0.692549,
    -0,
    1,
    -0,
    0.720375,
    -0,
    1,
    -0,
    0.747238,
    -0,
    1,
    -0,
    0.773956,
    -0,
    1,
    -0,
    0.799879,
    -0,
    1,
    -0,
    0.824889,
    -0,
    1,
    -0,
    0.849357,
    -0,
    1,
    -0,
    0.873016,
    -0,
    1,
    -0,
    0.89567,
    -0,
    1,
    -0,
    0.917194,
    -0,
    1,
    -0,
    0.937978,
    -0,
    1,
    -0,
    0.957872,
    -0,
    1,
    -0,
    0.976736,
    -0,
    1,
    -0,
    0.994433,
    -0,
    1,
    -0,
    1.011206,
    -0,
    1,
    -0,
    1.02682,
    -0,
    1,
    -0,
    1.04172,
    -0,
    1,
    -0,
    1.055657,
    -0,
    1,
    -0,
    1.068642,
    -0,
    1,
    -0,
    1.080646,
    -0,
    1,
    -0,
    1.091637,
    -0,
    1,
    -0,
    1.101837,
    -0,
    1,
    -0,
    1.111292,
    -0,
    1,
    -0,
    1.120025,
    -0,
    1,
    -0,
    1.127918,
    -0,
    1,
    -0,
    2e-4,
    -5e-6,
    1.000623,
    0.024938,
    504e-6,
    -13e-6,
    1.000643,
    0.024938,
    0.002016,
    -5e-5,
    1.000618,
    0.024938,
    0.004535,
    -113e-6,
    1.000621,
    0.024938,
    0.008063,
    -201e-6,
    1.000746,
    0.024938,
    0.012596,
    -314e-6,
    1.000463,
    0.024937,
    0.01814,
    -452e-6,
    1.000511,
    0.024939,
    0.024693,
    -616e-6,
    1.000541,
    0.024938,
    0.032253,
    -804e-6,
    1.000684,
    0.024938,
    0.040815,
    -0.001018,
    1.000524,
    0.02494,
    0.050399,
    -0.001257,
    1.000582,
    0.024937,
    0.060989,
    -0.001521,
    1.000655,
    0.024937,
    0.072591,
    -0.00181,
    1.000608,
    0.024938,
    0.085204,
    -0.002125,
    1.000622,
    0.024939,
    0.098835,
    -0.002465,
    1.000632,
    0.024937,
    0.113483,
    -0.00283,
    1.00064,
    0.024939,
    0.129143,
    -0.00322,
    1.000568,
    0.024938,
    0.14583,
    -0.003633,
    1.000635,
    0.024938,
    0.163497,
    -0.004062,
    1.000626,
    0.024938,
    0.181956,
    -0.004424,
    1.000612,
    0.024924,
    0.199791,
    -0.004593,
    1.000627,
    0.02489,
    0.220029,
    -0.00548,
    1.000594,
    0.024935,
    0.241586,
    -0.00601,
    1.000616,
    0.024933,
    0.264115,
    -0.00655,
    1.000607,
    0.024927,
    0.287514,
    -0.007072,
    1.000595,
    0.024909,
    0.311455,
    -0.007472,
    1.000616,
    0.024872,
    0.335083,
    -0.007491,
    1.000589,
    0.024755,
    0.359805,
    -0.00881,
    1.000601,
    0.024877,
    0.386438,
    -0.009282,
    1.00064,
    0.024824,
    0.413131,
    -0.009534,
    1.000599,
    0.024708,
    0.439249,
    -0.009701,
    1.000497,
    0.024573,
    0.466997,
    -0.010878,
    1.000467,
    0.024652,
    0.495138,
    -0.010959,
    1.000539,
    0.024455,
    0.522654,
    -0.011386,
    1.000518,
    0.024318,
    0.551415,
    -0.012022,
    1.000533,
    0.024216,
    0.57961,
    -0.011805,
    1.000495,
    0.023867,
    0.608185,
    -0.012773,
    1.000474,
    0.023834,
    0.636492,
    -0.012377,
    1.000488,
    0.023327,
    0.664826,
    -0.013172,
    1.000576,
    0.023205,
    0.692674,
    -0.012847,
    1.000505,
    0.022708,
    0.720341,
    -0.013141,
    1.000424,
    0.022349,
    0.747373,
    -0.013227,
    1.000449,
    0.021871,
    0.77398,
    -0.012739,
    1.000478,
    0.021171,
    0.799839,
    -0.012999,
    1.000396,
    0.020606,
    0.825113,
    -0.012727,
    1.000425,
    0.020006,
    0.849579,
    -0.01217,
    1.000469,
    0.019089,
    0.873046,
    -0.011855,
    1.000411,
    0.018291,
    0.895777,
    -0.011711,
    1.000426,
    0.017534,
    0.917518,
    -0.011107,
    1.000373,
    0.016542,
    0.938264,
    -0.010439,
    1.000322,
    0.015512,
    0.958032,
    -0.009807,
    1.000324,
    0.014491,
    0.976838,
    -0.009268,
    1.000341,
    0.013468,
    0.994631,
    -0.008662,
    1.000318,
    0.012376,
    1.011434,
    -0.007923,
    1.000289,
    0.011187,
    1.027169,
    -0.007132,
    1.000216,
    0.010078,
    1.041929,
    -0.006332,
    1.000096,
    0.008924,
    1.055767,
    -0.005554,
    1.000156,
    0.00777,
    1.068595,
    -0.004811,
    1.000084,
    0.006611,
    1.080612,
    -0.00395,
    1.000047,
    0.005485,
    1.091785,
    -0.003174,
    1.000109,
    0.004352,
    1.101998,
    -0.002363,
    1.000029,
    0.00318,
    1.111423,
    -0.001552,
    0.999985,
    0.002091,
    1.120007,
    -786e-6,
    0.999947,
    991e-6,
    1.127918,
    4e-6,
    1,
    -4e-6,
    2e-4,
    -1e-5,
    1.002495,
    0.049907,
    504e-6,
    -25e-6,
    1.002476,
    0.049908,
    0.002016,
    -101e-6,
    1.0025,
    0.049908,
    0.004535,
    -226e-6,
    1.002487,
    0.049908,
    0.008062,
    -402e-6,
    1.002364,
    0.049908,
    0.012598,
    -629e-6,
    1.002412,
    0.049908,
    0.01814,
    -905e-6,
    1.002379,
    0.049908,
    0.024691,
    -0.001232,
    1.00249,
    0.049907,
    0.032251,
    -0.00161,
    1.002398,
    0.049908,
    0.040821,
    -0.002037,
    1.002392,
    0.049908,
    0.050398,
    -0.002515,
    1.002431,
    0.049907,
    0.060989,
    -0.003044,
    1.002475,
    0.049908,
    0.072592,
    -0.003623,
    1.002546,
    0.049907,
    0.085204,
    -0.004252,
    1.002467,
    0.049907,
    0.098832,
    -0.004932,
    1.00245,
    0.049908,
    0.113481,
    -0.005663,
    1.002482,
    0.049907,
    0.129145,
    -0.006443,
    1.002443,
    0.049907,
    0.145825,
    -0.007271,
    1.002495,
    0.049906,
    0.163491,
    -0.008128,
    1.002475,
    0.049903,
    0.181911,
    -0.008826,
    1.002459,
    0.049879,
    0.200065,
    -0.009285,
    1.002443,
    0.049824,
    0.220025,
    -0.010966,
    1.00245,
    0.049897,
    0.241581,
    -0.012025,
    1.002463,
    0.049893,
    0.264099,
    -0.013105,
    1.002395,
    0.049881,
    0.287493,
    -0.014145,
    1.00239,
    0.049855,
    0.311399,
    -0.014925,
    1.002414,
    0.049769,
    0.335096,
    -0.015239,
    1.002363,
    0.049591,
    0.359815,
    -0.017559,
    1.002415,
    0.049777,
    0.386365,
    -0.018554,
    1.002354,
    0.049675,
    0.413017,
    -0.019043,
    1.002297,
    0.049444,
    0.439519,
    -0.019815,
    1.002284,
    0.049253,
    0.466938,
    -0.021741,
    1.002307,
    0.049327,
    0.494999,
    -0.021887,
    1.002181,
    0.048922,
    0.522922,
    -0.022844,
    1.002107,
    0.048677,
    0.55127,
    -0.024014,
    1.002101,
    0.048478,
    0.579771,
    -0.024156,
    1.00206,
    0.047904,
    0.608156,
    -0.025317,
    1.002077,
    0.047594,
    0.636662,
    -0.025321,
    1.001975,
    0.046876,
    0.664846,
    -0.026018,
    1.001992,
    0.046354,
    0.692877,
    -0.026041,
    1.001846,
    0.045504,
    0.720316,
    -0.026252,
    1.001846,
    0.044655,
    0.747658,
    -0.026159,
    1.001931,
    0.04367,
    0.774252,
    -0.026086,
    1.001845,
    0.042515,
    0.800179,
    -0.025653,
    1.001794,
    0.041211,
    0.825525,
    -0.02517,
    1.001787,
    0.039823,
    0.850013,
    -0.024788,
    1.001806,
    0.038409,
    0.873593,
    -0.023992,
    1.001688,
    0.036767,
    0.896343,
    -0.022985,
    1.001666,
    0.0349,
    0.918062,
    -0.022005,
    1.001548,
    0.03301,
    0.938928,
    -0.02111,
    1.001503,
    0.031143,
    0.958667,
    -0.019893,
    1.001341,
    0.029059,
    0.977457,
    -0.018546,
    1.001194,
    0.026888,
    0.995243,
    -0.017152,
    1.001095,
    0.024713,
    1.012023,
    -0.01575,
    1.0011,
    0.022496,
    1.027614,
    -0.014289,
    1.000851,
    0.020153,
    1.042389,
    -0.012688,
    1.000724,
    0.017839,
    1.056161,
    -0.011118,
    1.000572,
    0.015529,
    1.068968,
    -0.00954,
    1.000407,
    0.01324,
    1.080866,
    -0.007963,
    1.000258,
    0.01094,
    1.091944,
    -0.006416,
    1.000254,
    0.008716,
    1.102104,
    -0.004771,
    1.000175,
    0.006434,
    1.111571,
    -0.003056,
    1.000148,
    0.004169,
    1.120084,
    -0.001458,
    1.00005,
    0.002033,
    1.127981,
    21e-6,
    0.999987,
    -27e-6,
    2e-4,
    -15e-6,
    1.00562,
    0.07494,
    504e-6,
    -38e-6,
    1.00565,
    0.074939,
    0.002016,
    -151e-6,
    1.005613,
    0.074939,
    0.004535,
    -34e-5,
    1.005618,
    0.074939,
    0.008062,
    -604e-6,
    1.005614,
    0.074939,
    0.012597,
    -944e-6,
    1.005616,
    0.07494,
    0.018141,
    -0.001359,
    1.005558,
    0.074939,
    0.024695,
    -0.001851,
    1.005495,
    0.07494,
    0.032253,
    -0.002417,
    1.005616,
    0.074939,
    0.040822,
    -0.003059,
    1.005591,
    0.07494,
    0.050399,
    -0.003777,
    1.005596,
    0.07494,
    0.060989,
    -0.00457,
    1.005599,
    0.074939,
    0.072591,
    -0.00544,
    1.005616,
    0.07494,
    0.085203,
    -0.006385,
    1.005616,
    0.074939,
    0.098833,
    -0.007406,
    1.005595,
    0.074938,
    0.113481,
    -0.008502,
    1.005605,
    0.074938,
    0.129147,
    -0.009674,
    1.005605,
    0.074937,
    0.145817,
    -0.010916,
    1.005513,
    0.074937,
    0.163485,
    -0.012199,
    1.005579,
    0.074928,
    0.181824,
    -0.013172,
    1.005552,
    0.074885,
    0.200274,
    -0.0141,
    1.005524,
    0.074825,
    0.220017,
    -0.016464,
    1.005529,
    0.074928,
    0.241568,
    -0.018052,
    1.00549,
    0.074914,
    0.264084,
    -0.019671,
    1.005457,
    0.074898,
    0.28745,
    -0.021217,
    1.005431,
    0.07486,
    0.311281,
    -0.022341,
    1.005395,
    0.074717,
    0.335228,
    -0.023296,
    1.00532,
    0.074526,
    0.360047,
    -0.025965,
    1.005302,
    0.074649,
    0.386273,
    -0.027808,
    1.005285,
    0.074575,
    0.412855,
    -0.028504,
    1.005167,
    0.074237,
    0.439705,
    -0.030007,
    1.005129,
    0.074013,
    0.466975,
    -0.032263,
    1.005082,
    0.073967,
    0.494874,
    -0.032931,
    1.00496,
    0.073475,
    0.523066,
    -0.034348,
    1.004834,
    0.073084,
    0.551198,
    -0.035739,
    1.004806,
    0.072657,
    0.579889,
    -0.036575,
    1.004687,
    0.072029,
    0.608282,
    -0.037434,
    1.004605,
    0.071309,
    0.636812,
    -0.038323,
    1.004589,
    0.070507,
    0.66501,
    -0.038676,
    1.004403,
    0.069424,
    0.693063,
    -0.039237,
    1.00434,
    0.06837,
    0.72075,
    -0.039332,
    1.004224,
    0.066988,
    0.747911,
    -0.039179,
    1.004117,
    0.065447,
    0.774576,
    -0.03911,
    1.004035,
    0.063838,
    0.800737,
    -0.038542,
    1.004027,
    0.061923,
    0.825966,
    -0.037966,
    1.003825,
    0.059859,
    0.850534,
    -0.036943,
    1.003786,
    0.057529,
    0.874289,
    -0.035853,
    1.00356,
    0.055081,
    0.897152,
    -0.03473,
    1.003549,
    0.052476,
    0.919029,
    -0.033242,
    1.003454,
    0.049647,
    0.939851,
    -0.031508,
    1.003215,
    0.04667,
    0.959599,
    -0.029695,
    1.002916,
    0.043588,
    0.978293,
    -0.027845,
    1.00272,
    0.040401,
    0.996085,
    -0.025775,
    1.002445,
    0.03706,
    1.012768,
    -0.023607,
    1.002133,
    0.033726,
    1.028404,
    -0.021374,
    1.001822,
    0.030217,
    1.04315,
    -0.019108,
    1.001602,
    0.02682,
    1.05676,
    -0.016823,
    1.001274,
    0.023372,
    1.069471,
    -0.014378,
    1.000964,
    0.019891,
    1.081283,
    -0.011884,
    1.000684,
    0.016405,
    1.092238,
    -0.009398,
    1.000514,
    0.01295,
    1.102384,
    -0.00703,
    1.000319,
    0.009579,
    1.111737,
    -0.004751,
    1.000225,
    0.006384,
    1.120274,
    -0.002404,
    1.000046,
    0.003192,
    1.128182,
    31e-6,
    1.00002,
    33e-6,
    2e-4,
    -2e-5,
    1.010006,
    0.100065,
    504e-6,
    -5e-5,
    1.009927,
    0.100065,
    0.002016,
    -202e-6,
    1.010026,
    0.100064,
    0.004535,
    -454e-6,
    1.010018,
    0.100065,
    0.008062,
    -807e-6,
    1.009891,
    0.100064,
    0.012599,
    -0.001261,
    1.010175,
    0.100064,
    0.018141,
    -0.001815,
    1.010067,
    0.100065,
    0.024692,
    -0.002471,
    1.010014,
    0.100066,
    0.032251,
    -0.003227,
    1.00995,
    0.100065,
    0.040818,
    -0.004084,
    1.009963,
    0.100067,
    0.050401,
    -0.005043,
    1.010032,
    0.100064,
    0.060988,
    -0.006102,
    1.009979,
    0.100064,
    0.072588,
    -0.007263,
    1.009984,
    0.100063,
    0.085205,
    -0.008525,
    1.010023,
    0.100063,
    0.098832,
    -0.009888,
    1.00996,
    0.100062,
    0.113479,
    -0.011352,
    1.009974,
    0.100063,
    0.129142,
    -0.012916,
    1.009945,
    0.100062,
    0.145817,
    -0.014573,
    1.009924,
    0.100058,
    0.163468,
    -0.016276,
    1.009912,
    0.10005,
    0.181674,
    -0.017411,
    1.009859,
    0.099975,
    0.200435,
    -0.019002,
    1.009842,
    0.099932,
    0.220005,
    -0.021978,
    1.00982,
    0.100043,
    0.24155,
    -0.024096,
    1.009778,
    0.100031,
    0.264058,
    -0.02625,
    1.009765,
    0.100002,
    0.287399,
    -0.028286,
    1.009724,
    0.099939,
    0.311134,
    -0.029698,
    1.009596,
    0.099748,
    0.33535,
    -0.031442,
    1.009508,
    0.099582,
    0.360295,
    -0.034401,
    1.009475,
    0.099613,
    0.386112,
    -0.03703,
    1.009329,
    0.099558,
    0.412733,
    -0.038163,
    1.00925,
    0.099137,
    0.439833,
    -0.04025,
    1.009125,
    0.098866,
    0.467099,
    -0.042583,
    1.009011,
    0.098626,
    0.494828,
    -0.044299,
    1.008803,
    0.098149,
    0.523217,
    -0.045876,
    1.008712,
    0.0976,
    0.551338,
    -0.04744,
    1.008509,
    0.096929,
    0.579917,
    -0.048995,
    1.008371,
    0.096178,
    0.608454,
    -0.049901,
    1.008212,
    0.095145,
    0.636785,
    -0.051224,
    1.007963,
    0.094151,
    0.66522,
    -0.051675,
    1.007741,
    0.092728,
    0.693194,
    -0.052278,
    1.007616,
    0.091195,
    0.721008,
    -0.052406,
    1.007327,
    0.089384,
    0.748196,
    -0.052529,
    1.007219,
    0.087461,
    0.774975,
    -0.05195,
    1.006851,
    0.085133,
    0.801129,
    -0.051456,
    1.006732,
    0.082628,
    0.826668,
    -0.050569,
    1.006612,
    0.079817,
    0.851291,
    -0.049328,
    1.006374,
    0.07671,
    0.875056,
    -0.047988,
    1.006183,
    0.073481,
    0.897872,
    -0.046149,
    1.005742,
    0.069943,
    0.919803,
    -0.044144,
    1.005514,
    0.066151,
    0.940701,
    -0.042095,
    1.005153,
    0.062247,
    0.96058,
    -0.03973,
    1.004843,
    0.058158,
    0.979427,
    -0.037104,
    1.004535,
    0.05385,
    0.997157,
    -0.034369,
    1.004023,
    0.049403,
    1.013777,
    -0.031555,
    1.003622,
    0.044944,
    1.029452,
    -0.028571,
    1.003212,
    0.040414,
    1.044029,
    -0.025416,
    1.002698,
    0.035723,
    1.057586,
    -0.022217,
    1.002202,
    0.031072,
    1.070148,
    -0.019037,
    1.001703,
    0.026429,
    1.081875,
    -0.015936,
    1.001322,
    0.021896,
    1.092789,
    -0.012734,
    1.001053,
    0.017288,
    1.102704,
    -0.009454,
    1.000604,
    0.012841,
    1.112011,
    -0.006199,
    1.000387,
    0.008446,
    1.12059,
    -0.00301,
    1.000166,
    0.004122,
    1.128283,
    27e-6,
    0.999956,
    -38e-6,
    2e-4,
    -25e-6,
    1.015664,
    0.125315,
    504e-6,
    -63e-6,
    1.015664,
    0.125316,
    0.002016,
    -253e-6,
    1.015727,
    0.125315,
    0.004535,
    -568e-6,
    1.015695,
    0.125314,
    0.008063,
    -0.00101,
    1.015823,
    0.125316,
    0.012599,
    -0.001579,
    1.015867,
    0.125315,
    0.018141,
    -0.002273,
    1.015758,
    0.125316,
    0.024691,
    -0.003094,
    1.015662,
    0.125316,
    0.032252,
    -0.004042,
    1.015674,
    0.125316,
    0.04082,
    -0.005115,
    1.015678,
    0.125316,
    0.0504,
    -0.006316,
    1.015684,
    0.125315,
    0.060989,
    -0.007642,
    1.015685,
    0.125315,
    0.07259,
    -0.009096,
    1.015703,
    0.125314,
    0.085203,
    -0.010676,
    1.015654,
    0.125314,
    0.098833,
    -0.012383,
    1.01567,
    0.125315,
    0.113477,
    -0.014215,
    1.015635,
    0.125312,
    0.129138,
    -0.016173,
    1.015599,
    0.125311,
    0.145815,
    -0.018246,
    1.01561,
    0.125306,
    0.16345,
    -0.02036,
    1.015564,
    0.125294,
    0.181595,
    -0.021807,
    1.01546,
    0.125204,
    0.200563,
    -0.023971,
    1.01544,
    0.125165,
    0.220186,
    -0.02728,
    1.015412,
    0.12525,
    0.241528,
    -0.030164,
    1.015342,
    0.125267,
    0.26402,
    -0.032847,
    1.015269,
    0.125233,
    0.287311,
    -0.035345,
    1.015232,
    0.125138,
    0.310993,
    -0.037108,
    1.015063,
    0.124903,
    0.335467,
    -0.039653,
    1.01497,
    0.124749,
    0.360497,
    -0.042914,
    1.014819,
    0.124702,
    0.385986,
    -0.046142,
    1.014685,
    0.124623,
    0.412703,
    -0.04805,
    1.014543,
    0.124193,
    0.439929,
    -0.050527,
    1.014315,
    0.123833,
    0.467163,
    -0.05288,
    1.014087,
    0.123375,
    0.494824,
    -0.055672,
    1.013898,
    0.122982,
    0.523222,
    -0.057388,
    1.013647,
    0.122166,
    0.551557,
    -0.059328,
    1.013403,
    0.121343,
    0.579884,
    -0.061315,
    1.013059,
    0.12043,
    0.608619,
    -0.062531,
    1.012745,
    0.11914,
    0.637014,
    -0.063778,
    1.012425,
    0.117721,
    0.665425,
    -0.064734,
    1.012067,
    0.116069,
    0.69358,
    -0.065315,
    1.011712,
    0.114146,
    0.721194,
    -0.065535,
    1.0112,
    0.111846,
    0.748586,
    -0.065501,
    1.010896,
    0.109309,
    0.775437,
    -0.065091,
    1.010576,
    0.106504,
    0.801554,
    -0.064332,
    1.010136,
    0.103308,
    0.827079,
    -0.063078,
    1.009629,
    0.099695,
    0.851693,
    -0.061728,
    1.009233,
    0.095946,
    0.875586,
    -0.059853,
    1.008726,
    0.091802,
    0.898589,
    -0.057727,
    1.008412,
    0.087339,
    0.920421,
    -0.055377,
    1.007767,
    0.082687,
    0.941533,
    -0.052571,
    1.007529,
    0.077716,
    0.961426,
    -0.049544,
    1.006929,
    0.072574,
    0.980287,
    -0.0464,
    1.006393,
    0.067217,
    0.99808,
    -0.042966,
    1.005872,
    0.061757,
    1.01494,
    -0.039321,
    1.005346,
    0.056072,
    1.030455,
    -0.035585,
    1.004609,
    0.05041,
    1.045078,
    -0.031823,
    1.004151,
    0.044622,
    1.058555,
    -0.027947,
    1.003421,
    0.038893,
    1.071009,
    -0.023891,
    1.002704,
    0.032977,
    1.082594,
    -0.019822,
    1.002023,
    0.02729,
    1.093265,
    -0.015765,
    1.001403,
    0.021543,
    1.103132,
    -0.01179,
    1.000944,
    0.016072,
    1.112348,
    -0.007784,
    1.00055,
    0.010511,
    1.120845,
    -0.003849,
    1.000224,
    0.005174,
    1.128573,
    57e-6,
    0.999975,
    -39e-6,
    2e-4,
    -3e-5,
    1.022609,
    0.150725,
    504e-6,
    -76e-6,
    1.022728,
    0.150725,
    0.002016,
    -304e-6,
    1.022728,
    0.150725,
    0.004535,
    -684e-6,
    1.022733,
    0.150725,
    0.008062,
    -0.001215,
    1.022715,
    0.150725,
    0.012598,
    -0.001899,
    1.02272,
    0.150725,
    0.018141,
    -0.002734,
    1.022659,
    0.150725,
    0.024694,
    -0.003722,
    1.022801,
    0.150724,
    0.032254,
    -0.004861,
    1.022779,
    0.150726,
    0.040815,
    -0.006152,
    1.022693,
    0.150724,
    0.0504,
    -0.007596,
    1.022716,
    0.150725,
    0.06099,
    -0.009192,
    1.022733,
    0.150725,
    0.072587,
    -0.010939,
    1.02263,
    0.150723,
    0.085203,
    -0.012839,
    1.022676,
    0.150725,
    0.098828,
    -0.014891,
    1.022659,
    0.150725,
    0.113473,
    -0.017095,
    1.022589,
    0.15072,
    0.129137,
    -0.019449,
    1.022572,
    0.150716,
    0.145803,
    -0.021938,
    1.022508,
    0.150712,
    0.163417,
    -0.024443,
    1.022471,
    0.150691,
    0.18158,
    -0.026329,
    1.022406,
    0.1506,
    0.200667,
    -0.028997,
    1.022336,
    0.150553,
    0.220429,
    -0.032584,
    1.022296,
    0.15061,
    0.241497,
    -0.03626,
    1.022202,
    0.150658,
    0.263975,
    -0.039465,
    1.022119,
    0.150619,
    0.28721,
    -0.042385,
    1.021988,
    0.15049,
    0.310935,
    -0.044758,
    1.021771,
    0.150241,
    0.335556,
    -0.047922,
    1.021658,
    0.150076,
    0.360667,
    -0.051493,
    1.021437,
    0.149931,
    0.386028,
    -0.054931,
    1.021228,
    0.149754,
    0.412665,
    -0.058007,
    1.021023,
    0.1494,
    0.439951,
    -0.060813,
    1.020723,
    0.148913,
    0.467262,
    -0.063461,
    1.020332,
    0.148319,
    0.494972,
    -0.066738,
    1.020097,
    0.147798,
    0.523153,
    -0.068976,
    1.01963,
    0.146903,
    0.5517,
    -0.071268,
    1.019245,
    0.145863,
    0.580046,
    -0.073439,
    1.018797,
    0.144695,
    0.608649,
    -0.075193,
    1.018201,
    0.143237,
    0.637239,
    -0.076536,
    1.017746,
    0.141463,
    0.665388,
    -0.077771,
    1.017111,
    0.139462,
    0.693755,
    -0.078344,
    1.016609,
    0.137082,
    0.721345,
    -0.078817,
    1.015863,
    0.134403,
    0.748879,
    -0.078512,
    1.01539,
    0.131252,
    0.77556,
    -0.078128,
    1.014652,
    0.127866,
    0.801897,
    -0.077094,
    1.013877,
    0.123928,
    0.827193,
    -0.075863,
    1.013021,
    0.119733,
    0.85199,
    -0.073973,
    1.012395,
    0.115055,
    0.875823,
    -0.071765,
    1.011595,
    0.110098,
    0.898655,
    -0.069241,
    1.010862,
    0.104722,
    0.920915,
    -0.066232,
    1.010185,
    0.098991,
    0.941969,
    -0.06298,
    1.009588,
    0.093044,
    0.961882,
    -0.059507,
    1.008777,
    0.086925,
    0.980952,
    -0.055606,
    1.008252,
    0.08052,
    0.998955,
    -0.051503,
    1.007633,
    0.07389,
    1.015756,
    -0.047292,
    1.006908,
    0.067302,
    1.031571,
    -0.042804,
    1.006338,
    0.060412,
    1.046095,
    -0.038132,
    1.005512,
    0.053497,
    1.059542,
    -0.03338,
    1.004592,
    0.046569,
    1.072006,
    -0.028613,
    1.003731,
    0.039679,
    1.083348,
    -0.023811,
    1.002871,
    0.032772,
    1.093969,
    -0.01893,
    1.002068,
    0.025894,
    1.103697,
    -0.014098,
    1.001284,
    0.019178,
    1.112813,
    -0.009339,
    1.00082,
    0.012652,
    1.121193,
    -0.004661,
    1.000324,
    0.006226,
    1.12893,
    52e-6,
    0.999988,
    -8e-6,
    2e-4,
    -35e-6,
    1.030857,
    0.176327,
    504e-6,
    -89e-6,
    1.031137,
    0.176326,
    0.002016,
    -355e-6,
    1.031049,
    0.176325,
    0.004535,
    -8e-4,
    1.031105,
    0.176326,
    0.008062,
    -0.001422,
    1.030973,
    0.176326,
    0.012598,
    -0.002221,
    1.031168,
    0.176326,
    0.018141,
    -0.003199,
    1.031093,
    0.176326,
    0.024695,
    -0.004354,
    1.031297,
    0.176326,
    0.032253,
    -0.005687,
    1.031091,
    0.176327,
    0.040821,
    -0.007197,
    1.031012,
    0.176326,
    0.050399,
    -0.008886,
    1.031068,
    0.176325,
    0.060987,
    -0.010752,
    1.030967,
    0.176323,
    0.072588,
    -0.012797,
    1.031028,
    0.176324,
    0.0852,
    -0.015019,
    1.030985,
    0.176322,
    0.098829,
    -0.017419,
    1.030983,
    0.17632,
    0.113474,
    -0.019997,
    1.030953,
    0.176317,
    0.129133,
    -0.022748,
    1.030891,
    0.176312,
    0.1458,
    -0.025655,
    1.030825,
    0.176306,
    0.163372,
    -0.02851,
    1.030781,
    0.176279,
    0.181578,
    -0.030914,
    1.030683,
    0.176187,
    0.200761,
    -0.034076,
    1.030574,
    0.176139,
    0.220645,
    -0.037985,
    1.030476,
    0.17616,
    0.241473,
    -0.042391,
    1.030384,
    0.176238,
    0.263922,
    -0.046105,
    1.030241,
    0.176175,
    0.287074,
    -0.04939,
    1.030049,
    0.176013,
    0.310915,
    -0.052511,
    1.029839,
    0.175776,
    0.335604,
    -0.056236,
    1.029608,
    0.175578,
    0.360775,
    -0.060118,
    1.029355,
    0.175359,
    0.386196,
    -0.063907,
    1.029052,
    0.175083,
    0.412599,
    -0.067997,
    1.028766,
    0.174791,
    0.439916,
    -0.071088,
    1.028326,
    0.174174,
    0.467444,
    -0.074247,
    1.02789,
    0.173487,
    0.495132,
    -0.077728,
    1.027374,
    0.172774,
    0.523117,
    -0.080822,
    1.026763,
    0.171824,
    0.551783,
    -0.083228,
    1.026205,
    0.170554,
    0.580234,
    -0.085682,
    1.025614,
    0.16909,
    0.608568,
    -0.08786,
    1.024668,
    0.167468,
    0.637357,
    -0.089346,
    1.023939,
    0.165283,
    0.665507,
    -0.090704,
    1.022946,
    0.162966,
    0.693704,
    -0.091388,
    1.02201,
    0.160131,
    0.721396,
    -0.091783,
    1.021085,
    0.156957,
    0.748676,
    -0.091688,
    1.019894,
    0.153292,
    0.77537,
    -0.090992,
    1.018608,
    0.149158,
    0.801547,
    -0.089881,
    1.017646,
    0.144551,
    0.827013,
    -0.088267,
    1.016355,
    0.139614,
    0.851708,
    -0.086132,
    1.015446,
    0.134026,
    0.875652,
    -0.083707,
    1.014321,
    0.128101,
    0.898703,
    -0.080619,
    1.013454,
    0.121841,
    0.920904,
    -0.07728,
    1.012634,
    0.115379,
    0.942077,
    -0.073484,
    1.01177,
    0.108355,
    0.962245,
    -0.069252,
    1.010894,
    0.101153,
    0.981385,
    -0.064807,
    1.010114,
    0.093666,
    0.999379,
    -0.06008,
    1.009294,
    0.086007,
    1.016494,
    -0.055007,
    1.008591,
    0.078194,
    1.032357,
    -0.04976,
    1.007821,
    0.070328,
    1.047061,
    -0.044468,
    1.006871,
    0.062358,
    1.060675,
    -0.03896,
    1.006062,
    0.054279,
    1.073032,
    -0.033343,
    1.004911,
    0.046158,
    1.084293,
    -0.027699,
    1.003791,
    0.038111,
    1.094724,
    -0.02213,
    1.002744,
    0.030239,
    1.104302,
    -0.016508,
    1.001815,
    0.022397,
    1.11329,
    -0.010846,
    1.001083,
    0.014747,
    1.121649,
    -0.005294,
    1.00049,
    0.007234,
    1.12923,
    71e-6,
    0.999975,
    -53e-6,
    2e-4,
    -4e-5,
    1.040431,
    0.202155,
    504e-6,
    -102e-6,
    1.040912,
    0.202154,
    0.002016,
    -407e-6,
    1.041328,
    0.202152,
    0.004535,
    -917e-6,
    1.040877,
    0.202154,
    0.008063,
    -0.00163,
    1.040867,
    0.202153,
    0.012598,
    -0.002547,
    1.04087,
    0.202153,
    0.01814,
    -0.003667,
    1.040808,
    0.202153,
    0.024692,
    -0.004991,
    1.040861,
    0.202153,
    0.032252,
    -0.006519,
    1.040861,
    0.202153,
    0.040822,
    -0.008252,
    1.040864,
    0.202153,
    0.050397,
    -0.010187,
    1.040717,
    0.202151,
    0.060988,
    -0.012327,
    1.040791,
    0.202152,
    0.072582,
    -0.014669,
    1.04064,
    0.202149,
    0.085198,
    -0.017217,
    1.040716,
    0.202147,
    0.098827,
    -0.019968,
    1.040748,
    0.202141,
    0.113467,
    -0.022921,
    1.040632,
    0.202142,
    0.129129,
    -0.026074,
    1.040606,
    0.202137,
    0.145793,
    -0.029399,
    1.040566,
    0.202127,
    0.163294,
    -0.032524,
    1.040459,
    0.202078,
    0.181589,
    -0.035552,
    1.040315,
    0.201996,
    0.200844,
    -0.039208,
    1.040221,
    0.201948,
    0.220835,
    -0.043489,
    1.040047,
    0.201945,
    0.241471,
    -0.048523,
    1.039921,
    0.202031,
    0.263854,
    -0.052764,
    1.039756,
    0.201957,
    0.286935,
    -0.056387,
    1.039497,
    0.201743,
    0.310902,
    -0.060338,
    1.039252,
    0.201531,
    0.335642,
    -0.064594,
    1.038954,
    0.201286,
    0.360859,
    -0.068772,
    1.038582,
    0.200983,
    0.386419,
    -0.073086,
    1.03816,
    0.200651,
    0.412588,
    -0.077887,
    1.037724,
    0.200343,
    0.439836,
    -0.081391,
    1.037182,
    0.199618,
    0.467538,
    -0.085121,
    1.036602,
    0.198839,
    0.495286,
    -0.088718,
    1.035893,
    0.197895,
    0.523231,
    -0.092514,
    1.035121,
    0.196887,
    0.55173,
    -0.095238,
    1.034127,
    0.19539,
    0.580302,
    -0.097949,
    1.033131,
    0.193668,
    0.608559,
    -0.100418,
    1.031962,
    0.191773,
    0.637224,
    -0.102129,
    1.030838,
    0.189319,
    0.665597,
    -0.103578,
    1.029511,
    0.186529,
    0.693535,
    -0.104652,
    1.028263,
    0.183303,
    0.721325,
    -0.104766,
    1.026611,
    0.179497,
    0.748384,
    -0.104717,
    1.025128,
    0.175283,
    0.775058,
    -0.103846,
    1.023385,
    0.170493,
    0.801387,
    -0.102728,
    1.022236,
    0.165187,
    0.826412,
    -0.100679,
    1.019908,
    0.159362,
    0.851314,
    -0.098451,
    1.018839,
    0.153059,
    0.8751,
    -0.095363,
    1.017306,
    0.146284,
    0.89828,
    -0.092008,
    1.016151,
    0.138975,
    0.92045,
    -0.088095,
    1.01488,
    0.131361,
    0.941727,
    -0.08369,
    1.013556,
    0.123417,
    0.962308,
    -0.079077,
    1.012998,
    0.115201,
    0.981364,
    -0.073894,
    1.011841,
    0.106711,
    0.999798,
    -0.068435,
    1.011021,
    0.098063,
    1.016983,
    -0.06283,
    1.010194,
    0.089183,
    1.033039,
    -0.056914,
    1.009292,
    0.08019,
    1.047994,
    -0.050721,
    1.008474,
    0.07101,
    1.06158,
    -0.044454,
    1.007386,
    0.061867,
    1.074023,
    -0.038145,
    1.006135,
    0.052711,
    1.08547,
    -0.031679,
    1.00489,
    0.043595,
    1.095673,
    -0.025157,
    1.003627,
    0.034506,
    1.105,
    -0.018702,
    1.002331,
    0.025468,
    1.113795,
    -0.012458,
    1.001278,
    0.016834,
    1.122012,
    -0.006169,
    1.000548,
    0.008265,
    1.129683,
    78e-6,
    0.999988,
    -72e-6,
    2e-4,
    -46e-6,
    1.052496,
    0.228243,
    504e-6,
    -115e-6,
    1.052079,
    0.228243,
    0.002016,
    -46e-5,
    1.052079,
    0.228241,
    0.004535,
    -0.001035,
    1.052091,
    0.228242,
    0.008062,
    -0.00184,
    1.051962,
    0.228242,
    0.012598,
    -0.002875,
    1.052087,
    0.228242,
    0.018141,
    -0.00414,
    1.052088,
    0.228242,
    0.024692,
    -0.005636,
    1.052096,
    0.228239,
    0.032251,
    -0.007361,
    1.052029,
    0.228243,
    0.04082,
    -0.009316,
    1.052038,
    0.228241,
    0.050399,
    -0.011501,
    1.052042,
    0.228239,
    0.06099,
    -0.013917,
    1.052046,
    0.228238,
    0.072586,
    -0.016562,
    1.05199,
    0.228236,
    0.085198,
    -0.019437,
    1.051946,
    0.228234,
    0.098824,
    -0.022542,
    1.051879,
    0.228229,
    0.113467,
    -0.025875,
    1.051841,
    0.228227,
    0.129121,
    -0.02943,
    1.051724,
    0.228219,
    0.14578,
    -0.03317,
    1.051672,
    0.228205,
    0.163222,
    -0.036567,
    1.051556,
    0.228143,
    0.181604,
    -0.040245,
    1.051382,
    0.228069,
    0.200913,
    -0.044395,
    1.05123,
    0.22801,
    0.221005,
    -0.049088,
    1.051062,
    0.227988,
    0.241667,
    -0.054506,
    1.050881,
    0.228044,
    0.263777,
    -0.059437,
    1.050643,
    0.227986,
    0.286841,
    -0.06359,
    1.050312,
    0.227755,
    0.310879,
    -0.068224,
    1.050009,
    0.227525,
    0.33565,
    -0.072986,
    1.049597,
    0.227253,
    0.360869,
    -0.077435,
    1.049121,
    0.226845,
    0.386609,
    -0.082385,
    1.048587,
    0.226466,
    0.412742,
    -0.08757,
    1.047987,
    0.226059,
    0.439789,
    -0.091929,
    1.047308,
    0.225331,
    0.467558,
    -0.096038,
    1.046423,
    0.224409,
    0.495406,
    -0.099938,
    1.045481,
    0.223288,
    0.523417,
    -0.10405,
    1.044512,
    0.222066,
    0.551755,
    -0.107503,
    1.043408,
    0.220487,
    0.580468,
    -0.110234,
    1.042016,
    0.218451,
    0.608904,
    -0.112993,
    1.040535,
    0.2162,
    0.63723,
    -0.115173,
    1.038934,
    0.213458,
    0.665566,
    -0.116433,
    1.036961,
    0.210158,
    0.693413,
    -0.117589,
    1.03513,
    0.206457,
    0.721025,
    -0.117885,
    1.03308,
    0.202197,
    0.748054,
    -0.117606,
    1.030752,
    0.197296,
    0.774631,
    -0.116771,
    1.028608,
    0.191813,
    0.800677,
    -0.115194,
    1.02635,
    0.185691,
    0.826062,
    -0.113138,
    1.024472,
    0.179053,
    0.85059,
    -0.110359,
    1.022174,
    0.171839,
    0.87455,
    -0.107072,
    1.020381,
    0.164067,
    0.897567,
    -0.103268,
    1.018777,
    0.155959,
    0.919609,
    -0.098794,
    1.016886,
    0.14732,
    0.941177,
    -0.094067,
    1.01588,
    0.138365,
    0.961752,
    -0.08867,
    1.014616,
    0.129051,
    0.981518,
    -0.082965,
    1.013807,
    0.119515,
    0.99988,
    -0.076971,
    1.012793,
    0.109897,
    1.01737,
    -0.070518,
    1.011894,
    0.099872,
    1.033661,
    -0.06383,
    1.010943,
    0.089883,
    1.048672,
    -0.05704,
    1.009802,
    0.079691,
    1.062479,
    -0.049917,
    1.00867,
    0.069458,
    1.075052,
    -0.042735,
    1.007429,
    0.059191,
    1.086371,
    -0.035513,
    1.005991,
    0.048894,
    1.096623,
    -0.028359,
    1.004468,
    0.03877,
    1.105871,
    -0.021111,
    1.002927,
    0.028745,
    1.114481,
    -0.013908,
    1.001728,
    0.018884,
    1.12261,
    -0.006843,
    1.00074,
    0.009264,
    1.130165,
    62e-6,
    0.999983,
    -6e-6,
    2e-4,
    -51e-6,
    1.064931,
    0.25463,
    504e-6,
    -128e-6,
    1.064668,
    0.25463,
    0.002016,
    -513e-6,
    1.064794,
    0.25463,
    0.004535,
    -0.001155,
    1.064851,
    0.25463,
    0.008063,
    -0.002053,
    1.064966,
    0.25463,
    0.012598,
    -0.003208,
    1.06484,
    0.25463,
    0.01814,
    -0.004619,
    1.064602,
    0.254631,
    0.024695,
    -0.006288,
    1.064965,
    0.254632,
    0.032251,
    -0.008211,
    1.064795,
    0.25463,
    0.040821,
    -0.010393,
    1.064802,
    0.254628,
    0.050398,
    -0.01283,
    1.064758,
    0.254627,
    0.060987,
    -0.015525,
    1.064731,
    0.254625,
    0.072584,
    -0.018474,
    1.064615,
    0.254621,
    0.085199,
    -0.021682,
    1.064672,
    0.254619,
    0.098826,
    -0.025144,
    1.06463,
    0.254613,
    0.113465,
    -0.02886,
    1.064515,
    0.254606,
    0.129119,
    -0.032823,
    1.064416,
    0.254598,
    0.145767,
    -0.036969,
    1.064347,
    0.254579,
    0.16319,
    -0.040754,
    1.064132,
    0.254506,
    0.181622,
    -0.044989,
    1.063951,
    0.254437,
    0.200981,
    -0.049642,
    1.063745,
    0.25437,
    0.221145,
    -0.054776,
    1.063547,
    0.254324,
    0.241896,
    -0.060538,
    1.063289,
    0.254346,
    0.263684,
    -0.066113,
    1.063013,
    0.254296,
    0.286796,
    -0.070925,
    1.062625,
    0.254059,
    0.310867,
    -0.076187,
    1.062216,
    0.253817,
    0.335644,
    -0.081406,
    1.061703,
    0.253481,
    0.360917,
    -0.086336,
    1.061066,
    0.253005,
    0.386786,
    -0.09179,
    1.060454,
    0.252558,
    0.412921,
    -0.09723,
    1.059568,
    0.252008,
    0.439722,
    -0.102574,
    1.058706,
    0.251323,
    0.467559,
    -0.106972,
    1.057682,
    0.250239,
    0.495605,
    -0.111329,
    1.056612,
    0.248944,
    0.523589,
    -0.115561,
    1.055101,
    0.247471,
    0.551787,
    -0.119732,
    1.053745,
    0.245777,
    0.580426,
    -0.122711,
    1.051829,
    0.243448,
    0.608778,
    -0.125436,
    1.049642,
    0.240769,
    0.637069,
    -0.127993,
    1.047749,
    0.237739,
    0.665251,
    -0.129448,
    1.045244,
    0.233928,
    0.692977,
    -0.130408,
    1.042279,
    0.22964,
    0.720346,
    -0.130931,
    1.039693,
    0.224829,
    0.747365,
    -0.130392,
    1.036675,
    0.219144,
    0.773734,
    -0.12954,
    1.033719,
    0.212965,
    0.799578,
    -0.127689,
    1.030774,
    0.206047,
    0.825002,
    -0.125456,
    1.028551,
    0.198576,
    0.849564,
    -0.122291,
    1.0258,
    0.190471,
    0.873412,
    -0.11872,
    1.023657,
    0.181739,
    0.896628,
    -0.114323,
    1.021381,
    0.172586,
    0.918952,
    -0.109587,
    1.019674,
    0.162914,
    0.940602,
    -0.104093,
    1.018126,
    0.153039,
    0.960917,
    -0.098187,
    1.016339,
    0.142774,
    0.980911,
    -0.091963,
    1.01544,
    0.132316,
    0.999686,
    -0.085159,
    1.014377,
    0.121453,
    1.017538,
    -0.078139,
    1.013498,
    0.110527,
    1.033918,
    -0.070797,
    1.012332,
    0.099437,
    1.04939,
    -0.063129,
    1.011368,
    0.088157,
    1.063402,
    -0.055354,
    1.010111,
    0.076951,
    1.076096,
    -0.047522,
    1.008774,
    0.065616,
    1.087562,
    -0.039447,
    1.007202,
    0.05431,
    1.097591,
    -0.031359,
    1.005346,
    0.042948,
    1.106782,
    -0.023393,
    1.00371,
    0.031799,
    1.115234,
    -0.015461,
    1.002116,
    0.020943,
    1.123166,
    -0.007589,
    1.000858,
    0.010288,
    1.130796,
    104e-6,
    1.000032,
    -24e-6,
    2e-4,
    -56e-6,
    1.07878,
    0.281356,
    504e-6,
    -142e-6,
    1.079271,
    0.281355,
    0.002015,
    -567e-6,
    1.078635,
    0.281355,
    0.004535,
    -0.001276,
    1.079164,
    0.281356,
    0.008064,
    -0.002269,
    1.0793,
    0.281355,
    0.012598,
    -0.003544,
    1.079149,
    0.281355,
    0.018143,
    -0.005104,
    1.079329,
    0.281355,
    0.024691,
    -0.006947,
    1.079073,
    0.281353,
    0.032254,
    -0.009074,
    1.079253,
    0.281354,
    0.040822,
    -0.011484,
    1.079176,
    0.281353,
    0.050399,
    -0.014177,
    1.079057,
    0.281349,
    0.060987,
    -0.017153,
    1.079007,
    0.281347,
    0.072586,
    -0.020412,
    1.078998,
    0.281343,
    0.085203,
    -0.023956,
    1.078962,
    0.281336,
    0.098823,
    -0.027778,
    1.078839,
    0.281332,
    0.113464,
    -0.031882,
    1.078783,
    0.281325,
    0.129114,
    -0.036255,
    1.078633,
    0.281315,
    0.145748,
    -0.04079,
    1.078545,
    0.281287,
    0.163179,
    -0.045024,
    1.078311,
    0.281208,
    0.181649,
    -0.049791,
    1.078135,
    0.281137,
    0.201042,
    -0.054953,
    1.077845,
    0.281063,
    0.221267,
    -0.060551,
    1.077576,
    0.281006,
    0.242114,
    -0.066663,
    1.077257,
    0.280978,
    0.263568,
    -0.072771,
    1.076897,
    0.280925,
    0.286744,
    -0.078349,
    1.076405,
    0.280689,
    0.31084,
    -0.084201,
    1.075898,
    0.280418,
    0.335612,
    -0.089846,
    1.075287,
    0.28002,
    0.360975,
    -0.095394,
    1.074482,
    0.279513,
    0.386932,
    -0.10129,
    1.073617,
    0.278961,
    0.413171,
    -0.107042,
    1.072719,
    0.278283,
    0.439886,
    -0.113083,
    1.071698,
    0.277547,
    0.467535,
    -0.11801,
    1.070213,
    0.276311,
    0.495701,
    -0.122793,
    1.068857,
    0.274867,
    0.523772,
    -0.127278,
    1.067037,
    0.273153,
    0.551849,
    -0.131671,
    1.064923,
    0.271176,
    0.580338,
    -0.135293,
    1.062749,
    0.268626,
    0.608771,
    -0.138065,
    1.059944,
    0.265569,
    0.636756,
    -0.140565,
    1.056851,
    0.262054,
    0.664574,
    -0.142434,
    1.053461,
    0.257807,
    0.692151,
    -0.143237,
    1.04991,
    0.25293,
    0.719376,
    -0.143717,
    1.046426,
    0.247414,
    0.745852,
    -0.143117,
    1.042377,
    0.241001,
    0.7723,
    -0.141975,
    1.038789,
    0.233797,
    0.79805,
    -0.140114,
    1.03529,
    0.226218,
    0.82337,
    -0.137379,
    1.032374,
    0.217785,
    0.847735,
    -0.134119,
    1.028853,
    0.208748,
    0.871897,
    -0.129985,
    1.026395,
    0.198877,
    0.89495,
    -0.125324,
    1.023787,
    0.188803,
    0.917909,
    -0.120007,
    1.022073,
    0.178493,
    0.939567,
    -0.114099,
    1.020098,
    0.167466,
    0.960534,
    -0.107748,
    1.018851,
    0.156223,
    0.980423,
    -0.100748,
    1.017362,
    0.144716,
    0.999334,
    -0.093494,
    1.015961,
    0.133028,
    1.017561,
    -0.085728,
    1.015059,
    0.120953,
    1.034225,
    -0.077627,
    1.013888,
    0.108943,
    1.049937,
    -0.069375,
    1.012898,
    0.096678,
    1.064265,
    -0.060807,
    1.011635,
    0.08435,
    1.077188,
    -0.052052,
    1.010095,
    0.071964,
    1.088637,
    -0.043304,
    1.008399,
    0.059531,
    1.098766,
    -0.034458,
    1.006397,
    0.047134,
    1.107697,
    -0.025637,
    1.004354,
    0.034887,
    1.116055,
    -0.016932,
    1.002611,
    0.022948,
    1.123819,
    -0.008437,
    1.001023,
    0.011386,
    1.131333,
    87e-6,
    0.999952,
    -97e-6,
    2e-4,
    -62e-6,
    1.095622,
    0.308458,
    504e-6,
    -155e-6,
    1.094863,
    0.308458,
    0.002016,
    -622e-6,
    1.095169,
    0.308458,
    0.004535,
    -0.001399,
    1.095156,
    0.308458,
    0.008063,
    -0.002487,
    1.095413,
    0.308455,
    0.012598,
    -0.003886,
    1.095147,
    0.308458,
    0.018141,
    -0.005596,
    1.09515,
    0.308457,
    0.024692,
    -0.007616,
    1.09514,
    0.308457,
    0.032252,
    -0.009947,
    1.095098,
    0.308456,
    0.040822,
    -0.012589,
    1.095096,
    0.308453,
    0.050399,
    -0.015541,
    1.09507,
    0.308451,
    0.060985,
    -0.018803,
    1.094922,
    0.308448,
    0.072583,
    -0.022375,
    1.094902,
    0.308444,
    0.085197,
    -0.026258,
    1.094882,
    0.308438,
    0.098822,
    -0.030448,
    1.094775,
    0.308429,
    0.11346,
    -0.034944,
    1.094641,
    0.308419,
    0.129112,
    -0.039731,
    1.09453,
    0.308403,
    0.145711,
    -0.04461,
    1.094332,
    0.308365,
    0.163178,
    -0.049362,
    1.094149,
    0.308285,
    0.181679,
    -0.054666,
    1.093876,
    0.30821,
    0.201109,
    -0.060336,
    1.093603,
    0.308132,
    0.221388,
    -0.066414,
    1.09325,
    0.308047,
    0.242315,
    -0.072881,
    1.092835,
    0.307985,
    0.263651,
    -0.079453,
    1.092391,
    0.307902,
    0.28672,
    -0.085882,
    1.091866,
    0.307688,
    0.310817,
    -0.092274,
    1.091225,
    0.307379,
    0.335562,
    -0.098306,
    1.090346,
    0.306906,
    0.361043,
    -0.104572,
    1.089423,
    0.306374,
    0.387051,
    -0.110843,
    1.088437,
    0.30571,
    0.413405,
    -0.117062,
    1.087228,
    0.304906,
    0.440122,
    -0.123501,
    1.085879,
    0.304017,
    0.467522,
    -0.129245,
    1.084197,
    0.302783,
    0.495721,
    -0.134285,
    1.082284,
    0.301104,
    0.523925,
    -0.139143,
    1.080109,
    0.299142,
    0.551814,
    -0.143638,
    1.077043,
    0.296825,
    0.579878,
    -0.147774,
    1.074071,
    0.294071,
    0.608316,
    -0.150724,
    1.070621,
    0.290519,
    0.636059,
    -0.153168,
    1.06639,
    0.286424,
    0.663481,
    -0.155139,
    1.062069,
    0.281559,
    0.690753,
    -0.155944,
    1.057211,
    0.276024,
    0.717767,
    -0.156176,
    1.052682,
    0.269622,
    0.743937,
    -0.155783,
    1.047747,
    0.262532,
    0.770214,
    -0.154245,
    1.04351,
    0.254609,
    0.795542,
    -0.152192,
    1.039121,
    0.246007,
    0.821099,
    -0.149256,
    1.035962,
    0.236663,
    0.845452,
    -0.145605,
    1.03232,
    0.226751,
    0.86978,
    -0.141186,
    1.02939,
    0.216165,
    0.893141,
    -0.136137,
    1.026485,
    0.204937,
    0.916034,
    -0.130332,
    1.024389,
    0.193624,
    0.938089,
    -0.12404,
    1.02227,
    0.181756,
    0.959488,
    -0.117011,
    1.020457,
    0.169339,
    0.979594,
    -0.109617,
    1.018871,
    0.156875,
    0.998912,
    -0.101562,
    1.017533,
    0.144288,
    1.0171,
    -0.093164,
    1.016445,
    0.13137,
    1.034413,
    -0.084488,
    1.015453,
    0.118322,
    1.050347,
    -0.075377,
    1.014259,
    0.104963,
    1.064958,
    -0.066108,
    1.013057,
    0.091722,
    1.078045,
    -0.056702,
    1.011491,
    0.078231,
    1.089749,
    -0.047106,
    1.009662,
    0.064797,
    1.099831,
    -0.037467,
    1.007417,
    0.051315,
    1.108789,
    -0.02799,
    1.005144,
    0.038064,
    1.116865,
    -0.018464,
    1.002925,
    0.025008,
    1.124609,
    -0.009068,
    1.001221,
    0.01225,
    1.13204,
    93e-6,
    0.999984,
    -71e-6,
    2e-4,
    -67e-6,
    1.112554,
    0.335981,
    504e-6,
    -169e-6,
    1.11266,
    0.335981,
    0.002016,
    -677e-6,
    1.112827,
    0.335981,
    0.004533,
    -0.001523,
    1.112147,
    0.335982,
    0.008063,
    -0.002709,
    1.112882,
    0.335979,
    0.012598,
    -0.004233,
    1.112891,
    0.33598,
    0.018141,
    -0.006095,
    1.112882,
    0.33598,
    0.024693,
    -0.008296,
    1.112877,
    0.335978,
    0.032252,
    -0.010834,
    1.11286,
    0.335976,
    0.040824,
    -0.013713,
    1.112965,
    0.335974,
    0.050398,
    -0.016927,
    1.112753,
    0.335971,
    0.060991,
    -0.020482,
    1.112826,
    0.33597,
    0.072587,
    -0.024371,
    1.112676,
    0.335962,
    0.085199,
    -0.028597,
    1.112593,
    0.335955,
    0.098822,
    -0.033159,
    1.112453,
    0.335943,
    0.113461,
    -0.038052,
    1.112329,
    0.33593,
    0.129108,
    -0.043255,
    1.112144,
    0.33591,
    0.145665,
    -0.048412,
    1.111905,
    0.335857,
    0.163185,
    -0.053786,
    1.111668,
    0.335781,
    0.18171,
    -0.059608,
    1.111345,
    0.335696,
    0.201166,
    -0.065794,
    1.110979,
    0.335606,
    0.221489,
    -0.072361,
    1.110553,
    0.335505,
    0.242471,
    -0.079184,
    1.110112,
    0.335396,
    0.2639,
    -0.086213,
    1.109584,
    0.335271,
    0.286688,
    -0.093491,
    1.108927,
    0.335089,
    0.310773,
    -0.100406,
    1.108091,
    0.334737,
    0.335573,
    -0.106987,
    1.107169,
    0.334208,
    0.361117,
    -0.113844,
    1.106097,
    0.3336,
    0.387175,
    -0.120463,
    1.104826,
    0.332828,
    0.413665,
    -0.127245,
    1.103415,
    0.331929,
    0.440386,
    -0.133927,
    1.101632,
    0.330851,
    0.467527,
    -0.140496,
    1.099563,
    0.329538,
    0.49563,
    -0.145874,
    1.096956,
    0.327618,
    0.523864,
    -0.150997,
    1.094201,
    0.32539,
    0.551705,
    -0.155713,
    1.090342,
    0.322688,
    0.579383,
    -0.159993,
    1.08601,
    0.319483,
    0.607301,
    -0.163238,
    1.081226,
    0.315522,
    0.634873,
    -0.165667,
    1.076065,
    0.31084,
    0.662028,
    -0.167606,
    1.070466,
    0.305377,
    0.688755,
    -0.168626,
    1.064601,
    0.299056,
    0.715612,
    -0.168578,
    1.059269,
    0.291963,
    0.741604,
    -0.167961,
    1.053648,
    0.284018,
    0.767757,
    -0.166439,
    1.048928,
    0.275474,
    0.793264,
    -0.164023,
    1.044343,
    0.266056,
    0.818165,
    -0.160965,
    1.039909,
    0.25575,
    0.843255,
    -0.156896,
    1.03618,
    0.244843,
    0.867249,
    -0.152262,
    1.032303,
    0.233464,
    0.890994,
    -0.146655,
    1.029365,
    0.221128,
    0.913829,
    -0.140574,
    1.026607,
    0.208554,
    0.936508,
    -0.13364,
    1.024512,
    0.195772,
    0.95772,
    -0.12622,
    1.022421,
    0.18242,
    0.97894,
    -0.118164,
    1.021293,
    0.168852,
    0.998285,
    -0.109558,
    1.019444,
    0.155261,
    1.016764,
    -0.100562,
    1.017825,
    0.141395,
    1.034387,
    -0.091064,
    1.016996,
    0.127311,
    1.050916,
    -0.081468,
    1.015945,
    0.113089,
    1.065652,
    -0.071463,
    1.014547,
    0.098879,
    1.079155,
    -0.06124,
    1.013066,
    0.084468,
    1.090822,
    -0.05098,
    1.010788,
    0.06994,
    1.1011,
    -0.040549,
    1.008563,
    0.055475,
    1.109824,
    -0.030101,
    1.00595,
    0.041033,
    1.117828,
    -0.019884,
    1.003453,
    0.027022,
    1.125443,
    -0.0099,
    1.001484,
    0.013306,
    1.132869,
    94e-6,
    1.000004,
    -46e-6,
    2e-4,
    -73e-6,
    1.132849,
    0.36397,
    504e-6,
    -183e-6,
    1.132155,
    0.363969,
    0.002016,
    -734e-6,
    1.132516,
    0.363969,
    0.004535,
    -0.001651,
    1.132256,
    0.363969,
    0.008062,
    -0.002934,
    1.132318,
    0.363966,
    0.012597,
    -0.004585,
    1.132386,
    0.363968,
    0.018141,
    -0.006602,
    1.132457,
    0.363967,
    0.024693,
    -0.008987,
    1.132511,
    0.363967,
    0.032252,
    -0.011737,
    1.132488,
    0.363965,
    0.040819,
    -0.014853,
    1.132241,
    0.363959,
    0.050398,
    -0.018336,
    1.132372,
    0.363958,
    0.060988,
    -0.022185,
    1.132373,
    0.363954,
    0.072582,
    -0.026396,
    1.132137,
    0.363943,
    0.085195,
    -0.030973,
    1.132071,
    0.363935,
    0.098822,
    -0.035913,
    1.131978,
    0.363922,
    0.113461,
    -0.041209,
    1.131801,
    0.363905,
    0.129116,
    -0.046833,
    1.131535,
    0.363867,
    0.14564,
    -0.052346,
    1.13129,
    0.363814,
    0.163199,
    -0.058275,
    1.131046,
    0.363734,
    0.181742,
    -0.064623,
    1.130671,
    0.363642,
    0.201227,
    -0.071336,
    1.130224,
    0.363539,
    0.221587,
    -0.078396,
    1.129758,
    0.363419,
    0.242625,
    -0.085545,
    1.129213,
    0.363256,
    0.264183,
    -0.09311,
    1.128549,
    0.363097,
    0.286668,
    -0.101206,
    1.127767,
    0.362939,
    0.310745,
    -0.108586,
    1.126796,
    0.362516,
    0.335602,
    -0.115827,
    1.125686,
    0.361953,
    0.361202,
    -0.123212,
    1.124451,
    0.361275,
    0.387298,
    -0.130294,
    1.122861,
    0.360376,
    0.413918,
    -0.137553,
    1.121154,
    0.359362,
    0.44068,
    -0.144577,
    1.118825,
    0.358069,
    0.467667,
    -0.151558,
    1.116002,
    0.356581,
    0.495449,
    -0.157621,
    1.112778,
    0.354531,
    0.523514,
    -0.162844,
    1.108842,
    0.351915,
    0.55125,
    -0.167744,
    1.104075,
    0.348797,
    0.578629,
    -0.172132,
    1.098733,
    0.345222,
    0.605757,
    -0.175733,
    1.092224,
    0.340665,
    0.633392,
    -0.178109,
    1.086201,
    0.335286,
    0.660783,
    -0.180009,
    1.08011,
    0.329286,
    0.687219,
    -0.181105,
    1.073419,
    0.322319,
    0.713873,
    -0.181046,
    1.06741,
    0.314616,
    0.740094,
    -0.180219,
    1.061414,
    0.306014,
    0.765233,
    -0.178559,
    1.055287,
    0.296704,
    0.790885,
    -0.175806,
    1.049727,
    0.286394,
    0.815464,
    -0.172354,
    1.044519,
    0.275189,
    0.840259,
    -0.168048,
    1.040375,
    0.263441,
    0.864285,
    -0.162904,
    1.03601,
    0.250918,
    0.888806,
    -0.157194,
    1.033525,
    0.237611,
    0.911682,
    -0.150486,
    1.02949,
    0.223809,
    0.934481,
    -0.143212,
    1.026778,
    0.209705,
    0.956337,
    -0.135233,
    1.024632,
    0.195281,
    0.97738,
    -0.12665,
    1.022737,
    0.180878,
    0.997427,
    -0.117552,
    1.02111,
    0.166112,
    1.016666,
    -0.107814,
    1.019869,
    0.151231,
    1.034337,
    -0.097814,
    1.018543,
    0.136375,
    1.051082,
    -0.08733,
    1.017476,
    0.121187,
    1.066326,
    -0.076614,
    1.016083,
    0.106043,
    1.079897,
    -0.065793,
    1.014227,
    0.090566,
    1.092136,
    -0.054654,
    1.012334,
    0.074988,
    1.102315,
    -0.043516,
    1.009627,
    0.059577,
    1.111105,
    -0.032509,
    1.006808,
    0.044202,
    1.118861,
    -0.021381,
    1.003917,
    0.028995,
    1.126363,
    -0.010489,
    1.00167,
    0.014269,
    1.133598,
    83e-6,
    0.999989,
    -35e-6,
    2e-4,
    -79e-6,
    1.155026,
    0.39247,
    504e-6,
    -198e-6,
    1.154184,
    0.392469,
    0.002016,
    -791e-6,
    1.15399,
    0.392469,
    0.004535,
    -0.00178,
    1.154045,
    0.392469,
    0.008063,
    -0.003164,
    1.154007,
    0.392466,
    0.012598,
    -0.004944,
    1.154022,
    0.392469,
    0.018141,
    -0.007119,
    1.154015,
    0.392468,
    0.024692,
    -0.00969,
    1.154017,
    0.392466,
    0.032254,
    -0.012656,
    1.154069,
    0.392465,
    0.040826,
    -0.016018,
    1.15398,
    0.392459,
    0.050399,
    -0.019771,
    1.153911,
    0.392456,
    0.060987,
    -0.023919,
    1.15386,
    0.392447,
    0.072588,
    -0.028461,
    1.153777,
    0.392442,
    0.085197,
    -0.033393,
    1.153582,
    0.392428,
    0.098822,
    -0.038716,
    1.153434,
    0.392412,
    0.113462,
    -0.044422,
    1.153271,
    0.39239,
    0.129101,
    -0.050455,
    1.153019,
    0.392359,
    0.145642,
    -0.056392,
    1.152721,
    0.392283,
    0.163223,
    -0.062859,
    1.152404,
    0.392201,
    0.181779,
    -0.069721,
    1.151941,
    0.392099,
    0.201289,
    -0.076968,
    1.151422,
    0.391978,
    0.221678,
    -0.084518,
    1.150861,
    0.391833,
    0.242752,
    -0.092017,
    1.150156,
    0.391618,
    0.264474,
    -0.100184,
    1.149402,
    0.391421,
    0.286768,
    -0.108921,
    1.148545,
    0.391249,
    0.310719,
    -0.116815,
    1.147388,
    0.390773,
    0.335638,
    -0.124785,
    1.146042,
    0.390168,
    0.36124,
    -0.13263,
    1.144529,
    0.389394,
    0.387443,
    -0.140298,
    1.142602,
    0.388391,
    0.414067,
    -0.147913,
    1.140361,
    0.387199,
    0.440904,
    -0.155362,
    1.137612,
    0.385742,
    0.467771,
    -0.162574,
    1.133659,
    0.383926,
    0.494907,
    -0.169312,
    1.129246,
    0.381715,
    0.522801,
    -0.174778,
    1.124228,
    0.378678,
    0.550751,
    -0.179824,
    1.118697,
    0.375158,
    0.578018,
    -0.184284,
    1.112019,
    0.370851,
    0.605291,
    -0.188215,
    1.105151,
    0.365928,
    0.632269,
    -0.19076,
    1.097677,
    0.360114,
    0.659432,
    -0.192457,
    1.090816,
    0.353498,
    0.685839,
    -0.193458,
    1.083286,
    0.346094,
    0.711876,
    -0.193502,
    1.076245,
    0.337754,
    0.738184,
    -0.192371,
    1.069684,
    0.328412,
    0.763723,
    -0.190531,
    1.063249,
    0.318164,
    0.789192,
    -0.187726,
    1.057265,
    0.3069,
    0.813744,
    -0.183783,
    1.051177,
    0.295021,
    0.838408,
    -0.179328,
    1.045902,
    0.282144,
    0.862116,
    -0.173573,
    1.040853,
    0.268438,
    0.885636,
    -0.16735,
    1.036515,
    0.254108,
    0.909342,
    -0.160229,
    1.033269,
    0.239082,
    0.931962,
    -0.152529,
    1.029627,
    0.224024,
    0.954671,
    -0.14408,
    1.027507,
    0.208393,
    0.975707,
    -0.135023,
    1.024657,
    0.19263,
    0.996644,
    -0.125258,
    1.022998,
    0.176741,
    1.015817,
    -0.115089,
    1.021234,
    0.160926,
    1.034301,
    -0.104317,
    1.020025,
    0.145042,
    1.051131,
    -0.093218,
    1.018739,
    0.129052,
    1.066836,
    -0.081828,
    1.017419,
    0.112905,
    1.081027,
    -0.070132,
    1.015714,
    0.096578,
    1.093225,
    -0.058382,
    1.013465,
    0.080077,
    1.103691,
    -0.046527,
    1.010853,
    0.06358,
    1.112431,
    -0.034624,
    1.007702,
    0.047118,
    1.120035,
    -0.022913,
    1.004551,
    0.031018,
    1.127336,
    -0.011284,
    1.001924,
    0.015283,
    1.13451,
    17e-5,
    0.999937,
    -58e-6,
    2e-4,
    -84e-6,
    1.177044,
    0.421534,
    504e-6,
    -212e-6,
    1.177312,
    0.421533,
    0.002016,
    -85e-5,
    1.17773,
    0.421533,
    0.004535,
    -0.001912,
    1.177722,
    0.421533,
    0.008063,
    -0.003399,
    1.177844,
    0.421529,
    0.012598,
    -0.00531,
    1.177768,
    0.421533,
    0.018141,
    -0.007646,
    1.17773,
    0.421531,
    0.024692,
    -0.010407,
    1.177663,
    0.42153,
    0.032252,
    -0.013592,
    1.177681,
    0.421527,
    0.040821,
    -0.017201,
    1.177562,
    0.421524,
    0.050401,
    -0.021234,
    1.177445,
    0.421516,
    0.060988,
    -0.025688,
    1.177461,
    0.421509,
    0.07259,
    -0.030565,
    1.177364,
    0.421498,
    0.0852,
    -0.03586,
    1.177205,
    0.421482,
    0.098823,
    -0.041572,
    1.177011,
    0.421462,
    0.113465,
    -0.047694,
    1.176794,
    0.421436,
    0.129094,
    -0.054122,
    1.176504,
    0.421396,
    0.145652,
    -0.06053,
    1.176203,
    0.421311,
    0.163245,
    -0.067517,
    1.175805,
    0.421218,
    0.181825,
    -0.074919,
    1.175271,
    0.421108,
    0.20136,
    -0.0827,
    1.174717,
    0.420974,
    0.221773,
    -0.090727,
    1.174021,
    0.420795,
    0.242908,
    -0.098719,
    1.173173,
    0.420536,
    0.264742,
    -0.107417,
    1.172285,
    0.420296,
    0.287091,
    -0.116601,
    1.171326,
    0.420065,
    0.310723,
    -0.125265,
    1.169907,
    0.419582,
    0.335685,
    -0.133876,
    1.168352,
    0.418912,
    0.361285,
    -0.14214,
    1.166322,
    0.418006,
    0.387562,
    -0.150436,
    1.164136,
    0.416899,
    0.414175,
    -0.158388,
    1.161162,
    0.415513,
    0.441021,
    -0.166258,
    1.157608,
    0.413836,
    0.467698,
    -0.17372,
    1.152519,
    0.411702,
    0.49473,
    -0.180843,
    1.14702,
    0.409102,
    0.522524,
    -0.186906,
    1.141256,
    0.405789,
    0.550055,
    -0.192004,
    1.134114,
    0.401759,
    0.577512,
    -0.196588,
    1.127086,
    0.397153,
    0.604348,
    -0.20042,
    1.119029,
    0.391767,
    0.63097,
    -0.20332,
    1.110308,
    0.385573,
    0.658023,
    -0.204883,
    1.102643,
    0.378245,
    0.684422,
    -0.205716,
    1.094573,
    0.370191,
    0.710405,
    -0.205767,
    1.086405,
    0.361231,
    0.736417,
    -0.204513,
    1.078712,
    0.351106,
    0.761836,
    -0.202281,
    1.071619,
    0.340096,
    0.78714,
    -0.199395,
    1.064873,
    0.328139,
    0.812197,
    -0.195185,
    1.058313,
    0.315044,
    0.836342,
    -0.190191,
    1.052085,
    0.300933,
    0.860311,
    -0.184343,
    1.046705,
    0.286411,
    0.883597,
    -0.177415,
    1.041072,
    0.270897,
    0.906852,
    -0.170003,
    1.036797,
    0.254825,
    0.929991,
    -0.161592,
    1.033264,
    0.238176,
    0.952478,
    -0.152792,
    1.03025,
    0.221581,
    0.974216,
    -0.143032,
    1.027331,
    0.204378,
    0.995372,
    -0.132922,
    1.025135,
    0.18747,
    1.01533,
    -0.122009,
    1.02325,
    0.170538,
    1.03407,
    -0.11074,
    1.022021,
    0.153777,
    1.051295,
    -0.099016,
    1.020271,
    0.136916,
    1.06746,
    -0.08692,
    1.018948,
    0.11988,
    1.082022,
    -0.074729,
    1.017336,
    0.102565,
    1.094378,
    -0.062036,
    1.01482,
    0.084994,
    1.104998,
    -0.049413,
    1.011999,
    0.06765,
    1.113773,
    -0.036812,
    1.008711,
    0.050148,
    1.121263,
    -0.024274,
    1.005141,
    0.032976,
    1.12842,
    -0.012038,
    1.002196,
    0.016239,
    1.135496,
    106e-6,
    1.000042,
    -62e-6,
    2e-4,
    -9e-5,
    1.203048,
    0.451217,
    504e-6,
    -227e-6,
    1.203226,
    0.451215,
    0.002016,
    -909e-6,
    1.20345,
    0.451215,
    0.004535,
    -0.002046,
    1.203569,
    0.451215,
    0.008062,
    -0.003638,
    1.203609,
    0.451209,
    0.012598,
    -0.005684,
    1.20358,
    0.451214,
    0.018141,
    -0.008185,
    1.203515,
    0.451212,
    0.024694,
    -0.011141,
    1.203618,
    0.451211,
    0.032253,
    -0.014549,
    1.203609,
    0.451207,
    0.040815,
    -0.018409,
    1.203302,
    0.451203,
    0.050401,
    -0.022727,
    1.203454,
    0.451195,
    0.06099,
    -0.027495,
    1.20348,
    0.451188,
    0.072591,
    -0.032713,
    1.20322,
    0.451172,
    0.085203,
    -0.038378,
    1.203058,
    0.451154,
    0.098829,
    -0.044489,
    1.202838,
    0.45113,
    0.113466,
    -0.051031,
    1.20253,
    0.451098,
    0.129084,
    -0.057808,
    1.20227,
    0.451041,
    0.145669,
    -0.064769,
    1.201904,
    0.450956,
    0.163278,
    -0.072278,
    1.201411,
    0.450853,
    0.18188,
    -0.080224,
    1.200825,
    0.450721,
    0.201436,
    -0.088537,
    1.200164,
    0.450566,
    0.221865,
    -0.097009,
    1.199335,
    0.450351,
    0.243083,
    -0.105591,
    1.198383,
    0.450062,
    0.265033,
    -0.114818,
    1.19738,
    0.449769,
    0.287456,
    -0.124372,
    1.196137,
    0.449438,
    0.310758,
    -0.133892,
    1.194554,
    0.448974,
    0.335721,
    -0.143052,
    1.192649,
    0.448216,
    0.361348,
    -0.151868,
    1.190233,
    0.447202,
    0.387573,
    -0.160644,
    1.187211,
    0.445926,
    0.414159,
    -0.169028,
    1.183452,
    0.444313,
    0.44095,
    -0.177169,
    1.178562,
    0.442315,
    0.467998,
    -0.18509,
    1.17354,
    0.43996,
    0.494566,
    -0.192396,
    1.166344,
    0.436989,
    0.52173,
    -0.198915,
    1.159283,
    0.433439,
    0.549405,
    -0.20424,
    1.151503,
    0.428984,
    0.576755,
    -0.208861,
    1.143004,
    0.423839,
    0.603635,
    -0.212734,
    1.134099,
    0.418012,
    0.629979,
    -0.215712,
    1.124555,
    0.411445,
    0.656597,
    -0.217385,
    1.115293,
    0.403628,
    0.683317,
    -0.218093,
    1.10646,
    0.394639,
    0.70899,
    -0.217835,
    1.097389,
    0.385012,
    0.734898,
    -0.216774,
    1.08894,
    0.373999,
    0.760342,
    -0.21412,
    1.080385,
    0.362128,
    0.785517,
    -0.210821,
    1.072959,
    0.349184,
    0.809933,
    -0.206443,
    1.06545,
    0.33508,
    0.834339,
    -0.200942,
    1.058701,
    0.320257,
    0.858793,
    -0.194938,
    1.052711,
    0.304133,
    0.8823,
    -0.187615,
    1.047044,
    0.287771,
    0.90556,
    -0.179626,
    1.042083,
    0.270571,
    0.927916,
    -0.170753,
    1.037077,
    0.252741,
    0.950415,
    -0.16127,
    1.0332,
    0.234656,
    0.97292,
    -0.151239,
    1.030418,
    0.216652,
    0.993893,
    -0.140358,
    1.027479,
    0.198252,
    1.014204,
    -0.128963,
    1.024897,
    0.180113,
    1.033878,
    -0.117128,
    1.023648,
    0.162282,
    1.051754,
    -0.104678,
    1.02223,
    0.144366,
    1.067924,
    -0.092,
    1.020453,
    0.126455,
    1.082643,
    -0.078837,
    1.018518,
    0.108194,
    1.095503,
    -0.065669,
    1.016199,
    0.089966,
    1.10629,
    -0.052345,
    1.013113,
    0.07153,
    1.115219,
    -0.039024,
    1.009636,
    0.053158,
    1.122587,
    -0.025789,
    1.005801,
    0.034959,
    1.129461,
    -0.012622,
    1.002442,
    0.017222,
    1.136468,
    152e-6,
    0.999964,
    -65e-6,
    2e-4,
    -96e-6,
    1.231156,
    0.481574,
    504e-6,
    -243e-6,
    1.232187,
    0.481572,
    0.002016,
    -971e-6,
    1.231948,
    0.481572,
    0.004535,
    -0.002184,
    1.231919,
    0.481572,
    0.008061,
    -0.003882,
    1.231453,
    0.481566,
    0.012597,
    -0.006066,
    1.2318,
    0.481572,
    0.018142,
    -0.008736,
    1.231756,
    0.481569,
    0.024693,
    -0.011889,
    1.232062,
    0.48157,
    0.032254,
    -0.015528,
    1.231915,
    0.481563,
    0.040822,
    -0.01965,
    1.231863,
    0.481559,
    0.050402,
    -0.024255,
    1.231737,
    0.48155,
    0.060992,
    -0.029342,
    1.231678,
    0.481537,
    0.072592,
    -0.034908,
    1.231537,
    0.481521,
    0.085207,
    -0.040953,
    1.231336,
    0.481499,
    0.098834,
    -0.047469,
    1.231071,
    0.481469,
    0.113474,
    -0.054441,
    1.230757,
    0.481431,
    0.129077,
    -0.061556,
    1.230424,
    0.481359,
    0.145691,
    -0.069091,
    1.230022,
    0.481269,
    0.163321,
    -0.077151,
    1.229461,
    0.481156,
    0.181936,
    -0.085636,
    1.228718,
    0.481011,
    0.201516,
    -0.094484,
    1.228023,
    0.48083,
    0.221963,
    -0.103362,
    1.227057,
    0.480562,
    0.243264,
    -0.112628,
    1.225997,
    0.480247,
    0.265291,
    -0.122366,
    1.224744,
    0.479891,
    0.287824,
    -0.132256,
    1.223255,
    0.479461,
    0.310927,
    -0.142614,
    1.221348,
    0.478978,
    0.335749,
    -0.152326,
    1.218953,
    0.478132,
    0.361361,
    -0.161747,
    1.215806,
    0.476971,
    0.38748,
    -0.170879,
    1.211853,
    0.475477,
    0.414231,
    -0.179865,
    1.207783,
    0.473686,
    0.441065,
    -0.188331,
    1.202051,
    0.471415,
    0.467923,
    -0.196454,
    1.195463,
    0.468647,
    0.494526,
    -0.204048,
    1.187542,
    0.465459,
    0.521318,
    -0.21102,
    1.179235,
    0.46165,
    0.548654,
    -0.21652,
    1.17011,
    0.456868,
    0.575778,
    -0.221098,
    1.160163,
    0.451227,
    0.60261,
    -0.224923,
    1.149751,
    0.444866,
    0.628891,
    -0.227895,
    1.139169,
    0.437577,
    0.655635,
    -0.23002,
    1.129736,
    0.429369,
    0.682115,
    -0.230419,
    1.119516,
    0.419673,
    0.707514,
    -0.229789,
    1.108277,
    0.409143,
    0.733169,
    -0.22852,
    1.099159,
    0.397296,
    0.758342,
    -0.225793,
    1.089839,
    0.384578,
    0.783477,
    -0.222049,
    1.081428,
    0.370323,
    0.808497,
    -0.217562,
    1.073742,
    0.355253,
    0.83279,
    -0.211697,
    1.06585,
    0.339282,
    0.856677,
    -0.204989,
    1.058834,
    0.322181,
    0.880662,
    -0.197653,
    1.053291,
    0.30461,
    0.903474,
    -0.188858,
    1.046822,
    0.286042,
    0.926313,
    -0.179746,
    1.041663,
    0.267224,
    0.948458,
    -0.169542,
    1.036532,
    0.247978,
    0.970873,
    -0.159005,
    1.033008,
    0.228535,
    0.992958,
    -0.147658,
    1.029844,
    0.208819,
    1.013413,
    -0.135771,
    1.02693,
    0.189486,
    1.033483,
    -0.123256,
    1.025545,
    0.170422,
    1.051872,
    -0.110401,
    1.023935,
    0.152075,
    1.068396,
    -0.09686,
    1.022092,
    0.133169,
    1.083731,
    -0.083259,
    1.020221,
    0.114022,
    1.096849,
    -0.069266,
    1.017663,
    0.094772,
    1.107864,
    -0.055203,
    1.014524,
    0.075432,
    1.1166,
    -0.041097,
    1.010514,
    0.05598,
    1.123871,
    -0.027083,
    1.006313,
    0.036839,
    1.130718,
    -0.01351,
    1.002778,
    0.018156,
    1.137649,
    154e-6,
    1.000033,
    -28e-6,
    2e-4,
    -103e-6,
    1.264025,
    0.51267,
    504e-6,
    -258e-6,
    1.262437,
    0.512667,
    0.002016,
    -0.001033,
    1.262691,
    0.512668,
    0.004535,
    -0.002325,
    1.262834,
    0.512667,
    0.008063,
    -0.004133,
    1.262783,
    0.512659,
    0.012598,
    -0.006458,
    1.262803,
    0.512666,
    0.018141,
    -0.009299,
    1.26272,
    0.512665,
    0.024683,
    -0.012652,
    1.262061,
    0.512655,
    0.032257,
    -0.016532,
    1.262858,
    0.512656,
    0.040826,
    -0.020919,
    1.262709,
    0.512649,
    0.050403,
    -0.02582,
    1.262685,
    0.512639,
    0.060993,
    -0.031233,
    1.262544,
    0.512625,
    0.072597,
    -0.037157,
    1.262435,
    0.512607,
    0.085211,
    -0.043587,
    1.262209,
    0.512581,
    0.098842,
    -0.05052,
    1.261907,
    0.512544,
    0.113484,
    -0.057926,
    1.261575,
    0.5125,
    0.129097,
    -0.06546,
    1.261293,
    0.51242,
    0.145727,
    -0.073543,
    1.260736,
    0.512316,
    0.163375,
    -0.082134,
    1.260117,
    0.51219,
    0.182011,
    -0.091173,
    1.259299,
    0.512024,
    0.201598,
    -0.10054,
    1.258381,
    0.51181,
    0.222084,
    -0.109931,
    1.257293,
    0.511505,
    0.243446,
    -0.119838,
    1.25605,
    0.511151,
    0.265574,
    -0.13009,
    1.254607,
    0.510724,
    0.28823,
    -0.140421,
    1.252808,
    0.510191,
    0.311336,
    -0.151343,
    1.250489,
    0.509627,
    0.335719,
    -0.161689,
    1.247279,
    0.508688,
    0.361314,
    -0.171748,
    1.243467,
    0.507393,
    0.387541,
    -0.181399,
    1.239145,
    0.505758,
    0.414204,
    -0.190768,
    1.23376,
    0.503676,
    0.441092,
    -0.199659,
    1.227433,
    0.501129,
    0.467789,
    -0.207934,
    1.219247,
    0.498078,
    0.494454,
    -0.215747,
    1.210441,
    0.49463,
    0.52095,
    -0.222869,
    1.200559,
    0.490467,
    0.547802,
    -0.228881,
    1.189872,
    0.485444,
    0.575563,
    -0.23376,
    1.180081,
    0.479268,
    0.602426,
    -0.237566,
    1.168544,
    0.472272,
    0.628772,
    -0.240447,
    1.156546,
    0.46439,
    0.654963,
    -0.242427,
    1.145123,
    0.455345,
    0.681384,
    -0.24298,
    1.134322,
    0.444885,
    0.707173,
    -0.24215,
    1.122665,
    0.433338,
    0.732477,
    -0.240435,
    1.111733,
    0.420647,
    0.757567,
    -0.237806,
    1.101271,
    0.406799,
    0.782341,
    -0.233503,
    1.091341,
    0.391761,
    0.80669,
    -0.228346,
    1.082042,
    0.375576,
    0.830804,
    -0.222386,
    1.073504,
    0.358545,
    0.85494,
    -0.215141,
    1.06588,
    0.340431,
    0.878709,
    -0.207207,
    1.05885,
    0.32169,
    0.901928,
    -0.198273,
    1.052588,
    0.30193,
    0.924845,
    -0.188476,
    1.046521,
    0.281513,
    0.946932,
    -0.177996,
    1.040966,
    0.261234,
    0.969256,
    -0.166644,
    1.03667,
    0.240356,
    0.991323,
    -0.154968,
    1.032694,
    0.219748,
    1.013013,
    -0.142425,
    1.030061,
    0.199103,
    1.032845,
    -0.129456,
    1.027254,
    0.178936,
    1.051887,
    -0.115763,
    1.025497,
    0.159243,
    1.069179,
    -0.101851,
    1.023807,
    0.13956,
    1.084499,
    -0.087357,
    1.021441,
    0.119607,
    1.097921,
    -0.072796,
    1.01878,
    0.099501,
    1.109281,
    -0.058037,
    1.015566,
    0.079211,
    1.118194,
    -0.043226,
    1.011494,
    0.058873,
    1.125351,
    -0.028633,
    1.007089,
    0.038736,
    1.132002,
    -0.013996,
    1.003014,
    0.019063,
    1.138951,
    132e-6,
    1.000036,
    -7e-6,
    2e-4,
    -109e-6,
    1.296791,
    0.544571,
    504e-6,
    -274e-6,
    1.296055,
    0.544568,
    0.002016,
    -0.001098,
    1.297239,
    0.544568,
    0.004535,
    -0.00247,
    1.2966,
    0.544568,
    0.008062,
    -0.00439,
    1.296368,
    0.544559,
    0.012597,
    -0.00686,
    1.296454,
    0.544566,
    0.018141,
    -0.009878,
    1.296522,
    0.544565,
    0.024693,
    -0.013444,
    1.296536,
    0.54456,
    0.032256,
    -0.017559,
    1.296638,
    0.544557,
    0.040824,
    -0.022218,
    1.296491,
    0.544547,
    0.050408,
    -0.027426,
    1.296552,
    0.544532,
    0.060997,
    -0.033173,
    1.296283,
    0.544518,
    0.0726,
    -0.039463,
    1.296113,
    0.544496,
    0.08522,
    -0.046292,
    1.295894,
    0.544466,
    0.098851,
    -0.053648,
    1.295545,
    0.544422,
    0.113496,
    -0.061487,
    1.295201,
    0.544371,
    0.129112,
    -0.069467,
    1.294754,
    0.544273,
    0.145765,
    -0.078092,
    1.294209,
    0.54416,
    0.163431,
    -0.087231,
    1.293534,
    0.544017,
    0.182088,
    -0.096837,
    1.29258,
    0.543828,
    0.201698,
    -0.106713,
    1.291586,
    0.543585,
    0.222231,
    -0.116699,
    1.290325,
    0.543238,
    0.243653,
    -0.127208,
    1.288888,
    0.542836,
    0.265855,
    -0.137949,
    1.287131,
    0.542329,
    0.288623,
    -0.148847,
    1.284936,
    0.5417,
    0.31183,
    -0.160204,
    1.282109,
    0.540997,
    0.335728,
    -0.171324,
    1.278036,
    0.540045,
    0.361403,
    -0.181915,
    1.273912,
    0.538603,
    0.387647,
    -0.192124,
    1.268881,
    0.536741,
    0.414217,
    -0.201807,
    1.262363,
    0.534432,
    0.44109,
    -0.211093,
    1.254755,
    0.531623,
    0.467823,
    -0.219678,
    1.245456,
    0.528314,
    0.494361,
    -0.227581,
    1.234953,
    0.524391,
    0.521264,
    -0.235087,
    1.224839,
    0.519902,
    0.547881,
    -0.241508,
    1.213175,
    0.514574,
    0.574965,
    -0.246315,
    1.200505,
    0.507837,
    0.601847,
    -0.250061,
    1.187901,
    0.500286,
    0.628207,
    -0.252822,
    1.174601,
    0.491502,
    0.654445,
    -0.254691,
    1.161944,
    0.481726,
    0.680175,
    -0.255318,
    1.149305,
    0.470727,
    0.706168,
    -0.254257,
    1.136708,
    0.458045,
    0.731458,
    -0.2521,
    1.124047,
    0.444438,
    0.756378,
    -0.249115,
    1.112942,
    0.429611,
    0.781311,
    -0.244899,
    1.1018,
    0.413501,
    0.805755,
    -0.239225,
    1.091662,
    0.395889,
    0.829867,
    -0.23283,
    1.082291,
    0.37786,
    0.853067,
    -0.225193,
    1.07282,
    0.358704,
    0.877084,
    -0.216648,
    1.065415,
    0.338413,
    0.900123,
    -0.20739,
    1.058403,
    0.317596,
    0.92337,
    -0.197095,
    1.051412,
    0.296301,
    0.946021,
    -0.186084,
    1.045877,
    0.274498,
    0.967669,
    -0.174262,
    1.040316,
    0.252565,
    0.989761,
    -0.161814,
    1.035489,
    0.230312,
    1.012163,
    -0.149076,
    1.03254,
    0.208746,
    1.032547,
    -0.135299,
    1.029598,
    0.18718,
    1.052032,
    -0.121277,
    1.027355,
    0.166482,
    1.069907,
    -0.106582,
    1.025622,
    0.145939,
    1.085563,
    -0.091589,
    1.023244,
    0.125362,
    1.099447,
    -0.076263,
    1.020661,
    0.104087,
    1.110848,
    -0.060825,
    1.017035,
    0.083036,
    1.119923,
    -0.045319,
    1.012675,
    0.061719,
    1.126805,
    -0.029852,
    1.007668,
    0.040583,
    1.133282,
    -0.014846,
    1.003335,
    0.019969,
    1.140128,
    149e-6,
    1.000024,
    -37e-6,
    2e-4,
    -116e-6,
    1.334863,
    0.57735,
    504e-6,
    -291e-6,
    1.33335,
    0.577348,
    0.002015,
    -0.001164,
    1.332853,
    0.577347,
    0.004535,
    -0.002618,
    1.333295,
    0.577347,
    0.008062,
    -0.004655,
    1.333189,
    0.577336,
    0.012598,
    -0.007273,
    1.333309,
    0.577345,
    0.018141,
    -0.010472,
    1.333274,
    0.577342,
    0.024694,
    -0.014253,
    1.333231,
    0.577339,
    0.032254,
    -0.018614,
    1.333265,
    0.577332,
    0.040827,
    -0.023556,
    1.333261,
    0.577321,
    0.0504,
    -0.029069,
    1.332893,
    0.577309,
    0.061,
    -0.035166,
    1.332998,
    0.577288,
    0.072608,
    -0.041833,
    1.332901,
    0.577263,
    0.085227,
    -0.049067,
    1.332603,
    0.577226,
    0.098864,
    -0.05686,
    1.332264,
    0.577177,
    0.113507,
    -0.065114,
    1.331825,
    0.577109,
    0.129146,
    -0.07361,
    1.331311,
    0.577005,
    0.145808,
    -0.082766,
    1.330639,
    0.576872,
    0.163494,
    -0.092458,
    1.329878,
    0.576709,
    0.182176,
    -0.102639,
    1.328889,
    0.576501,
    0.201804,
    -0.112983,
    1.32771,
    0.576207,
    0.222394,
    -0.12365,
    1.326256,
    0.575823,
    0.243881,
    -0.13478,
    1.324593,
    0.575363,
    0.266122,
    -0.145931,
    1.322426,
    0.574751,
    0.289043,
    -0.1575,
    1.319837,
    0.574033,
    0.31233,
    -0.169208,
    1.316301,
    0.573181,
    0.33612,
    -0.181125,
    1.312251,
    0.572188,
    0.361506,
    -0.192232,
    1.307003,
    0.570631,
    0.387757,
    -0.202981,
    1.301068,
    0.568558,
    0.414365,
    -0.21316,
    1.293695,
    0.566027,
    0.440986,
    -0.222617,
    1.283958,
    0.562942,
    0.467943,
    -0.231583,
    1.274057,
    0.559219,
    0.494821,
    -0.239881,
    1.262864,
    0.554913,
    0.521486,
    -0.247336,
    1.250633,
    0.549953,
    0.547884,
    -0.253921,
    1.237448,
    0.544251,
    0.574582,
    -0.259099,
    1.223164,
    0.53712,
    0.601342,
    -0.262695,
    1.208784,
    0.52865,
    0.627861,
    -0.265337,
    1.194424,
    0.518978,
    0.653745,
    -0.266872,
    1.179361,
    0.508525,
    0.679348,
    -0.267403,
    1.16501,
    0.496705,
    0.705068,
    -0.266429,
    1.151693,
    0.482926,
    0.730312,
    -0.263829,
    1.137584,
    0.468519,
    0.755576,
    -0.260491,
    1.125328,
    0.452213,
    0.780371,
    -0.256166,
    1.113759,
    0.435127,
    0.804632,
    -0.250079,
    1.101656,
    0.416833,
    0.828983,
    -0.243181,
    1.091235,
    0.397009,
    0.852585,
    -0.235383,
    1.081475,
    0.376647,
    0.875237,
    -0.226031,
    1.071806,
    0.355506,
    0.899152,
    -0.216343,
    1.064453,
    0.333133,
    0.922121,
    -0.205772,
    1.057161,
    0.311073,
    0.944523,
    -0.19398,
    1.050447,
    0.287781,
    0.967313,
    -0.18192,
    1.044531,
    0.26435,
    0.989042,
    -0.168822,
    1.039312,
    0.241128,
    1.010881,
    -0.15535,
    1.035298,
    0.218138,
    1.032368,
    -0.141231,
    1.032073,
    0.195579,
    1.052254,
    -0.126521,
    1.029395,
    0.173399,
    1.070207,
    -0.111243,
    1.026938,
    0.151866,
    1.086528,
    -0.095617,
    1.024957,
    0.130711,
    1.10067,
    -0.079687,
    1.021924,
    0.108865,
    1.112461,
    -0.063593,
    1.018281,
    0.08676,
    1.121588,
    -0.047313,
    1.013747,
    0.064575,
    1.128522,
    -0.031385,
    1.008433,
    0.042499,
    1.134759,
    -0.015356,
    1.003569,
    0.02084,
    1.141448,
    114e-6,
    0.999978,
    -56e-6,
    2e-4,
    -122e-6,
    1.372763,
    0.611086,
    503e-6,
    -308e-6,
    1.371456,
    0.611084,
    0.002016,
    -0.001232,
    1.37344,
    0.611084,
    0.004535,
    -0.002771,
    1.373387,
    0.611083,
    0.008061,
    -0.004926,
    1.372916,
    0.611083,
    0.012601,
    -0.0077,
    1.373956,
    0.611084,
    0.018142,
    -0.011084,
    1.373419,
    0.611078,
    0.024695,
    -0.015087,
    1.373492,
    0.611074,
    0.032255,
    -0.019701,
    1.37336,
    0.611066,
    0.040827,
    -0.02493,
    1.373327,
    0.611055,
    0.050408,
    -0.030769,
    1.373222,
    0.611037,
    0.061004,
    -0.037217,
    1.373079,
    0.611014,
    0.072613,
    -0.04427,
    1.372895,
    0.610982,
    0.085238,
    -0.051923,
    1.372624,
    0.610941,
    0.098878,
    -0.060161,
    1.372252,
    0.610883,
    0.113522,
    -0.068785,
    1.371785,
    0.610798,
    0.129176,
    -0.077863,
    1.371103,
    0.610683,
    0.145876,
    -0.087593,
    1.370541,
    0.610537,
    0.16357,
    -0.097847,
    1.369496,
    0.610349,
    0.182283,
    -0.108592,
    1.368477,
    0.610109,
    0.20193,
    -0.11942,
    1.36698,
    0.609763,
    0.22257,
    -0.130789,
    1.365375,
    0.609343,
    0.244123,
    -0.142514,
    1.363456,
    0.608815,
    0.266437,
    -0.154232,
    1.360916,
    0.608114,
    0.289467,
    -0.16637,
    1.357909,
    0.607291,
    0.312861,
    -0.178505,
    1.353588,
    0.606272,
    0.336736,
    -0.19098,
    1.349211,
    0.605153,
    0.36174,
    -0.202859,
    1.343319,
    0.603548,
    0.387878,
    -0.213997,
    1.335908,
    0.601268,
    0.414357,
    -0.224584,
    1.326676,
    0.598499,
    0.441442,
    -0.234664,
    1.317331,
    0.595066,
    0.468409,
    -0.243875,
    1.305818,
    0.590996,
    0.494999,
    -0.252121,
    1.291863,
    0.586293,
    0.52173,
    -0.259714,
    1.278212,
    0.58084,
    0.547894,
    -0.266242,
    1.262656,
    0.574494,
    0.573865,
    -0.271578,
    1.246364,
    0.567007,
    0.601124,
    -0.275503,
    1.231274,
    0.557771,
    0.627606,
    -0.277954,
    1.215252,
    0.547255,
    0.654004,
    -0.279404,
    1.199977,
    0.535766,
    0.679554,
    -0.279632,
    1.183995,
    0.522792,
    0.70428,
    -0.278457,
    1.167428,
    0.508488,
    0.72983,
    -0.275706,
    1.15276,
    0.492425,
    0.754376,
    -0.27164,
    1.137942,
    0.475285,
    0.779209,
    -0.266911,
    1.125222,
    0.456679,
    0.803562,
    -0.260838,
    1.112179,
    0.437267,
    0.827985,
    -0.253353,
    1.101439,
    0.416227,
    0.851737,
    -0.245027,
    1.08989,
    0.394728,
    0.87485,
    -0.235719,
    1.080018,
    0.372244,
    0.89768,
    -0.225051,
    1.070807,
    0.348846,
    0.921351,
    -0.214051,
    1.06318,
    0.324961,
    0.943818,
    -0.202039,
    1.056148,
    0.300836,
    0.966368,
    -0.189134,
    1.049277,
    0.276333,
    0.987426,
    -0.175613,
    1.042176,
    0.251862,
    1.010162,
    -0.161473,
    1.038567,
    0.227217,
    1.031224,
    -0.146866,
    1.034102,
    0.203582,
    1.052317,
    -0.131644,
    1.0316,
    0.180629,
    1.070879,
    -0.115909,
    1.028913,
    0.158165,
    1.087407,
    -0.099638,
    1.026193,
    0.135905,
    1.102159,
    -0.083091,
    1.023567,
    0.113394,
    1.114006,
    -0.066178,
    1.019567,
    0.090325,
    1.123374,
    -0.04943,
    1.014856,
    0.067302,
    1.13031,
    -0.032557,
    1.009141,
    0.044264,
    1.136334,
    -0.016157,
    1.003984,
    0.021807,
    1.142961,
    172e-6,
    0.999951,
    -77e-6,
    2e-4,
    -129e-6,
    1.416584,
    0.645866,
    504e-6,
    -326e-6,
    1.417762,
    0.645865,
    0.002016,
    -0.001302,
    1.417825,
    0.645866,
    0.004535,
    -0.002929,
    1.417142,
    0.645865,
    0.008062,
    -0.005207,
    1.416968,
    0.645864,
    0.012598,
    -0.008136,
    1.417109,
    0.645862,
    0.018141,
    -0.011715,
    1.417001,
    0.645859,
    0.02469,
    -0.015941,
    1.416878,
    0.645853,
    0.032257,
    -0.020823,
    1.417134,
    0.645843,
    0.040827,
    -0.026347,
    1.416983,
    0.645829,
    0.050411,
    -0.032518,
    1.416949,
    0.645808,
    0.061007,
    -0.03933,
    1.416694,
    0.645781,
    0.072621,
    -0.046783,
    1.416599,
    0.645746,
    0.085249,
    -0.054865,
    1.416241,
    0.645695,
    0.098897,
    -0.063563,
    1.415832,
    0.64563,
    0.113546,
    -0.072607,
    1.415264,
    0.645529,
    0.12922,
    -0.082257,
    1.414482,
    0.645396,
    0.145888,
    -0.092515,
    1.413626,
    0.645268,
    0.163659,
    -0.103393,
    1.41271,
    0.645018,
    0.182385,
    -0.114684,
    1.411418,
    0.644739,
    0.202078,
    -0.126098,
    1.409822,
    0.644348,
    0.222772,
    -0.138145,
    1.407948,
    0.643872,
    0.24437,
    -0.150405,
    1.405678,
    0.643255,
    0.266787,
    -0.162798,
    1.402763,
    0.642463,
    0.289844,
    -0.175434,
    1.398863,
    0.641504,
    0.31354,
    -0.188158,
    1.394695,
    0.640346,
    0.337489,
    -0.201014,
    1.389376,
    0.639042,
    0.362008,
    -0.213719,
    1.382439,
    0.637412,
    0.38799,
    -0.225248,
    1.373281,
    0.63493,
    0.414728,
    -0.236348,
    1.363729,
    0.631861,
    0.441635,
    -0.246701,
    1.352304,
    0.628155,
    0.468588,
    -0.256167,
    1.339162,
    0.623625,
    0.495337,
    -0.264662,
    1.323811,
    0.618458,
    0.521886,
    -0.272207,
    1.30763,
    0.612373,
    0.548355,
    -0.27889,
    1.291265,
    0.605263,
    0.574535,
    -0.284442,
    1.273752,
    0.597048,
    0.60087,
    -0.288389,
    1.256171,
    0.587401,
    0.627715,
    -0.290816,
    1.238447,
    0.576001,
    0.65383,
    -0.291886,
    1.221036,
    0.563198,
    0.679175,
    -0.291629,
    1.202283,
    0.549249,
    0.704539,
    -0.290489,
    1.185866,
    0.533881,
    0.729126,
    -0.287529,
    1.168822,
    0.516966,
    0.754297,
    -0.283184,
    1.152934,
    0.498501,
    0.778678,
    -0.277732,
    1.137821,
    0.478728,
    0.802473,
    -0.271203,
    1.123387,
    0.457814,
    0.826596,
    -0.263494,
    1.110573,
    0.435865,
    0.850835,
    -0.254572,
    1.099099,
    0.412597,
    0.874203,
    -0.244815,
    1.088403,
    0.388995,
    0.897271,
    -0.233993,
    1.078085,
    0.364487,
    0.919667,
    -0.221934,
    1.068543,
    0.339344,
    0.943001,
    -0.209714,
    1.061081,
    0.31377,
    0.965688,
    -0.196367,
    1.054023,
    0.287928,
    0.987598,
    -0.182263,
    1.047247,
    0.262157,
    1.00928,
    -0.167775,
    1.041376,
    0.236855,
    1.031762,
    -0.15253,
    1.037647,
    0.211847,
    1.051965,
    -0.136809,
    1.033396,
    0.187546,
    1.071699,
    -0.120418,
    1.031021,
    0.164186,
    1.088881,
    -0.103618,
    1.028403,
    0.141184,
    1.103482,
    -0.086271,
    1.024987,
    0.117665,
    1.115646,
    -0.068973,
    1.020884,
    0.093896,
    1.125258,
    -0.051285,
    1.015966,
    0.069978,
    1.132045,
    -0.033998,
    1.00999,
    0.046126,
    1.138004,
    -0.016696,
    1.00427,
    0.022635,
    1.144463,
    89e-6,
    0.999987,
    -16e-6,
    2e-4,
    -136e-6,
    1.463614,
    0.681786,
    504e-6,
    -344e-6,
    1.465345,
    0.681785,
    0.002015,
    -0.001374,
    1.464172,
    0.681783,
    0.004535,
    -0.003092,
    1.464846,
    0.681784,
    0.008062,
    -0.005496,
    1.464783,
    0.681784,
    0.012598,
    -0.008588,
    1.464883,
    0.681781,
    0.018141,
    -0.012366,
    1.46474,
    0.681777,
    0.024692,
    -0.016829,
    1.464665,
    0.68177,
    0.032258,
    -0.02198,
    1.46472,
    0.68176,
    0.040829,
    -0.027811,
    1.464625,
    0.681742,
    0.050415,
    -0.034324,
    1.464571,
    0.68172,
    0.061013,
    -0.041513,
    1.464346,
    0.681688,
    0.072628,
    -0.049375,
    1.464131,
    0.681644,
    0.085264,
    -0.057903,
    1.463847,
    0.681588,
    0.098918,
    -0.067067,
    1.463369,
    0.681509,
    0.113568,
    -0.07657,
    1.462549,
    0.681389,
    0.129265,
    -0.086782,
    1.461703,
    0.681239,
    0.145997,
    -0.097637,
    1.46084,
    0.681047,
    0.163751,
    -0.109101,
    1.459737,
    0.680806,
    0.182505,
    -0.120922,
    1.458231,
    0.68048,
    0.202241,
    -0.133007,
    1.456393,
    0.680042,
    0.222987,
    -0.145693,
    1.454258,
    0.679503,
    0.244638,
    -0.158488,
    1.451543,
    0.678792,
    0.267132,
    -0.171585,
    1.448115,
    0.677907,
    0.290365,
    -0.184746,
    1.443992,
    0.676796,
    0.314178,
    -0.198101,
    1.439271,
    0.675498,
    0.338289,
    -0.21137,
    1.43283,
    0.673922,
    0.362543,
    -0.224489,
    1.424163,
    0.672151,
    0.38847,
    -0.236914,
    1.41516,
    0.669601,
    0.415105,
    -0.248342,
    1.403811,
    0.666255,
    0.441925,
    -0.258957,
    1.390149,
    0.662166,
    0.468668,
    -0.268556,
    1.374104,
    0.657229,
    0.49572,
    -0.277359,
    1.358102,
    0.651347,
    0.522574,
    -0.285078,
    1.340754,
    0.644598,
    0.548981,
    -0.291718,
    1.322033,
    0.63682,
    0.574946,
    -0.297087,
    1.302148,
    0.627812,
    0.600744,
    -0.301079,
    1.28213,
    0.617485,
    0.627565,
    -0.303566,
    1.263339,
    0.605047,
    0.653598,
    -0.30433,
    1.242712,
    0.591167,
    0.679239,
    -0.30382,
    1.223212,
    0.576025,
    0.704043,
    -0.302064,
    1.203763,
    0.559649,
    0.728796,
    -0.299095,
    1.185434,
    0.541271,
    0.753581,
    -0.294392,
    1.16763,
    0.5218,
    0.778577,
    -0.288603,
    1.15193,
    0.500628,
    0.80255,
    -0.281604,
    1.136072,
    0.478434,
    0.825803,
    -0.273472,
    1.121673,
    0.455384,
    0.849768,
    -0.264011,
    1.108491,
    0.430811,
    0.87325,
    -0.253653,
    1.09655,
    0.405524,
    0.896725,
    -0.242642,
    1.085905,
    0.380038,
    0.919158,
    -0.230191,
    1.075091,
    0.353482,
    0.942236,
    -0.217145,
    1.066848,
    0.326605,
    0.965031,
    -0.203555,
    1.05931,
    0.299842,
    0.987048,
    -0.188777,
    1.051749,
    0.272859,
    1.008718,
    -0.173613,
    1.044999,
    0.24604,
    1.031097,
    -0.157972,
    1.040066,
    0.219826,
    1.052493,
    -0.141589,
    1.035951,
    0.194278,
    1.071773,
    -0.124814,
    1.03252,
    0.16983,
    1.089646,
    -0.107321,
    1.029803,
    0.146135,
    1.104932,
    -0.089726,
    1.026612,
    0.122127,
    1.117687,
    -0.071433,
    1.022391,
    0.097461,
    1.127188,
    -0.053395,
    1.017113,
    0.072556,
    1.13401,
    -0.035151,
    1.010934,
    0.047749,
    1.139746,
    -0.017427,
    1.004633,
    0.02353,
    1.146205,
    151e-6,
    1.00002,
    -106e-6,
    2e-4,
    -144e-6,
    1.517643,
    0.718949,
    504e-6,
    -362e-6,
    1.516387,
    0.718947,
    0.002016,
    -0.001449,
    1.516742,
    0.718946,
    0.004536,
    -0.003261,
    1.517196,
    0.718946,
    0.008063,
    -0.005796,
    1.516806,
    0.718945,
    0.012598,
    -0.009057,
    1.516986,
    0.718943,
    0.01814,
    -0.013039,
    1.516603,
    0.718937,
    0.024694,
    -0.017747,
    1.516739,
    0.718929,
    0.03226,
    -0.023178,
    1.516994,
    0.718917,
    0.040831,
    -0.029325,
    1.516649,
    0.718896,
    0.050419,
    -0.036192,
    1.516594,
    0.71887,
    0.061019,
    -0.04377,
    1.516327,
    0.718833,
    0.072638,
    -0.052056,
    1.516054,
    0.718782,
    0.085274,
    -0.061039,
    1.515628,
    0.718714,
    0.098938,
    -0.070676,
    1.515199,
    0.718623,
    0.113607,
    -0.080679,
    1.514222,
    0.718483,
    0.129329,
    -0.091485,
    1.513354,
    0.718316,
    0.146077,
    -0.102931,
    1.512301,
    0.718096,
    0.163856,
    -0.114986,
    1.510977,
    0.717818,
    0.18264,
    -0.127305,
    1.509225,
    0.717432,
    0.202432,
    -0.140147,
    1.507152,
    0.716939,
    0.223229,
    -0.153468,
    1.50478,
    0.716331,
    0.244943,
    -0.166875,
    1.501612,
    0.715527,
    0.267559,
    -0.180658,
    1.497898,
    0.714523,
    0.290926,
    -0.194405,
    1.493208,
    0.713266,
    0.314863,
    -0.208302,
    1.487388,
    0.711758,
    0.339053,
    -0.22202,
    1.479677,
    0.709982,
    0.363627,
    -0.235683,
    1.47095,
    0.707958,
    0.388887,
    -0.248723,
    1.459907,
    0.705346,
    0.415474,
    -0.260563,
    1.446579,
    0.701644,
    0.442065,
    -0.271352,
    1.429962,
    0.697134,
    0.469418,
    -0.281541,
    1.414343,
    0.691665,
    0.496419,
    -0.290429,
    1.395681,
    0.685227,
    0.523071,
    -0.298032,
    1.375347,
    0.677815,
    0.549641,
    -0.304679,
    1.354816,
    0.669063,
    0.575489,
    -0.309902,
    1.332505,
    0.659071,
    0.601108,
    -0.313771,
    1.309752,
    0.647799,
    0.627199,
    -0.316225,
    1.288381,
    0.634856,
    0.653243,
    -0.316679,
    1.265785,
    0.619627,
    0.67896,
    -0.315816,
    1.244333,
    0.603244,
    0.704055,
    -0.313776,
    1.223315,
    0.585191,
    0.728713,
    -0.310417,
    1.203142,
    0.565969,
    0.753301,
    -0.305786,
    1.184323,
    0.545347,
    0.77789,
    -0.299262,
    1.16607,
    0.522753,
    0.802354,
    -0.29183,
    1.149599,
    0.499017,
    0.826005,
    -0.283281,
    1.133655,
    0.474335,
    0.84892,
    -0.273512,
    1.118132,
    0.449019,
    0.872765,
    -0.262525,
    1.105606,
    0.422329,
    0.89595,
    -0.250769,
    1.093539,
    0.395057,
    0.918816,
    -0.238257,
    1.082388,
    0.367709,
    0.941089,
    -0.224381,
    1.072484,
    0.33935,
    0.964514,
    -0.210289,
    1.064054,
    0.311239,
    0.987128,
    -0.195488,
    1.056645,
    0.283272,
    1.009064,
    -0.179491,
    1.049549,
    0.255163,
    1.030163,
    -0.163172,
    1.042741,
    0.227757,
    1.052502,
    -0.146457,
    1.03827,
    0.20097,
    1.072971,
    -0.129054,
    1.035014,
    0.175767,
    1.091223,
    -0.111285,
    1.032231,
    0.151118,
    1.106518,
    -0.092617,
    1.028211,
    0.126196,
    1.119235,
    -0.074168,
    1.023686,
    0.100828,
    1.129311,
    -0.055212,
    1.018311,
    0.07524,
    1.135983,
    -0.036571,
    1.011485,
    0.049558,
    1.141648,
    -0.017954,
    1.004952,
    0.024273,
    1.147938,
    125e-6,
    1.000009,
    -48e-6,
    199e-6,
    -151e-6,
    1.566887,
    0.757466,
    504e-6,
    -382e-6,
    1.574111,
    0.757466,
    0.002016,
    -0.001527,
    1.573735,
    0.757466,
    0.004535,
    -0.003435,
    1.573737,
    0.757466,
    0.008062,
    -0.006107,
    1.573782,
    0.757464,
    0.012599,
    -0.009542,
    1.573796,
    0.75746,
    0.018142,
    -0.013739,
    1.57371,
    0.757455,
    0.024694,
    -0.018697,
    1.573562,
    0.757446,
    0.032259,
    -0.024418,
    1.573667,
    0.757429,
    0.040834,
    -0.030895,
    1.573555,
    0.757407,
    0.050422,
    -0.038127,
    1.573383,
    0.757376,
    0.061025,
    -0.046108,
    1.573086,
    0.757332,
    0.07265,
    -0.054835,
    1.572833,
    0.757274,
    0.085296,
    -0.064294,
    1.572395,
    0.757195,
    0.098962,
    -0.074376,
    1.571729,
    0.757087,
    0.113649,
    -0.084955,
    1.570571,
    0.756925,
    0.129389,
    -0.096334,
    1.569582,
    0.756729,
    0.146167,
    -0.108406,
    1.568444,
    0.756481,
    0.163973,
    -0.121056,
    1.566905,
    0.756158,
    0.182798,
    -0.13397,
    1.564939,
    0.755715,
    0.20265,
    -0.147522,
    1.562666,
    0.755167,
    0.223502,
    -0.161466,
    1.559877,
    0.754465,
    0.245269,
    -0.175539,
    1.556008,
    0.753552,
    0.26801,
    -0.189957,
    1.552013,
    0.75242,
    0.291474,
    -0.204361,
    1.546509,
    0.751008,
    0.315527,
    -0.218714,
    1.539575,
    0.749266,
    0.339954,
    -0.233029,
    1.530968,
    0.747232,
    0.364649,
    -0.247149,
    1.520994,
    0.744906,
    0.38952,
    -0.260672,
    1.507748,
    0.742123,
    0.415717,
    -0.272873,
    1.491777,
    0.738187,
    0.442862,
    -0.284317,
    1.475658,
    0.733189,
    0.469939,
    -0.294552,
    1.456572,
    0.727165,
    0.496916,
    -0.303517,
    1.435237,
    0.720043,
    0.52348,
    -0.311061,
    1.412192,
    0.71164,
    0.550092,
    -0.317596,
    1.389033,
    0.702174,
    0.576384,
    -0.322921,
    1.365086,
    0.691225,
    0.60228,
    -0.326806,
    1.341317,
    0.678841,
    0.627676,
    -0.329057,
    1.316518,
    0.664815,
    0.653458,
    -0.329372,
    1.291877,
    0.648548,
    0.679227,
    -0.328067,
    1.268126,
    0.630676,
    0.704476,
    -0.325585,
    1.244424,
    0.611585,
    0.729232,
    -0.321775,
    1.22301,
    0.590803,
    0.753405,
    -0.316713,
    1.201297,
    0.568653,
    0.777274,
    -0.309858,
    1.181071,
    0.544763,
    0.801882,
    -0.301866,
    1.162826,
    0.519747,
    0.82603,
    -0.292861,
    1.145704,
    0.493531,
    0.849359,
    -0.282794,
    1.129629,
    0.4669,
    0.871837,
    -0.271197,
    1.114155,
    0.43923,
    0.895896,
    -0.258954,
    1.102334,
    0.41057,
    0.918951,
    -0.245878,
    1.090163,
    0.381314,
    0.941148,
    -0.231897,
    1.078738,
    0.352268,
    0.963464,
    -0.216743,
    1.068862,
    0.322688,
    0.986628,
    -0.201486,
    1.061077,
    0.293523,
    1.009289,
    -0.185521,
    1.053561,
    0.264125,
    1.030659,
    -0.168429,
    1.046627,
    0.235706,
    1.052382,
    -0.15121,
    1.040953,
    0.208022,
    1.073476,
    -0.133289,
    1.036534,
    0.181245,
    1.092237,
    -0.114768,
    1.03358,
    0.155661,
    1.1082,
    -0.095917,
    1.029997,
    0.130223,
    1.121435,
    -0.076492,
    1.025374,
    0.104098,
    1.131382,
    -0.057204,
    1.019485,
    0.077776,
    1.137994,
    -0.037747,
    1.012188,
    0.05125,
    1.143441,
    -0.018673,
    1.005309,
    0.025245,
    1.149714,
    216e-6,
    1.000004,
    -12e-5,
    2e-4,
    -159e-6,
    1.633988,
    0.797469,
    504e-6,
    -402e-6,
    1.636076,
    0.797469,
    0.002016,
    -0.001607,
    1.635679,
    0.797467,
    0.004535,
    -0.003617,
    1.63604,
    0.797468,
    0.008063,
    -0.00643,
    1.636159,
    0.797467,
    0.012599,
    -0.010046,
    1.636128,
    0.797462,
    0.018141,
    -0.014464,
    1.63573,
    0.797457,
    0.024696,
    -0.019685,
    1.635836,
    0.797445,
    0.032259,
    -0.025705,
    1.635719,
    0.797426,
    0.040835,
    -0.032523,
    1.63561,
    0.797401,
    0.050425,
    -0.040135,
    1.63546,
    0.797363,
    0.061033,
    -0.048536,
    1.635182,
    0.797313,
    0.072661,
    -0.057718,
    1.634817,
    0.797243,
    0.085315,
    -0.067666,
    1.634314,
    0.79715,
    0.098985,
    -0.078179,
    1.63335,
    0.797016,
    0.113699,
    -0.089383,
    1.632253,
    0.796839,
    0.129456,
    -0.101364,
    1.631025,
    0.796623,
    0.146275,
    -0.114081,
    1.629867,
    0.796331,
    0.164108,
    -0.127318,
    1.628043,
    0.795956,
    0.182983,
    -0.140901,
    1.625813,
    0.795458,
    0.202891,
    -0.155174,
    1.623149,
    0.794834,
    0.223787,
    -0.169654,
    1.619686,
    0.794015,
    0.245678,
    -0.18454,
    1.615694,
    0.793013,
    0.268495,
    -0.199543,
    1.610812,
    0.791727,
    0.292093,
    -0.214639,
    1.604629,
    0.790107,
    0.316184,
    -0.229499,
    1.596061,
    0.788154,
    0.340986,
    -0.244407,
    1.587195,
    0.785797,
    0.365808,
    -0.258907,
    1.575031,
    0.783093,
    0.390528,
    -0.272746,
    1.559448,
    0.77997,
    0.41651,
    -0.285845,
    1.543294,
    0.775852,
    0.443443,
    -0.297404,
    1.523476,
    0.770323,
    0.470442,
    -0.307757,
    1.501515,
    0.763721,
    0.497499,
    -0.316846,
    1.477841,
    0.755889,
    0.524316,
    -0.324561,
    1.452427,
    0.746662,
    0.551212,
    -0.33106,
    1.427421,
    0.736004,
    0.577323,
    -0.335956,
    1.400369,
    0.72381,
    0.602976,
    -0.339501,
    1.373093,
    0.710184,
    0.628357,
    -0.341577,
    1.345853,
    0.695017,
    0.653642,
    -0.342031,
    1.31904,
    0.677972,
    0.67944,
    -0.340342,
    1.29249,
    0.658877,
    0.704744,
    -0.337356,
    1.267182,
    0.638085,
    0.729692,
    -0.333042,
    1.24328,
    0.615615,
    0.75392,
    -0.327504,
    1.219751,
    0.592054,
    0.777695,
    -0.320537,
    1.197796,
    0.566967,
    0.801426,
    -0.31188,
    1.176872,
    0.540643,
    0.825649,
    -0.302211,
    1.15816,
    0.512906,
    0.849282,
    -0.291665,
    1.141257,
    0.484587,
    0.872341,
    -0.28005,
    1.125469,
    0.455556,
    0.89511,
    -0.266978,
    1.110222,
    0.425652,
    0.918841,
    -0.253326,
    1.097419,
    0.395015,
    0.941209,
    -0.238899,
    1.086101,
    0.364948,
    0.963142,
    -0.223523,
    1.075023,
    0.334151,
    0.985996,
    -0.207346,
    1.065628,
    0.303708,
    1.008718,
    -0.190889,
    1.057256,
    0.273008,
    1.030554,
    -0.173517,
    1.04972,
    0.243221,
    1.053085,
    -0.155645,
    1.043837,
    0.214426,
    1.074267,
    -0.137472,
    1.039312,
    0.187036,
    1.093591,
    -0.118385,
    1.035457,
    0.160512,
    1.10985,
    -0.098883,
    1.03163,
    0.134384,
    1.123516,
    -0.07905,
    1.026762,
    0.107424,
    1.133578,
    -0.058977,
    1.02064,
    0.080317,
    1.140289,
    -0.039013,
    1.013096,
    0.052944,
    1.14561,
    -0.019228,
    1.005694,
    0.025989,
    1.151704,
    105e-6,
    0.999981,
    -19e-6,
    2e-4,
    -168e-6,
    1.704841,
    0.839096,
    504e-6,
    -423e-6,
    1.704242,
    0.839097,
    0.002016,
    -0.001691,
    1.703821,
    0.839091,
    0.004534,
    -0.003805,
    1.703804,
    0.839094,
    0.008063,
    -0.006765,
    1.704224,
    0.839092,
    0.012598,
    -0.01057,
    1.704013,
    0.839087,
    0.018142,
    -0.015219,
    1.703889,
    0.839079,
    0.024697,
    -0.020712,
    1.704023,
    0.839066,
    0.032261,
    -0.027046,
    1.703836,
    0.839045,
    0.040837,
    -0.034218,
    1.703608,
    0.839014,
    0.050429,
    -0.042224,
    1.703414,
    0.838972,
    0.061041,
    -0.051061,
    1.703148,
    0.838912,
    0.072676,
    -0.060717,
    1.702744,
    0.838831,
    0.08534,
    -0.071175,
    1.702223,
    0.838724,
    0.099023,
    -0.082182,
    1.700984,
    0.838567,
    0.113759,
    -0.094007,
    1.699764,
    0.838367,
    0.129546,
    -0.106621,
    1.698462,
    0.838112,
    0.146382,
    -0.119956,
    1.696938,
    0.837782,
    0.16426,
    -0.13376,
    1.694868,
    0.837346,
    0.183188,
    -0.148108,
    1.692262,
    0.83678,
    0.203158,
    -0.163075,
    1.689251,
    0.836073,
    0.224147,
    -0.178255,
    1.685408,
    0.835148,
    0.246147,
    -0.1939,
    1.680946,
    0.833992,
    0.269072,
    -0.209553,
    1.675277,
    0.832546,
    0.292718,
    -0.225226,
    1.667626,
    0.830727,
    0.317159,
    -0.240836,
    1.658952,
    0.82851,
    0.341979,
    -0.256103,
    1.647624,
    0.825843,
    0.366844,
    -0.270887,
    1.633014,
    0.82276,
    0.392043,
    -0.285324,
    1.617191,
    0.819159,
    0.417356,
    -0.298817,
    1.597501,
    0.814788,
    0.444093,
    -0.310711,
    1.575184,
    0.808751,
    0.471379,
    -0.32141,
    1.55159,
    0.801294,
    0.498267,
    -0.330421,
    1.524134,
    0.792711,
    0.525401,
    -0.338331,
    1.496672,
    0.78248,
    0.551846,
    -0.34443,
    1.467062,
    0.770659,
    0.578009,
    -0.349047,
    1.436943,
    0.757348,
    0.604054,
    -0.35249,
    1.407611,
    0.742541,
    0.629387,
    -0.354158,
    1.377441,
    0.726071,
    0.654435,
    -0.354422,
    1.347651,
    0.707524,
    0.679845,
    -0.352663,
    1.318769,
    0.687067,
    0.704892,
    -0.348994,
    1.2906,
    0.664637,
    0.729763,
    -0.344105,
    1.263997,
    0.640663,
    0.754345,
    -0.338129,
    1.239273,
    0.615484,
    0.778629,
    -0.330905,
    1.215858,
    0.58921,
    0.801939,
    -0.322113,
    1.192318,
    0.56155,
    0.825723,
    -0.311673,
    1.17138,
    0.532175,
    0.849387,
    -0.30041,
    1.152991,
    0.502055,
    0.872792,
    -0.288328,
    1.136139,
    0.471308,
    0.895083,
    -0.275087,
    1.119534,
    0.440427,
    0.918335,
    -0.2607,
    1.105542,
    0.40926,
    0.941577,
    -0.245717,
    1.09307,
    0.377142,
    0.963992,
    -0.230079,
    1.081207,
    0.345289,
    0.98651,
    -0.213523,
    1.071488,
    0.313508,
    1.008806,
    -0.196157,
    1.062011,
    0.281962,
    1.030724,
    -0.178467,
    1.05324,
    0.251177,
    1.053782,
    -0.160291,
    1.047057,
    0.220986,
    1.075451,
    -0.141308,
    1.041842,
    0.192256,
    1.094947,
    -0.121975,
    1.037704,
    0.165023,
    1.111783,
    -0.101744,
    1.0333,
    0.138228,
    1.125525,
    -0.081476,
    1.028234,
    0.110679,
    1.135873,
    -0.06077,
    1.021695,
    0.082672,
    1.142478,
    -0.040207,
    1.013838,
    0.054506,
    1.147889,
    -0.019908,
    1.006166,
    0.026938,
    1.153852,
    204e-6,
    0.999983,
    -123e-6,
    199e-6,
    -176e-6,
    1.771601,
    0.882501,
    504e-6,
    -445e-6,
    1.779195,
    0.882504,
    0.002016,
    -0.001779,
    1.779635,
    0.882498,
    0.004536,
    -0.004003,
    1.779586,
    0.882499,
    0.008062,
    -0.007115,
    1.778613,
    0.882496,
    0.012598,
    -0.011116,
    1.778678,
    0.882492,
    0.018142,
    -0.016005,
    1.778531,
    0.882481,
    0.024696,
    -0.021782,
    1.778556,
    0.882466,
    0.032262,
    -0.028444,
    1.778507,
    0.882442,
    0.040842,
    -0.035987,
    1.778385,
    0.882408,
    0.050436,
    -0.044404,
    1.778034,
    0.882364,
    0.061053,
    -0.053695,
    1.777761,
    0.882287,
    0.072692,
    -0.063842,
    1.777256,
    0.88219,
    0.085364,
    -0.074821,
    1.776518,
    0.882067,
    0.099064,
    -0.086368,
    1.77508,
    0.881884,
    0.113828,
    -0.098805,
    1.773836,
    0.881657,
    0.129649,
    -0.11209,
    1.77237,
    0.881361,
    0.146518,
    -0.126067,
    1.770594,
    0.880982,
    0.16444,
    -0.140493,
    1.768089,
    0.880484,
    0.183437,
    -0.155646,
    1.765301,
    0.879843,
    0.203468,
    -0.171266,
    1.761698,
    0.879035,
    0.224562,
    -0.187231,
    1.757518,
    0.877982,
    0.246665,
    -0.20354,
    1.752318,
    0.876667,
    0.269652,
    -0.219916,
    1.745356,
    0.875028,
    0.293531,
    -0.236255,
    1.737186,
    0.872977,
    0.318048,
    -0.25241,
    1.726709,
    0.870448,
    0.342963,
    -0.268192,
    1.713109,
    0.8674,
    0.368336,
    -0.283587,
    1.698087,
    0.863882,
    0.393512,
    -0.298186,
    1.678638,
    0.859724,
    0.418602,
    -0.311882,
    1.655604,
    0.854835,
    0.44508,
    -0.3245,
    1.63225,
    0.848353,
    0.472289,
    -0.335295,
    1.605069,
    0.840218,
    0.499128,
    -0.344256,
    1.573846,
    0.830556,
    0.525834,
    -0.351716,
    1.54112,
    0.819269,
    0.553177,
    -0.358241,
    1.511385,
    0.806222,
    0.57948,
    -0.36264,
    1.477866,
    0.791647,
    0.605205,
    -0.365513,
    1.444218,
    0.775398,
    0.630617,
    -0.366822,
    1.410954,
    0.757144,
    0.65573,
    -0.366785,
    1.37901,
    0.737323,
    0.680529,
    -0.364904,
    1.34728,
    0.715601,
    0.7058,
    -0.36099,
    1.316416,
    0.691547,
    0.73055,
    -0.355397,
    1.286344,
    0.666141,
    0.75497,
    -0.348664,
    1.258954,
    0.638929,
    0.779042,
    -0.340774,
    1.232965,
    0.611015,
    0.802839,
    -0.331767,
    1.209775,
    0.581877,
    0.825793,
    -0.321054,
    1.185813,
    0.551509,
    0.849512,
    -0.309016,
    1.16508,
    0.519698,
    0.87312,
    -0.296369,
    1.147091,
    0.487506,
    0.895942,
    -0.282704,
    1.129658,
    0.45532,
    0.917996,
    -0.268007,
    1.113463,
    0.422605,
    0.941281,
    -0.252329,
    1.10004,
    0.389347,
    0.964584,
    -0.236203,
    1.087973,
    0.35643,
    0.986371,
    -0.219209,
    1.075983,
    0.323089,
    1.009522,
    -0.201588,
    1.06694,
    0.290806,
    1.031976,
    -0.183296,
    1.057999,
    0.258682,
    1.053461,
    -0.164509,
    1.049542,
    0.227722,
    1.076121,
    -0.145165,
    1.043718,
    0.197439,
    1.096597,
    -0.125199,
    1.039607,
    0.169578,
    1.113908,
    -0.104921,
    1.035528,
    0.142222,
    1.127939,
    -0.083623,
    1.029807,
    0.113802,
    1.138391,
    -0.062589,
    1.023312,
    0.085164,
    1.14511,
    -0.041376,
    1.014806,
    0.056186,
    1.150141,
    -0.020433,
    1.006501,
    0.027654,
    1.156069,
    97e-6,
    0.999949,
    -46e-6,
    2e-4,
    -185e-6,
    1.858268,
    0.927857,
    504e-6,
    -468e-6,
    1.861583,
    0.927859,
    0.002016,
    -0.00187,
    1.860659,
    0.927855,
    0.004535,
    -0.004208,
    1.860963,
    0.927867,
    0.008063,
    -0.00748,
    1.860766,
    0.927855,
    0.012594,
    -0.011683,
    1.859996,
    0.927851,
    0.018142,
    -0.016828,
    1.860739,
    0.927839,
    0.024698,
    -0.022901,
    1.860763,
    0.927818,
    0.032263,
    -0.029903,
    1.860501,
    0.927791,
    0.040846,
    -0.037834,
    1.860431,
    0.927751,
    0.05044,
    -0.04668,
    1.859827,
    0.92769,
    0.061066,
    -0.056446,
    1.859624,
    0.92761,
    0.072713,
    -0.067109,
    1.859039,
    0.927505,
    0.085393,
    -0.078613,
    1.858144,
    0.927357,
    0.09912,
    -0.090747,
    1.856618,
    0.927145,
    0.11391,
    -0.10385,
    1.855221,
    0.926884,
    0.129755,
    -0.117777,
    1.85347,
    0.926546,
    0.146669,
    -0.132441,
    1.851413,
    0.926104,
    0.164648,
    -0.147565,
    1.848498,
    0.92553,
    0.183708,
    -0.16347,
    1.845281,
    0.924802,
    0.203832,
    -0.179763,
    1.841273,
    0.923871,
    0.225029,
    -0.196564,
    1.836481,
    0.922691,
    0.247221,
    -0.213537,
    1.830273,
    0.921198,
    0.270343,
    -0.230662,
    1.822374,
    0.91932,
    0.294399,
    -0.24774,
    1.812975,
    0.917008,
    0.31904,
    -0.264448,
    1.800693,
    0.914141,
    0.344269,
    -0.280831,
    1.785923,
    0.910707,
    0.369625,
    -0.296478,
    1.767203,
    0.906585,
    0.394925,
    -0.311287,
    1.744434,
    0.901918,
    0.420583,
    -0.325578,
    1.720938,
    0.89624,
    0.4462,
    -0.338384,
    1.693005,
    0.889335,
    0.472969,
    -0.349187,
    1.660901,
    0.880394,
    0.50049,
    -0.358687,
    1.628806,
    0.869705,
    0.527312,
    -0.366042,
    1.593001,
    0.857145,
    0.554207,
    -0.372045,
    1.557046,
    0.842943,
    0.58062,
    -0.376134,
    1.520192,
    0.826837,
    0.60648,
    -0.378636,
    1.482947,
    0.808891,
    0.631815,
    -0.379414,
    1.445954,
    0.789119,
    0.657021,
    -0.378972,
    1.410833,
    0.767564,
    0.681686,
    -0.376728,
    1.376575,
    0.744338,
    0.706498,
    -0.372844,
    1.342935,
    0.718799,
    0.731258,
    -0.366649,
    1.311052,
    0.691756,
    0.755937,
    -0.359354,
    1.280478,
    0.662683,
    0.779259,
    -0.350487,
    1.250585,
    0.632892,
    0.803295,
    -0.340941,
    1.225722,
    0.60216,
    0.82657,
    -0.330174,
    1.201003,
    0.57052,
    0.849954,
    -0.317854,
    1.178488,
    0.537651,
    0.873696,
    -0.304426,
    1.158302,
    0.503799,
    0.896695,
    -0.29012,
    1.139886,
    0.469645,
    0.919149,
    -0.275106,
    1.122884,
    0.435625,
    0.942121,
    -0.259282,
    1.107691,
    0.401228,
    0.964627,
    -0.242123,
    1.093661,
    0.367086,
    0.986614,
    -0.224575,
    1.08158,
    0.332885,
    1.009623,
    -0.206837,
    1.071375,
    0.299209,
    1.033126,
    -0.188092,
    1.062241,
    0.266187,
    1.054954,
    -0.168637,
    1.052912,
    0.233733,
    1.07766,
    -0.149166,
    1.047047,
    0.203192,
    1.097983,
    -0.128587,
    1.041607,
    0.173918,
    1.115586,
    -0.107339,
    1.03685,
    0.145531,
    1.13017,
    -0.086203,
    1.031427,
    0.11689,
    1.141018,
    -0.064171,
    1.024395,
    0.087388,
    1.147681,
    -0.04253,
    1.015719,
    0.057733,
    1.15256,
    -0.021011,
    1.006883,
    0.028413,
    1.158406,
    158e-6,
    0.999897,
    -106e-6,
    2e-4,
    -195e-6,
    1.950982,
    0.975366,
    504e-6,
    -491e-6,
    1.950207,
    0.975365,
    0.002015,
    -0.001966,
    1.950675,
    0.975362,
    0.004535,
    -0.004423,
    1.951281,
    0.97537,
    0.008062,
    -0.007863,
    1.951045,
    0.975362,
    0.012597,
    -0.012285,
    1.951199,
    0.975356,
    0.018145,
    -0.017692,
    1.951528,
    0.97534,
    0.024699,
    -0.024074,
    1.951194,
    0.975321,
    0.032266,
    -0.031434,
    1.950865,
    0.975288,
    0.040853,
    -0.039771,
    1.951038,
    0.975244,
    0.050452,
    -0.049067,
    1.950336,
    0.975173,
    0.061077,
    -0.059324,
    1.949805,
    0.975078,
    0.072736,
    -0.070526,
    1.949133,
    0.974951,
    0.085431,
    -0.082528,
    1.947947,
    0.974777,
    0.099182,
    -0.095345,
    1.946337,
    0.97454,
    0.113999,
    -0.109118,
    1.944725,
    0.974241,
    0.129888,
    -0.123741,
    1.942857,
    0.973852,
    0.146842,
    -0.139071,
    1.940251,
    0.973342,
    0.16489,
    -0.154986,
    1.937086,
    0.972684,
    0.184025,
    -0.171661,
    1.933404,
    0.971856,
    0.204245,
    -0.188672,
    1.92877,
    0.970785,
    0.225528,
    -0.206252,
    1.923041,
    0.969448,
    0.247841,
    -0.223972,
    1.915788,
    0.967742,
    0.271157,
    -0.241827,
    1.907008,
    0.965607,
    0.295297,
    -0.259562,
    1.895854,
    0.963007,
    0.320121,
    -0.276909,
    1.881289,
    0.959722,
    0.345566,
    -0.293883,
    1.864528,
    0.955831,
    0.371012,
    -0.309816,
    1.842062,
    0.951127,
    0.396834,
    -0.325157,
    1.818068,
    0.945725,
    0.422277,
    -0.339357,
    1.788874,
    0.939318,
    0.447928,
    -0.352387,
    1.758283,
    0.93147,
    0.474315,
    -0.36368,
    1.723668,
    0.9219,
    0.50156,
    -0.372963,
    1.686081,
    0.909996,
    0.528391,
    -0.380159,
    1.645816,
    0.896244,
    0.554754,
    -0.385545,
    1.603709,
    0.880326,
    0.581888,
    -0.389778,
    1.565475,
    0.862716,
    0.607791,
    -0.391839,
    1.524196,
    0.843146,
    0.633511,
    -0.392331,
    1.483921,
    0.821554,
    0.658621,
    -0.391193,
    1.445013,
    0.798336,
    0.68316,
    -0.388424,
    1.406963,
    0.773299,
    0.707429,
    -0.384104,
    1.370996,
    0.746668,
    0.732212,
    -0.377945,
    1.335879,
    0.717502,
    0.756871,
    -0.369856,
    1.302489,
    0.686954,
    0.781065,
    -0.360707,
    1.271815,
    0.655372,
    0.804167,
    -0.350091,
    1.242416,
    0.622683,
    0.827948,
    -0.338941,
    1.217208,
    0.589185,
    0.850901,
    -0.326427,
    1.192354,
    0.555005,
    0.873589,
    -0.312199,
    1.169639,
    0.519594,
    0.897085,
    -0.297374,
    1.150181,
    0.484105,
    0.920459,
    -0.281932,
    1.132858,
    0.448661,
    0.942637,
    -0.265625,
    1.115401,
    0.413051,
    0.965341,
    -0.248332,
    1.101078,
    0.377329,
    0.98753,
    -0.229983,
    1.087377,
    0.342349,
    1.010739,
    -0.211647,
    1.076582,
    0.307824,
    1.033449,
    -0.192725,
    1.0659,
    0.273368,
    1.055618,
    -0.172726,
    1.056958,
    0.240238,
    1.079345,
    -0.15264,
    1.04962,
    0.208322,
    1.100058,
    -0.131931,
    1.044084,
    0.178242,
    1.118547,
    -0.110351,
    1.039387,
    0.149493,
    1.132748,
    -0.088128,
    1.033049,
    0.119673,
    1.143419,
    -0.066069,
    1.025521,
    0.089728,
    1.150316,
    -0.043513,
    1.016378,
    0.059253,
    1.155208,
    -0.021593,
    1.007506,
    0.02914,
    1.160871,
    111e-6,
    0.999916,
    -35e-6,
    201e-6,
    -206e-6,
    2.061,
    1.025243,
    504e-6,
    -516e-6,
    2.049647,
    1.025237,
    0.002015,
    -0.002066,
    2.050169,
    1.025237,
    0.004535,
    -0.00465,
    2.051254,
    1.025255,
    0.008063,
    -0.008266,
    2.051302,
    1.025236,
    0.0126,
    -0.012915,
    2.051508,
    1.025226,
    0.018144,
    -0.018594,
    2.050981,
    1.025215,
    0.0247,
    -0.025304,
    2.050841,
    1.02519,
    0.032267,
    -0.033038,
    2.050537,
    1.025152,
    0.040852,
    -0.041795,
    2.05066,
    1.02509,
    0.05046,
    -0.05157,
    2.049921,
    1.025017,
    0.061094,
    -0.062347,
    2.04935,
    1.024908,
    0.072762,
    -0.074111,
    2.048517,
    1.02476,
    0.085475,
    -0.086661,
    2.047009,
    1.024555,
    0.099249,
    -0.10016,
    2.045261,
    1.024278,
    0.114106,
    -0.114628,
    2.043508,
    1.023941,
    0.130032,
    -0.130002,
    2.041321,
    1.023488,
    0.14705,
    -0.145985,
    2.038299,
    1.022905,
    0.165164,
    -0.162762,
    2.034658,
    1.022151,
    0.18438,
    -0.180172,
    2.030312,
    1.0212,
    0.204704,
    -0.198022,
    2.024944,
    1.019966,
    0.226129,
    -0.216359,
    2.018546,
    1.018424,
    0.248582,
    -0.234923,
    2.010153,
    1.016519,
    0.272011,
    -0.253474,
    1.999659,
    1.014072,
    0.296259,
    -0.27182,
    1.986076,
    1.011071,
    0.321423,
    -0.289959,
    1.970618,
    1.007389,
    0.346897,
    -0.307283,
    1.949667,
    1.002955,
    0.37275,
    -0.323817,
    1.925287,
    0.997633,
    0.398603,
    -0.339241,
    1.896006,
    0.991354,
    0.424351,
    -0.353633,
    1.863658,
    0.983937,
    0.449887,
    -0.36666,
    1.82743,
    0.975254,
    0.475715,
    -0.378213,
    1.789521,
    0.964753,
    0.502204,
    -0.387133,
    1.745632,
    0.951594,
    0.530179,
    -0.394976,
    1.705347,
    0.936344,
    0.556732,
    -0.400134,
    1.658928,
    0.918907,
    0.583123,
    -0.403439,
    1.613077,
    0.899504,
    0.609477,
    -0.405285,
    1.567884,
    0.878172,
    0.634927,
    -0.405055,
    1.523507,
    0.854396,
    0.660357,
    -0.403494,
    1.481712,
    0.829259,
    0.684851,
    -0.400104,
    1.439,
    0.802359,
    0.709654,
    -0.395536,
    1.400956,
    0.773534,
    0.733472,
    -0.388996,
    1.362156,
    0.74323,
    0.757502,
    -0.380263,
    1.325113,
    0.71109,
    0.782249,
    -0.370594,
    1.292913,
    0.677166,
    0.806017,
    -0.359509,
    1.262088,
    0.642527,
    0.828687,
    -0.347126,
    1.232059,
    0.607589,
    0.852372,
    -0.334474,
    1.20716,
    0.571938,
    0.874266,
    -0.320074,
    1.181978,
    0.535518,
    0.898168,
    -0.304719,
    1.161156,
    0.498375,
    0.920456,
    -0.288246,
    1.140667,
    0.461179,
    0.942832,
    -0.271311,
    1.12278,
    0.424533,
    0.966458,
    -0.254154,
    1.108743,
    0.387784,
    0.988907,
    -0.235659,
    1.093872,
    0.351689,
    1.011557,
    -0.216322,
    1.081959,
    0.315743,
    1.035099,
    -0.197007,
    1.070885,
    0.280402,
    1.056354,
    -0.176878,
    1.059968,
    0.246472,
    1.079854,
    -0.156058,
    1.051815,
    0.212818,
    1.101494,
    -0.134772,
    1.045757,
    0.182143,
    1.120587,
    -0.113071,
    1.041169,
    0.152867,
    1.135399,
    -0.090411,
    1.034844,
    0.122796,
    1.146612,
    -0.067477,
    1.026974,
    0.091888,
    1.153168,
    -0.044849,
    1.017303,
    0.060779,
    1.157912,
    -0.021998,
    1.007735,
    0.029919,
    1.163607,
    121e-6,
    0.999959,
    3e-6,
    2e-4,
    -216e-6,
    2.163956,
    1.077737,
    504e-6,
    -543e-6,
    2.161128,
    1.077732,
    0.002016,
    -0.002173,
    2.162732,
    1.077729,
    0.004535,
    -0.004887,
    2.161402,
    1.077749,
    0.008066,
    -0.008692,
    2.163252,
    1.077732,
    0.012599,
    -0.013576,
    2.1613,
    1.077727,
    0.018145,
    -0.019546,
    2.161151,
    1.077702,
    0.024702,
    -0.026599,
    2.161223,
    1.077675,
    0.032272,
    -0.034729,
    2.160949,
    1.077632,
    0.040862,
    -0.043936,
    2.160967,
    1.077575,
    0.05047,
    -0.054203,
    2.160035,
    1.077473,
    0.061113,
    -0.065528,
    2.15949,
    1.077348,
    0.072794,
    -0.077882,
    2.158517,
    1.077178,
    0.085528,
    -0.09103,
    2.156605,
    1.076937,
    0.099337,
    -0.105251,
    2.154828,
    1.076631,
    0.114228,
    -0.120456,
    2.152812,
    1.076229,
    0.130202,
    -0.136573,
    2.150298,
    1.075713,
    0.147284,
    -0.153306,
    2.146752,
    1.075031,
    0.16548,
    -0.170931,
    2.142744,
    1.074173,
    0.184793,
    -0.189083,
    2.137475,
    1.073063,
    0.205224,
    -0.20784,
    2.13132,
    1.071683,
    0.226743,
    -0.226939,
    2.123154,
    1.069914,
    0.249401,
    -0.246344,
    2.114086,
    1.067718,
    0.272955,
    -0.26564,
    2.101599,
    1.064924,
    0.297494,
    -0.284846,
    2.086612,
    1.061512,
    0.322731,
    -0.303452,
    2.067356,
    1.057359,
    0.348451,
    -0.32133,
    2.043711,
    1.052294,
    0.374451,
    -0.338201,
    2.015033,
    1.046153,
    0.400454,
    -0.353816,
    1.981139,
    1.039003,
    0.426434,
    -0.368216,
    1.944128,
    1.030498,
    0.452088,
    -0.381251,
    1.903094,
    1.020454,
    0.477901,
    -0.392833,
    1.860402,
    1.008793,
    0.504173,
    -0.402408,
    1.814402,
    0.994791,
    0.53152,
    -0.409545,
    1.766273,
    0.977733,
    0.558049,
    -0.414351,
    1.714119,
    0.958625,
    0.584778,
    -0.417437,
    1.664612,
    0.937189,
    0.610808,
    -0.418519,
    1.613793,
    0.913543,
    0.636915,
    -0.418094,
    1.565942,
    0.888137,
    0.662204,
    -0.415742,
    1.518783,
    0.860728,
    0.686848,
    -0.411746,
    1.473306,
    0.831793,
    0.710992,
    -0.406153,
    1.430153,
    0.800862,
    0.735382,
    -0.399519,
    1.389824,
    0.768768,
    0.759079,
    -0.390927,
    1.350744,
    0.734825,
    0.782912,
    -0.380111,
    1.313559,
    0.69945,
    0.806746,
    -0.368383,
    1.280028,
    0.663191,
    0.830269,
    -0.355606,
    1.249814,
    0.625927,
    0.853305,
    -0.341988,
    1.221138,
    0.588644,
    0.876326,
    -0.327545,
    1.195837,
    0.550849,
    0.898322,
    -0.311779,
    1.171844,
    0.512694,
    0.921811,
    -0.294944,
    1.150671,
    0.474225,
    0.944563,
    -0.277333,
    1.132224,
    0.435772,
    0.967089,
    -0.25934,
    1.115422,
    0.398001,
    0.989754,
    -0.240836,
    1.100405,
    0.360802,
    1.01247,
    -0.221293,
    1.086533,
    0.323566,
    1.036426,
    -0.201191,
    1.075496,
    0.287387,
    1.058709,
    -0.18059,
    1.064233,
    0.252184,
    1.081593,
    -0.15981,
    1.055296,
    0.218441,
    1.103146,
    -0.137772,
    1.047978,
    0.186223,
    1.122814,
    -0.115347,
    1.042693,
    0.156019,
    1.13779,
    -0.092582,
    1.036049,
    0.125579,
    1.149184,
    -0.069152,
    1.027944,
    0.093986,
    1.156062,
    -0.045661,
    1.018039,
    0.062122,
    1.160733,
    -0.022719,
    1.008072,
    0.03065,
    1.166487,
    231e-6,
    1.000063,
    -12e-5,
    201e-6,
    -228e-6,
    2.308308,
    1.133128,
    504e-6,
    -571e-6,
    2.283756,
    1.133123,
    0.002016,
    -0.002284,
    2.283756,
    1.133123,
    0.004535,
    -0.005138,
    2.28331,
    1.133144,
    0.008048,
    -0.009119,
    2.266192,
    1.133138,
    0.0126,
    -0.014274,
    2.284377,
    1.13311,
    0.018147,
    -0.020553,
    2.284204,
    1.133093,
    0.024702,
    -0.027964,
    2.283517,
    1.13306,
    0.032272,
    -0.03651,
    2.282997,
    1.133007,
    0.040866,
    -0.046188,
    2.282986,
    1.13293,
    0.050481,
    -0.056979,
    2.28226,
    1.132824,
    0.061133,
    -0.068881,
    2.281533,
    1.132678,
    0.07283,
    -0.08185,
    2.280504,
    1.132481,
    0.085592,
    -0.095657,
    2.278304,
    1.132202,
    0.099431,
    -0.110594,
    2.276269,
    1.131845,
    0.11436,
    -0.12659,
    2.27389,
    1.131383,
    0.130388,
    -0.143454,
    2.270761,
    1.130784,
    0.147547,
    -0.161029,
    2.266794,
    1.130003,
    0.165836,
    -0.179523,
    2.262332,
    1.129016,
    0.185269,
    -0.198527,
    2.256326,
    1.127738,
    0.205822,
    -0.218138,
    2.249031,
    1.126156,
    0.227527,
    -0.238141,
    2.239993,
    1.124132,
    0.250325,
    -0.258302,
    2.228878,
    1.121594,
    0.27407,
    -0.278329,
    2.214204,
    1.118449,
    0.298793,
    -0.29831,
    2.196654,
    1.114528,
    0.324131,
    -0.317462,
    2.173394,
    1.109783,
    0.350101,
    -0.335853,
    2.146395,
    1.103901,
    0.376293,
    -0.353064,
    2.112341,
    1.096954,
    0.402547,
    -0.36895,
    2.0737,
    1.088642,
    0.428791,
    -0.383462,
    2.031152,
    1.078946,
    0.454976,
    -0.396635,
    1.986661,
    1.067536,
    0.480566,
    -0.407873,
    1.937038,
    1.054403,
    0.506154,
    -0.417303,
    1.885155,
    1.038894,
    0.532862,
    -0.424194,
    1.830369,
    1.020535,
    0.560354,
    -0.429344,
    1.776976,
    0.999295,
    0.587114,
    -0.431949,
    1.721214,
    0.97599,
    0.613345,
    -0.432547,
    1.665739,
    0.950239,
    0.639335,
    -0.431338,
    1.6122,
    0.922467,
    0.664996,
    -0.428473,
    1.561035,
    0.892593,
    0.688947,
    -0.423355,
    1.50824,
    0.861325,
    0.713403,
    -0.417235,
    1.461776,
    0.828289,
    0.737649,
    -0.409848,
    1.418888,
    0.793863,
    0.761275,
    -0.400901,
    1.376807,
    0.758074,
    0.784778,
    -0.390174,
    1.337204,
    0.721974,
    0.808762,
    -0.377683,
    1.301527,
    0.682718,
    0.831993,
    -0.364037,
    1.267144,
    0.644001,
    0.854696,
    -0.349494,
    1.236023,
    0.605478,
    0.877933,
    -0.334499,
    1.209284,
    0.565588,
    0.90018,
    -0.318435,
    1.183967,
    0.526138,
    0.923039,
    -0.301669,
    1.161513,
    0.486524,
    0.945895,
    -0.283298,
    1.140838,
    0.446747,
    0.968069,
    -0.264438,
    1.122475,
    0.408041,
    0.991179,
    -0.245463,
    1.106968,
    0.369477,
    1.012926,
    -0.22568,
    1.091435,
    0.331626,
    1.036995,
    -0.205401,
    1.079561,
    0.294288,
    1.060909,
    -0.18431,
    1.068215,
    0.257696,
    1.083531,
    -0.162846,
    1.058133,
    0.223343,
    1.105644,
    -0.14104,
    1.050851,
    0.190541,
    1.125691,
    -0.117965,
    1.045001,
    0.15931,
    1.141297,
    -0.094377,
    1.038028,
    0.128238,
    1.152672,
    -0.070831,
    1.029694,
    0.096282,
    1.159333,
    -0.046853,
    1.019136,
    0.06372,
    1.163819,
    -0.022991,
    1.008518,
    0.031234,
    1.169564,
    125e-6,
    1.000069,
    -24e-6,
    202e-6,
    -241e-6,
    2.458341,
    1.191742,
    504e-6,
    -6e-4,
    2.418738,
    1.19174,
    0.002015,
    -0.002401,
    2.418821,
    1.19173,
    0.004535,
    -0.005405,
    2.421986,
    1.191756,
    0.008071,
    -0.009618,
    2.424988,
    1.191753,
    0.0126,
    -0.015012,
    2.420242,
    1.191727,
    0.018145,
    -0.021612,
    2.419937,
    1.191703,
    0.024704,
    -0.02941,
    2.419746,
    1.191662,
    0.032278,
    -0.038398,
    2.419409,
    1.191604,
    0.040874,
    -0.048574,
    2.418995,
    1.191515,
    0.050496,
    -0.05992,
    2.41819,
    1.191389,
    0.06116,
    -0.072432,
    2.417487,
    1.191221,
    0.072871,
    -0.086009,
    2.415853,
    1.190984,
    0.085664,
    -0.100559,
    2.413669,
    1.190664,
    0.099543,
    -0.116283,
    2.411423,
    1.190256,
    0.11452,
    -0.133071,
    2.408711,
    1.189719,
    0.130616,
    -0.15067,
    2.4049,
    1.189019,
    0.147856,
    -0.169197,
    2.400512,
    1.188125,
    0.166235,
    -0.188545,
    2.394939,
    1.186972,
    0.185804,
    -0.20848,
    2.388232,
    1.185515,
    0.206488,
    -0.228883,
    2.37919,
    1.183673,
    0.228383,
    -0.249897,
    2.369208,
    1.181382,
    0.251305,
    -0.270851,
    2.355459,
    1.178478,
    0.275349,
    -0.29178,
    2.339142,
    1.174857,
    0.300106,
    -0.312257,
    2.316655,
    1.170411,
    0.325849,
    -0.332225,
    2.29154,
    1.164883,
    0.351782,
    -0.350862,
    2.257242,
    1.158196,
    0.378248,
    -0.368431,
    2.218671,
    1.150173,
    0.404674,
    -0.384428,
    2.17368,
    1.140703,
    0.431385,
    -0.39923,
    2.127083,
    1.129555,
    0.457407,
    -0.411875,
    2.073236,
    1.116436,
    0.483275,
    -0.423013,
    2.018223,
    1.101373,
    0.509278,
    -0.432624,
    1.962674,
    1.084257,
    0.534751,
    -0.439261,
    1.900814,
    1.064592,
    0.561895,
    -0.443801,
    1.839558,
    1.040881,
    0.588677,
    -0.445872,
    1.777763,
    1.015208,
    0.6149,
    -0.445896,
    1.71655,
    0.987252,
    0.641051,
    -0.444148,
    1.657984,
    0.957271,
    0.666409,
    -0.440299,
    1.600832,
    0.924841,
    0.691872,
    -0.435318,
    1.548237,
    0.891185,
    0.716638,
    -0.428631,
    1.497572,
    0.855929,
    0.739864,
    -0.419872,
    1.447043,
    0.819676,
    0.763707,
    -0.410456,
    1.403648,
    0.781455,
    0.786744,
    -0.39939,
    1.360844,
    0.742965,
    0.809585,
    -0.386381,
    1.320529,
    0.70326,
    0.834164,
    -0.372622,
    1.286467,
    0.662385,
    0.856713,
    -0.357177,
    1.252306,
    0.621379,
    0.87982,
    -0.341458,
    1.22307,
    0.580238,
    0.902721,
    -0.325024,
    1.197115,
    0.539028,
    0.92465,
    -0.307543,
    1.172314,
    0.498592,
    0.947613,
    -0.289557,
    1.151171,
    0.45798,
    0.96959,
    -0.269799,
    1.129986,
    0.417696,
    0.992961,
    -0.250111,
    1.113321,
    0.377529,
    1.014582,
    -0.229761,
    1.097149,
    0.339096,
    1.038069,
    -0.209375,
    1.083913,
    0.301119,
    1.061661,
    -0.188038,
    1.071241,
    0.263506,
    1.085069,
    -0.165874,
    1.060508,
    0.227921,
    1.107744,
    -0.143437,
    1.05293,
    0.194062,
    1.127982,
    -0.120574,
    1.046396,
    0.162506,
    1.144541,
    -0.096569,
    1.03988,
    0.130788,
    1.155876,
    -0.072039,
    1.030946,
    0.098057,
    1.162719,
    -0.047888,
    1.020124,
    0.064956,
    1.167089,
    -0.02374,
    1.008953,
    0.031966,
    1.172775,
    277e-6,
    1.000067,
    -111e-6,
    2e-4,
    -251e-6,
    2.573709,
    1.253951,
    504e-6,
    -632e-6,
    2.572401,
    1.25394,
    0.002015,
    -0.002527,
    2.571267,
    1.253927,
    0.004535,
    -0.005687,
    2.572481,
    1.253948,
    0.008062,
    -0.010108,
    2.571851,
    1.253941,
    0.012588,
    -0.01578,
    2.568431,
    1.253934,
    0.018139,
    -0.022731,
    2.569765,
    1.253893,
    0.024709,
    -0.030948,
    2.572115,
    1.253853,
    0.032283,
    -0.040401,
    2.571456,
    1.253785,
    0.040883,
    -0.051105,
    2.571041,
    1.253683,
    0.050514,
    -0.063041,
    2.570153,
    1.253538,
    0.061188,
    -0.076195,
    2.569085,
    1.253336,
    0.072926,
    -0.090402,
    2.567184,
    1.253065,
    0.085746,
    -0.105745,
    2.564731,
    1.252697,
    0.099661,
    -0.122296,
    2.561995,
    1.252218,
    0.114699,
    -0.139912,
    2.559019,
    1.25159,
    0.130882,
    -0.158362,
    2.555017,
    1.250766,
    0.148202,
    -0.177856,
    2.549419,
    1.249744,
    0.166706,
    -0.198049,
    2.542908,
    1.248423,
    0.186404,
    -0.219014,
    2.535205,
    1.246741,
    0.207272,
    -0.240376,
    2.524893,
    1.244596,
    0.229345,
    -0.26223,
    2.512804,
    1.241917,
    0.252494,
    -0.284134,
    2.496923,
    1.23861,
    0.27669,
    -0.305828,
    2.476583,
    1.234474,
    0.301798,
    -0.327107,
    2.451548,
    1.229292,
    0.327423,
    -0.3473,
    2.41863,
    1.222997,
    0.353848,
    -0.366699,
    2.381002,
    1.215366,
    0.380342,
    -0.384421,
    2.334413,
    1.206199,
    0.40739,
    -0.400855,
    2.28566,
    1.195374,
    0.433913,
    -0.415241,
    2.228604,
    1.18229,
    0.460837,
    -0.428275,
    2.171532,
    1.167385,
    0.486381,
    -0.438573,
    2.105639,
    1.150401,
    0.511959,
    -0.447348,
    2.040835,
    1.13099,
    0.537586,
    -0.454152,
    1.974797,
    1.109302,
    0.564035,
    -0.458684,
    1.907895,
    1.084131,
    0.59069,
    -0.460058,
    1.839482,
    1.055803,
    0.61725,
    -0.459662,
    1.772332,
    1.025103,
    0.643406,
    -0.45726,
    1.707313,
    0.992502,
    0.668794,
    -0.452666,
    1.644722,
    0.957657,
    0.69393,
    -0.446641,
    1.586832,
    0.92134,
    0.718708,
    -0.439121,
    1.531197,
    0.883841,
    0.743469,
    -0.430429,
    1.480765,
    0.844931,
    0.76608,
    -0.419622,
    1.430338,
    0.804786,
    0.789801,
    -0.408368,
    1.386295,
    0.764206,
    0.812718,
    -0.395392,
    1.343758,
    0.722565,
    0.835453,
    -0.380699,
    1.304655,
    0.680585,
    0.858801,
    -0.364834,
    1.269287,
    0.637235,
    0.881537,
    -0.348092,
    1.237493,
    0.594579,
    0.904656,
    -0.331087,
    1.208862,
    0.552313,
    0.926357,
    -0.312966,
    1.182365,
    0.51008,
    0.949001,
    -0.294684,
    1.159452,
    0.468677,
    0.971598,
    -0.275361,
    1.138706,
    0.426723,
    0.994905,
    -0.254947,
    1.120552,
    0.385875,
    1.017981,
    -0.234109,
    1.104215,
    0.345751,
    1.04084,
    -0.21304,
    1.089276,
    0.306762,
    1.063893,
    -0.191616,
    1.075845,
    0.269066,
    1.086907,
    -0.169272,
    1.063788,
    0.232171,
    1.109937,
    -0.146076,
    1.054977,
    0.197826,
    1.130808,
    -0.122544,
    1.048572,
    0.165272,
    1.146831,
    -0.098492,
    1.040742,
    0.13328,
    1.158955,
    -0.07371,
    1.031818,
    0.100262,
    1.166161,
    -0.04861,
    1.020747,
    0.066165,
    1.170491,
    -0.024209,
    1.00938,
    0.032741,
    1.176111,
    1e-5,
    1.000042,
    56e-6,
    202e-6,
    -267e-6,
    2.786357,
    1.320169,
    504e-6,
    -665e-6,
    2.741889,
    1.320168,
    0.002015,
    -0.00266,
    2.74,
    1.320143,
    0.004536,
    -0.005987,
    2.744276,
    1.320161,
    0.008063,
    -0.010644,
    2.743432,
    1.320162,
    0.0126,
    -0.016628,
    2.741741,
    1.320148,
    0.018144,
    -0.023937,
    2.741314,
    1.320127,
    0.024708,
    -0.032577,
    2.741916,
    1.320061,
    0.03229,
    -0.042536,
    2.742132,
    1.319976,
    0.040894,
    -0.053799,
    2.741199,
    1.319861,
    0.050533,
    -0.066361,
    2.740258,
    1.319691,
    0.061223,
    -0.080202,
    2.739045,
    1.319458,
    0.072985,
    -0.095109,
    2.736519,
    1.319138,
    0.085841,
    -0.111296,
    2.733903,
    1.318715,
    0.099808,
    -0.128685,
    2.730944,
    1.318156,
    0.114903,
    -0.147202,
    2.727293,
    1.317424,
    0.131164,
    -0.166575,
    2.722169,
    1.316485,
    0.148599,
    -0.187019,
    2.716148,
    1.315274,
    0.167245,
    -0.20824,
    2.708701,
    1.313733,
    0.187078,
    -0.230151,
    2.698998,
    1.311792,
    0.208153,
    -0.252538,
    2.687341,
    1.309343,
    0.230418,
    -0.275295,
    2.672621,
    1.306247,
    0.253802,
    -0.298066,
    2.653619,
    1.302374,
    0.278261,
    -0.320673,
    2.629943,
    1.297573,
    0.303527,
    -0.342528,
    2.599228,
    1.291625,
    0.329571,
    -0.363531,
    2.562226,
    1.284374,
    0.355939,
    -0.382963,
    2.515491,
    1.275478,
    0.382987,
    -0.401306,
    2.464858,
    1.264866,
    0.409917,
    -0.417455,
    2.404877,
    1.252184,
    0.437015,
    -0.432067,
    2.341408,
    1.237415,
    0.463474,
    -0.444204,
    2.271837,
    1.220687,
    0.489835,
    -0.454631,
    2.200593,
    1.200973,
    0.516054,
    -0.463338,
    2.129733,
    1.179346,
    0.541397,
    -0.469425,
    2.055635,
    1.155039,
    0.566798,
    -0.473526,
    1.980812,
    1.127866,
    0.593114,
    -0.474632,
    1.904723,
    1.097304,
    0.619945,
    -0.473597,
    1.832456,
    1.063603,
    0.646325,
    -0.470656,
    1.761501,
    1.027971,
    0.67232,
    -0.465675,
    1.694248,
    0.990692,
    0.697163,
    -0.458527,
    1.629227,
    0.951582,
    0.721472,
    -0.449904,
    1.568132,
    0.911197,
    0.745855,
    -0.44014,
    1.512084,
    0.869745,
    0.770089,
    -0.429338,
    1.460694,
    0.827648,
    0.792546,
    -0.416701,
    1.410739,
    0.784728,
    0.815161,
    -0.403151,
    1.365438,
    0.741884,
    0.837994,
    -0.388714,
    1.324811,
    0.6978,
    0.86122,
    -0.372573,
    1.287723,
    0.653341,
    0.883737,
    -0.355024,
    1.252491,
    0.609455,
    0.906784,
    -0.337092,
    1.221844,
    0.565275,
    0.928493,
    -0.31837,
    1.192881,
    0.521558,
    0.951495,
    -0.299605,
    1.169131,
    0.478149,
    0.973586,
    -0.280067,
    1.146316,
    0.436325,
    0.9964,
    -0.259823,
    1.12786,
    0.394409,
    1.01978,
    -0.238313,
    1.110521,
    0.353045,
    1.042775,
    -0.216506,
    1.093915,
    0.312803,
    1.066822,
    -0.194695,
    1.080326,
    0.2741,
    1.089869,
    -0.17229,
    1.067722,
    0.236657,
    1.113606,
    -0.149264,
    1.058471,
    0.201603,
    1.134229,
    -0.124814,
    1.050701,
    0.168398,
    1.150922,
    -0.10007,
    1.043051,
    0.135616,
    1.163224,
    -0.075155,
    1.033742,
    0.102144,
    1.169965,
    -0.049933,
    1.021818,
    0.067532,
    1.1742,
    -0.024461,
    1.009916,
    0.033215,
    1.179766,
    188e-6,
    1.000045,
    -14e-6,
    202e-6,
    -281e-6,
    2.964186,
    1.39088,
    505e-6,
    -702e-6,
    2.945157,
    1.390903,
    0.002015,
    -0.002802,
    2.931184,
    1.390863,
    0.004535,
    -0.006307,
    2.935673,
    1.3909,
    0.008063,
    -0.011213,
    2.934274,
    1.39089,
    0.012598,
    -0.017516,
    2.932216,
    1.390876,
    0.018147,
    -0.025221,
    2.933324,
    1.390832,
    0.024711,
    -0.034322,
    2.933945,
    1.390769,
    0.032295,
    -0.04481,
    2.933496,
    1.390674,
    0.040904,
    -0.056673,
    2.932487,
    1.390538,
    0.050555,
    -0.069906,
    2.931571,
    1.390342,
    0.061259,
    -0.084468,
    2.929914,
    1.390064,
    0.073053,
    -0.100152,
    2.927039,
    1.389695,
    0.085948,
    -0.117202,
    2.924241,
    1.389201,
    0.099968,
    -0.135531,
    2.92076,
    1.388548,
    0.115135,
    -0.154906,
    2.915998,
    1.387692,
    0.131496,
    -0.175352,
    2.910285,
    1.386611,
    0.149049,
    -0.196783,
    2.903174,
    1.38519,
    0.167848,
    -0.219066,
    2.894584,
    1.383407,
    0.187879,
    -0.241983,
    2.883171,
    1.381148,
    0.209143,
    -0.265398,
    2.869102,
    1.378261,
    0.231689,
    -0.289254,
    2.852238,
    1.37469,
    0.255223,
    -0.312776,
    2.828264,
    1.370166,
    0.279952,
    -0.33626,
    2.800175,
    1.364591,
    0.305572,
    -0.358865,
    2.764282,
    1.357758,
    0.33165,
    -0.380223,
    2.717845,
    1.349413,
    0.358491,
    -0.400252,
    2.665326,
    1.339084,
    0.385445,
    -0.418422,
    2.602293,
    1.326773,
    0.412947,
    -0.434993,
    2.536973,
    1.312141,
    0.439681,
    -0.448757,
    2.459463,
    1.295205,
    0.467272,
    -0.461427,
    2.38625,
    1.275573,
    0.493568,
    -0.471102,
    2.303225,
    1.2534,
    0.519743,
    -0.47893,
    2.221945,
    1.22889,
    0.544882,
    -0.484098,
    2.136425,
    1.20173,
    0.57069,
    -0.488125,
    2.057093,
    1.172022,
    0.595905,
    -0.489185,
    1.975334,
    1.139312,
    0.622747,
    -0.487535,
    1.895055,
    1.103038,
    0.648695,
    -0.483482,
    1.815995,
    1.064364,
    0.675159,
    -0.478096,
    1.744272,
    1.024098,
    0.700714,
    -0.470492,
    1.675257,
    0.982186,
    0.725641,
    -0.461398,
    1.609135,
    0.939137,
    0.748552,
    -0.449825,
    1.545091,
    0.894791,
    0.772808,
    -0.438185,
    1.489394,
    0.850373,
    0.795928,
    -0.425073,
    1.437026,
    0.805287,
    0.8189,
    -0.411028,
    1.389654,
    0.760003,
    0.841633,
    -0.396047,
    1.345873,
    0.714914,
    0.863213,
    -0.379637,
    1.305185,
    0.669271,
    0.886662,
    -0.362227,
    1.269147,
    0.622935,
    0.908504,
    -0.343068,
    1.234714,
    0.577757,
    0.931425,
    -0.323982,
    1.204997,
    0.532922,
    0.953835,
    -0.304347,
    1.178871,
    0.488154,
    0.975813,
    -0.284219,
    1.155019,
    0.444885,
    0.997662,
    -0.263544,
    1.133941,
    0.402224,
    1.021167,
    -0.242611,
    1.1161,
    0.36053,
    1.044038,
    -0.220065,
    1.098348,
    0.318968,
    1.068837,
    -0.19758,
    1.084605,
    0.279107,
    1.092548,
    -0.174779,
    1.071217,
    0.241111,
    1.116157,
    -0.151596,
    1.060486,
    0.204913,
    1.137486,
    -0.127478,
    1.052751,
    0.17141,
    1.154694,
    -0.101915,
    1.044807,
    0.137999,
    1.166867,
    -0.076246,
    1.034824,
    0.103807,
    1.173715,
    -0.050661,
    1.022501,
    0.068802,
    1.178236,
    -0.025355,
    1.010324,
    0.034155,
    1.183545,
    205e-6,
    1.000059,
    -11e-5,
    201e-6,
    -294e-6,
    3.16108,
    1.466721,
    505e-6,
    -74e-5,
    3.155526,
    1.466737,
    0.002016,
    -0.002957,
    3.152852,
    1.466688,
    0.004537,
    -0.006655,
    3.150654,
    1.466667,
    0.008066,
    -0.011828,
    3.153109,
    1.466694,
    0.012604,
    -0.018479,
    3.152143,
    1.466721,
    0.01815,
    -0.026598,
    3.151025,
    1.466636,
    0.024714,
    -0.036191,
    3.1503,
    1.466562,
    0.032301,
    -0.047249,
    3.149861,
    1.46645,
    0.040924,
    -0.059766,
    3.149548,
    1.466289,
    0.050579,
    -0.073703,
    3.147516,
    1.466055,
    0.061306,
    -0.089022,
    3.14568,
    1.465738,
    0.073135,
    -0.105563,
    3.142428,
    1.465301,
    0.086075,
    -0.123544,
    3.139113,
    1.464715,
    0.100153,
    -0.142853,
    3.135064,
    1.463956,
    0.115411,
    -0.163183,
    3.129509,
    1.462962,
    0.131876,
    -0.18476,
    3.122959,
    1.46167,
    0.14957,
    -0.207172,
    3.114153,
    1.460045,
    0.168523,
    -0.230578,
    3.103626,
    1.457945,
    0.188784,
    -0.254658,
    3.090818,
    1.455279,
    0.210264,
    -0.279114,
    3.073352,
    1.451998,
    0.23303,
    -0.30393,
    3.052592,
    1.44778,
    0.256959,
    -0.328517,
    3.025187,
    1.442568,
    0.281901,
    -0.352755,
    2.990341,
    1.436026,
    0.307728,
    -0.375894,
    2.94682,
    1.427979,
    0.334197,
    -0.397924,
    2.892845,
    1.418249,
    0.360966,
    -0.417914,
    2.827937,
    1.40637,
    0.388478,
    -0.436526,
    2.758006,
    1.392134,
    0.415567,
    -0.452366,
    2.674696,
    1.375244,
    0.443518,
    -0.466917,
    2.595136,
    1.35566,
    0.470631,
    -0.478417,
    2.504173,
    1.333123,
    0.497419,
    -0.487825,
    2.413227,
    1.308181,
    0.523961,
    -0.495064,
    2.321239,
    1.280227,
    0.549708,
    -0.499844,
    2.228911,
    1.249894,
    0.575296,
    -0.502844,
    2.138834,
    1.21713,
    0.600168,
    -0.503368,
    2.04903,
    1.181412,
    0.625874,
    -0.501622,
    1.962267,
    1.142648,
    0.652164,
    -0.496936,
    1.8769,
    1.101268,
    0.678029,
    -0.490319,
    1.796344,
    1.057782,
    0.703248,
    -0.481575,
    1.718925,
    1.012884,
    0.72852,
    -0.471822,
    1.648358,
    0.966487,
    0.752577,
    -0.460134,
    1.581989,
    0.91988,
    0.776163,
    -0.447164,
    1.520109,
    0.873087,
    0.800016,
    -0.433601,
    1.465081,
    0.825803,
    0.822176,
    -0.418388,
    1.412564,
    0.778249,
    0.844873,
    -0.402704,
    1.366184,
    0.730849,
    0.865955,
    -0.385633,
    1.321865,
    0.684037,
    0.888173,
    -0.368255,
    1.283464,
    0.637192,
    0.910994,
    -0.349332,
    1.249215,
    0.590131,
    0.93427,
    -0.329612,
    1.218366,
    0.543213,
    0.956653,
    -0.309228,
    1.189808,
    0.497752,
    0.978476,
    -0.28831,
    1.163674,
    0.452837,
    1.000755,
    -0.267243,
    1.141389,
    0.409481,
    1.023827,
    -0.246015,
    1.122012,
    0.367354,
    1.045572,
    -0.223777,
    1.103303,
    0.325171,
    1.070445,
    -0.200837,
    1.08801,
    0.284442,
    1.094268,
    -0.177211,
    1.07365,
    0.245138,
    1.118639,
    -0.153531,
    1.063051,
    0.208289,
    1.139786,
    -0.129074,
    1.053921,
    0.173607,
    1.157848,
    -0.104051,
    1.045968,
    0.140467,
    1.170697,
    -0.077694,
    1.035782,
    0.105594,
    1.177874,
    -0.051393,
    1.023483,
    0.069898,
    1.182242,
    -0.025392,
    1.01062,
    0.034532,
    1.187612,
    -32e-6,
    1.000062,
    -35e-6,
    202e-6,
    -313e-6,
    3.450327,
    1.548291,
    504e-6,
    -78e-5,
    3.396162,
    1.548289,
    0.002015,
    -0.00312,
    3.395621,
    1.54826,
    0.004533,
    -0.007019,
    3.394299,
    1.548217,
    0.008066,
    -0.012486,
    3.398803,
    1.548274,
    0.0126,
    -0.0195,
    3.396363,
    1.548245,
    0.018151,
    -0.028076,
    3.396805,
    1.548192,
    0.024722,
    -0.038209,
    3.396384,
    1.548109,
    0.032306,
    -0.049868,
    3.395158,
    1.547979,
    0.040936,
    -0.063077,
    3.394303,
    1.547785,
    0.05061,
    -0.077791,
    3.392979,
    1.547513,
    0.06136,
    -0.093869,
    3.38991,
    1.547134,
    0.073227,
    -0.11138,
    3.386669,
    1.546619,
    0.086217,
    -0.130371,
    3.382974,
    1.545938,
    0.100364,
    -0.150684,
    3.378046,
    1.545039,
    0.115733,
    -0.172116,
    3.371719,
    1.54388,
    0.132309,
    -0.194809,
    3.363764,
    1.54238,
    0.150174,
    -0.218431,
    3.353699,
    1.540462,
    0.16934,
    -0.242954,
    3.341397,
    1.538002,
    0.189788,
    -0.268175,
    3.324957,
    1.534894,
    0.211581,
    -0.293776,
    3.304776,
    1.530954,
    0.234561,
    -0.319619,
    3.278192,
    1.526033,
    0.258776,
    -0.345089,
    3.24491,
    1.519926,
    0.284059,
    -0.370176,
    3.203338,
    1.512296,
    0.310312,
    -0.394171,
    3.152477,
    1.502956,
    0.336748,
    -0.416137,
    3.083616,
    1.491463,
    0.364029,
    -0.436752,
    3.010481,
    1.477493,
    0.391575,
    -0.455102,
    2.925454,
    1.460933,
    0.419409,
    -0.471378,
    2.83438,
    1.441554,
    0.446811,
    -0.484714,
    2.733329,
    1.418861,
    0.474489,
    -0.496021,
    2.63363,
    1.393405,
    0.501751,
    -0.504991,
    2.530935,
    1.364633,
    0.528488,
    -0.511392,
    2.426653,
    1.333234,
    0.554428,
    -0.515395,
    2.323633,
    1.299138,
    0.580434,
    -0.517761,
    2.224964,
    1.262462,
    0.605474,
    -0.517598,
    2.127228,
    1.223784,
    0.629888,
    -0.514946,
    2.030545,
    1.182321,
    0.655579,
    -0.510177,
    1.93907,
    1.138515,
    0.68194,
    -0.503097,
    1.852355,
    1.091502,
    0.707228,
    -0.493537,
    1.768084,
    1.043464,
    0.731894,
    -0.482372,
    1.69084,
    0.994242,
    0.756741,
    -0.470312,
    1.619277,
    0.944749,
    0.78016,
    -0.456412,
    1.55343,
    0.894816,
    0.803384,
    -0.441492,
    1.493357,
    0.845202,
    0.826347,
    -0.425944,
    1.43783,
    0.795954,
    0.849145,
    -0.409532,
    1.388578,
    0.746915,
    0.870617,
    -0.391988,
    1.341527,
    0.698025,
    0.892943,
    -0.374229,
    1.302188,
    0.649579,
    0.913828,
    -0.355148,
    1.262877,
    0.601833,
    0.93683,
    -0.335238,
    1.230136,
    0.554521,
    0.958687,
    -0.313939,
    1.199596,
    0.507208,
    0.982008,
    -0.292741,
    1.173619,
    0.461357,
    1.003691,
    -0.27094,
    1.149015,
    0.416031,
    1.027223,
    -0.249102,
    1.128689,
    0.372457,
    1.050048,
    -0.226899,
    1.109444,
    0.330281,
    1.074105,
    -0.204329,
    1.092943,
    0.288987,
    1.098971,
    -0.18056,
    1.078591,
    0.249075,
    1.123324,
    -0.155987,
    1.066885,
    0.211519,
    1.145445,
    -0.130929,
    1.057617,
    0.176506,
    1.162856,
    -0.105269,
    1.048453,
    0.142345,
    1.17536,
    -0.079267,
    1.037439,
    0.107452,
    1.182514,
    -0.052547,
    1.024393,
    0.071252,
    1.186575,
    -0.025744,
    1.011093,
    0.035019,
    1.19205,
    318e-6,
    1.000013,
    -152e-6,
    204e-6,
    -334e-6,
    3.909175,
    1.636412,
    504e-6,
    -825e-6,
    3.678647,
    1.63641,
    0.002015,
    -0.003298,
    3.678315,
    1.636387,
    0.004533,
    -0.007417,
    3.674126,
    1.63631,
    0.008062,
    -0.01319,
    3.676771,
    1.636376,
    0.012603,
    -0.020613,
    3.678135,
    1.636369,
    0.018153,
    -0.029675,
    3.677315,
    1.636299,
    0.024723,
    -0.040378,
    3.676872,
    1.636196,
    0.032318,
    -0.052708,
    3.67575,
    1.636038,
    0.040955,
    -0.06666,
    3.674803,
    1.63581,
    0.050645,
    -0.082203,
    3.672735,
    1.635494,
    0.061429,
    -0.09915,
    3.669047,
    1.635048,
    0.073333,
    -0.117679,
    3.665401,
    1.634437,
    0.086388,
    -0.137725,
    3.661315,
    1.633634,
    0.10062,
    -0.159081,
    3.654992,
    1.632571,
    0.116087,
    -0.181721,
    3.647341,
    1.631202,
    0.13282,
    -0.205611,
    3.637877,
    1.629432,
    0.150867,
    -0.230542,
    3.626333,
    1.627161,
    0.170234,
    -0.256239,
    3.610671,
    1.624266,
    0.190981,
    -0.282751,
    3.591685,
    1.620589,
    0.213013,
    -0.30943,
    3.565864,
    1.615999,
    0.236387,
    -0.336427,
    3.534826,
    1.610216,
    0.260943,
    -0.362931,
    3.493984,
    1.603047,
    0.286497,
    -0.388644,
    3.442075,
    1.59392,
    0.312769,
    -0.412912,
    3.375973,
    1.582961,
    0.339832,
    -0.435635,
    3.299355,
    1.569343,
    0.367214,
    -0.456181,
    3.208994,
    1.553137,
    0.394935,
    -0.474325,
    3.10891,
    1.533791,
    0.422935,
    -0.490318,
    3.001767,
    1.511093,
    0.451166,
    -0.503827,
    2.891735,
    1.485145,
    0.478695,
    -0.514185,
    2.77343,
    1.455617,
    0.506313,
    -0.522502,
    2.657639,
    1.422946,
    0.533427,
    -0.528119,
    2.541132,
    1.387843,
    0.559942,
    -0.53143,
    2.42695,
    1.349542,
    0.58515,
    -0.531978,
    2.312437,
    1.309303,
    0.6105,
    -0.531054,
    2.205966,
    1.26628,
    0.63538,
    -0.528058,
    2.101993,
    1.221709,
    0.659852,
    -0.522751,
    2.00295,
    1.175062,
    0.685151,
    -0.515026,
    1.908647,
    1.125078,
    0.71092,
    -0.50502,
    1.819389,
    1.074296,
    0.736066,
    -0.493268,
    1.735806,
    1.02242,
    0.760503,
    -0.480032,
    1.658607,
    0.97023,
    0.785091,
    -0.465986,
    1.589424,
    0.917077,
    0.807523,
    -0.449721,
    1.522533,
    0.864888,
    0.830974,
    -0.433461,
    1.465416,
    0.813006,
    0.852659,
    -0.415808,
    1.409076,
    0.761689,
    0.874841,
    -0.397855,
    1.360758,
    0.711258,
    0.896322,
    -0.379041,
    1.316829,
    0.661721,
    0.918134,
    -0.360048,
    1.278574,
    0.612263,
    0.939356,
    -0.340108,
    1.2422,
    0.564369,
    0.961025,
    -0.318877,
    1.210305,
    0.516506,
    0.984371,
    -0.29713,
    1.183689,
    0.469342,
    1.006905,
    -0.274661,
    1.157466,
    0.42308,
    1.029941,
    -0.252234,
    1.135066,
    0.378315,
    1.052751,
    -0.229268,
    1.114518,
    0.335169,
    1.077981,
    -0.206662,
    1.09776,
    0.293336,
    1.102542,
    -0.183331,
    1.082051,
    0.252984,
    1.126539,
    -0.158797,
    1.068935,
    0.21499,
    1.149023,
    -0.133014,
    1.058996,
    0.178903,
    1.16755,
    -0.106641,
    1.050245,
    0.144559,
    1.179994,
    -0.079952,
    1.038648,
    0.108667,
    1.187104,
    -0.053316,
    1.025284,
    0.072209,
    1.191406,
    -0.026826,
    1.011453,
    0.035833,
    1.196748,
    226e-6,
    1.000034,
    -61e-6,
    2e-4,
    -346e-6,
    3.996419,
    1.732034,
    504e-6,
    -873e-6,
    4.000138,
    1.732038,
    0.002016,
    -0.003492,
    4.002078,
    1.732012,
    0.004538,
    -0.007859,
    4.005626,
    1.731962,
    0.008064,
    -0.013963,
    3.9985,
    1.731999,
    0.01259,
    -0.021794,
    3.995024,
    1.732004,
    0.018154,
    -0.031406,
    3.999233,
    1.731901,
    0.024727,
    -0.042733,
    3.998497,
    1.731774,
    0.032327,
    -0.055781,
    3.997064,
    1.731599,
    0.040974,
    -0.070543,
    3.995856,
    1.731325,
    0.050685,
    -0.086984,
    3.993839,
    1.730945,
    0.061506,
    -0.104897,
    3.989519,
    1.730417,
    0.073458,
    -0.124506,
    3.985313,
    1.729697,
    0.086573,
    -0.145706,
    3.979984,
    1.728747,
    0.100909,
    -0.168211,
    3.972562,
    1.727491,
    0.116509,
    -0.192198,
    3.963836,
    1.725854,
    0.133404,
    -0.21728,
    3.951919,
    1.723749,
    0.151659,
    -0.243556,
    3.937734,
    1.721093,
    0.171288,
    -0.270611,
    3.919021,
    1.71764,
    0.192301,
    -0.298389,
    3.895171,
    1.713272,
    0.214683,
    -0.326338,
    3.864171,
    1.707825,
    0.238392,
    -0.354394,
    3.824682,
    1.700956,
    0.263151,
    -0.381636,
    3.771168,
    1.692392,
    0.289155,
    -0.408266,
    3.709961,
    1.681769,
    0.315832,
    -0.43307,
    3.630302,
    1.668539,
    0.342942,
    -0.455741,
    3.534719,
    1.652513,
    0.370892,
    -0.476655,
    3.431531,
    1.633428,
    0.398985,
    -0.494692,
    3.314933,
    1.610694,
    0.427206,
    -0.510313,
    3.189741,
    1.58424,
    0.455266,
    -0.52276,
    3.058325,
    1.554195,
    0.483472,
    -0.532872,
    2.927213,
    1.520805,
    0.511192,
    -0.540229,
    2.794112,
    1.484026,
    0.538706,
    -0.545105,
    2.663786,
    1.443796,
    0.565422,
    -0.547251,
    2.534841,
    1.401429,
    0.59127,
    -0.547115,
    2.408437,
    1.356231,
    0.616787,
    -0.545113,
    2.291284,
    1.308887,
    0.64138,
    -0.540853,
    2.177478,
    1.260447,
    0.665344,
    -0.534561,
    2.069265,
    1.210634,
    0.690147,
    -0.527115,
    1.969776,
    1.158569,
    0.714578,
    -0.516171,
    1.870847,
    1.104593,
    0.740349,
    -0.504048,
    1.782674,
    1.049578,
    0.764563,
    -0.489683,
    1.698614,
    0.994458,
    0.78871,
    -0.474541,
    1.624447,
    0.938612,
    0.812154,
    -0.458099,
    1.554453,
    0.883694,
    0.834566,
    -0.440345,
    1.490045,
    0.83022,
    0.857486,
    -0.422491,
    1.432889,
    0.776499,
    0.879224,
    -0.403588,
    1.380669,
    0.724257,
    0.899971,
    -0.383819,
    1.333124,
    0.673311,
    0.922111,
    -0.36425,
    1.292648,
    0.622999,
    0.942842,
    -0.343873,
    1.253933,
    0.573304,
    0.964398,
    -0.323206,
    1.221027,
    0.52509,
    0.98686,
    -0.301711,
    1.191806,
    0.47758,
    1.00976,
    -0.278695,
    1.165162,
    0.430624,
    1.033347,
    -0.255591,
    1.141715,
    0.384482,
    1.055937,
    -0.232039,
    1.119739,
    0.340532,
    1.081178,
    -0.208664,
    1.102117,
    0.297311,
    1.105696,
    -0.184935,
    1.085062,
    0.256227,
    1.129575,
    -0.160673,
    1.070918,
    0.217709,
    1.152135,
    -0.135414,
    1.060642,
    0.181471,
    1.171221,
    -0.108462,
    1.051041,
    0.14638,
    1.184412,
    -0.081008,
    1.039694,
    0.11012,
    1.19182,
    -0.05371,
    1.025903,
    0.073052,
    1.196195,
    -0.026625,
    1.011816,
    0.036129,
    1.201677,
    -175e-6,
    0.999945,
    98e-6,
    196e-6,
    -36e-5,
    4.100786,
    1.83629,
    504e-6,
    -925e-6,
    4.370184,
    1.836295,
    0.002018,
    -0.003706,
    4.385247,
    1.836243,
    0.004534,
    -0.008324,
    4.370146,
    1.83621,
    0.008064,
    -0.014805,
    4.372335,
    1.836256,
    0.012597,
    -0.023116,
    4.359918,
    1.836259,
    0.018158,
    -0.033299,
    4.371503,
    1.836123,
    0.024732,
    -0.045301,
    4.370533,
    1.835988,
    0.032344,
    -0.059143,
    4.369649,
    1.835768,
    0.040999,
    -0.074779,
    4.367861,
    1.835454,
    0.050739,
    -0.092178,
    4.364322,
    1.834974,
    0.061594,
    -0.111161,
    4.359221,
    1.834355,
    0.073604,
    -0.131958,
    4.35462,
    1.833499,
    0.086796,
    -0.154393,
    4.347915,
    1.832355,
    0.101246,
    -0.178201,
    4.339152,
    1.83088,
    0.11699,
    -0.203531,
    4.328327,
    1.828936,
    0.134086,
    -0.230043,
    4.31424,
    1.826442,
    0.152589,
    -0.257718,
    4.296795,
    1.82323,
    0.172514,
    -0.286176,
    4.273985,
    1.819124,
    0.193853,
    -0.315295,
    4.244136,
    1.813909,
    0.216582,
    -0.344507,
    4.205152,
    1.80741,
    0.240668,
    -0.373646,
    4.154781,
    1.799084,
    0.265904,
    -0.401897,
    4.091563,
    1.788905,
    0.292226,
    -0.429136,
    4.013199,
    1.776206,
    0.319045,
    -0.454057,
    3.912886,
    1.7605,
    0.346721,
    -0.477219,
    3.800927,
    1.741586,
    0.374849,
    -0.497883,
    3.675652,
    1.718818,
    0.403078,
    -0.515504,
    3.536892,
    1.692138,
    0.431597,
    -0.530621,
    3.391351,
    1.661434,
    0.460246,
    -0.542852,
    3.242817,
    1.626989,
    0.488899,
    -0.552238,
    3.093685,
    1.588582,
    0.517215,
    -0.559045,
    2.944163,
    1.5463,
    0.54448,
    -0.562351,
    2.794189,
    1.501299,
    0.571542,
    -0.563394,
    2.650239,
    1.453758,
    0.598167,
    -0.56259,
    2.513757,
    1.403321,
    0.624104,
    -0.559636,
    2.384203,
    1.352431,
    0.648789,
    -0.554148,
    2.259149,
    1.298758,
    0.672715,
    -0.546779,
    2.14025,
    1.244943,
    0.696258,
    -0.537896,
    2.030401,
    1.189971,
    0.720048,
    -0.527401,
    1.928311,
    1.134526,
    0.744078,
    -0.514142,
    1.830175,
    1.076504,
    0.768895,
    -0.499352,
    1.740731,
    1.018032,
    0.792551,
    -0.482982,
    1.658911,
    0.96025,
    0.817007,
    -0.466406,
    1.586579,
    0.903029,
    0.839035,
    -0.447616,
    1.516969,
    0.846484,
    0.862742,
    -0.429261,
    1.458675,
    0.79142,
    0.884307,
    -0.409479,
    1.402989,
    0.737125,
    0.905641,
    -0.389303,
    1.352817,
    0.683912,
    0.926185,
    -0.368344,
    1.306684,
    0.63269,
    0.947229,
    -0.347366,
    1.267395,
    0.581739,
    0.969502,
    -0.32672,
    1.233192,
    0.532305,
    0.990758,
    -0.304973,
    1.201017,
    0.484166,
    1.012749,
    -0.282816,
    1.173018,
    0.437385,
    1.035533,
    -0.259084,
    1.147184,
    0.390755,
    1.059915,
    -0.235239,
    1.125388,
    0.345399,
    1.084348,
    -0.211044,
    1.105859,
    0.301356,
    1.109544,
    -0.186698,
    1.088888,
    0.259708,
    1.13377,
    -0.1619,
    1.073848,
    0.220324,
    1.157553,
    -0.136604,
    1.06319,
    0.183857,
    1.176461,
    -0.110428,
    1.05311,
    0.148521,
    1.190137,
    -0.082898,
    1.041484,
    0.112124,
    1.197215,
    -0.054554,
    1.026844,
    0.07416,
    1.201654,
    -0.026744,
    1.012264,
    0.036527,
    1.207085,
    399e-6,
    1.000034,
    -201e-6,
    191e-6,
    -373e-6,
    4.194318,
    1.950551,
    504e-6,
    -983e-6,
    4.80435,
    1.950552,
    0.002015,
    -0.003931,
    4.80282,
    1.950518,
    0.004536,
    -0.008847,
    4.805254,
    1.950472,
    0.008064,
    -0.015725,
    4.804152,
    1.950517,
    0.012693,
    -0.02474,
    4.826828,
    1.949914,
    0.018159,
    -0.035365,
    4.803103,
    1.950349,
    0.02474,
    -0.048122,
    4.80322,
    1.950183,
    0.032361,
    -0.062822,
    4.801522,
    1.949917,
    0.041034,
    -0.07943,
    4.799593,
    1.949538,
    0.050815,
    -0.097841,
    4.797179,
    1.948972,
    0.061702,
    -0.118026,
    4.789557,
    1.948246,
    0.073766,
    -0.140112,
    4.783293,
    1.947204,
    0.087066,
    -0.163819,
    4.775698,
    1.945855,
    0.101637,
    -0.189122,
    4.764612,
    1.944052,
    0.117558,
    -0.215884,
    4.751486,
    1.94171,
    0.134884,
    -0.243968,
    4.734791,
    1.938727,
    0.153637,
    -0.27317,
    4.712078,
    1.934891,
    0.17389,
    -0.303146,
    4.683575,
    1.929976,
    0.195643,
    -0.333704,
    4.646766,
    1.92374,
    0.218767,
    -0.36417,
    4.596814,
    1.915888,
    0.243337,
    -0.39453,
    4.535509,
    1.90597,
    0.26886,
    -0.423512,
    4.452006,
    1.893623,
    0.295173,
    -0.450609,
    4.345682,
    1.878286,
    0.322784,
    -0.476488,
    4.231632,
    1.859391,
    0.350616,
    -0.49942,
    4.093553,
    1.836912,
    0.379127,
    -0.519862,
    3.944127,
    1.809625,
    0.40786,
    -0.537373,
    3.782223,
    1.778529,
    0.436717,
    -0.551802,
    3.615563,
    1.742684,
    0.465345,
    -0.562951,
    3.440672,
    1.702289,
    0.494158,
    -0.571334,
    3.26807,
    1.658666,
    0.522896,
    -0.577227,
    3.100668,
    1.611027,
    0.551379,
    -0.580514,
    2.937615,
    1.559742,
    0.578992,
    -0.58061,
    2.778703,
    1.507257,
    0.605095,
    -0.577729,
    2.621626,
    1.451941,
    0.630653,
    -0.573,
    2.476506,
    1.395218,
    0.656175,
    -0.566944,
    2.341592,
    1.337862,
    0.681036,
    -0.558988,
    2.216478,
    1.279275,
    0.704713,
    -0.549211,
    2.096972,
    1.220526,
    0.726894,
    -0.53719,
    1.983311,
    1.161709,
    0.749865,
    -0.524167,
    1.8811,
    1.102095,
    0.773553,
    -0.508991,
    1.785637,
    1.042039,
    0.797102,
    -0.491658,
    1.697234,
    0.981588,
    0.821187,
    -0.474093,
    1.62025,
    0.921265,
    0.843848,
    -0.45498,
    1.547071,
    0.862757,
    0.866662,
    -0.435421,
    1.482008,
    0.8047,
    0.888696,
    -0.41499,
    1.424116,
    0.749432,
    0.910945,
    -0.394472,
    1.372658,
    0.694767,
    0.9323,
    -0.373239,
    1.325157,
    0.641106,
    0.95285,
    -0.351347,
    1.282217,
    0.589689,
    0.974718,
    -0.329809,
    1.244897,
    0.539322,
    0.996445,
    -0.307902,
    1.212306,
    0.490083,
    1.01758,
    -0.285392,
    1.181402,
    0.442702,
    1.040342,
    -0.262782,
    1.155996,
    0.395911,
    1.064399,
    -0.238995,
    1.131708,
    0.350206,
    1.089464,
    -0.214297,
    1.111215,
    0.305175,
    1.115565,
    -0.189293,
    1.093094,
    0.262686,
    1.14064,
    -0.163843,
    1.077994,
    0.223078,
    1.163824,
    -0.137789,
    1.066014,
    0.185651,
    1.182577,
    -0.111087,
    1.055615,
    0.150045,
    1.195775,
    -0.083945,
    1.04294,
    0.113457,
    1.203175,
    -0.056145,
    1.028015,
    0.075453,
    1.207282,
    -0.027685,
    1.012552,
    0.037217,
    1.213019,
    362e-6,
    0.999938,
    -293e-6,
    187e-6,
    -388e-6,
    4.316009,
    2.0765,
    504e-6,
    -0.001048,
    5.317799,
    2.076499,
    0.002014,
    -0.004182,
    5.306557,
    2.076523,
    0.004539,
    -0.009425,
    5.317505,
    2.076453,
    0.008063,
    -0.016737,
    5.312143,
    2.07641,
    0.012614,
    -0.026171,
    5.316434,
    2.076389,
    0.018158,
    -0.037641,
    5.307836,
    2.076265,
    0.024767,
    -0.051266,
    5.315297,
    2.076044,
    0.032372,
    -0.066859,
    5.307433,
    2.075743,
    0.041066,
    -0.084538,
    5.304809,
    2.07527,
    0.050871,
    -0.104062,
    5.299277,
    2.074622,
    0.061821,
    -0.125613,
    5.293419,
    2.073708,
    0.07397,
    -0.149085,
    5.286629,
    2.072457,
    0.087375,
    -0.174214,
    5.275937,
    2.070804,
    0.102105,
    -0.201136,
    5.263267,
    2.068647,
    0.118223,
    -0.229505,
    5.246309,
    2.065846,
    0.135814,
    -0.259217,
    5.225496,
    2.062189,
    0.154887,
    -0.28999,
    5.19658,
    2.057566,
    0.17551,
    -0.321618,
    5.160716,
    2.051593,
    0.197636,
    -0.353632,
    5.112202,
    2.043949,
    0.221168,
    -0.385303,
    5.046981,
    2.034445,
    0.246099,
    -0.416511,
    4.965386,
    2.022368,
    0.27207,
    -0.446377,
    4.860735,
    2.00716,
    0.29909,
    -0.474279,
    4.73514,
    1.988598,
    0.326702,
    -0.499809,
    4.584962,
    1.965865,
    0.355017,
    -0.52279,
    4.420447,
    1.938705,
    0.383856,
    -0.542755,
    4.241942,
    1.90637,
    0.413059,
    -0.559903,
    4.053302,
    1.869455,
    0.441882,
    -0.573174,
    3.852753,
    1.827946,
    0.471516,
    -0.584151,
    3.660377,
    1.781652,
    0.500872,
    -0.591843,
    3.466027,
    1.730885,
    0.529677,
    -0.596253,
    3.272812,
    1.676821,
    0.557683,
    -0.597604,
    3.084286,
    1.620064,
    0.585652,
    -0.596591,
    2.906111,
    1.560909,
    0.612819,
    -0.593138,
    2.738258,
    1.500318,
    0.639848,
    -0.588245,
    2.584172,
    1.438127,
    0.664758,
    -0.58014,
    2.430697,
    1.375746,
    0.688754,
    -0.570189,
    2.290701,
    1.312727,
    0.712848,
    -0.55942,
    2.162679,
    1.250063,
    0.735111,
    -0.54657,
    2.042186,
    1.18784,
    0.757521,
    -0.532944,
    1.933435,
    1.125513,
    0.780056,
    -0.517981,
    1.833524,
    1.063827,
    0.802513,
    -0.500724,
    1.739053,
    1.002154,
    0.825462,
    -0.481625,
    1.652381,
    0.939811,
    0.848973,
    -0.462327,
    1.57756,
    0.878279,
    0.871521,
    -0.441928,
    1.509291,
    0.8192,
    0.892325,
    -0.420297,
    1.443799,
    0.761607,
    0.914935,
    -0.399072,
    1.389647,
    0.705351,
    0.936429,
    -0.377232,
    1.339903,
    0.650213,
    0.957614,
    -0.355091,
    1.295467,
    0.597773,
    0.979578,
    -0.332767,
    1.256692,
    0.545914,
    1.00086,
    -0.310147,
    1.221666,
    0.495661,
    1.02255,
    -0.287395,
    1.190775,
    0.448026,
    1.045005,
    -0.264582,
    1.162641,
    0.40049,
    1.068703,
    -0.241464,
    1.138358,
    0.354088,
    1.093098,
    -0.217504,
    1.115973,
    0.309812,
    1.11923,
    -0.19214,
    1.096284,
    0.266297,
    1.144608,
    -0.165975,
    1.080042,
    0.225831,
    1.168599,
    -0.139174,
    1.067749,
    0.187761,
    1.18797,
    -0.11191,
    1.056635,
    0.151322,
    1.20124,
    -0.083978,
    1.043566,
    0.114337,
    1.208895,
    -0.056089,
    1.028366,
    0.076083,
    1.213344,
    -0.028369,
    1.013074,
    0.037735,
    1.21922,
    -534e-6,
    0.999968,
    76e-6,
    182e-6,
    -404e-6,
    4.433519,
    2.216201,
    504e-6,
    -0.001117,
    5.911693,
    2.216198,
    0.002017,
    -0.004469,
    5.919142,
    2.21619,
    0.004536,
    -0.010051,
    5.913172,
    2.21613,
    0.008065,
    -0.017867,
    5.911791,
    2.216145,
    0.012467,
    -0.027603,
    5.785357,
    2.216447,
    0.018156,
    -0.040159,
    5.901121,
    2.215958,
    0.024758,
    -0.05467,
    5.908781,
    2.215654,
    0.032395,
    -0.071352,
    5.906098,
    2.215283,
    0.041108,
    -0.090201,
    5.902558,
    2.214715,
    0.050955,
    -0.111004,
    5.895707,
    2.213905,
    0.061968,
    -0.134002,
    5.888736,
    2.212807,
    0.074206,
    -0.159038,
    5.880633,
    2.211303,
    0.087742,
    -0.185801,
    5.867001,
    2.209297,
    0.102652,
    -0.214368,
    5.851446,
    2.206657,
    0.119006,
    -0.244573,
    5.830722,
    2.203232,
    0.136883,
    -0.276067,
    5.802688,
    2.198778,
    0.156335,
    -0.30866,
    5.767185,
    2.193091,
    0.177396,
    -0.34194,
    5.719726,
    2.185858,
    0.20007,
    -0.375591,
    5.658792,
    2.176584,
    0.224067,
    -0.408564,
    5.573508,
    2.164759,
    0.24942,
    -0.440668,
    5.465696,
    2.149777,
    0.275879,
    -0.471138,
    5.332207,
    2.131225,
    0.303307,
    -0.499204,
    5.173339,
    2.108794,
    0.331189,
    -0.524547,
    4.985102,
    2.080585,
    0.359932,
    -0.547256,
    4.785788,
    2.047792,
    0.389063,
    -0.566479,
    4.569344,
    2.009518,
    0.418725,
    -0.583031,
    4.349557,
    1.965601,
    0.448181,
    -0.595809,
    4.121278,
    1.916911,
    0.477703,
    -0.605102,
    3.892291,
    1.86353,
    0.507999,
    -0.612462,
    3.676557,
    1.806286,
    0.536889,
    -0.615451,
    3.456241,
    1.745841,
    0.565778,
    -0.616029,
    3.249464,
    1.681137,
    0.593863,
    -0.613644,
    3.050273,
    1.615238,
    0.62077,
    -0.608268,
    2.859599,
    1.548003,
    0.647171,
    -0.601116,
    2.683287,
    1.480447,
    0.673458,
    -0.59284,
    2.524036,
    1.412084,
    0.698064,
    -0.581973,
    2.371046,
    1.34513,
    0.721011,
    -0.568963,
    2.229104,
    1.27844,
    0.744293,
    -0.555642,
    2.103213,
    1.212448,
    0.766314,
    -0.540934,
    1.98537,
    1.146287,
    0.788164,
    -0.525271,
    1.878842,
    1.0826,
    0.809019,
    -0.507986,
    1.779821,
    1.019978,
    0.830947,
    -0.489717,
    1.69163,
    0.956931,
    0.853732,
    -0.469345,
    1.607513,
    0.894207,
    0.874904,
    -0.447618,
    1.531176,
    0.833436,
    0.897289,
    -0.426124,
    1.467302,
    0.773611,
    0.919226,
    -0.404025,
    1.408321,
    0.716016,
    0.94086,
    -0.381454,
    1.356209,
    0.659515,
    0.962764,
    -0.358901,
    1.310082,
    0.604629,
    0.984322,
    -0.335983,
    1.268485,
    0.552335,
    1.005343,
    -0.312533,
    1.230662,
    0.501591,
    1.028153,
    -0.289452,
    1.199168,
    0.452032,
    1.049283,
    -0.265754,
    1.168575,
    0.404347,
    1.073687,
    -0.242571,
    1.143533,
    0.357445,
    1.097546,
    -0.218681,
    1.119859,
    0.312534,
    1.12334,
    -0.194465,
    1.099634,
    0.269437,
    1.148166,
    -0.168797,
    1.081968,
    0.228586,
    1.172518,
    -0.141552,
    1.068789,
    0.189866,
    1.19293,
    -0.113325,
    1.057548,
    0.152772,
    1.206816,
    -0.0848,
    1.044145,
    0.11539,
    1.215045,
    -0.056019,
    1.028938,
    0.076493,
    1.220048,
    -0.027733,
    1.013338,
    0.037767,
    1.225852,
    5e-5,
    0.999927,
    -16e-5,
    178e-6,
    -422e-6,
    4.587902,
    2.372253,
    504e-6,
    -0.001195,
    6.624675,
    2.372248,
    0.002016,
    -0.004782,
    6.626884,
    2.372187,
    0.004531,
    -0.010746,
    6.607379,
    2.372318,
    0.008081,
    -0.019161,
    6.640102,
    2.372084,
    0.012637,
    -0.029945,
    6.653708,
    2.372128,
    0.018167,
    -0.042999,
    6.623837,
    2.371902,
    0.024769,
    -0.058516,
    6.624484,
    2.371595,
    0.032421,
    -0.07637,
    6.620877,
    2.37112,
    0.041164,
    -0.096474,
    6.615235,
    2.370428,
    0.051057,
    -0.118786,
    6.607844,
    2.36944,
    0.062136,
    -0.14339,
    6.599216,
    2.368075,
    0.07449,
    -0.170034,
    6.588018,
    2.366218,
    0.088179,
    -0.198717,
    6.572526,
    2.363747,
    0.103307,
    -0.229147,
    6.551868,
    2.360517,
    0.119964,
    -0.261253,
    6.526089,
    2.356304,
    0.138173,
    -0.294703,
    6.489593,
    2.350797,
    0.158072,
    -0.329261,
    6.443573,
    2.343783,
    0.179592,
    -0.364298,
    6.379764,
    2.334673,
    0.202709,
    -0.399375,
    6.295845,
    2.323125,
    0.227335,
    -0.433616,
    6.184929,
    2.308547,
    0.25323,
    -0.466794,
    6.045905,
    2.28998,
    0.2801,
    -0.497509,
    5.871803,
    2.266964,
    0.308146,
    -0.525956,
    5.672422,
    2.239074,
    0.336544,
    -0.551101,
    5.443256,
    2.204809,
    0.365223,
    -0.572471,
    5.188034,
    2.164827,
    0.395484,
    -0.592088,
    4.943783,
    2.119489,
    0.424416,
    -0.606026,
    4.6664,
    2.067262,
    0.455641,
    -0.619671,
    4.418961,
    2.009937,
    0.485298,
    -0.627583,
    4.152737,
    1.9489,
    0.514774,
    -0.632072,
    3.893344,
    1.882692,
    0.544172,
    -0.634033,
    3.645332,
    1.814073,
    0.573283,
    -0.633239,
    3.414651,
    1.742717,
    0.602155,
    -0.630008,
    3.195712,
    1.669703,
    0.63052,
    -0.62455,
    2.994536,
    1.596021,
    0.657121,
    -0.615749,
    2.799373,
    1.522572,
    0.682071,
    -0.604738,
    2.616102,
    1.448978,
    0.707605,
    -0.593301,
    2.456112,
    1.37625,
    0.731492,
    -0.579628,
    2.303517,
    1.305297,
    0.754139,
    -0.564473,
    2.16534,
    1.235548,
    0.776505,
    -0.548787,
    2.041646,
    1.167051,
    0.796833,
    -0.531415,
    1.923334,
    1.100534,
    0.817565,
    -0.513778,
    1.818176,
    1.035144,
    0.837981,
    -0.495167,
    1.72383,
    0.971583,
    0.858513,
    -0.47569,
    1.638448,
    0.908841,
    0.879892,
    -0.454099,
    1.55942,
    0.846701,
    0.902258,
    -0.432038,
    1.491471,
    0.785332,
    0.924114,
    -0.409316,
    1.428878,
    0.726409,
    0.94423,
    -0.385618,
    1.370785,
    0.668588,
    0.967001,
    -0.362604,
    1.323529,
    0.612943,
    0.988579,
    -0.339117,
    1.279679,
    0.559038,
    1.01021,
    -0.315355,
    1.240104,
    0.506867,
    1.032084,
    -0.291408,
    1.205261,
    0.456934,
    1.054671,
    -0.267387,
    1.175197,
    0.407792,
    1.078314,
    -0.243346,
    1.148153,
    0.360992,
    1.102443,
    -0.219205,
    1.123799,
    0.315577,
    1.128524,
    -0.194996,
    1.102624,
    0.271742,
    1.153989,
    -0.169897,
    1.085134,
    0.230702,
    1.17942,
    -0.14396,
    1.071699,
    0.192146,
    1.200098,
    -0.116173,
    1.060179,
    0.155164,
    1.214837,
    -0.086655,
    1.04629,
    0.117071,
    1.222749,
    -0.056956,
    1.03004,
    0.07745,
    1.227273,
    -0.027883,
    1.01365,
    0.038092,
    1.233293,
    831e-6,
    1.000043,
    -462e-6,
    173e-6,
    -442e-6,
    4.741539,
    2.547922,
    504e-6,
    -0.001284,
    7.491127,
    2.547919,
    0.002014,
    -0.005132,
    7.484889,
    2.547844,
    0.004523,
    -0.011521,
    7.439875,
    2.547587,
    0.008059,
    -0.020524,
    7.483694,
    2.547725,
    0.012586,
    -0.032029,
    7.470912,
    2.547685,
    0.018081,
    -0.045948,
    7.422534,
    2.547686,
    0.024783,
    -0.062844,
    7.487581,
    2.547107,
    0.032451,
    -0.082011,
    7.483603,
    2.546522,
    0.041233,
    -0.10354,
    7.475124,
    2.545684,
    0.051181,
    -0.127537,
    7.467521,
    2.544438,
    0.062347,
    -0.153921,
    7.456266,
    2.542744,
    0.074829,
    -0.182427,
    7.440422,
    2.540459,
    0.088703,
    -0.213134,
    7.420694,
    2.53738,
    0.10408,
    -0.24575,
    7.394875,
    2.533347,
    0.12105,
    -0.279941,
    7.358515,
    2.528069,
    0.139697,
    -0.315591,
    7.313001,
    2.521237,
    0.160036,
    -0.35198,
    7.246342,
    2.512378,
    0.182147,
    -0.388993,
    7.163688,
    2.500993,
    0.205799,
    -0.42557,
    7.048339,
    2.48645,
    0.231091,
    -0.461093,
    6.902586,
    2.468174,
    0.257405,
    -0.494668,
    6.712721,
    2.444774,
    0.284956,
    -0.525889,
    6.491261,
    2.415538,
    0.31318,
    -0.553693,
    6.232833,
    2.38061,
    0.342327,
    -0.578724,
    5.953834,
    2.338525,
    0.371689,
    -0.599706,
    5.649698,
    2.290256,
    0.401919,
    -0.617615,
    5.3479,
    2.235157,
    0.432204,
    -0.631632,
    5.036417,
    2.173932,
    0.463151,
    -0.643082,
    4.735976,
    2.107298,
    0.493388,
    -0.64997,
    4.432044,
    2.036121,
    0.524128,
    -0.654188,
    4.145472,
    1.961595,
    0.55393,
    -0.654671,
    3.866877,
    1.883602,
    0.583856,
    -0.653051,
    3.607848,
    1.804521,
    0.611762,
    -0.646994,
    3.356237,
    1.724047,
    0.639117,
    -0.63886,
    3.122531,
    1.643016,
    0.666279,
    -0.629093,
    2.913178,
    1.563932,
    0.692936,
    -0.617862,
    2.722675,
    1.484614,
    0.716498,
    -0.603279,
    2.536926,
    1.406734,
    0.742273,
    -0.589878,
    2.381054,
    1.331469,
    0.764031,
    -0.572744,
    2.228312,
    1.256796,
    0.786601,
    -0.555933,
    2.095451,
    1.18529,
    0.807776,
    -0.537992,
    1.972866,
    1.11594,
    0.8284,
    -0.519596,
    1.863394,
    1.048371,
    0.847412,
    -0.499847,
    1.76063,
    0.982934,
    0.86685,
    -0.47992,
    1.670998,
    0.919972,
    0.88634,
    -0.459434,
    1.587962,
    0.8581,
    0.906933,
    -0.437767,
    1.515505,
    0.796714,
    0.92749,
    -0.414068,
    1.448243,
    0.736162,
    0.950217,
    -0.39091,
    1.390505,
    0.677613,
    0.971545,
    -0.366964,
    1.337865,
    0.620477,
    0.992901,
    -0.342603,
    1.291104,
    0.565807,
    1.01546,
    -0.318596,
    1.251138,
    0.513086,
    1.037859,
    -0.294242,
    1.214291,
    0.461573,
    1.060535,
    -0.269601,
    1.182517,
    0.411838,
    1.086885,
    -0.245608,
    1.1553,
    0.363221,
    1.111237,
    -0.220589,
    1.129715,
    0.317174,
    1.138718,
    -0.196008,
    1.108103,
    0.273213,
    1.164223,
    -0.170408,
    1.08964,
    0.231968,
    1.187256,
    -0.144205,
    1.074145,
    0.192987,
    1.207851,
    -0.116945,
    1.061615,
    0.156118,
    1.222217,
    -0.088852,
    1.047599,
    0.118674,
    1.230315,
    -0.059381,
    1.030869,
    0.078993,
    1.235052,
    -0.029145,
    1.014126,
    0.038924,
    1.241359,
    479e-6,
    1.000114,
    -211e-6,
    169e-6,
    -465e-6,
    4.953966,
    2.747437,
    504e-6,
    -0.001384,
    8.54453,
    2.74743,
    0.002015,
    -0.005537,
    8.545147,
    2.747339,
    0.004542,
    -0.012477,
    8.557734,
    2.747125,
    0.008064,
    -0.022143,
    8.530193,
    2.747341,
    0.012543,
    -0.034411,
    8.465151,
    2.747411,
    0.018178,
    -0.049792,
    8.543328,
    2.746874,
    0.02481,
    -0.067784,
    8.547247,
    2.746396,
    0.032489,
    -0.088416,
    8.537436,
    2.74573,
    0.041313,
    -0.11158,
    8.526655,
    2.744596,
    0.051332,
    -0.137462,
    8.517438,
    2.743082,
    0.062603,
    -0.16586,
    8.502803,
    2.74095,
    0.07524,
    -0.196548,
    8.481507,
    2.738057,
    0.089341,
    -0.22944,
    8.454287,
    2.734174,
    0.105021,
    -0.264395,
    8.420289,
    2.729086,
    0.122399,
    -0.30102,
    8.373503,
    2.72242,
    0.141526,
    -0.338997,
    8.309059,
    2.713686,
    0.162451,
    -0.377589,
    8.221539,
    2.702492,
    0.185098,
    -0.416349,
    8.100116,
    2.687893,
    0.209406,
    -0.454284,
    7.941704,
    2.669386,
    0.235098,
    -0.49045,
    7.733318,
    2.64559,
    0.2621,
    -0.524592,
    7.48612,
    2.615709,
    0.290103,
    -0.555558,
    7.193498,
    2.579231,
    0.319135,
    -0.583516,
    6.874796,
    2.534957,
    0.348286,
    -0.606714,
    6.516118,
    2.483017,
    0.37884,
    -0.62785,
    6.163912,
    2.424214,
    0.409608,
    -0.644715,
    5.801404,
    2.357563,
    0.440553,
    -0.657657,
    5.435955,
    2.285835,
    0.470599,
    -0.665621,
    5.063481,
    2.20794,
    0.503172,
    -0.673767,
    4.743532,
    2.12644,
    0.533884,
    -0.676009,
    4.413409,
    2.040694,
    0.563808,
    -0.674536,
    4.092169,
    1.953979,
    0.591849,
    -0.668913,
    3.787057,
    1.865897,
    0.621474,
    -0.663159,
    3.520578,
    1.777762,
    0.6505,
    -0.655018,
    3.275065,
    1.689902,
    0.678011,
    -0.643949,
    3.043141,
    1.603528,
    0.70349,
    -0.63003,
    2.827104,
    1.519484,
    0.72825,
    -0.61491,
    2.63262,
    1.436677,
    0.752165,
    -0.598649,
    2.45557,
    1.355753,
    0.775894,
    -0.581771,
    2.295932,
    1.278884,
    0.79765,
    -0.563193,
    2.152291,
    1.202767,
    0.818505,
    -0.54375,
    2.022099,
    1.130338,
    0.838596,
    -0.524017,
    1.903562,
    1.060263,
    0.858396,
    -0.504064,
    1.797204,
    0.993077,
    0.877088,
    -0.483418,
    1.701208,
    0.928606,
    0.896606,
    -0.462786,
    1.617736,
    0.866039,
    0.914342,
    -0.440943,
    1.539227,
    0.804293,
    0.93355,
    -0.419129,
    1.470383,
    0.745206,
    0.955237,
    -0.3961,
    1.4091,
    0.685832,
    0.9767,
    -0.371743,
    1.35493,
    0.627953,
    0.997681,
    -0.346882,
    1.305249,
    0.572127,
    1.020784,
    -0.322391,
    1.262603,
    0.517941,
    1.04384,
    -0.297564,
    1.225115,
    0.466188,
    1.067224,
    -0.272639,
    1.190817,
    0.415499,
    1.092358,
    -0.247664,
    1.161265,
    0.366782,
    1.117573,
    -0.22226,
    1.133935,
    0.319377,
    1.14573,
    -0.196933,
    1.11175,
    0.275293,
    1.170822,
    -0.170577,
    1.091981,
    0.233306,
    1.194559,
    -0.143878,
    1.07581,
    0.19395,
    1.214819,
    -0.116347,
    1.062438,
    0.156724,
    1.22983,
    -0.088233,
    1.048092,
    0.118984,
    1.238185,
    -0.059408,
    1.031325,
    0.079385,
    1.243527,
    -0.030703,
    1.014698,
    0.039893,
    1.249724,
    -0.00152,
    0.999819,
    76e-5,
    164e-6,
    -489e-6,
    5.157359,
    2.9763,
    505e-6,
    -0.001502,
    9.891415,
    2.976286,
    0.002016,
    -0.006,
    9.85773,
    2.976197,
    0.004543,
    -0.013519,
    9.870651,
    2.975832,
    0.008064,
    -0.023985,
    9.85578,
    2.97617,
    0.012611,
    -0.037471,
    9.850209,
    2.975941,
    0.018162,
    -0.053866,
    9.827134,
    2.974968,
    0.02482,
    -0.07339,
    9.849955,
    2.97501,
    0.032545,
    -0.095758,
    9.842021,
    2.974073,
    0.041418,
    -0.120834,
    9.829989,
    2.9727,
    0.051511,
    -0.148861,
    9.817421,
    2.970736,
    0.06292,
    -0.179456,
    9.797347,
    2.968033,
    0.075744,
    -0.212674,
    9.771533,
    2.964371,
    0.090131,
    -0.248193,
    9.735924,
    2.959437,
    0.106187,
    -0.285748,
    9.687707,
    2.952881,
    0.124035,
    -0.325017,
    9.622684,
    2.944273,
    0.143733,
    -0.365463,
    9.531452,
    2.933093,
    0.165262,
    -0.406157,
    9.401732,
    2.918484,
    0.188622,
    -0.446833,
    9.232451,
    2.899529,
    0.213693,
    -0.486209,
    9.013432,
    2.875137,
    0.239987,
    -0.522925,
    8.725671,
    2.844166,
    0.267796,
    -0.557452,
    8.400028,
    2.805649,
    0.296547,
    -0.588266,
    8.023041,
    2.75872,
    0.325838,
    -0.614837,
    7.606773,
    2.702676,
    0.355479,
    -0.63676,
    7.16068,
    2.638483,
    0.386984,
    -0.65723,
    6.736765,
    2.566849,
    0.418853,
    -0.673592,
    6.313742,
    2.488091,
    0.450302,
    -0.684966,
    5.884479,
    2.402458,
    0.481149,
    -0.691591,
    5.455771,
    2.311816,
    0.512177,
    -0.695337,
    5.055698,
    2.21733,
    0.543437,
    -0.69637,
    4.681506,
    2.121285,
    0.574309,
    -0.694186,
    4.334716,
    2.02416,
    0.604787,
    -0.689158,
    4.008524,
    1.927738,
    0.633483,
    -0.68058,
    3.703505,
    1.830456,
    0.660766,
    -0.669088,
    3.418386,
    1.734934,
    0.688471,
    -0.656673,
    3.168101,
    1.642316,
    0.715729,
    -0.64282,
    2.941735,
    1.550744,
    0.740435,
    -0.626155,
    2.73057,
    1.463345,
    0.764114,
    -0.608299,
    2.537561,
    1.378151,
    0.787028,
    -0.589519,
    2.364323,
    1.29763,
    0.807985,
    -0.569257,
    2.20797,
    1.21783,
    0.830663,
    -0.550055,
    2.076646,
    1.142746,
    0.850416,
    -0.528812,
    1.948085,
    1.070757,
    0.869609,
    -0.507478,
    1.834684,
    1.001282,
    0.888324,
    -0.486131,
    1.734879,
    0.934987,
    0.907482,
    -0.46491,
    1.645974,
    0.871203,
    0.924829,
    -0.442742,
    1.56355,
    0.80926,
    0.942958,
    -0.420777,
    1.491264,
    0.750037,
    0.961999,
    -0.398842,
    1.428069,
    0.691715,
    0.981043,
    -0.375967,
    1.369668,
    0.635669,
    1.002371,
    -0.351469,
    1.318588,
    0.578689,
    1.025343,
    -0.326601,
    1.273628,
    0.524424,
    1.048511,
    -0.301395,
    1.234572,
    0.471403,
    1.072242,
    -0.275835,
    1.198354,
    0.41995,
    1.096758,
    -0.2502,
    1.166392,
    0.370733,
    1.122781,
    -0.224474,
    1.138991,
    0.322864,
    1.150871,
    -0.198592,
    1.114313,
    0.277723,
    1.177319,
    -0.171805,
    1.093534,
    0.23495,
    1.201765,
    -0.144291,
    1.077462,
    0.195376,
    1.222629,
    -0.115949,
    1.063288,
    0.157315,
    1.237334,
    -0.08714,
    1.048366,
    0.118843,
    1.246153,
    -0.058094,
    1.031224,
    0.079207,
    1.25257,
    -0.029194,
    1.014695,
    0.039376,
    1.25906,
    -418e-6,
    0.999881,
    307e-6,
    159e-6,
    -515e-6,
    5.393984,
    3.241865,
    505e-6,
    -0.001636,
    11.548038,
    3.241848,
    0.002016,
    -0.006534,
    11.50664,
    3.241718,
    0.004537,
    -0.014706,
    11.51346,
    3.241196,
    0.008068,
    -0.026134,
    11.510533,
    3.241693,
    0.012573,
    -0.040676,
    11.428978,
    3.24103,
    0.018212,
    -0.058794,
    11.510745,
    3.240924,
    0.024847,
    -0.079926,
    11.497339,
    3.240201,
    0.032603,
    -0.10416,
    11.484607,
    3.238994,
    0.041543,
    -0.131552,
    11.470801,
    3.237182,
    0.051738,
    -0.162012,
    11.453219,
    3.234635,
    0.063313,
    -0.19526,
    11.427244,
    3.231153,
    0.076381,
    -0.231205,
    11.388534,
    3.226361,
    0.091096,
    -0.269678,
    11.340406,
    3.219943,
    0.1076,
    -0.31017,
    11.270127,
    3.211448,
    0.126017,
    -0.352435,
    11.178583,
    3.200168,
    0.146411,
    -0.395551,
    11.046559,
    3.185328,
    0.168663,
    -0.438627,
    10.858624,
    3.165972,
    0.19273,
    -0.48066,
    10.606379,
    3.140735,
    0.218497,
    -0.520987,
    10.288093,
    3.108388,
    0.245752,
    -0.558483,
    9.90748,
    3.067586,
    0.273993,
    -0.59209,
    9.453246,
    3.016931,
    0.303495,
    -0.622416,
    8.966138,
    2.956444,
    0.333717,
    -0.648303,
    8.443776,
    2.885116,
    0.363928,
    -0.66864,
    7.894122,
    2.805963,
    0.39624,
    -0.687748,
    7.385728,
    2.718338,
    0.427161,
    -0.699903,
    6.838511,
    2.622346,
    0.460175,
    -0.71121,
    6.356371,
    2.522476,
    0.492593,
    -0.717734,
    5.878312,
    2.417984,
    0.524449,
    -0.719956,
    5.423285,
    2.310941,
    0.55601,
    -0.719127,
    4.997909,
    2.201885,
    0.587032,
    -0.715077,
    4.600426,
    2.09333,
    0.61703,
    -0.707574,
    4.235885,
    1.986585,
    0.644684,
    -0.695781,
    3.881712,
    1.881279,
    0.674483,
    -0.685313,
    3.59096,
    1.777918,
    0.70029,
    -0.669619,
    3.303138,
    1.678004,
    0.727892,
    -0.654728,
    3.057771,
    1.581162,
    0.751694,
    -0.635727,
    2.826642,
    1.487769,
    0.776271,
    -0.617343,
    2.622178,
    1.399628,
    0.799502,
    -0.597683,
    2.441265,
    1.313195,
    0.821768,
    -0.57709,
    2.276954,
    1.232316,
    0.84196,
    -0.555165,
    2.125744,
    1.153914,
    0.861582,
    -0.532983,
    1.991236,
    1.079598,
    0.88146,
    -0.510933,
    1.874027,
    1.008883,
    0.899952,
    -0.488321,
    1.766812,
    0.940802,
    0.918954,
    -0.466405,
    1.673436,
    0.875653,
    0.93613,
    -0.443623,
    1.586986,
    0.81313,
    0.954799,
    -0.421532,
    1.513558,
    0.752241,
    0.972435,
    -0.398897,
    1.445787,
    0.694711,
    0.990147,
    -0.376302,
    1.384382,
    0.63877,
    1.009189,
    -0.353623,
    1.331934,
    0.583826,
    1.029687,
    -0.330635,
    1.284478,
    0.530476,
    1.052604,
    -0.305698,
    1.243632,
    0.477187,
    1.076524,
    -0.279917,
    1.204997,
    0.425349,
    1.101701,
    -0.253951,
    1.17175,
    0.375165,
    1.127264,
    -0.227541,
    1.142519,
    0.326869,
    1.156397,
    -0.201265,
    1.116817,
    0.280912,
    1.18302,
    -0.173943,
    1.095289,
    0.237447,
    1.208448,
    -0.14586,
    1.078296,
    0.196694,
    1.230417,
    -0.116901,
    1.064416,
    0.158409,
    1.248617,
    -0.087507,
    1.050504,
    0.119483,
    1.25731,
    -0.057353,
    1.032796,
    0.079092,
    1.263076,
    -0.027785,
    1.015128,
    0.038883,
    1.26987,
    0.001331,
    0.999935,
    -557e-6,
    154e-6,
    -549e-6,
    5.705205,
    3.554136,
    506e-6,
    -0.001797,
    13.703335,
    3.554133,
    0.002014,
    -0.007156,
    13.614074,
    3.553937,
    0.004544,
    -0.016145,
    13.657344,
    3.553096,
    0.00807,
    -0.028652,
    13.627997,
    3.553894,
    0.012584,
    -0.044617,
    13.606235,
    3.554,
    0.01818,
    -0.064288,
    13.581339,
    3.549637,
    0.024887,
    -0.087627,
    13.608851,
    3.552006,
    0.03269,
    -0.114134,
    13.599099,
    3.550341,
    0.041705,
    -0.144154,
    13.579829,
    3.547982,
    0.052035,
    -0.1774,
    13.552845,
    3.544641,
    0.06381,
    -0.213813,
    13.515619,
    3.539941,
    0.077171,
    -0.252978,
    13.46046,
    3.533696,
    0.092329,
    -0.294852,
    13.393559,
    3.524977,
    0.10939,
    -0.338688,
    13.292376,
    3.513655,
    0.128455,
    -0.384018,
    13.147332,
    3.498484,
    0.149661,
    -0.42996,
    12.945774,
    3.478323,
    0.172694,
    -0.475024,
    12.658979,
    3.451862,
    0.19765,
    -0.518614,
    12.289564,
    3.417602,
    0.224156,
    -0.559298,
    11.828307,
    3.372913,
    0.252008,
    -0.59611,
    11.285162,
    3.317454,
    0.281165,
    -0.629292,
    10.684922,
    3.251171,
    0.311434,
    -0.658379,
    10.052939,
    3.172222,
    0.342741,
    -0.683455,
    9.405296,
    3.082825,
    0.373543,
    -0.701674,
    8.716078,
    2.983976,
    0.407008,
    -0.719664,
    8.108425,
    2.876244,
    0.438623,
    -0.729882,
    7.461252,
    2.763279,
    0.471872,
    -0.738696,
    6.880182,
    2.64559,
    0.5047,
    -0.743136,
    6.324308,
    2.52468,
    0.537118,
    -0.743676,
    5.808302,
    2.402723,
    0.569412,
    -0.741181,
    5.332306,
    2.281437,
    0.598202,
    -0.732348,
    4.857402,
    2.161401,
    0.62964,
    -0.724832,
    4.465554,
    2.043872,
    0.659239,
    -0.713435,
    4.093661,
    1.930129,
    0.686547,
    -0.698539,
    3.752593,
    1.817654,
    0.715529,
    -0.684471,
    3.457593,
    1.712567,
    0.739456,
    -0.664983,
    3.17122,
    1.610687,
    0.764892,
    -0.646322,
    2.929674,
    1.512031,
    0.789301,
    -0.626393,
    2.710719,
    1.419033,
    0.809881,
    -0.603498,
    2.506139,
    1.330115,
    0.833385,
    -0.582934,
    2.336089,
    1.245859,
    0.854254,
    -0.560419,
    2.17847,
    1.165042,
    0.873964,
    -0.537294,
    2.040087,
    1.086633,
    0.893433,
    -0.514264,
    1.911969,
    1.015028,
    0.911756,
    -0.490657,
    1.79984,
    0.944938,
    0.930894,
    -0.467601,
    1.703188,
    0.878743,
    0.948078,
    -0.444043,
    1.612092,
    0.815356,
    0.966162,
    -0.421155,
    1.534444,
    0.753883,
    0.984166,
    -0.398238,
    1.462397,
    0.695534,
    1.002184,
    -0.375278,
    1.400793,
    0.638806,
    1.019669,
    -0.352159,
    1.344172,
    0.584549,
    1.039571,
    -0.329651,
    1.295227,
    0.53166,
    1.059989,
    -0.306804,
    1.251281,
    0.480529,
    1.081116,
    -0.283345,
    1.211504,
    0.430071,
    1.105742,
    -0.258568,
    1.1764,
    0.380277,
    1.13308,
    -0.232146,
    1.144519,
    0.331076,
    1.161888,
    -0.205244,
    1.118059,
    0.28404,
    1.192408,
    -0.177932,
    1.097561,
    0.239958,
    1.221043,
    -0.149532,
    1.082021,
    0.198751,
    1.244141,
    -0.120046,
    1.067634,
    0.160114,
    1.259465,
    -0.089542,
    1.051626,
    0.121101,
    1.268124,
    -0.058593,
    1.033296,
    0.079898,
    1.27433,
    -0.028011,
    1.015382,
    0.039038,
    1.28159,
    0.00233,
    1.000087,
    -0.001259,
    149e-6,
    -587e-6,
    6.059834,
    3.927143,
    507e-6,
    -0.001992,
    16.5604,
    3.927149,
    0.002014,
    -0.00791,
    16.406326,
    3.926821,
    0.004549,
    -0.017856,
    16.545532,
    3.927027,
    0.008064,
    -0.031632,
    16.375853,
    3.925487,
    0.01245,
    -0.048749,
    15.928564,
    3.928272,
    0.01803,
    -0.070371,
    16.072989,
    3.917862,
    0.024964,
    -0.096897,
    16.458925,
    3.924489,
    0.032807,
    -0.126073,
    16.377851,
    3.921896,
    0.041917,
    -0.159205,
    16.351561,
    3.91886,
    0.052416,
    -0.195762,
    16.307037,
    3.914339,
    0.064464,
    -0.235784,
    16.255514,
    3.907954,
    0.078225,
    -0.278812,
    16.176226,
    3.899254,
    0.0939,
    -0.324457,
    16.06653,
    3.887455,
    0.111657,
    -0.372174,
    15.913818,
    3.871777,
    0.131478,
    -0.42053,
    15.669197,
    3.850776,
    0.153574,
    -0.46933,
    15.355453,
    3.822348,
    0.177505,
    -0.516029,
    14.908978,
    3.785168,
    0.203383,
    -0.560585,
    14.352687,
    3.736602,
    0.230569,
    -0.600607,
    13.666022,
    3.675046,
    0.259188,
    -0.636296,
    12.900244,
    3.599811,
    0.289272,
    -0.668312,
    12.111226,
    3.51055,
    0.32049,
    -0.695986,
    11.292102,
    3.408535,
    0.353031,
    -0.719848,
    10.493485,
    3.295667,
    0.385228,
    -0.737073,
    9.661955,
    3.171998,
    0.419219,
    -0.752419,
    8.909942,
    3.042428,
    0.452096,
    -0.761179,
    8.155107,
    2.907108,
    0.484909,
    -0.766166,
    7.450609,
    2.769858,
    0.518306,
    -0.768596,
    6.811866,
    2.631935,
    0.550067,
    -0.765683,
    6.205275,
    2.49287,
    0.582562,
    -0.761197,
    5.663215,
    2.358645,
    0.61445,
    -0.753834,
    5.165358,
    2.227377,
    0.644563,
    -0.74286,
    4.712554,
    2.097547,
    0.673658,
    -0.729294,
    4.306101,
    1.97492,
    0.702857,
    -0.714839,
    3.943352,
    1.857613,
    0.72935,
    -0.696774,
    3.609432,
    1.743601,
    0.754958,
    -0.677394,
    3.308389,
    1.636607,
    0.779575,
    -0.657018,
    3.043803,
    1.533841,
    0.800491,
    -0.633342,
    2.793592,
    1.437092,
    0.82503,
    -0.612471,
    2.590307,
    1.344272,
    0.847535,
    -0.589882,
    2.406477,
    1.256436,
    0.865979,
    -0.56485,
    2.231999,
    1.173938,
    0.886254,
    -0.541357,
    2.083556,
    1.094722,
    0.905566,
    -0.517353,
    1.950928,
    1.021107,
    0.924607,
    -0.49332,
    1.835979,
    0.948941,
    0.943365,
    -0.469366,
    1.731417,
    0.88106,
    0.960405,
    -0.444745,
    1.635838,
    0.816479,
    0.977893,
    -0.420493,
    1.552981,
    0.754604,
    0.996573,
    -0.39715,
    1.481595,
    0.694917,
    1.014,
    -0.373483,
    1.41407,
    0.638445,
    1.031807,
    -0.349985,
    1.356031,
    0.584035,
    1.051877,
    -0.327062,
    1.305041,
    0.53001,
    1.071701,
    -0.304134,
    1.258836,
    0.479439,
    1.093109,
    -0.280962,
    1.217297,
    0.429763,
    1.116681,
    -0.258121,
    1.182063,
    0.38105,
    1.143886,
    -0.235365,
    1.150039,
    0.333395,
    1.175163,
    -0.211621,
    1.125074,
    0.287477,
    1.203675,
    -0.184061,
    1.102339,
    0.243301,
    1.230477,
    -0.154815,
    1.083927,
    0.201826,
    1.253134,
    -0.124513,
    1.067989,
    0.162271,
    1.270092,
    -0.093383,
    1.052032,
    0.122855,
    1.279576,
    -0.06177,
    1.033685,
    0.081639,
    1.286472,
    -0.030317,
    1.015583,
    0.040411,
    1.294476,
    964e-6,
    1.000206,
    -454e-6,
    144e-6,
    -63e-5,
    6.467978,
    4.381146,
    504e-6,
    -0.002208,
    20.193617,
    4.381151,
    0.002017,
    -0.008834,
    20.206446,
    4.380687,
    0.004536,
    -0.019864,
    20.183254,
    4.38055,
    0.008174,
    -0.035759,
    20.564249,
    4.381247,
    0.012608,
    -0.055034,
    20.111612,
    4.38239,
    0.018198,
    -0.079119,
    20.106096,
    4.379815,
    0.025057,
    -0.108067,
    20.215635,
    4.376874,
    0.032962,
    -0.14063,
    20.153549,
    4.374143,
    0.042199,
    -0.17735,
    20.084061,
    4.369558,
    0.052928,
    -0.218094,
    20.026609,
    4.363287,
    0.065327,
    -0.262407,
    19.940054,
    4.354386,
    0.079568,
    -0.309833,
    19.806814,
    4.342127,
    0.095961,
    -0.360074,
    19.641878,
    4.325533,
    0.114516,
    -0.411747,
    19.370914,
    4.30295,
    0.135349,
    -0.463726,
    18.9839,
    4.271991,
    0.158293,
    -0.514211,
    18.433926,
    4.230856,
    0.183348,
    -0.562511,
    17.733471,
    4.17625,
    0.209959,
    -0.60631,
    16.864214,
    4.105895,
    0.238736,
    -0.646958,
    15.935207,
    4.020104,
    0.268543,
    -0.681574,
    14.890014,
    3.916094,
    0.299996,
    -0.712458,
    13.846786,
    3.798239,
    0.33193,
    -0.73713,
    12.758296,
    3.664191,
    0.365222,
    -0.758156,
    11.73294,
    3.521867,
    0.399061,
    -0.774364,
    10.741743,
    3.369831,
    0.43348,
    -0.786412,
    9.812527,
    3.212079,
    0.467002,
    -0.792373,
    8.91513,
    3.053715,
    0.500754,
    -0.79541,
    8.094276,
    2.894526,
    0.534023,
    -0.794617,
    7.342067,
    2.735959,
    0.566988,
    -0.790689,
    6.664186,
    2.58116,
    0.59996,
    -0.784433,
    6.052983,
    2.432318,
    0.630599,
    -0.773378,
    5.486277,
    2.28763,
    0.660807,
    -0.760334,
    4.982516,
    2.150183,
    0.690103,
    -0.74543,
    4.531104,
    2.017266,
    0.717315,
    -0.727511,
    4.120734,
    1.891699,
    0.743819,
    -0.708376,
    3.759599,
    1.77268,
    0.770147,
    -0.688632,
    3.441912,
    1.66062,
    0.79351,
    -0.665931,
    3.1526,
    1.553166,
    0.816535,
    -0.643045,
    2.898883,
    1.45208,
    0.839163,
    -0.619917,
    2.674488,
    1.355544,
    0.859066,
    -0.594923,
    2.469262,
    1.267232,
    0.879489,
    -0.570343,
    2.292209,
    1.181702,
    0.898525,
    -0.544975,
    2.131086,
    1.102089,
    0.918359,
    -0.520585,
    1.994526,
    1.024744,
    0.937502,
    -0.496044,
    1.873079,
    0.951712,
    0.955573,
    -0.47101,
    1.761232,
    0.883374,
    0.972957,
    -0.445712,
    1.661604,
    0.818008,
    0.991248,
    -0.421201,
    1.577169,
    0.754446,
    1.008997,
    -0.396444,
    1.499653,
    0.694518,
    1.028127,
    -0.372362,
    1.43203,
    0.637259,
    1.04571,
    -0.347895,
    1.36987,
    0.581515,
    1.065977,
    -0.324409,
    1.317341,
    0.527713,
    1.087469,
    -0.301181,
    1.270447,
    0.476281,
    1.109943,
    -0.277866,
    1.228398,
    0.426403,
    1.13444,
    -0.254849,
    1.190986,
    0.377822,
    1.160986,
    -0.231754,
    1.157681,
    0.33074,
    1.188458,
    -0.207973,
    1.128665,
    0.286014,
    1.214405,
    -0.183424,
    1.103711,
    0.2436,
    1.239504,
    -0.157972,
    1.084253,
    0.203686,
    1.262961,
    -0.130607,
    1.068258,
    0.165214,
    1.28034,
    -0.099652,
    1.051919,
    0.126067,
    1.292129,
    -0.067363,
    1.034016,
    0.084791,
    1.299876,
    -0.035026,
    1.015775,
    0.042786,
    1.308328,
    -0.002944,
    0.999963,
    0.001385,
    138e-6,
    -681e-6,
    6.943771,
    4.946556,
    503e-6,
    -0.002486,
    25.346689,
    4.946532,
    0.002016,
    -0.009973,
    25.49432,
    4.946311,
    0.004539,
    -0.02244,
    25.484949,
    4.945823,
    0.008069,
    -0.039836,
    25.420902,
    4.945311,
    0.012628,
    -0.062172,
    25.394403,
    4.945041,
    0.018294,
    -0.089609,
    25.440279,
    4.943295,
    0.025079,
    -0.121584,
    25.399988,
    4.939368,
    0.033142,
    -0.158595,
    25.356537,
    4.9362,
    0.042596,
    -0.199971,
    25.295067,
    4.929842,
    0.053628,
    -0.245624,
    25.196465,
    4.920586,
    0.066496,
    -0.29524,
    25.055311,
    4.9077,
    0.081434,
    -0.348006,
    24.84617,
    4.889647,
    0.09864,
    -0.403167,
    24.527803,
    4.86468,
    0.118231,
    -0.459106,
    24.051735,
    4.830574,
    0.140139,
    -0.513907,
    23.352467,
    4.78353,
    0.164198,
    -0.565953,
    22.418245,
    4.72053,
    0.190502,
    -0.614858,
    21.324049,
    4.638075,
    0.21853,
    -0.658304,
    20.038671,
    4.535464,
    0.248094,
    -0.696133,
    18.639786,
    4.411646,
    0.279435,
    -0.729388,
    17.234526,
    4.268872,
    0.312002,
    -0.757534,
    15.830426,
    4.109603,
    0.346173,
    -0.781866,
    14.495901,
    3.938782,
    0.379435,
    -0.797579,
    13.136444,
    3.756138,
    0.414945,
    -0.812334,
    11.946491,
    3.571258,
    0.449991,
    -0.821119,
    10.811908,
    3.384217,
    0.484636,
    -0.825066,
    9.763482,
    3.198076,
    0.518675,
    -0.824728,
    8.796811,
    3.015808,
    0.552559,
    -0.82171,
    7.932528,
    2.836886,
    0.587272,
    -0.817478,
    7.185156,
    2.664995,
    0.61696,
    -0.804441,
    6.445302,
    2.502223,
    0.648054,
    -0.792063,
    5.818812,
    2.345851,
    0.678575,
    -0.777793,
    5.264731,
    2.19715,
    0.707287,
    -0.760476,
    4.766033,
    2.056042,
    0.735851,
    -0.742541,
    4.335871,
    1.922805,
    0.760594,
    -0.720503,
    3.928021,
    1.798585,
    0.784534,
    -0.697719,
    3.579153,
    1.680605,
    0.811029,
    -0.677036,
    3.285307,
    1.568942,
    0.831809,
    -0.651479,
    3.001423,
    1.465496,
    0.854364,
    -0.627376,
    2.760672,
    1.367849,
    0.872639,
    -0.600496,
    2.540697,
    1.275644,
    0.894296,
    -0.576297,
    2.355273,
    1.188638,
    0.913123,
    -0.550377,
    2.188563,
    1.105652,
    0.932025,
    -0.52464,
    2.040739,
    1.028614,
    0.949876,
    -0.498402,
    1.910315,
    0.954421,
    0.968933,
    -0.47322,
    1.79575,
    0.884061,
    0.985366,
    -0.447086,
    1.690336,
    0.817765,
    1.00494,
    -0.422394,
    1.599626,
    0.753295,
    1.022217,
    -0.396726,
    1.519055,
    0.69338,
    1.04149,
    -0.371854,
    1.448745,
    0.635747,
    1.05992,
    -0.346769,
    1.384292,
    0.579508,
    1.080408,
    -0.322343,
    1.328798,
    0.525045,
    1.101632,
    -0.297979,
    1.279898,
    0.473773,
    1.124812,
    -0.274059,
    1.234005,
    0.422949,
    1.148503,
    -0.249954,
    1.195373,
    0.374609,
    1.174554,
    -0.225988,
    1.160362,
    0.32735,
    1.202931,
    -0.201932,
    1.131307,
    0.283494,
    1.229335,
    -0.176886,
    1.105885,
    0.241092,
    1.254254,
    -0.151225,
    1.085802,
    0.201514,
    1.275743,
    -0.124282,
    1.068524,
    0.162866,
    1.292929,
    -0.097122,
    1.051493,
    0.124991,
    1.305805,
    -0.068939,
    1.03389,
    0.085521,
    1.314991,
    -0.040082,
    1.015927,
    0.045247,
    1.324033,
    -0.009923,
    0.999893,
    0.004738,
    131e-6,
    -745e-6,
    7.562414,
    5.671075,
    473e-6,
    -0.002681,
    27.216688,
    5.670949,
    0.002021,
    -0.011462,
    32.962402,
    5.670177,
    0.00454,
    -0.025728,
    33.183949,
    5.670197,
    0.008087,
    -0.045746,
    33.185688,
    5.667313,
    0.012673,
    -0.071427,
    33.170441,
    5.668396,
    0.018358,
    -0.102673,
    33.145138,
    5.665252,
    0.025299,
    -0.13978,
    33.303326,
    5.653404,
    0.033469,
    -0.181718,
    33.107243,
    5.652829,
    0.043139,
    -0.228698,
    32.859524,
    5.645676,
    0.054622,
    -0.280648,
    32.694893,
    5.631547,
    0.068115,
    -0.336524,
    32.422569,
    5.611561,
    0.083957,
    -0.395671,
    32.035511,
    5.583449,
    0.102259,
    -0.456164,
    31.415047,
    5.543651,
    0.123021,
    -0.515765,
    30.47044,
    5.488278,
    0.146127,
    -0.572309,
    29.186451,
    5.413118,
    0.171749,
    -0.62571,
    27.653852,
    5.312369,
    0.199549,
    -0.673853,
    25.902435,
    5.185774,
    0.229188,
    -0.715905,
    23.978609,
    5.030582,
    0.260421,
    -0.751533,
    21.999035,
    4.853484,
    0.293421,
    -0.782309,
    20.087366,
    4.656137,
    0.327077,
    -0.806332,
    18.186535,
    4.443975,
    0.361892,
    -0.825818,
    16.418409,
    4.223844,
    0.397146,
    -0.840019,
    14.774344,
    3.998959,
    0.434169,
    -0.852434,
    13.321097,
    3.775443,
    0.469288,
    -0.856632,
    11.929448,
    3.552818,
    0.504319,
    -0.85713,
    10.675201,
    3.338825,
    0.540067,
    -0.855903,
    9.5919,
    3.130547,
    0.575404,
    -0.851565,
    8.607655,
    2.93293,
    0.606782,
    -0.839818,
    7.69056,
    2.743876,
    0.63866,
    -0.827508,
    6.900781,
    2.565115,
    0.670577,
    -0.814154,
    6.216821,
    2.395215,
    0.696718,
    -0.793162,
    5.551886,
    2.238233,
    0.72599,
    -0.775291,
    5.015406,
    2.090264,
    0.75414,
    -0.755758,
    4.546843,
    1.950834,
    0.775992,
    -0.729824,
    4.094254,
    1.820582,
    0.80299,
    -0.708909,
    3.732984,
    1.699191,
    0.828291,
    -0.686483,
    3.413194,
    1.583805,
    0.847406,
    -0.659162,
    3.103861,
    1.478093,
    0.864951,
    -0.631051,
    2.832976,
    1.378496,
    0.887154,
    -0.60659,
    2.616645,
    1.282127,
    0.906337,
    -0.580124,
    2.413988,
    1.194643,
    0.927184,
    -0.554835,
    2.24438,
    1.110354,
    0.94381,
    -0.527583,
    2.081964,
    1.031996,
    0.96363,
    -0.502243,
    1.948979,
    0.956718,
    0.979691,
    -0.475006,
    1.822701,
    0.886957,
    0.99769,
    -0.448815,
    1.715714,
    0.819006,
    1.01646,
    -0.423044,
    1.621868,
    0.754892,
    1.035485,
    -0.397637,
    1.539537,
    0.693707,
    1.053165,
    -0.371775,
    1.462285,
    0.634867,
    1.072394,
    -0.346372,
    1.396193,
    0.578574,
    1.093397,
    -0.321291,
    1.338344,
    0.524341,
    1.115194,
    -0.296102,
    1.287594,
    0.472059,
    1.137943,
    -0.271023,
    1.240495,
    0.421674,
    1.164163,
    -0.246367,
    1.201224,
    0.371963,
    1.191457,
    -0.221414,
    1.164472,
    0.32504,
    1.220253,
    -0.196228,
    1.134325,
    0.280343,
    1.245456,
    -0.169991,
    1.108214,
    0.238098,
    1.270647,
    -0.143314,
    1.087277,
    0.197886,
    1.292124,
    -0.115881,
    1.069397,
    0.15956,
    1.309091,
    -0.087816,
    1.051426,
    0.120547,
    1.32113,
    -0.059301,
    1.032904,
    0.080834,
    1.332484,
    -0.030912,
    1.015767,
    0.040933,
    1.342834,
    -0.002172,
    0.999591,
    0.001185,
    125e-6,
    -83e-5,
    8.392562,
    6.634228,
    443e-6,
    -0.002936,
    29.687805,
    6.634032,
    0.002016,
    -0.013374,
    45.025234,
    6.633008,
    0.00454,
    -0.030089,
    45.020294,
    6.633056,
    0.008092,
    -0.053499,
    45.066029,
    6.626466,
    0.01271,
    -0.08361,
    44.810101,
    6.63033,
    0.018485,
    -0.12026,
    45.216747,
    6.614516,
    0.025134,
    -0.161031,
    44.674168,
    6.600349,
    0.033897,
    -0.212161,
    44.819195,
    6.610186,
    0.043978,
    -0.266661,
    44.450245,
    6.593605,
    0.056094,
    -0.326582,
    44.134544,
    6.570142,
    0.070528,
    -0.390342,
    43.591648,
    6.536712,
    0.087498,
    -0.456162,
    42.70816,
    6.488329,
    0.107138,
    -0.521609,
    41.365093,
    6.420198,
    0.129461,
    -0.584225,
    39.525822,
    6.323702,
    0.154245,
    -0.641931,
    37.186111,
    6.193606,
    0.181228,
    -0.692829,
    34.47847,
    6.026897,
    0.210711,
    -0.73844,
    31.680904,
    5.825769,
    0.242181,
    -0.777397,
    28.828054,
    5.595428,
    0.275337,
    -0.80998,
    26.042755,
    5.342321,
    0.309698,
    -0.83599,
    23.376804,
    5.073076,
    0.345702,
    -0.858077,
    20.965754,
    4.794572,
    0.382135,
    -0.874122,
    18.710079,
    4.516676,
    0.419871,
    -0.887133,
    16.713011,
    4.241767,
    0.455609,
    -0.891199,
    14.819674,
    3.972124,
    0.492617,
    -0.894082,
    13.187921,
    3.717271,
    0.528186,
    -0.89127,
    11.708584,
    3.471719,
    0.563462,
    -0.885719,
    10.422834,
    3.23776,
    0.596013,
    -0.874241,
    9.237741,
    3.01906,
    0.629455,
    -0.862814,
    8.248549,
    2.813572,
    0.66111,
    -0.848126,
    7.358398,
    2.621046,
    0.690314,
    -0.829798,
    6.569392,
    2.441627,
    0.720589,
    -0.812314,
    5.905934,
    2.274629,
    0.745631,
    -0.788704,
    5.2768,
    2.119423,
    0.771488,
    -0.766133,
    4.752773,
    1.97438,
    0.798704,
    -0.744726,
    4.306095,
    1.839482,
    0.820172,
    -0.718062,
    3.889792,
    1.713244,
    0.844368,
    -0.693972,
    3.545456,
    1.594809,
    0.863128,
    -0.665748,
    3.212762,
    1.487512,
    0.880094,
    -0.637003,
    2.926572,
    1.386724,
    0.904252,
    -0.613728,
    2.70426,
    1.288131,
    0.920506,
    -0.585217,
    2.483164,
    1.199845,
    0.940919,
    -0.559603,
    2.300348,
    1.114958,
    0.957044,
    -0.531597,
    2.130516,
    1.034754,
    0.972648,
    -0.503583,
    1.979313,
    0.960912,
    0.994318,
    -0.478813,
    1.859664,
    0.889786,
    1.008754,
    -0.450943,
    1.742705,
    0.820833,
    1.028667,
    -0.425516,
    1.64522,
    0.756332,
    1.046145,
    -0.398977,
    1.557184,
    0.693921,
    1.067212,
    -0.373657,
    1.480814,
    0.635955,
    1.084111,
    -0.346657,
    1.408762,
    0.578832,
    1.106749,
    -0.321392,
    1.350468,
    0.523561,
    1.12844,
    -0.295773,
    1.294865,
    0.471146,
    1.151073,
    -0.270028,
    1.246118,
    0.420298,
    1.178601,
    -0.244816,
    1.204226,
    0.370575,
    1.206845,
    -0.219027,
    1.166896,
    0.323716,
    1.235963,
    -0.192622,
    1.135756,
    0.278058,
    1.26303,
    -0.165331,
    1.10924,
    0.235743,
    1.288937,
    -0.137489,
    1.088379,
    0.19539,
    1.310681,
    -0.108685,
    1.068987,
    0.156439,
    1.334352,
    -0.07971,
    1.054273,
    0.117096,
    1.344847,
    -0.049947,
    1.034598,
    0.076554,
    1.354943,
    -0.020272,
    1.016079,
    0.035585,
    1.365515,
    0.00917,
    0.999969,
    -0.004771,
    117e-6,
    -935e-6,
    9.424866,
    7.979243,
    41e-5,
    -0.003275,
    33.013195,
    7.979422,
    0.002009,
    -0.016024,
    64.370331,
    7.977156,
    0.004541,
    -0.036176,
    64.655952,
    7.976128,
    0.008109,
    -0.064384,
    64.864494,
    7.964988,
    0.012694,
    -0.099984,
    64.487198,
    7.971348,
    0.018554,
    -0.143991,
    64.63797,
    7.923116,
    0.025303,
    -0.19204,
    61.930538,
    7.953975,
    0.035297,
    -0.259442,
    66.274422,
    7.921861,
    0.045226,
    -0.31837,
    63.33469,
    7.909609,
    0.05837,
    -0.388821,
    62.686401,
    7.864696,
    0.074083,
    -0.461667,
    61.332054,
    7.801843,
    0.092537,
    -0.533744,
    59.125607,
    7.708949,
    0.113781,
    -0.601905,
    55.997845,
    7.575799,
    0.137786,
    -0.664409,
    52.177567,
    7.393524,
    0.16477,
    -0.721193,
    48.019485,
    7.161756,
    0.193894,
    -0.768842,
    43.460278,
    6.882018,
    0.225586,
    -0.810332,
    39.08659,
    6.564607,
    0.259311,
    -0.845096,
    34.896049,
    6.221983,
    0.294517,
    -0.872849,
    30.952213,
    5.865831,
    0.331163,
    -0.895159,
    27.375792,
    5.507064,
    0.368964,
    -0.91286,
    24.21331,
    5.149763,
    0.407255,
    -0.925338,
    21.364958,
    4.806172,
    0.444704,
    -0.930956,
    18.791691,
    4.472272,
    0.482041,
    -0.932576,
    16.52116,
    4.160864,
    0.519572,
    -0.931547,
    14.589918,
    3.865206,
    0.556236,
    -0.926554,
    12.887797,
    3.590445,
    0.590431,
    -0.915839,
    11.352402,
    3.332747,
    0.622723,
    -0.901266,
    10.00266,
    3.093264,
    0.657029,
    -0.888747,
    8.90521,
    2.873842,
    0.686164,
    -0.868666,
    7.876704,
    2.66674,
    0.719168,
    -0.853152,
    7.051816,
    2.479017,
    0.742294,
    -0.826169,
    6.226034,
    2.306498,
    0.77032,
    -0.804936,
    5.590831,
    2.141328,
    0.792337,
    -0.777772,
    4.984083,
    1.994663,
    0.81905,
    -0.755478,
    4.507655,
    1.85395,
    0.837684,
    -0.726072,
    4.049884,
    1.72559,
    0.861324,
    -0.701424,
    3.678201,
    1.606303,
    0.880741,
    -0.673615,
    3.337163,
    1.495452,
    0.903335,
    -0.648506,
    3.05572,
    1.391162,
    0.920311,
    -0.61964,
    2.792068,
    1.294734,
    0.935769,
    -0.590245,
    2.554566,
    1.204518,
    0.956592,
    -0.564944,
    2.366468,
    1.11863,
    0.972424,
    -0.536842,
    2.187863,
    1.038323,
    0.986269,
    -0.50802,
    2.02348,
    0.963803,
    1.006122,
    -0.482411,
    1.895137,
    0.890986,
    1.022504,
    -0.45511,
    1.775886,
    0.820936,
    1.037905,
    -0.42745,
    1.665951,
    0.758556,
    1.059281,
    -0.402198,
    1.577363,
    0.696126,
    1.076613,
    -0.375156,
    1.493391,
    0.636676,
    1.097828,
    -0.349577,
    1.421129,
    0.579947,
    1.116671,
    -0.322955,
    1.355205,
    0.52514,
    1.140514,
    -0.297406,
    1.299979,
    0.47146,
    1.166473,
    -0.271786,
    1.249847,
    0.420473,
    1.192591,
    -0.245461,
    1.204625,
    0.371118,
    1.223349,
    -0.219412,
    1.166686,
    0.3226,
    1.254833,
    -0.19266,
    1.134121,
    0.277572,
    1.285808,
    -0.165167,
    1.108617,
    0.234417,
    1.322015,
    -0.137236,
    1.093841,
    0.19464,
    1.342172,
    -0.106871,
    1.074616,
    0.155001,
    1.357238,
    -0.075759,
    1.05355,
    0.114648,
    1.367725,
    -0.044279,
    1.033851,
    0.073254,
    1.379461,
    -0.013001,
    1.015713,
    0.031895,
    1.391625,
    0.018075,
    1.000203,
    -0.009397,
    109e-6,
    -0.001093,
    10.98682,
    9.992467,
    378e-6,
    -0.003779,
    37.989063,
    9.992861,
    0.002028,
    -0.020252,
    101.850441,
    9.988345,
    0.004557,
    -0.045429,
    101.10675,
    9.983879,
    0.008115,
    -0.080453,
    100.646606,
    9.953411,
    0.012864,
    -0.125836,
    101.366592,
    9.943727,
    0.018734,
    -0.17935,
    100.786118,
    9.908408,
    0.026314,
    -0.24368,
    99.779343,
    9.821631,
    0.0355,
    -0.313552,
    98.608231,
    9.78245,
    0.047562,
    -0.394644,
    97.689568,
    9.845875,
    0.062065,
    -0.476697,
    95.177795,
    9.755218,
    0.079552,
    -0.557933,
    91.095581,
    9.615121,
    0.099905,
    -0.632818,
    85.110382,
    9.408299,
    0.123231,
    -0.699926,
    77.948921,
    9.120996,
    0.14998,
    -0.760671,
    70.491119,
    8.764173,
    0.17955,
    -0.812251,
    62.821407,
    8.341752,
    0.211839,
    -0.855909,
    55.51289,
    7.876337,
    0.246434,
    -0.892023,
    48.744549,
    7.386268,
    0.282317,
    -0.9192,
    42.462059,
    6.886009,
    0.31958,
    -0.940333,
    36.901031,
    6.400318,
    0.360135,
    -0.962176,
    32.353752,
    5.937503,
    0.397805,
    -0.969755,
    27.996445,
    5.489783,
    0.437077,
    -0.976494,
    24.359192,
    5.072855,
    0.474388,
    -0.975265,
    21.1243,
    4.684682,
    0.513695,
    -0.975335,
    18.476677,
    4.326597,
    0.551542,
    -0.970264,
    16.167391,
    3.999049,
    0.587525,
    -0.960365,
    14.143442,
    3.696317,
    0.621251,
    -0.945944,
    12.374341,
    3.414176,
    0.654738,
    -0.930709,
    10.877112,
    3.160455,
    0.685794,
    -0.911702,
    9.580887,
    2.921461,
    0.717135,
    -0.892948,
    8.481939,
    2.707478,
    0.740798,
    -0.865086,
    7.435941,
    2.510382,
    0.77092,
    -0.845137,
    6.650625,
    2.329648,
    0.792303,
    -0.815956,
    5.879976,
    2.163206,
    0.818363,
    -0.792225,
    5.274404,
    2.008042,
    0.837362,
    -0.762396,
    4.70096,
    1.867576,
    0.862266,
    -0.738465,
    4.254798,
    1.735819,
    0.880069,
    -0.70889,
    3.828697,
    1.61469,
    0.896021,
    -0.678588,
    3.451655,
    1.503477,
    0.920156,
    -0.654832,
    3.168722,
    1.3958,
    0.934948,
    -0.62474,
    2.879533,
    1.299955,
    0.949686,
    -0.595203,
    2.628258,
    1.208597,
    0.970989,
    -0.570041,
    2.433689,
    1.12231,
    0.985606,
    -0.541116,
    2.241461,
    1.042168,
    1.000819,
    -0.512835,
    2.075567,
    0.966543,
    1.012209,
    -0.483024,
    1.919932,
    0.895758,
    1.03532,
    -0.459125,
    1.807884,
    0.825668,
    1.052077,
    -0.432333,
    1.695689,
    0.760812,
    1.070459,
    -0.406131,
    1.595491,
    0.699897,
    1.088704,
    -0.379721,
    1.508512,
    0.640575,
    1.103817,
    -0.352104,
    1.428159,
    0.583765,
    1.131711,
    -0.328122,
    1.366565,
    0.52824,
    1.156448,
    -0.302568,
    1.306843,
    0.473988,
    1.181821,
    -0.276487,
    1.252861,
    0.422189,
    1.211347,
    -0.25054,
    1.205265,
    0.372005,
    1.243636,
    -0.224264,
    1.165943,
    0.324184,
    1.283038,
    -0.198289,
    1.137772,
    0.278419,
    1.316722,
    -0.170179,
    1.115057,
    0.235425,
    1.342715,
    -0.140095,
    1.092994,
    0.195084,
    1.363288,
    -0.108794,
    1.071875,
    0.155439,
    1.380656,
    -0.076774,
    1.052475,
    0.114636,
    1.394826,
    -0.044509,
    1.032525,
    0.07289,
    1.40883,
    -0.011968,
    1.015459,
    0.031101,
    1.42237,
    0.020555,
    0.999808,
    -0.011002,
    1e-4,
    -0.001334,
    13.377127,
    13.342275,
    342e-6,
    -0.004563,
    45.758434,
    13.34271,
    0.002026,
    -0.027004,
    179.672058,
    13.331846,
    0.004559,
    -0.060563,
    179.294235,
    13.314877,
    0.008232,
    -0.108154,
    181.242035,
    13.222856,
    0.013031,
    -0.16759,
    179.684509,
    13.15386,
    0.019526,
    -0.242041,
    181.004608,
    12.986094,
    0.026364,
    -0.309289,
    159.606293,
    13.247752,
    0.03767,
    -0.409755,
    179.468521,
    12.368877,
    0.051804,
    -0.512051,
    167.955582,
    12.981333,
    0.068214,
    -0.601994,
    156.278793,
    12.704532,
    0.088295,
    -0.686849,
    143.096878,
    12.316531,
    0.111478,
    -0.75867,
    127.423111,
    11.793048,
    0.138336,
    -0.821348,
    111.763031,
    11.157992,
    0.168447,
    -0.873616,
    96.887924,
    10.447472,
    0.201411,
    -0.916322,
    83.225327,
    9.696606,
    0.237443,
    -0.95309,
    71.403137,
    8.949244,
    0.274234,
    -0.977751,
    60.739277,
    8.225874,
    0.314566,
    -1.003135,
    52.115578,
    7.547433,
    0.353932,
    -1.016312,
    44.341869,
    6.910326,
    0.393858,
    -1.024848,
    37.827263,
    6.324401,
    0.433805,
    -1.02895,
    32.380932,
    5.790555,
    0.475812,
    -1.034084,
    27.955982,
    5.312826,
    0.513254,
    -1.026743,
    23.977417,
    4.866118,
    0.549965,
    -1.01674,
    20.628025,
    4.468437,
    0.5903,
    -1.01203,
    18.036856,
    4.105483,
    0.62642,
    -0.998919,
    15.669224,
    3.780593,
    0.658897,
    -0.979874,
    13.603898,
    3.482054,
    0.687252,
    -0.955238,
    11.788331,
    3.211213,
    0.718941,
    -0.935663,
    10.355552,
    2.962083,
    0.749877,
    -0.915206,
    9.131123,
    2.741382,
    0.772094,
    -0.884837,
    7.973935,
    2.536501,
    0.799495,
    -0.861214,
    7.08623,
    2.347282,
    0.820136,
    -0.830976,
    6.240769,
    2.179332,
    0.846715,
    -0.807408,
    5.604792,
    2.018005,
    0.865176,
    -0.776657,
    4.975034,
    1.877021,
    0.8811,
    -0.744657,
    4.442767,
    1.743528,
    0.907637,
    -0.722088,
    4.035177,
    1.621563,
    0.922239,
    -0.690432,
    3.63316,
    1.506158,
    0.936558,
    -0.65965,
    3.281798,
    1.403606,
    0.950047,
    -0.629105,
    2.974179,
    1.304276,
    0.961959,
    -0.598277,
    2.704483,
    1.213888,
    0.98741,
    -0.576085,
    2.510453,
    1.125569,
    0.999996,
    -0.546494,
    2.304016,
    1.045567,
    1.014127,
    -0.518186,
    2.127867,
    0.970718,
    1.036275,
    -0.494009,
    1.985804,
    0.897557,
    1.049695,
    -0.465659,
    1.845074,
    0.830584,
    1.064617,
    -0.438159,
    1.72513,
    0.766083,
    1.077131,
    -0.409813,
    1.613818,
    0.705101,
    1.101054,
    -0.385632,
    1.528694,
    0.644828,
    1.122361,
    -0.360045,
    1.447086,
    0.587878,
    1.147359,
    -0.335186,
    1.377588,
    0.53213,
    1.169881,
    -0.30904,
    1.313673,
    0.478843,
    1.200554,
    -0.28459,
    1.257256,
    0.426855,
    1.232047,
    -0.259332,
    1.208431,
    0.376125,
    1.275402,
    -0.235215,
    1.174692,
    0.326614,
    1.306595,
    -0.207508,
    1.141042,
    0.281524,
    1.334304,
    -0.17829,
    1.111778,
    0.238694,
    1.364678,
    -0.14853,
    1.090976,
    0.198549,
    1.387168,
    -0.117114,
    1.069308,
    0.158529,
    1.408657,
    -0.084977,
    1.050625,
    0.118042,
    1.426214,
    -0.052052,
    1.031444,
    0.076541,
    1.444257,
    -0.018653,
    1.014298,
    0.034061,
    1.460618,
    0.015206,
    0.999413,
    -0.008132,
    1e-4,
    -0.002003,
    20.052612,
    20.032721,
    297e-6,
    -0.005947,
    59.540512,
    20.033842,
    0.002022,
    -0.040439,
    404.848511,
    20.032743,
    0.004588,
    -0.090999,
    403.741241,
    19.910591,
    0.008769,
    -0.169802,
    441.471558,
    19.572552,
    0.013708,
    -0.253629,
    411.667816,
    19.145721,
    0.020331,
    -0.349396,
    371.322571,
    18.591049,
    0.030259,
    -0.468121,
    385.816498,
    18.331083,
    0.04519,
    -0.611444,
    391.924133,
    15.807686,
    0.058476,
    -0.676875,
    319.638641,
    16.947781,
    0.079894,
    -0.781421,
    278.80426,
    17.512903,
    0.103871,
    -0.855116,
    235.999786,
    16.290295,
    0.131756,
    -0.915747,
    197.168076,
    14.956566,
    0.163487,
    -0.966333,
    163.452347,
    13.60801,
    0.198693,
    -1.008386,
    135.632706,
    12.299661,
    0.236157,
    -1.039862,
    111.919281,
    11.08879,
    0.274579,
    -1.059988,
    92.136581,
    9.983883,
    0.317164,
    -1.084069,
    77.063034,
    9.008505,
    0.357624,
    -1.092124,
    63.963051,
    8.127298,
    0.399009,
    -1.09756,
    53.483341,
    7.347628,
    0.441182,
    -1.100981,
    45.052429,
    6.658191,
    0.481606,
    -1.097318,
    37.93264,
    6.047333,
    0.524253,
    -1.09657,
    32.395638,
    5.505878,
    0.564351,
    -1.088739,
    27.67938,
    5.018494,
    0.600843,
    -1.073396,
    23.611519,
    4.58077,
    0.635527,
    -1.055024,
    20.207081,
    4.194785,
    0.672045,
    -1.039775,
    17.469036,
    3.847436,
    0.698372,
    -1.009545,
    14.928226,
    3.532546,
    0.729336,
    -0.987168,
    12.95317,
    3.248834,
    0.761147,
    -0.966299,
    11.346271,
    2.994166,
    0.78227,
    -0.932841,
    9.813129,
    2.762244,
    0.811832,
    -0.910431,
    8.672224,
    2.549933,
    0.832053,
    -0.878369,
    7.578633,
    2.363132,
    0.849383,
    -0.844673,
    6.648379,
    2.189266,
    0.86602,
    -0.811703,
    5.850784,
    2.031716,
    0.893083,
    -0.789181,
    5.273372,
    1.88448,
    0.909212,
    -0.757541,
    4.700618,
    1.750298,
    0.923169,
    -0.725157,
    4.19664,
    1.62759,
    0.937112,
    -0.693769,
    3.764841,
    1.514906,
    0.961901,
    -0.670828,
    3.444598,
    1.406839,
    0.975245,
    -0.64024,
    3.120745,
    1.307873,
    0.989696,
    -0.611032,
    2.840732,
    1.216417,
    1.002057,
    -0.581144,
    2.591596,
    1.132553,
    1.014022,
    -0.55162,
    2.37382,
    1.051695,
    1.025307,
    -0.522268,
    2.177992,
    0.9775,
    1.05219,
    -0.500826,
    2.042511,
    0.904301,
    1.064408,
    -0.472355,
    1.891934,
    0.837557,
    1.077876,
    -0.444815,
    1.761054,
    0.773004,
    1.088939,
    -0.416531,
    1.638939,
    0.713958,
    1.118551,
    -0.395057,
    1.555724,
    0.652485,
    1.134469,
    -0.368289,
    1.46549,
    0.59633,
    1.162778,
    -0.345095,
    1.390977,
    0.539703,
    1.185298,
    -0.319527,
    1.321225,
    0.48625,
    1.208419,
    -0.29359,
    1.259318,
    0.434178,
    1.261013,
    -0.273471,
    1.219767,
    0.382032,
    1.297811,
    -0.248226,
    1.176422,
    0.33419,
    1.326591,
    -0.220354,
    1.139881,
    0.289075,
    1.357918,
    -0.191937,
    1.111418,
    0.246259,
    1.38759,
    -0.162282,
    1.086511,
    0.205129,
    1.415797,
    -0.131515,
    1.067072,
    0.165601,
    1.440194,
    -0.099555,
    1.047799,
    0.125462,
    1.4656,
    -0.066957,
    1.030406,
    0.084082,
    1.487714,
    -0.033496,
    1.013889,
    0.041981,
    1.509947,
    663e-6,
    0.998773,
    -485e-6,
    1e-4,
    -0.004009,
    40.102047,
    40.087105,
    228e-6,
    -0.009141,
    91.431366,
    40.074432,
    0.001522,
    -0.060544,
    605.651733,
    39.918827,
    0.004919,
    -0.188871,
    1712.9823,
    38.873421,
    0.009053,
    -0.320325,
    1583.453125,
    39.715633,
    0.015375,
    -0.471415,
    1486.033691,
    39.162876,
    0.029306,
    -0.735111,
    1751.70105,
    28.0832,
    0.04345,
    -0.859759,
    1392.47522,
    24.599945,
    0.079075,
    -1.220033,
    1629.972656,
    18.507019,
    0.09013,
    -1.091255,
    940.347351,
    17.961655,
    0.098008,
    -0.945965,
    425.901093,
    24.47801,
    0.138246,
    -1.084105,
    416.823944,
    20.003433,
    0.174489,
    -1.133148,
    302.730042,
    18.550846,
    0.207969,
    -1.138483,
    242.853577,
    15.923334,
    0.249132,
    -1.168197,
    191.649445,
    13.940813,
    0.291391,
    -1.187038,
    152.910309,
    12.263267,
    0.332856,
    -1.192793,
    121.905075,
    10.822873,
    0.377473,
    -1.202846,
    99.145561,
    9.618412,
    0.422601,
    -1.208871,
    81.343315,
    8.591735,
    0.465276,
    -1.204545,
    66.742569,
    7.692911,
    0.50471,
    -1.190839,
    54.787876,
    6.915612,
    0.544909,
    -1.178827,
    45.507313,
    6.242786,
    0.582125,
    -1.16059,
    37.819912,
    5.65169,
    0.620694,
    -1.145481,
    31.926588,
    5.12366,
    0.659127,
    -1.130178,
    27.14731,
    4.669475,
    0.684358,
    -1.093728,
    22.650702,
    4.258717,
    0.719453,
    -1.074591,
    19.454103,
    3.901225,
    0.751695,
    -1.051678,
    16.735672,
    3.57687,
    0.775082,
    -1.017716,
    14.281039,
    3.287471,
    0.796233,
    -0.982759,
    12.261332,
    3.023708,
    0.827404,
    -0.961227,
    10.767912,
    2.78774,
    0.848149,
    -0.928433,
    9.37135,
    2.570737,
    0.864891,
    -0.892838,
    8.142364,
    2.379204,
    0.880979,
    -0.858193,
    7.118954,
    2.20447,
    0.910434,
    -0.837281,
    6.389041,
    2.041554,
    0.925396,
    -0.803638,
    5.643217,
    1.893353,
    0.942463,
    -0.772925,
    5.031223,
    1.757331,
    0.955217,
    -0.73972,
    4.486978,
    1.633572,
    0.96857,
    -0.708048,
    4.014621,
    1.520414,
    0.981672,
    -0.677109,
    3.617768,
    1.412506,
    0.992829,
    -0.645712,
    3.258773,
    1.317079,
    1.02127,
    -0.625746,
    3.00664,
    1.222611,
    1.031247,
    -0.594628,
    2.733073,
    1.137911,
    1.043581,
    -0.56554,
    2.498495,
    1.058439,
    1.05593,
    -0.536962,
    2.289843,
    0.984428,
    1.066727,
    -0.508076,
    2.108603,
    0.912794,
    1.081225,
    -0.481297,
    1.951454,
    0.845536,
    1.088198,
    -0.451563,
    1.801891,
    0.782718,
    1.123316,
    -0.433247,
    1.704316,
    0.721664,
    1.133206,
    -0.404812,
    1.586153,
    0.662761,
    1.152889,
    -0.379901,
    1.490958,
    0.606866,
    1.188158,
    -0.359421,
    1.41573,
    0.550666,
    1.217064,
    -0.336049,
    1.344172,
    0.496748,
    1.257727,
    -0.314816,
    1.283196,
    0.443538,
    1.286647,
    -0.28953,
    1.225903,
    0.394018,
    1.308729,
    -0.262053,
    1.173928,
    0.346255,
    1.351453,
    -0.237704,
    1.139992,
    0.300393,
    1.380284,
    -0.209733,
    1.105997,
    0.256661,
    1.414621,
    -0.181613,
    1.082109,
    0.215429,
    1.453045,
    -0.152797,
    1.063853,
    0.177098,
    1.481066,
    -0.121803,
    1.043185,
    0.137203,
    1.514113,
    -0.09025,
    1.027072,
    0.096998,
    1.547317,
    -0.057603,
    1.012551,
    0.055328,
    1.577983,
    -0.023799,
    0.999267,
    0.013094,
    108e-6,
    -0.12497,
    1249.704346,
    1249.703491,
    14e-5,
    -0.119585,
    1195.855469,
    1195.85437,
    0.003995,
    -0.927433,
    9274.246094,
    232.443573,
    0.012013,
    -1.13158,
    11315.999023,
    98.211105,
    0.023892,
    -1.216018,
    12162.739258,
    67.2145,
    0.047506,
    -1.517865,
    15186.294922,
    42.410069,
    0.082523,
    -1.812564,
    18145.71875,
    24.421545,
    0.112452,
    -1.805072,
    11112.966797,
    18.450365,
    0.16446,
    -2.016784,
    8086.032715,
    14.043465,
    0.19587,
    -1.898199,
    4245.658203,
    13.178202,
    0.197797,
    -1.556158,
    1315.561768,
    30.760096,
    0.21954,
    -1.433455,
    802.380371,
    25.037956,
    0.268696,
    -1.483235,
    579.715515,
    20.975695,
    0.265968,
    -1.261051,
    386.583649,
    12.017023,
    0.325369,
    -1.343349,
    316.795959,
    12.612406,
    0.387968,
    -1.411606,
    232.491623,
    13.29694,
    0.435543,
    -1.411236,
    181.515228,
    11.646996,
    0.482729,
    -1.405722,
    143.425354,
    10.265131,
    0.531742,
    -1.402782,
    114.920082,
    9.114828,
    0.559383,
    -1.346165,
    88.589005,
    8.089214,
    0.607851,
    -1.342407,
    73.05661,
    7.249064,
    0.656928,
    -1.338238,
    60.826897,
    6.531094,
    0.681212,
    -1.285692,
    48.727219,
    5.868711,
    0.729238,
    -1.279951,
    41.256016,
    5.324553,
    0.751172,
    -1.230045,
    33.72826,
    4.816513,
    0.773107,
    -1.184288,
    27.913816,
    4.377203,
    0.815726,
    -1.171653,
    24.065962,
    3.999965,
    0.837886,
    -1.130636,
    20.25486,
    3.658493,
    0.857674,
    -1.089071,
    17.138168,
    3.34793,
    0.87612,
    -1.048303,
    14.572968,
    3.072666,
    0.893935,
    -1.00904,
    12.496377,
    2.825165,
    0.927998,
    -0.989064,
    11.040731,
    2.60552,
    0.928445,
    -0.935017,
    9.365102,
    2.401481,
    0.945279,
    -0.899993,
    8.177711,
    2.222282,
    0.959378,
    -0.863854,
    7.155303,
    2.059342,
    0.971761,
    -0.827684,
    6.284632,
    1.909314,
    0.987812,
    -0.795878,
    5.583837,
    1.771094,
    1.001958,
    -0.76354,
    4.962345,
    1.645968,
    1.014357,
    -0.730897,
    4.435898,
    1.527438,
    1.025946,
    -0.698675,
    3.973241,
    1.421337,
    1.036435,
    -0.666662,
    3.568025,
    1.323677,
    1.046807,
    -0.635466,
    3.218647,
    1.232678,
    1.052974,
    -0.60266,
    2.902273,
    1.147675,
    1.086089,
    -0.585364,
    2.694939,
    1.068352,
    1.09466,
    -0.554784,
    2.454491,
    0.993445,
    1.117131,
    -0.5315,
    2.270746,
    0.923758,
    1.114009,
    -0.496581,
    2.063934,
    0.858381,
    1.137328,
    -0.473914,
    1.91799,
    0.79498,
    1.158671,
    -0.450127,
    1.786523,
    0.735697,
    1.177878,
    -0.425306,
    1.662454,
    0.677498,
    1.20751,
    -0.403797,
    1.559058,
    0.621762,
    1.244496,
    -0.383812,
    1.466801,
    0.56619,
    1.240412,
    -0.35108,
    1.366853,
    0.514288,
    1.321257,
    -0.3412,
    1.309808,
    0.464621,
    1.336512,
    -0.31271,
    1.241822,
    0.413228,
    1.365047,
    -0.286935,
    1.186612,
    0.366092,
    1.418984,
    -0.265184,
    1.15212,
    0.321528,
    1.388864,
    -0.22775,
    1.089937,
    0.271827,
    1.464383,
    -0.207168,
    1.077271,
    0.232838,
    1.473125,
    -0.17577,
    1.041835,
    0.193289,
    1.542908,
    -0.150424,
    1.036794,
    0.156153,
    1.563005,
    -0.118748,
    1.013029,
    0.114866,
    1.637048,
    -0.089604,
    1.013493,
    0.076804,
    1.670777,
    -0.056398,
    0.999208,
    0.032691,
  ]),
  (XG.PolyLight.ltcMagData = [
    1,
    4.9723599302549885e-34,
    1,
    8.871365657047213e-24,
    1,
    9.253802688709342e-18,
    1,
    2.998832735953694e-14,
    1,
    8.825863651029664e-12,
    0.9999993443489075,
    6.643000594053206e-10,
    0.9999925494194031,
    1.9913889204303814e-8,
    0.9999614953994751,
    2.984031084451999e-7,
    0.9998213648796082,
    2561353085184237e-21,
    0.9988022446632385,
    13457865861710161e-21,
    0.9795094728469849,
    11896545402123593e-22,
    0.9785933494567871,
    5169624273548834e-21,
    0.9750710129737854,
    16189613234018907e-21,
    0.95542311668396,
    9889836292131804e-21,
    0.9470353722572327,
    2295730882906355e-20,
    0.9251033067703247,
    21790827304357663e-21,
    0.9039908051490784,
    30495604733005166e-21,
    0.8773829340934753,
    351582420989871e-19,
    0.8458513617515564,
    38647187466267496e-21,
    0.8101488947868347,
    41614777728682384e-21,
    0.7705395221710205,
    4331504533183761e-20,
    0.7285891175270081,
    4555909617920406e-20,
    0.6844283938407898,
    47463865485042334e-21,
    0.6383334398269653,
    4731946319225244e-20,
    0.5921696424484253,
    47633071517338976e-21,
    0.5460947155952454,
    46813282096991315e-21,
    0.500735342502594,
    4492110019782558e-20,
    0.45738598704338074,
    434852008766029e-19,
    0.4160003960132599,
    4142210673308e-17,
    0.37686944007873535,
    3876877963193692e-20,
    0.3404451310634613,
    36174835258862004e-21,
    0.3069041669368744,
    33757041819626465e-21,
    1,
    3.484353461275869e-15,
    1,
    3.676718455245583e-15,
    1,
    1.2571829868638935e-14,
    1,
    6.409696449820312e-13,
    0.9999998807907104,
    3.9094654596949496e-11,
    0.9999992251396179,
    1.4388235047846365e-9,
    0.9999923706054688,
    3.060469211391137e-8,
    0.9999598860740662,
    3.86157296361489e-7,
    0.9998152256011963,
    30248768325691344e-22,
    0.9986841082572937,
    14877443391014822e-21,
    0.9957596659660339,
    5883387530047912e-21,
    0.9906166195869446,
    1118690943258116e-20,
    0.9820987582206726,
    2040820982074365e-20,
    0.9651585817337036,
    25617177016101778e-21,
    0.9424709677696228,
    14907192962709814e-21,
    0.929432213306427,
    22906311642145738e-21,
    0.9093611240386963,
    3298077717772685e-20,
    0.8809629678726196,
    424117170041427e-19,
    0.8440450429916382,
    4300312866689637e-20,
    0.8062857985496521,
    38192250940483063e-21,
    0.7707816958427429,
    4511761653702706e-20,
    0.7289775609970093,
    4817411536350846e-20,
    0.6849337220191956,
    5019790114602074e-20,
    0.6383635997772217,
    5059950490249321e-20,
    0.5916448831558228,
    48434238124173135e-21,
    0.5462520122528076,
    49303402192890644e-21,
    0.5007233619689941,
    46784385631326586e-21,
    0.4574684202671051,
    45121712901163846e-21,
    0.41607901453971863,
    4273800732335076e-20,
    0.3770703971385956,
    4004369839094579e-20,
    0.34077027440071106,
    3741792534128763e-20,
    0.30720973014831543,
    34707252780208364e-21,
    1,
    3.555587031398022e-12,
    1,
    3.6016847056868917e-12,
    1,
    4.555361296509908e-12,
    0.9999998807907104,
    1.8482996383406558e-11,
    0.9999998807907104,
    2.962420586616332e-10,
    0.999998927116394,
    5.3636171060134075e-9,
    0.999991238117218,
    7.324008777231938e-8,
    0.9999642372131348,
    5.106547291688912e-7,
    0.9996134042739868,
    26343850549892522e-22,
    0.998034656047821,
    2950551561298198e-21,
    0.9957220554351807,
    7269138677656883e-21,
    0.9905380606651306,
    13763788047072012e-21,
    0.9819369316101074,
    2431732718832791e-20,
    0.9648937582969666,
    29587748940684833e-21,
    0.9423127174377441,
    17692509572952986e-21,
    0.9292111396789551,
    2705379665712826e-20,
    0.9090583920478821,
    3848519190796651e-20,
    0.8805898427963257,
    4879530388279818e-20,
    0.8436343669891357,
    4946756234858185e-20,
    0.8059477806091309,
    44421936763683334e-21,
    0.770418107509613,
    5189147123019211e-20,
    0.7286810874938965,
    55194806918734685e-21,
    0.6847314834594727,
    56741271691862494e-21,
    0.638262927532196,
    57250112149631605e-21,
    0.5917738676071167,
    5477243030327372e-20,
    0.5463683605194092,
    5509306356543675e-20,
    0.5011235475540161,
    5246519867796451e-20,
    0.45787563920021057,
    5003271871828474e-20,
    0.4166870713233948,
    4757062197313644e-20,
    0.3777269124984741,
    4410088149597868e-20,
    0.34149447083473206,
    41352835978614166e-21,
    0.3078345060348511,
    37733345379820094e-21,
    1,
    2.0392437738436797e-10,
    1,
    2.050830338884424e-10,
    1,
    2.2526711052073267e-10,
    0.9999998807907104,
    3.883267596371809e-10,
    0.9999998211860657,
    1.9945427531808946e-9,
    0.9999982714653015,
    1.9617473867583612e-8,
    0.9999914765357971,
    8.676927620854258e-8,
    0.9999576210975647,
    6.843680466772639e-7,
    0.9995915293693542,
    32147545425686985e-22,
    0.9979994297027588,
    4158150204602862e-21,
    0.9956579804420471,
    997109691525111e-20,
    0.9904067516326904,
    1862859062384814e-20,
    0.9816834926605225,
    31560084607917815e-21,
    0.9644421935081482,
    3663621100713499e-20,
    0.9420456886291504,
    23040682208375074e-21,
    0.9288370013237,
    3486980858724564e-20,
    0.9085549116134644,
    48680340114515275e-21,
    0.8799675703048706,
    6045426562195644e-20,
    0.8429601788520813,
    6116852455306798e-20,
    0.8053827881813049,
    55800206610001624e-21,
    0.7698301076889038,
    6418847624445334e-20,
    0.7282079458236694,
    6779727118555456e-20,
    0.6843969821929932,
    6844157906016335e-20,
    0.6381362080574036,
    6908563227625564e-20,
    0.5919710397720337,
    6608713010791689e-20,
    0.546595573425293,
    6525012577185407e-20,
    0.5017878413200378,
    6249842408578843e-20,
    0.45859867334365845,
    5843830876983702e-20,
    0.41762855648994446,
    5582111407420598e-20,
    0.3787376880645752,
    5128803240950219e-20,
    0.3427509665489197,
    4793655170942657e-20,
    0.3091078996658325,
    4390078902360983e-20,
    1,
    3.5941150056117976e-9,
    1,
    3.6055098906473404e-9,
    0.9999998807907104,
    3.7921492612724705e-9,
    0.9999998807907104,
    4.9590247463981996e-9,
    0.9999995827674866,
    1.2430871443314118e-8,
    0.9999980330467224,
    2.8987333422492156e-8,
    0.9999876022338867,
    1.743084965255548e-7,
    0.9999457001686096,
    10401091685707797e-22,
    0.9995582103729248,
    4292543962947093e-21,
    0.9979528188705444,
    63808747654547915e-22,
    0.9955669641494751,
    14677651051897556e-21,
    0.9902148246765137,
    26741456167655997e-21,
    0.9813223481178284,
    4322859240346588e-20,
    0.9637941122055054,
    4751081360154785e-20,
    0.9416635036468506,
    3217334233340807e-20,
    0.9283020496368408,
    4786436693393625e-20,
    0.9078357219696045,
    6520551687572151e-20,
    0.8790907263755798,
    7903506048023701e-20,
    0.842024028301239,
    7966245175339282e-20,
    0.8045891523361206,
    7394397107418627e-20,
    0.7690172791481018,
    835330574773252e-19,
    0.7275615334510803,
    873752505867742e-19,
    0.6839832663536072,
    8674211130710319e-20,
    0.6380016803741455,
    8727407112019137e-20,
    0.5922262072563171,
    8344028901774436e-20,
    0.5470587611198425,
    8089735638350248e-20,
    0.5026577115058899,
    7756722334306687e-20,
    0.45977509021759033,
    7220609404612333e-20,
    0.41891151666641235,
    6785998266423121e-20,
    0.3802843391895294,
    626364562776871e-19,
    0.3443710207939148,
    57524121075402945e-21,
    0.31088417768478394,
    525497853232082e-19,
    1,
    3.315136254400386e-8,
    1,
    3.321820329915681e-8,
    0.9999998807907104,
    3.428135997296522e-8,
    0.9999998807907104,
    4.0122937861042374e-8,
    0.9999993443489075,
    6.884137349061348e-8,
    0.999997079372406,
    1.153320567937044e-7,
    0.9999822378158569,
    4.1366322989233595e-7,
    0.9999264478683472,
    17887547301143059e-22,
    0.9995124936103821,
    62861768128641415e-22,
    0.9978879690170288,
    10372253200330306e-21,
    0.9954444169998169,
    2259549728478305e-20,
    0.9899566173553467,
    39708666008664295e-21,
    0.9808306694030762,
    6105979991843924e-20,
    0.9629612565040588,
    6358415703289211e-20,
    0.9411571025848389,
    4716955663752742e-20,
    0.927593469619751,
    6851855869172141e-20,
    0.906886637210846,
    9070617670658976e-20,
    0.8779544830322266,
    0.00010712965740822256,
    0.8408229351043701,
    0.00010736460535554215,
    0.8035710453987122,
    0.0001013750588754192,
    0.7679961323738098,
    0.00011226818605791777,
    0.7267556190490723,
    0.00011612738308031112,
    0.6835330724716187,
    0.0001139894375228323,
    0.6378693580627441,
    0.00011361506039975211,
    0.5925200581550598,
    0.00010833039414137602,
    0.5477656722068787,
    0.00010326132905902341,
    0.5037316679954529,
    9865148604148999e-20,
    0.4612429141998291,
    9166631934931502e-20,
    0.4206485450267792,
    8449579763691872e-20,
    0.38223329186439514,
    7804275082889944e-20,
    0.34656456112861633,
    718433948350139e-19,
    0.3131188154220581,
    6461292650783435e-20,
    1,
    2.028580752266862e-7,
    1,
    2.0313970594543207e-7,
    0.9999998807907104,
    2.0755510377057362e-7,
    0.9999998807907104,
    2.3010673544376914e-7,
    0.9999992251396179,
    2.752639431946591e-7,
    0.9999939203262329,
    4.518161915711971e-7,
    0.9999713897705078,
    10922479987129918e-22,
    0.9998999238014221,
    3428180207265541e-21,
    0.9994540810585022,
    10047225259768311e-21,
    0.9978080987930298,
    1752028038026765e-20,
    0.9952890872955322,
    35787354136118665e-21,
    0.9896163940429688,
    6013278471073136e-20,
    0.9801874756813049,
    877630736795254e-19,
    0.9619150161743164,
    8684329077368602e-20,
    0.9405182600021362,
    7141684181988239e-20,
    0.9266974329948425,
    0.00010072087025037035,
    0.9056936502456665,
    0.0001292046217713505,
    0.8765460848808289,
    0.00014860687952023,
    0.8393606543540955,
    0.00014789306442253292,
    0.802323043346405,
    0.0001417738531017676,
    0.766758918762207,
    0.0001538011129014194,
    0.7258138060569763,
    0.00015715895278844982,
    0.6830078959465027,
    0.000152826018165797,
    0.6377876996994019,
    0.00015078099386300892,
    0.5928740501403809,
    0.0001430046686436981,
    0.5487264394760132,
    0.00013505709648597986,
    0.5050747394561768,
    0.00012746566790156066,
    0.4630185663700104,
    0.00011816729238489643,
    0.4228866696357727,
    0.00010843645577551797,
    0.3846159279346466,
    9818199760047719e-20,
    0.3492530882358551,
    9076905553229153e-20,
    0.3159977197647095,
    81846650573425e-18,
    1,
    9.345664579996082e-7,
    1,
    9.355123324894521e-7,
    0.9999998807907104,
    9.501987960902625e-7,
    0.9999998211860657,
    10219027899438515e-22,
    0.9999986290931702,
    11567085493879858e-22,
    0.9999909400939941,
    16173099766092491e-22,
    0.9999564290046692,
    298959616884531e-20,
    0.9998655319213867,
    7109597845555982e-21,
    0.9993844032287598,
    1730209078232292e-20,
    0.9977094531059265,
    30375405913218856e-21,
    0.9950905442237854,
    5776531179435551e-20,
    0.9891849756240845,
    9219977800967172e-20,
    0.9793606400489807,
    0.00012746801075991243,
    0.9606325030326843,
    0.00012038017302984372,
    0.9397254586219788,
    0.00011030882888007909,
    0.9255924820899963,
    0.00015041654114611447,
    0.9042379856109619,
    0.00018665830430109054,
    0.8748508095741272,
    0.0002090869384119287,
    0.8376354575157166,
    0.00020647814380936325,
    0.8008498549461365,
    0.00020041796960867941,
    0.7653152346611023,
    0.00021292836754582822,
    0.7247453331947327,
    0.0002148216444766149,
    0.6824364066123962,
    0.00020713670528493822,
    0.6377478241920471,
    0.00020206280169077218,
    0.5933591723442078,
    0.00019054950098507106,
    0.5499100685119629,
    0.00017878308426588774,
    0.5066502690315247,
    0.00016553698515053838,
    0.46514052152633667,
    0.00015346206782851368,
    0.42561981081962585,
    0.00014112971257418394,
    0.38764286041259766,
    0.0001266445469809696,
    0.3523785173892975,
    0.0001141603133874014,
    0.31935131549835205,
    0.00010346704948460683,
    1,
    3495762484817533e-21,
    1,
    34984550438821316e-22,
    0.9999998807907104,
    3539881845426862e-21,
    0.9999995827674866,
    37362340208346723e-22,
    0.9999979734420776,
    4087012257514289e-21,
    0.9999836683273315,
    5188031536818016e-21,
    0.9999328255653381,
    8041374712774996e-21,
    0.9998289346694946,
    15386283848783933e-21,
    0.9993001818656921,
    3149425538140349e-20,
    0.9975883960723877,
    53596031648339704e-21,
    0.9948448538780212,
    9449828212382272e-20,
    0.9886416792869568,
    0.00014262743934523314,
    0.9783145785331726,
    0.00018643679504748434,
    0.9591134786605835,
    0.000169582839589566,
    0.9387755990028381,
    0.00017240847228094935,
    0.92425537109375,
    0.00022653627092950046,
    0.9024949073791504,
    0.0002717370225582272,
    0.8728576302528381,
    0.00029659003484994173,
    0.8356517553329468,
    0.00029074528720229864,
    0.799156129360199,
    0.00028466666117310524,
    0.7636834979057312,
    0.0002963131701108068,
    0.7235600352287292,
    0.0002950532070826739,
    0.6818390488624573,
    0.0002820825029630214,
    0.6377801895141602,
    0.0002719080075621605,
    0.5940210223197937,
    0.0002549737982917577,
    0.5513138771057129,
    0.00023767948732711375,
    0.5085931420326233,
    0.00021696648036595434,
    0.46760013699531555,
    0.00019950199930462986,
    0.4287278950214386,
    0.00018330931197851896,
    0.39123567938804626,
    0.00016490917187184095,
    0.35627874732017517,
    0.00014828784333076328,
    0.32335159182548523,
    0.00013188539014663547,
    1,
    11146606993861496e-21,
    1,
    11153327250212897e-21,
    0.9999998807907104,
    11256202014919836e-21,
    0.9999995827674866,
    11566048669919837e-21,
    0.9999958276748657,
    12548099221021403e-21,
    0.9999750852584839,
    14970674783398863e-21,
    0.9999067187309265,
    2064961699943524e-20,
    0.9997859597206116,
    33625008654780686e-21,
    0.9992002844810486,
    59298097767168656e-21,
    0.9974387884140015,
    9556706208968535e-20,
    0.9945343732833862,
    0.00015605863882228732,
    0.9879552721977234,
    0.00022214680211618543,
    0.9770373106002808,
    0.0002748904225882143,
    0.9573721885681152,
    0.00024368167214561254,
    0.9376460909843445,
    0.0002709526161197573,
    0.9226574301719666,
    0.00034227679134346545,
    0.9004448056221008,
    0.0003969359095208347,
    0.8705503940582275,
    0.0004225193988531828,
    0.8334026336669922,
    0.0004111567104700953,
    0.7972437739372253,
    0.0004045880923513323,
    0.761879026889801,
    0.0004128344589844346,
    0.7222740054130554,
    0.00040566097595728934,
    0.6812437176704407,
    0.0003847752814181149,
    0.6378998756408691,
    0.0003661027003545314,
    0.5948634147644043,
    0.0003410204080864787,
    0.5529966950416565,
    0.00031651140307076275,
    0.5110486149787903,
    0.00028767294134013355,
    0.47047552466392517,
    0.00025893637211993337,
    0.4322490692138672,
    0.00023695049458183348,
    0.39531901478767395,
    0.00021366923465393484,
    0.36068305373191833,
    0.0001916612673085183,
    0.3280943036079407,
    0.00017114455113187432,
    1,
    313225100398995e-19,
    1,
    313375931000337e-19,
    0.9999998807907104,
    3156844832119532e-20,
    0.9999995231628418,
    3224074680474587e-20,
    0.9999942183494568,
    34340238926233724e-21,
    0.9999635815620422,
    3928444129996933e-20,
    0.9998784065246582,
    5004906779504381e-20,
    0.9997355341911316,
    7247707253554836e-20,
    0.9990777373313904,
    0.00011317530879750848,
    0.99725741147995,
    0.00017103416030295193,
    0.9941516518592834,
    0.00025919973268173635,
    0.9871675968170166,
    0.00034929794492200017,
    0.9754965901374817,
    0.0004084361426066607,
    0.9554405212402344,
    0.0003582572389859706,
    0.9362972378730774,
    0.00042549887439236045,
    0.9207638502120972,
    0.000516805041115731,
    0.8980605602264404,
    0.0005799091886729002,
    0.8679356575012207,
    0.0006031727534718812,
    0.8309044241905212,
    0.0005826879059895873,
    0.795112133026123,
    0.0005737107712775469,
    0.759913980960846,
    0.0005742605426348746,
    0.7209106087684631,
    0.0005569281638599932,
    0.6806814670562744,
    0.0005242460174486041,
    0.6381562948226929,
    0.0004924500244669616,
    0.5959593057632446,
    0.0004556169151328504,
    0.5549776554107666,
    0.00042054057121276855,
    0.5139293670654297,
    0.0003811741480603814,
    0.47398316860198975,
    0.00034024062915705144,
    0.43628886342048645,
    0.0003061612951569259,
    0.399902880191803,
    0.0002744085795711726,
    0.3656311631202698,
    0.0002456617949064821,
    0.333377480506897,
    0.00021885032765567303,
    1,
    7942884258227423e-20,
    0.9999998807907104,
    7946020923554897e-20,
    0.9999998807907104,
    7993690087459981e-20,
    0.9999988079071045,
    8127414912451059e-20,
    0.999991774559021,
    8541991701349616e-20,
    0.999937891960144,
    948517772485502e-19,
    0.999845027923584,
    0.00011427410936448723,
    0.9996801614761353,
    0.00015192673890851438,
    0.9989284873008728,
    0.00021545625349972397,
    0.9970328211784363,
    0.0003051866660825908,
    0.9936702847480774,
    0.0004312041273806244,
    0.9861934781074524,
    0.0005509073962457478,
    0.9735866189002991,
    0.0006089170346967876,
    0.9534494876861572,
    0.0005429650191217661,
    0.9346889853477478,
    0.0006651540170423687,
    0.9185329079627991,
    0.0007774252444505692,
    0.8953306674957275,
    0.0008457021904177964,
    0.8649731278419495,
    0.0008597435662522912,
    0.8281720876693726,
    0.0008257927838712931,
    0.7928025722503662,
    0.0008103349828161299,
    0.7578296661376953,
    0.0007963153184391558,
    0.7195484638214111,
    0.0007630019681528211,
    0.6802068948745728,
    0.0007120147929526865,
    0.6385806798934937,
    0.0006603786023333669,
    0.5973770022392273,
    0.0006074856501072645,
    0.557275652885437,
    0.0005564765306189656,
    0.5172183513641357,
    0.0005025688442401588,
    0.4781257212162018,
    0.0004483155207708478,
    0.4410014748573303,
    0.0004001616616733372,
    0.4051946699619293,
    0.0003555190342012793,
    0.3711559474468231,
    0.000313900934997946,
    0.3393208086490631,
    0.000278926600003615,
    1,
    0.00018497688870411366,
    0.9999998807907104,
    0.00018503708997741342,
    0.9999998807907104,
    0.0001859551848610863,
    0.9999986290931702,
    0.00018842339341063052,
    0.9999825954437256,
    0.00019606415298767388,
    0.999917209148407,
    0.00021299757645465434,
    0.9998063445091248,
    0.00024639617186039686,
    0.9996086955070496,
    0.00030754972249269485,
    0.9987448453903198,
    0.00040451722452417016,
    0.9967576265335083,
    0.0005396826309151947,
    0.9930658340454102,
    0.0007153602782636881,
    0.9849414825439453,
    0.0008673097472637892,
    0.9712895750999451,
    0.0009115047287195921,
    0.9519128799438477,
    0.0008648194489069283,
    0.9327709674835205,
    0.0010319059947505593,
    0.9159188270568848,
    0.0011622296879068017,
    0.8922213912010193,
    0.0012280362425372005,
    0.8616902232170105,
    0.0012228479608893394,
    0.8252346515655518,
    0.0011685527861118317,
    0.7903201580047607,
    0.0011380502255633473,
    0.7556473612785339,
    0.0010988099966198206,
    0.7182032465934753,
    0.0010407502995803952,
    0.6798734664916992,
    0.0009630543645471334,
    0.6392568945884705,
    0.0008829478174448013,
    0.5991494059562683,
    0.0008068376337178051,
    0.5599762201309204,
    0.000732983578927815,
    0.5210378170013428,
    0.0006603185320273042,
    0.48287108540534973,
    0.0005880913231521845,
    0.44637465476989746,
    0.000522624934092164,
    0.41127538681030273,
    0.0004637721576727927,
    0.3776545524597168,
    0.00040908646769821644,
    0.3461458086967468,
    0.00036203028867021203,
    1,
    0.0004009077965747565,
    0.9999998807907104,
    0.0004010170523542911,
    0.9999998807907104,
    0.0004026854585390538,
    0.9999982714653015,
    0.000406946666771546,
    0.9999787211418152,
    0.0004201953997835517,
    0.9998985528945923,
    0.0004489627026487142,
    0.9997645616531372,
    0.0005038040108047426,
    0.9995216727256775,
    0.0005996969412080944,
    0.9985226392745972,
    0.0007436821470037103,
    0.9964115023612976,
    0.000941126374527812,
    0.9922924637794495,
    0.00117833586409688,
    0.9833220839500427,
    0.0013582039391621947,
    0.9685819149017334,
    0.0013688340550288558,
    0.9503327012062073,
    0.0013813228579238057,
    0.9304899573326111,
    0.0015847831964492798,
    0.9128994941711426,
    0.0017245045164600015,
    0.8886758089065552,
    0.0017711715772747993,
    0.8580658435821533,
    0.0017315082950517535,
    0.8222084045410156,
    0.0016523832455277443,
    0.7876880764961243,
    0.001587021630257368,
    0.7534105777740479,
    0.0015069965738803148,
    0.7169104218482971,
    0.0014114828081801534,
    0.6797063946723938,
    0.0012949994998052716,
    0.6402789354324341,
    0.0011761130299419165,
    0.6013129949569702,
    0.0010653268545866013,
    0.5630807280540466,
    0.0009596236050128937,
    0.5253864526748657,
    0.000862580316606909,
    0.4882074296474457,
    0.0007652285858057439,
    0.4523884654045105,
    0.0006779665709473193,
    0.41806817054748535,
    0.0006002774462103844,
    0.38496294617652893,
    0.0005286975065246224,
    0.353765070438385,
    0.0004661277635022998,
    1,
    0.0008170487126335502,
    0.9999998807907104,
    0.0008172377711161971,
    0.9999998211860657,
    0.0008201166056096554,
    0.9999958872795105,
    0.000827036565169692,
    0.9999712705612183,
    0.0008487752638757229,
    0.999868631362915,
    0.0008952107164077461,
    0.999718964099884,
    0.000981343211606145,
    0.9994185566902161,
    0.0011263363994657993,
    0.9982463121414185,
    0.001333469757810235,
    0.9959758520126343,
    0.0016124547692015767,
    0.9912904500961304,
    0.0019195264903828502,
    0.9813029170036316,
    0.002113644964993,
    0.9654432535171509,
    0.002058587968349457,
    0.9484148621559143,
    0.0021744167897850275,
    0.9277746081352234,
    0.002404476050287485,
    0.9094065427780151,
    0.00253373384475708,
    0.8847052454948425,
    0.002535954350605607,
    0.8541228771209717,
    0.0024380881804972887,
    0.819056510925293,
    0.002323688007891178,
    0.7849671244621277,
    0.0021957301069051027,
    0.7511888742446899,
    0.0020529241301119328,
    0.7157456278800964,
    0.0019018709426745772,
    0.6798288822174072,
    0.0017322935163974762,
    0.6417125463485718,
    0.0015609883703291416,
    0.6039620637893677,
    0.0013985446421429515,
    0.5667142868041992,
    0.001250682515092194,
    0.5302678942680359,
    0.0011172611266374588,
    0.4942619204521179,
    0.0009905664483085275,
    0.4590606093406677,
    0.0008704899810254574,
    0.42557626962661743,
    0.0007690446218475699,
    0.39304670691490173,
    0.0006750519969500601,
    0.36205917596817017,
    0.0005897301016375422,
    1,
    0.0015786398435011506,
    0.9999998807907104,
    0.001578951021656394,
    0.9999997019767761,
    0.0015837071696296334,
    0.9999949932098389,
    0.0015943063190206885,
    0.9999446272850037,
    0.0016281814314424992,
    0.9998370409011841,
    0.001699594664387405,
    0.9996569156646729,
    0.0018291180022060871,
    0.999291181564331,
    0.002040265128016472,
    0.9979047775268555,
    0.002327719470486045,
    0.9954121112823486,
    0.002707430860027671,
    0.9899663329124451,
    0.003081965958699584,
    0.9786978363990784,
    0.0032518126536160707,
    0.9620490074157715,
    0.0031087531242519617,
    0.9460811614990234,
    0.0033676314633339643,
    0.9245449304580688,
    0.0035980006214231253,
    0.9053626656532288,
    0.003679088316857815,
    0.8802715539932251,
    0.0035975826904177666,
    0.8499215841293335,
    0.0034114234149456024,
    0.8157170414924622,
    0.003235634183511138,
    0.7822147011756897,
    0.0030118071008473635,
    0.7490512728691101,
    0.002775391563773155,
    0.7148115038871765,
    0.0025447786320000887,
    0.6803180575370789,
    0.00230251788161695,
    0.643667995929718,
    0.0020621786825358868,
    0.6072387099266052,
    0.0018297929782420397,
    0.5708948969841003,
    0.0016184179112315178,
    0.5358534455299377,
    0.00143984064925462,
    0.500960111618042,
    0.0012685820693150163,
    0.466646283864975,
    0.0011119474656879902,
    0.4337874948978424,
    0.0009760607499629259,
    0.4019894599914551,
    0.0008569401688873768,
    0.3714294731616974,
    0.0007520686485804617,
    1,
    0.0029108307790011168,
    0.9999998807907104,
    0.0029113292694091797,
    0.9999995827674866,
    0.0029188790358603,
    0.9999939203262329,
    0.0029341757763177156,
    0.9999232292175293,
    0.002984406426548958,
    0.9997974634170532,
    0.0030891753267496824,
    0.9995762705802917,
    0.0032756298314779997,
    0.9991302490234375,
    0.003571221837773919,
    0.9974761009216309,
    0.003953914158046246,
    0.9946742057800293,
    0.0044480860233306885,
    0.9882583022117615,
    0.004869313444942236,
    0.9754138588905334,
    0.0049394769594073296,
    0.9593328237533569,
    0.00478742178529501,
    0.9432409405708313,
    0.005124739371240139,
    0.9207090735435486,
    0.00530279241502285,
    0.9007392525672913,
    0.005275663919746876,
    0.8754144310951233,
    0.005053830333054066,
    0.8455151319503784,
    0.004738631658256054,
    0.8122400045394897,
    0.004457577131688595,
    0.7794992327690125,
    0.004092161078006029,
    0.7470912337303162,
    0.0037206581328064203,
    0.7142261862754822,
    0.003380086040124297,
    0.6812762022018433,
    0.003039485076442361,
    0.6462566256523132,
    0.0027081393636763096,
    0.6113574504852295,
    0.0023940110113471746,
    0.5761368274688721,
    0.002102465834468603,
    0.5422928929328918,
    0.0018580463947728276,
    0.5086895227432251,
    0.0016355352709069848,
    0.4753577709197998,
    0.0014335776213556528,
    0.4431697130203247,
    0.0012596339220181108,
    0.4121963381767273,
    0.001109234057366848,
    0.38215652108192444,
    0.0009733971673995256,
    1,
    0.00514982920140028,
    0.9999998807907104,
    0.0051505835726857185,
    0.9999995827674866,
    0.005156354513019323,
    0.9999896287918091,
    0.0051828715950250626,
    0.9999085664749146,
    0.005253704264760017,
    0.9997556805610657,
    0.005400160793215036,
    0.9994800090789795,
    0.005656661000102758,
    0.9989307522773743,
    0.006053065415471792,
    0.9969843626022339,
    0.00654215645045042,
    0.9936774373054504,
    0.0071439314633607864,
    0.9860166311264038,
    0.007553808391094208,
    0.9713460803031921,
    0.007397466339170933,
    0.9569413065910339,
    0.0073686097748577595,
    0.9397642612457275,
    0.007654766086488962,
    0.9162077307701111,
    0.007692985702306032,
    0.8954983353614807,
    0.007463844493031502,
    0.8701610565185547,
    0.007024289574474096,
    0.8410991430282593,
    0.00654118787497282,
    0.8087263703346252,
    0.006071383133530617,
    0.7769513130187988,
    0.005505856592208147,
    0.7454173564910889,
    0.004944223910570145,
    0.7141332030296326,
    0.004456194117665291,
    0.6828809976577759,
    0.0039864880964159966,
    0.6495635509490967,
    0.0035339398309588432,
    0.6162917017936707,
    0.0031144339591264725,
    0.5824683308601379,
    0.0027307888958603144,
    0.5497102737426758,
    0.0023994878865778446,
    0.517501950263977,
    0.00211310270242393,
    0.4853088855743408,
    0.0018530820962041616,
    0.4536786675453186,
    0.00162035773973912,
    0.423523485660553,
    0.001423511654138565,
    0.39414113759994507,
    0.0012478313874453306,
    1,
    0.008781113661825657,
    0.9999998807907104,
    0.008782250806689262,
    0.9999995231628418,
    0.008789858780801296,
    0.9999810457229614,
    0.008825347758829594,
    0.9998871088027954,
    0.008919996209442616,
    0.9997116327285767,
    0.009114330634474754,
    0.9993581771850586,
    0.009449927136301994,
    0.9986737370491028,
    0.009955829940736294,
    0.9964500069618225,
    0.010553664527833462,
    0.9922869205474854,
    0.011210176162421703,
    0.9828514456748962,
    0.011462666094303131,
    0.966590404510498,
    0.010942341759800911,
    0.9539383053779602,
    0.011102051474153996,
    0.9355066418647766,
    0.01121359970420599,
    0.9109336137771606,
    0.010973316617310047,
    0.8896371126174927,
    0.01041148230433464,
    0.8645746111869812,
    0.00965377688407898,
    0.8366612195968628,
    0.008939074352383614,
    0.8053125143051147,
    0.008173693902790546,
    0.7746899724006653,
    0.007331684231758118,
    0.7442728281021118,
    0.00651463633403182,
    0.7146793603897095,
    0.005829517729580402,
    0.6851472854614258,
    0.005182467866688967,
    0.6537533402442932,
    0.0045829638838768005,
    0.6221988201141357,
    0.004027039278298616,
    0.5898833274841309,
    0.003525900188833475,
    0.5582146644592285,
    0.003083770629018545,
    0.5273421406745911,
    0.002709123305976391,
    0.4963016211986542,
    0.002371974289417267,
    0.4656708538532257,
    0.002071167342364788,
    0.43599048256874084,
    0.0018063206225633621,
    0.4073277413845062,
    0.0015753306215628982,
    1,
    0.014484788291156292,
    0.9999998807907104,
    0.014486453495919704,
    0.9999987483024597,
    0.014495768584311008,
    0.9999776482582092,
    0.014540332369506359,
    0.9998500943183899,
    0.014659006148576736,
    0.9996382594108582,
    0.01490150298923254,
    0.9992026090621948,
    0.015315020456910133,
    0.998336911201477,
    0.01592146046459675,
    0.995718240737915,
    0.016593143343925476,
    0.9902902245521545,
    0.0171788539737463,
    0.9785705804824829,
    0.017021413892507553,
    0.9626328945159912,
    0.016236452385783195,
    0.9501498341560364,
    0.016367292031645775,
    0.9303038120269775,
    0.01610034890472889,
    0.9047937393188477,
    0.015376884490251541,
    0.8831865191459656,
    0.014312634244561195,
    0.8588321208953857,
    0.013121667318046093,
    0.8321588039398193,
    0.012045647017657757,
    0.8021290302276611,
    0.010870425030589104,
    0.7729312777519226,
    0.009663310833275318,
    0.7440451979637146,
    0.00851679127663374,
    0.7160144448280334,
    0.007560419384390116,
    0.6883515119552612,
    0.006690638139843941,
    0.6589763164520264,
    0.005896061658859253,
    0.6292344331741333,
    0.005173892714083195,
    0.598577618598938,
    0.004521057941019535,
    0.5681574940681458,
    0.003936563618481159,
    0.53830885887146,
    0.0034439379815012217,
    0.5085618495941162,
    0.0030091004446148872,
    0.4790176749229431,
    0.0026174471713602543,
    0.4498245120048523,
    0.0022649490274488926,
    0.42175745964050293,
    0.0019711104687303305,
    1,
    0.02318751998245716,
    0.9999998807907104,
    0.023189831525087357,
    0.9999986290931702,
    0.02320014126598835,
    0.9999673962593079,
    0.023251373320817947,
    0.9998109340667725,
    0.023388182744383812,
    0.9995402097702026,
    0.023666987195611,
    0.9989989995956421,
    0.024136699736118317,
    0.9978742003440857,
    0.024800801649689674,
    0.9946720600128174,
    0.025450238958001137,
    0.9875483512878418,
    0.025734124705195427,
    0.9728531241416931,
    0.024720782414078712,
    0.9594616889953613,
    0.023991674184799194,
    0.9453520774841309,
    0.023601805791258812,
    0.9240635633468628,
    0.022656673565506935,
    0.8977890610694885,
    0.02116716280579567,
    0.8763020634651184,
    0.01939302869141102,
    0.8533101677894592,
    0.017666829749941826,
    0.8278051018714905,
    0.01600640080869198,
    0.7994223237037659,
    0.014282339252531528,
    0.7719488143920898,
    0.012605263851583004,
    0.7448646426200867,
    0.011039326898753643,
    0.7183104753494263,
    0.009716251865029335,
    0.6926193237304688,
    0.008567593060433865,
    0.6653493046760559,
    0.007526721339672804,
    0.6374363899230957,
    0.0065890830010175705,
    0.6085887551307678,
    0.005747430957853794,
    0.5795894861221313,
    0.004994467366486788,
    0.5504584312438965,
    0.0043333000503480434,
    0.5221819877624512,
    0.003773026168346405,
    0.4937811493873596,
    0.0032880280632525682,
    0.4656572639942169,
    0.0028842499013990164,
    0.43822285532951355,
    0.0025385343469679356,
    1,
    0.036119915544986725,
    0.9999998807907104,
    0.036123037338256836,
    0.9999983310699463,
    0.03613238036632538,
    0.999925971031189,
    0.03618348389863968,
    0.9997624158859253,
    0.036321040242910385,
    0.9994243383407593,
    0.036602236330509186,
    0.9987225532531738,
    0.03706963360309601,
    0.9972200393676758,
    0.03768647462129593,
    0.9930840730667114,
    0.03810041397809982,
    0.9832266569137573,
    0.037559669464826584,
    0.9661542773246765,
    0.03529861569404602,
    0.9552278518676758,
    0.03461970388889313,
    0.9393109083175659,
    0.033278755843639374,
    0.9165701866149902,
    0.03121091052889824,
    0.889992356300354,
    0.028621654957532883,
    0.8692442178726196,
    0.025907745584845543,
    0.8478714823722839,
    0.02343318983912468,
    0.8238598704338074,
    0.020967595279216766,
    0.7974788546562195,
    0.018537262454628944,
    0.7719876170158386,
    0.016262907534837723,
    0.7469906806945801,
    0.014174382202327251,
    0.7219353318214417,
    0.012376618571579456,
    0.6982242465019226,
    0.010873598046600819,
    0.6731786131858826,
    0.009528286755084991,
    0.6469571590423584,
    0.008320010267198086,
    0.6200631856918335,
    0.0072359321638941765,
    0.5924756526947021,
    0.006272470578551292,
    0.5646946430206299,
    0.005448717158287764,
    0.537643551826477,
    0.004783661104738712,
    0.5106642246246338,
    0.004218283575028181,
    0.48378950357437134,
    0.003716002218425274,
    0.4571387767791748,
    0.0032691305968910456,
    1,
    0.054877735674381256,
    0.9999998807907104,
    0.054881878197193146,
    0.999995231628418,
    0.05488637089729309,
    0.9999129772186279,
    0.05492263287305832,
    0.9997130632400513,
    0.055023614317178726,
    0.9992547035217285,
    0.0552348867058754,
    0.998328685760498,
    0.05557789281010628,
    0.9962402582168579,
    0.055930595844984055,
    0.990487813949585,
    0.055661577731370926,
    0.9766780138015747,
    0.05339629948139191,
    0.9620794653892517,
    0.05062970146536827,
    0.949517011642456,
    0.04875345900654793,
    0.9316648244857788,
    0.04582635313272476,
    0.9078508615493774,
    0.04209979251027107,
    0.8816372156143188,
    0.03802478685975075,
    0.8626100420951843,
    0.03419625759124756,
    0.8427760004997253,
    0.030579833313822746,
    0.8207062482833862,
    0.027078259736299515,
    0.7968108057975769,
    0.02378470078110695,
    0.7733734250068665,
    0.020749632269144058,
    0.7508492469787598,
    0.018033595755696297,
    0.7273937463760376,
    0.015642531216144562,
    0.7052904963493347,
    0.013674733228981495,
    0.682493269443512,
    0.01193926390260458,
    0.6581026911735535,
    0.010401400737464428,
    0.6333559155464172,
    0.00907706469297409,
    0.607593297958374,
    0.007949341088533401,
    0.5816879868507385,
    0.00696500763297081,
    0.5553980469703674,
    0.006108662113547325,
    0.5296545624732971,
    0.005376973655074835,
    0.5040144920349121,
    0.004737631417810917,
    0.4783157706260681,
    0.00416637072339654,
    1,
    0.08148409426212311,
    0.9999998807907104,
    0.08148957043886185,
    0.9999942183494568,
    0.08148171007633209,
    0.999882698059082,
    0.08147498965263367,
    0.9996143579483032,
    0.08146817982196808,
    0.9990149140357971,
    0.08147260546684265,
    0.9977524280548096,
    0.08146005868911743,
    0.9946437478065491,
    0.08111938834190369,
    0.985908567905426,
    0.07922664284706116,
    0.9677019715309143,
    0.07408709079027176,
    0.9568265676498413,
    0.07101979106664658,
    0.9418231248855591,
    0.06693457812070847,
    0.9221896529197693,
    0.06159081310033798,
    0.8980724811553955,
    0.05560671538114548,
    0.8733835816383362,
    0.0497000552713871,
    0.8563596606254578,
    0.044376302510499954,
    0.8384827971458435,
    0.039259593933820724,
    0.818854808807373,
    0.03448687866330147,
    0.7977358102798462,
    0.030135253444314003,
    0.7766509652137756,
    0.02620469592511654,
    0.7566617727279663,
    0.0226997472345829,
    0.7353000044822693,
    0.01962413266301155,
    0.7140952348709106,
    0.017016500234603882,
    0.6937720775604248,
    0.014878773130476475,
    0.6717890501022339,
    0.01306450366973877,
    0.6491398215293884,
    0.011481668800115585,
    0.6253446340560913,
    0.010085390880703926,
    0.6009864807128906,
    0.008852623403072357,
    0.5760692954063416,
    0.007759853266179562,
    0.5511251091957092,
    0.006795078050345182,
    0.5264513492584229,
    0.005966846365481615,
    0.5020902752876282,
    0.005241612438112497,
    1,
    0.11845015734434128,
    0.9999998807907104,
    0.11845692247152328,
    0.9999839663505554,
    0.11842353641986847,
    0.9998346567153931,
    0.11832276731729507,
    0.9994792938232422,
    0.11807908862829208,
    0.9986546039581299,
    0.11762857437133789,
    0.9968227744102478,
    0.11683618277311325,
    0.9917505979537964,
    0.11492409557104111,
    0.9777219891548157,
    0.10955154150724411,
    0.9621626138687134,
    0.10287504643201828,
    0.949332058429718,
    0.09705906361341476,
    0.9316338896751404,
    0.08946692198514938,
    0.9109919667243958,
    0.08079186081886292,
    0.8878742456436157,
    0.07198622822761536,
    0.8661704063415527,
    0.06400766968727112,
    0.8510252237319946,
    0.05652714893221855,
    0.8356629014015198,
    0.04960061237215996,
    0.819007396697998,
    0.04332910105586052,
    0.8009445667266846,
    0.037703968584537506,
    0.782430112361908,
    0.03270804136991501,
    0.7648444771766663,
    0.028282418847084045,
    0.7459982633590698,
    0.024462224915623665,
    0.7264190316200256,
    0.021256163716316223,
    0.7078356742858887,
    0.01863222010433674,
    0.6882588863372803,
    0.0163962934166193,
    0.6672788858413696,
    0.014421883039176464,
    0.6456640362739563,
    0.01267970260232687,
    0.6228654384613037,
    0.011134385131299496,
    0.5996813178062439,
    0.009758916683495045,
    0.5759059190750122,
    0.008535985834896564,
    0.5521543025970459,
    0.007453986443579197,
    0.5284970998764038,
    0.006514128763228655,
    1,
    0.1688302755355835,
    0.9999998807907104,
    0.16883879899978638,
    0.9999790787696838,
    0.16875533759593964,
    0.9997648596763611,
    0.16846884787082672,
    0.9992637634277344,
    0.16775725781917572,
    0.998065710067749,
    0.16640785336494446,
    0.9951513409614563,
    0.1640273928642273,
    0.9860142469406128,
    0.15865765511989594,
    0.9660518765449524,
    0.14764997363090515,
    0.954704999923706,
    0.1395324319601059,
    0.9385280013084412,
    0.12884680926799774,
    0.9188490509986877,
    0.1163267195224762,
    0.8987041115760803,
    0.10347608476877213,
    0.8788196444511414,
    0.09163937717676163,
    0.8600752949714661,
    0.0807318240404129,
    0.8475458025932312,
    0.07072216272354126,
    0.8353716731071472,
    0.06171669811010361,
    0.821943461894989,
    0.053687602281570435,
    0.8071359395980835,
    0.0465904138982296,
    0.7915299534797668,
    0.04041082784533501,
    0.7765632271766663,
    0.03514613211154938,
    0.7605788707733154,
    0.030588174238801003,
    0.7432041168212891,
    0.026636673137545586,
    0.725105345249176,
    0.023224472999572754,
    0.7074119448661804,
    0.02037244476377964,
    0.6884443163871765,
    0.017911456525325775,
    0.6685107946395874,
    0.015741297975182533,
    0.6478361487388611,
    0.013823072426021099,
    0.6261966824531555,
    0.012119917199015617,
    0.6042677164077759,
    0.010611855424940586,
    0.5818374752998352,
    0.009283081628382206,
    0.559741735458374,
    0.008231556974351406,
    1,
    0.23626625537872314,
    0.9999997019767761,
    0.2362765371799469,
    0.9999340772628784,
    0.23610058426856995,
    0.9996722936630249,
    0.2354590892791748,
    0.998900294303894,
    0.23385630548000336,
    0.9969972372055054,
    0.2307794690132141,
    0.9914978742599487,
    0.22503536939620972,
    0.9735234379768372,
    0.21185773611068726,
    0.9586296081542969,
    0.19842229783535004,
    0.9428296089172363,
    0.183420330286026,
    0.923704206943512,
    0.1656544953584671,
    0.9041783213615417,
    0.1470605731010437,
    0.8875536918640137,
    0.12988513708114624,
    0.8715113997459412,
    0.11415597051382065,
    0.8566660284996033,
    0.09978459030389786,
    0.8473064303398132,
    0.08695197850465775,
    0.8386282324790955,
    0.0755869522690773,
    0.8287517428398132,
    0.06567428261041641,
    0.8179552555084229,
    0.05724557489156723,
    0.8057219386100769,
    0.049928825348615646,
    0.7926202416419983,
    0.04355546087026596,
    0.7792407274246216,
    0.0379716120660305,
    0.7640332579612732,
    0.03308714181184769,
    0.7474016547203064,
    0.02881506085395813,
    0.7301750779151917,
    0.025099053978919983,
    0.7127180695533752,
    0.021926019340753555,
    0.6947205066680908,
    0.019262216985225677,
    0.6758882999420166,
    0.016926946118474007,
    0.6569411754608154,
    0.015049583278596401,
    0.637305736541748,
    0.013472186401486397,
    0.6174024939537048,
    0.012106116861104965,
    0.5973087549209595,
    0.010902498848736286,
    1,
    0.32501813769340515,
    0.9999995827674866,
    0.32499584555625916,
    0.9999033212661743,
    0.3246780037879944,
    0.9994678497314453,
    0.323353111743927,
    0.9981954097747803,
    0.3200335204601288,
    0.9945827126502991,
    0.3134599030017853,
    0.9810848832130432,
    0.29922086000442505,
    0.9611642360687256,
    0.2784349322319031,
    0.9451319575309753,
    0.2576608657836914,
    0.9250714778900146,
    0.23240454494953156,
    0.9058858156204224,
    0.20599548518657684,
    0.8910742998123169,
    0.18154340982437134,
    0.8792330026626587,
    0.15922942757606506,
    0.8681660890579224,
    0.13899770379066467,
    0.8583075404167175,
    0.12097477912902832,
    0.8523272275924683,
    0.10522552579641342,
    0.8479938507080078,
    0.0917801484465599,
    0.8422219753265381,
    0.08011527359485626,
    0.8346062302589417,
    0.06995224207639694,
    0.8250599503517151,
    0.06106135994195938,
    0.8139487504959106,
    0.053273048251867294,
    0.8018507957458496,
    0.04646903648972511,
    0.7889829277992249,
    0.040514878928661346,
    0.7745019793510437,
    0.03531218320131302,
    0.7588183879852295,
    0.03077462688088417,
    0.742843747138977,
    0.027125027030706406,
    0.7268459796905518,
    0.024080947041511536,
    0.710379421710968,
    0.021507613360881805,
    0.6937799453735352,
    0.0193832665681839,
    0.6767339110374451,
    0.017515895888209343,
    0.659289538860321,
    0.015847407281398773,
    0.6412655711174011,
    0.014354811049997807,
    0.9999998807907104,
    0.4399769604206085,
    0.9999985098838806,
    0.439930260181427,
    0.9998032450675964,
    0.43927568197250366,
    0.9990205764770508,
    0.4365485906600952,
    0.9964376091957092,
    0.4296136796474457,
    0.9862276315689087,
    0.4139145016670227,
    0.962151288986206,
    0.384680837392807,
    0.9444311261177063,
    0.3556208312511444,
    0.9222219586372375,
    0.3197406232357025,
    0.9029309749603271,
    0.2827257513999939,
    0.8911056518554688,
    0.2490660399198532,
    0.8830918073654175,
    0.21813452243804932,
    0.8775331974029541,
    0.1903085708618164,
    0.8730635046958923,
    0.1659218966960907,
    0.8695764541625977,
    0.14492221176624298,
    0.8668751120567322,
    0.12655852735042572,
    0.865445613861084,
    0.11045990884304047,
    0.8622264862060547,
    0.09638455510139465,
    0.8568942546844482,
    0.08407947421073914,
    0.8496779203414917,
    0.07335495948791504,
    0.84067702293396,
    0.06401440501213074,
    0.8304466009140015,
    0.05603782832622528,
    0.8198321461677551,
    0.04958834499120712,
    0.8088050484657288,
    0.04405725747346878,
    0.7967303991317749,
    0.03924921900033951,
    0.7834534049034119,
    0.035025447607040405,
    0.769321084022522,
    0.031320326030254364,
    0.7545203566551208,
    0.028050176799297333,
    0.7395243644714355,
    0.025176819413900375,
    0.7242056131362915,
    0.022654689848423004,
    0.7085790038108826,
    0.02045733854174614,
    0.6930575966835022,
    0.018601344898343086,
    0.9999998807907104,
    0.5866483449935913,
    0.9999937415122986,
    0.5865479707717896,
    0.9995688199996948,
    0.5850739479064941,
    0.9976115226745605,
    0.57888263463974,
    0.9882634878158569,
    0.5609240531921387,
    0.9604440331459045,
    0.5213394165039062,
    0.937431812286377,
    0.4785776734352112,
    0.9121115207672119,
    0.42722955346107483,
    0.8959197402000427,
    0.3777864873409271,
    0.8887543678283691,
    0.3326959013938904,
    0.8871288895606995,
    0.29170748591423035,
    0.8893368244171143,
    0.2559751570224762,
    0.8920711874961853,
    0.22432221472263336,
    0.8938846588134766,
    0.19617396593093872,
    0.894096851348877,
    0.17124520242214203,
    0.892995297908783,
    0.149303138256073,
    0.8909121155738831,
    0.13008329272270203,
    0.8888714909553528,
    0.1135101318359375,
    0.8867655396461487,
    0.10011104494333267,
    0.8831060528755188,
    0.08858555555343628,
    0.8777309656143188,
    0.07855860888957977,
    0.8709537386894226,
    0.06984192132949829,
    0.8629432320594788,
    0.06225427985191345,
    0.8538238406181335,
    0.05563684180378914,
    0.8438599705696106,
    0.04985157027840614,
    0.83316570520401,
    0.044778503477573395,
    0.8221805691719055,
    0.04031811282038689,
    0.8107494711875916,
    0.03638627752661705,
    0.798716127872467,
    0.032924458384513855,
    0.7861288189888,
    0.029846424236893654,
    0.7731727957725525,
    0.027110036462545395,
    0.759900689125061,
    0.024670327082276344,
    0.9999998807907104,
    0.7711153030395508,
    0.999901533126831,
    0.7708041667938232,
    0.998163104057312,
    0.7661157250404358,
    0.9821500778198242,
    0.7397897243499756,
    0.9464316368103027,
    0.6818641424179077,
    0.9112593531608582,
    0.6113927960395813,
    0.8931443095207214,
    0.5445133447647095,
    0.8906470537185669,
    0.4843099117279053,
    0.8982126712799072,
    0.43117475509643555,
    0.9079634547233582,
    0.3821532428264618,
    0.9169542193412781,
    0.3368130624294281,
    0.9237368106842041,
    0.29538825154304504,
    0.9285380840301514,
    0.25846078991889954,
    0.9336192607879639,
    0.22768156230449677,
    0.9365038275718689,
    0.20039011538028717,
    0.9376296997070312,
    0.17639677226543427,
    0.9371587634086609,
    0.1554010808467865,
    0.9353922605514526,
    0.137116476893425,
    0.9326346516609192,
    0.12125279754400253,
    0.9290563464164734,
    0.10750587284564972,
    0.9249114990234375,
    0.0956064835190773,
    0.9206029176712036,
    0.08530539274215698,
    0.9158710241317749,
    0.07637721300125122,
    0.91045743227005,
    0.06863324344158173,
    0.9044853448867798,
    0.06189843639731407,
    0.8980108499526978,
    0.056058403104543686,
    0.890998363494873,
    0.050957854837179184,
    0.8835744857788086,
    0.04649262875318527,
    0.8758228421211243,
    0.042568888515233994,
    0.8676913380622864,
    0.039107099175453186,
    0.8592711687088013,
    0.03604135289788246,
    0.8505854606628418,
    0.03331342339515686,
    0.9949004650115967,
    0.9907703399658203,
    0.8990931510925293,
    0.8818700909614563,
    0.9644099473953247,
    0.8877869248390198,
    0.9843448400497437,
    0.8364757895469666,
    0.9912524223327637,
    0.7677941918373108,
    0.9944184422492981,
    0.6952739357948303,
    0.9961252808570862,
    0.6239668726921082,
    0.9971455931663513,
    0.5562926530838013,
    0.9977937340736389,
    0.4935127794742584,
    0.9982258677482605,
    0.4362220764160156,
    0.9985172152519226,
    0.3845938742160797,
    0.998707115650177,
    0.33852919936180115,
    0.9988334774971008,
    0.2977551519870758,
    0.9989035129547119,
    0.26189759373664856,
    0.9989327192306519,
    0.2305271178483963,
    0.9989284873008728,
    0.20319679379463196,
    0.998895525932312,
    0.17946358025074005,
    0.998838484287262,
    0.15890514850616455,
    0.998759388923645,
    0.14112819731235504,
    0.9986607432365417,
    0.12577509880065918,
    0.9985431432723999,
    0.11252337694168091,
    0.9984103441238403,
    0.10108739137649536,
    0.998259961605072,
    0.09121601283550262,
    0.9980973601341248,
    0.08269023895263672,
    0.9979205131530762,
    0.075319804251194,
    0.9977298974990845,
    0.06894070655107498,
    0.9975262880325317,
    0.06341172754764557,
    0.9973112344741821,
    0.058612000197172165,
    0.9970836639404297,
    0.05443798378109932,
    0.9968447089195251,
    0.05080118402838707,
    0.9965949058532715,
    0.047626085579395294,
    0.9963352680206299,
    0.04484841972589493,
  ]),
  (XG.PolyLight.prototype = Object.create(XG.Light.prototype)),
  (XG.DayLight = function (e, t, a, r, i) {
    XG.Light.call(this, e),
      (this.skyColor = new XG.Color(t)),
      (this.groundColor = new XG.Color(a)),
      (this.position = new XG.Vector3(0, 100, 0)),
      (this.hemiPosition = new XG.Vector3(0, 100, 0)),
      (this.target = new XG.Node()),
      (this.sunIntensity = void 0 !== r ? r : 1),
      (this.hemiIntensity = void 0 !== i ? i : 1),
      (this.distance = 0),
      (this.castShadow = !1),
      (this.shadowCameraNear = 50),
      (this.shadowCameraFar = 5e3),
      (this.shadowCameraLeft = -500),
      (this.shadowCameraRight = 500),
      (this.shadowCameraTop = 500),
      (this.shadowCameraBottom = -500),
      (this.shadowCameraVisible = !1),
      (this.shadowBias = 0),
      (this.shadowDarkness = 0.5),
      (this.shadowMapWidth = 512),
      (this.shadowMapHeight = 512),
      (this.shadowCascade = !1),
      (this.shadowCascadeOffset = new XG.Vector3(0, 0, -1e3)),
      (this.shadowCascadeCount = 2),
      (this.shadowCascadeBias = [0, 0, 0, 0]),
      (this.shadowCascadeWidth = [512, 512, 512, 512]),
      (this.shadowCascadeHeight = [512, 512, 512, 512]),
      (this.shadowCascadeNearZ = [-1, 0.99, 0.998]),
      (this.shadowCascadeFarZ = [0.99, 0.998, 1]),
      (this.shadowCascadeArray = []),
      (this.texture = null),
      (this.textureCameraLeft = -500),
      (this.textureCameraRight = 500),
      (this.textureCameraTop = 500),
      (this.textureCameraBottom = -500),
      (this.textureCameraNear = 1),
      (this.textureCameraFar = 5e3),
      (this.textureWidth = 512),
      (this.textureHeight = 512),
      (this.textureBias = -4),
      (this.castTransparentShadow = !1);
  }),
  (XG.DayLight.prototype = Object.create(XG.Light.prototype)),
  (XG.DayLightCube = function (e, t) {
    XG.Light.call(this, e),
      (this.position = new XG.Vector3(0, 100, 0)),
      (this.target = new XG.Node()),
      (this.intensity = void 0 !== t ? t : 1),
      (this.distance = 0),
      (this.textureEncoding = XG.rgba8Encoding),
      (this.textureGamma = !0),
      (this.textureFixSeams = !1),
      (this.textureSpecular = null),
      (this.textureDiffuse = null),
      (this.textureMip = null),
      (this.ambientIntensity = 1),
      (this.local = !1),
      (this.size = new XG.Vector3(1, 1, 1)),
      (this.cubePosition = new XG.Vector3(0, 0, 0)),
      (this.castShadow = !1),
      (this.shadowCameraNear = 50),
      (this.shadowCameraFar = 5e3),
      (this.shadowCameraLeft = -500),
      (this.shadowCameraRight = 500),
      (this.shadowCameraTop = 500),
      (this.shadowCameraBottom = -500),
      (this.shadowCameraVisible = !1),
      (this.shadowBias = 0),
      (this.shadowDarkness = 0.5),
      (this.shadowMapWidth = 512),
      (this.shadowMapHeight = 512),
      (this.shadowCascade = !1),
      (this.shadowCascadeOffset = new XG.Vector3(0, 0, -1e3)),
      (this.shadowCascadeCount = 2),
      (this.shadowCascadeBias = [0, 0, 0, 0]),
      (this.shadowCascadeWidth = [512, 512, 512, 512]),
      (this.shadowCascadeHeight = [512, 512, 512, 512]),
      (this.shadowCascadeNearZ = [-1, 0.99, 0.998]),
      (this.shadowCascadeFarZ = [0.99, 0.998, 1]),
      (this.shadowCascadeArray = []),
      (this.texture = null),
      (this.textureCameraLeft = -500),
      (this.textureCameraRight = 500),
      (this.textureCameraTop = 500),
      (this.textureCameraBottom = -500),
      (this.textureCameraNear = 1),
      (this.textureCameraFar = 5e3),
      (this.textureWidth = 512),
      (this.textureHeight = 512),
      (this.textureBias = -4),
      (this.castTransparentShadow = !1);
  }),
  (XG.DayLightCube.prototype = Object.create(XG.Light.prototype)),
  (XG.DirectionalLight = function (e, t) {
    XG.Light.call(this, e),
      (this.position = new XG.Vector3(0, 1, 0)),
      (this.target = new XG.Node()),
      (this.intensity = void 0 !== t ? t : 1),
      (this.distance = 0),
      (this.castShadow = !1),
      (this.onlyShadow = !1),
      (this.shadowCameraNear = 50),
      (this.shadowCameraFar = 5e3),
      (this.shadowCameraLeft = -500),
      (this.shadowCameraRight = 500),
      (this.shadowCameraTop = 500),
      (this.shadowCameraBottom = -500),
      (this.shadowCameraVisible = !1),
      (this.shadowBias = 0),
      (this.shadowDarkness = 0.5),
      (this.shadowMapWidth = 512),
      (this.shadowMapHeight = 512),
      (this.shadowCascade = !1),
      (this.shadowCascadeOffset = new XG.Vector3(0, 0, -1e3)),
      (this.shadowCascadeCount = 2),
      (this.shadowCascadeBias = [0, 0, 0, 0]),
      (this.shadowCascadeWidth = [512, 512, 512, 512]),
      (this.shadowCascadeHeight = [512, 512, 512, 512]),
      (this.shadowCascadeNearZ = [-1, 0.99, 0.998]),
      (this.shadowCascadeFarZ = [0.99, 0.998, 1]),
      (this.shadowCascadeArray = []),
      (this.texture = null),
      (this.textureCameraLeft = -500),
      (this.textureCameraRight = 500),
      (this.textureCameraTop = 500),
      (this.textureCameraBottom = -500),
      (this.textureCameraNear = 1),
      (this.textureCameraFar = 5e3),
      (this.textureWidth = 512),
      (this.textureHeight = 512),
      (this.textureBias = -4),
      (this.castTransparentShadow = !1);
  }),
  (XG.DirectionalLight.prototype = Object.create(XG.Light.prototype)),
  (XG.HemisphereLight = function (e, t, a) {
    XG.Light.call(this, e),
      (this.groundColor = new XG.Color(t)),
      (this.position = new XG.Vector3(0, 100, 0)),
      (this.intensity = void 0 !== a ? a : 1);
  }),
  (XG.HemisphereLight.prototype = Object.create(XG.Light.prototype)),
  (XG.PointLight = function (e, t, a) {
    XG.Light.call(this, e),
      (this.position = new XG.Vector3(0, 0, 0)),
      (this.intensity = void 0 !== t ? t : 1),
      (this.distance = void 0 !== a ? a : 0),
      (this.castShadow = !1),
      (this.onlyShadow = !1),
      (this.shadowCameraNear = 50),
      (this.shadowCameraFar = 5e3),
      (this.shadowCameraVisible = !1),
      (this.shadowBias = 0),
      (this.shadowDarkness = 0.5),
      (this.shadowMapWidth = 512),
      (this.shadowMapHeight = 512);
  }),
  (XG.PointLight.prototype = Object.create(XG.Light.prototype)),
  (XG.SphereLight = function (e, t, a, r) {
    XG.Light.call(this, e),
      (this.position = new XG.Vector3(0, 0, 0)),
      (this.intensity = void 0 !== t ? t : 1),
      (this.distance = void 0 !== a ? a : 0),
      (this.radius = void 0 !== r ? r : 1),
      (this.castShadow = !1),
      (this.onlyShadow = !1),
      (this.shadowCameraNear = 50),
      (this.shadowCameraFar = 5e3),
      (this.shadowCameraVisible = !1),
      (this.shadowBias = 0),
      (this.shadowDarkness = 0.5),
      (this.shadowMapWidth = 512),
      (this.shadowMapHeight = 512);
  }),
  (XG.SphereLight.prototype = Object.create(XG.Light.prototype)),
  (XG.TubeLight = function (e, t, a, r, i) {
    XG.Light.call(this, e),
      (this.position = new XG.Vector3(0, 0, 0)),
      (this.intensity = void 0 !== t ? t : 1),
      (this.distance = void 0 !== a ? a : 0),
      (this.radius = void 0 !== r ? r : 0.1),
      (this.length = void 0 !== i ? r : 5),
      (this.occlusionEnabled = !1),
      (this.castShadow = !1),
      (this.onlyShadow = !1),
      (this.endPoint0 = new XG.Node()),
      (this.endPoint1 = new XG.Node()),
      (this.endPoint0.position.y = 0.5 * -i),
      (this.endPoint1.position.y = 0.5 * i),
      this.add(this.endPoint0),
      this.add(this.endPoint1);
  }),
  (XG.TubeLight.prototype = Object.create(XG.Light.prototype)),
  (XG.SpotLight = function (e, t, a, r, i) {
    XG.Light.call(this, e),
      (this.position = new XG.Vector3(0, 1, 0)),
      (this.target = new XG.Node()),
      (this.intensity = void 0 !== t ? t : 1),
      (this.distance = void 0 !== a ? a : 0),
      (this.angle = void 0 !== r ? r : Math.PI / 2),
      (this.exponent = void 0 !== i ? i : 10),
      (this.castShadow = !1),
      (this.onlyShadow = !1),
      (this.shadowCameraNear = 50),
      (this.shadowCameraFar = 5e3),
      (this.shadowCameraFov = 50),
      (this.shadowCameraVisible = !1),
      (this.shadowBias = 0),
      (this.shadowDarkness = 0.5),
      (this.shadowMapWidth = 512),
      (this.shadowMapHeight = 512),
      (this.texture = null),
      (this.textureCameraNear = 1),
      (this.textureCameraFar = 5e3),
      (this.textureCameraFov = 50),
      (this.textureCameraAspectScale = 1),
      (this.textureWidth = 512),
      (this.textureHeight = 512),
      (this.textureBias = -4),
      (this.castTransparentShadow = !1);
  }),
  (XG.SpotLight.prototype = Object.create(XG.Light.prototype)),
  (XG.ImageLight = function (e, t, a) {
    XG.Light.call(this, 16777215),
      (this.textureSpecular = e),
      (this.textureDiffuse = t),
      (this.textureMip = e),
      (this.textureEncoding = XG.rgba8Encoding),
      (this.textureGamma = !0),
      (this.textureFixSeams = !1),
      (this.intensity = void 0 !== a ? a : 1),
      (this.local = !1),
      (this.size = new XG.Vector3(1, 1, 1));
  }),
  (XG.ImageLight.prototype = Object.create(XG.Light.prototype)),
  (XG.LightProxy = function (e, t) {
    (this.light = e), (this.renderer = t);
  }),
  (XG.LightProxy.prototype = Object.create(XG.Mesh.prototype)),
  (XG.LightProxy.prototype.update = function (e) {
    var t = this.materials[0].uniforms;
    t.matProj && (t.matProj.value = e.projectionMatrix),
      t.matProjInverse && (t.matProjInverse.value = e.projectionMatrixInverse),
      t.matView && (t.matView.value = e.matrixWorldInverse),
      t.matViewInverse && (t.matViewInverse.value = e.matrixWorld),
      this.light && (this.visible = this.light.visible);
  }),
  (XG.LightProxy.prototype.resize = function (e, t) {
    var a = this.materials[0],
      r = a.uniforms;
    r.viewSize && r.viewSize.value.set(e, t);
  }),
  (XG.LightProxy.prototype.setSamplers = function (e) {
    var t = this.renderer,
      a = e.uniforms,
      r = t.getUseMultipleRenderTargets();
    if (r) {
      var i = t.getCombinedTarget();
      a.viewSize.value.set(i.width, i.height),
        a.samplerDiffuseRGB && (a.samplerDiffuseRGB.value = i.colorTexture[0]),
        a.samplerSpecularRGB &&
        (a.samplerSpecularRGB.value = i.colorTexture[1]),
        a.samplerWrapRGB && (a.samplerWrapRGB.value = i.colorTexture[2]),
        a.samplerNormal && (a.samplerNormal.value = i.colorTexture[3]),
        a.samplerDepth &&
        (a.samplerDepth.value = t.useDepthTexture
          ? i.depthTexture
          : i.colorTexture[4]);
    } else {
      var o = t.getColorTarget(),
        n = t.getNormalDepthTarget();
      a.viewSize.value.set(o.width, o.height),
        a.samplerColor && (a.samplerColor.value = o),
        a.samplerNormalDepth && (a.samplerNormalDepth.value = n);
    }
    var s = t.getSSAOTarget();
    a.samplerSSAO && (a.samplerSSAO.value = s);
  }),
  (XG.LightProxy.prototype.generateDefines = function () {
    var e = this.light,
      t = this.renderer,
      a = "webgl2" === t.renderer.getRenderingBackend(),
      r = t.shadowMapUseDepthTextures && t.renderer.supportsDepthTextures(),
      i = {};
    if (t.shadowMapEnabled && e && e.castShadow) {
      i.USE_SHADOWMAP = !0;
      var o = void 0 !== e.shadowMapType ? e.shadowMapType : t.shadowMapType;
      switch (o) {
        case XG.BasicShadowMap:
          i.SHADOWMAP_TYPE_BASIC = !0;
          break;
        case XG.PCFSoftShadowMap:
          i.SHADOWMAP_TYPE_PCF_SOFT = !0;
          break;
        case XG.PCFSoftHQShadowMap:
          i.SHADOWMAP_TYPE_PCF_SOFT_HQ = !0;
      }
      (i.SLOPE_DEPTH_BIAS = t.shadowMapSlopeDepthBias),
        (i.SHADOWMAP_DEBUG = t.shadowMapDebug),
        r ? (i.SHADOW_TEXTURE_DEPTH = !0) : (i.SHADOW_FLOAT_DEPTH = !0),
        (i.USE_SHADOWSAMPLER = a && r);
    }
    return (
      t.ssaoEnabled && e && (i.USE_SSAO = !0),
      t.skinHighQuality && (i.SKIN_HQ = !0),
      (i.USE_MRT = t.getUseMultipleRenderTargets()),
      (i.TEXTURE_DEPTH = t.useDepthTexture),
      (i.PROJECTED_TEXTURE = !!e.texture || !!e.castTransparentShadow),
      (i.PROJECTED_SHADOW = !!e.castTransparentShadow),
      i
    );
  }),
  (XG.LightProxy.prototype.getShadowMapParameters = function () {
    var e,
      t = this.renderer,
      a = t.renderer,
      r = !a.supportsDepthOnlyRenderTarget(),
      i = "webgl2" === a.getRenderingBackend(),
      o = a.supportsLuminanceFloatRenderTarget()
        ? XG.LuminanceFormat
        : a.supportsRGBFloatRenderTarget()
          ? XG.RGBFormat
          : XG.RGBAFormat;
    if (i)
      switch (o) {
        case XG.LuminanceFormat:
          (e = XG.R32F), (o = XG.RED);
          break;
        case XG.RGBFormat:
          e = XG.RGB32F;
          break;
        case XG.RGBAFormat:
          e = XG.RGBA32F;
      }
    else e = o;
    var n = {
      minFilter: XG.NearestFilter,
      magFilter: XG.NearestFilter,
      stencilBuffer: !1,
      format: o,
      internalFormat: e,
      type: XG.FloatType,
    };
    if (i)
      var s = {
        minFilter: XG.LinearFilter,
        magFilter: XG.LinearFilter,
        useColorTexture: r,
        stencilBuffer: !1,
        format: o,
        useDepthTexture: !0,
        depthTextureType: t.shadowMapDepthTextureType,
      };
    else
      var s = {
        minFilter: XG.NearestFilter,
        magFilter: XG.NearestFilter,
        useColorTexture: r,
        stencilBuffer: !1,
        format: o,
        useDepthTexture: !0,
        depthTextureType: t.shadowMapDepthTextureType,
      };
    var l = t.shadowMapUseDepthTextures && a.supportsDepthTextures(),
      h = l ? s : n;
    return h;
  }),
  (XG.LightProxy.prototype.setupDirectionalShadowmap = function (e) {
    var t = this.light,
      a = t.properties,
      r = this.getShadowMapParameters();
    (a.shadowMap = []),
      (a.shadowMatrixDeferred = []),
      (a.shadowMatrixForward = []),
      (a.shadowCamera = []),
      (a.pointsWorld = []),
      (a.pointsFrustum = []);
    for (var i = 0; e > i; i++) {
      var o = new XG.RenderTarget(t.shadowMapWidth, t.shadowMapHeight, r);
      (o.generateMipmaps = !1), (a.shadowMap[i] = o);
      var n = new XG.OrthographicCamera(
        t.shadowCameraLeft,
        t.shadowCameraRight,
        t.shadowCameraTop,
        t.shadowCameraBottom,
        t.shadowCameraNear,
        t.shadowCameraFar
      );
      if (
        ((a.shadowCamera[i] = n),
          (a.shadowMatrixDeferred[i] = new XG.Matrix4()),
          (a.shadowMatrixForward[i] = new XG.Matrix4()),
          t.shadowCascade)
      ) {
        (a.pointsWorld[i] = []), (a.pointsFrustum[i] = []);
        for (
          var s = a.pointsWorld[i], l = a.pointsFrustum[i], h = 0;
          8 > h;
          h++
        )
          (s[h] = new XG.Vector3()), (l[h] = new XG.Vector3());
        var d = t.shadowCascadeNearZ[i],
          c = t.shadowCascadeFarZ[i];
        l[0].set(-1, -1, d),
          l[1].set(1, -1, d),
          l[2].set(-1, 1, d),
          l[3].set(1, 1, d),
          l[4].set(-1, -1, c),
          l[5].set(1, -1, c),
          l[6].set(-1, 1, c),
          l[7].set(1, 1, c);
      }
      (a.shadowMapPars = [
        t.shadowMapWidth,
        t.shadowMapHeight,
        t.shadowDarkness,
        t.shadowBias,
      ]),
        (a.shadowCameraPars = [t.shadowCameraNear, t.shadowCameraFar]);
    }
    t.properties.cascadeCount = e;
  }),
  (XG.LightProxy.prototype.updateDirectionalShadowmap = function (e) {
    var t = this.light,
      a = this.materials[0].uniforms,
      r = t.properties;
    if (t.shadowCascade && !r.gyro) {
      var i = new XG.Gyroscope();
      (i.position = t.shadowCascadeOffset),
        i.add(t),
        i.add(t.target),
        e.add(i),
        (r.gyro = i);
      var o = e.getTopParent();
      if (void 0 !== o && o instanceof XG.Scene) {
        var n = new XG.Node(),
          s = new XG.Node();
        o.add(n),
          o.add(s),
          (n.position = t.position),
          (s.position = t.target.position),
          (r.nonGyroLight = n),
          (r.nonGyroTarget = s);
      } else
        console.error(
          "XG.LightProxy.updateDirectionalShadowmap: can't find parent scene node"
        );
    }
    for (var l = 0; l < r.cascadeCount; l++) {
      var h = r.shadowMatrixDeferred[l],
        d = r.shadowMatrixForward[l],
        c = r.shadowCamera[l],
        u = r.shadowMap[l];
      h.multiply(c.projectionMatrix, c.matrixWorldInverse),
        d.multiply(XG.LightProxy.biasMatrix, h),
        h.multiplySelf(e.matrixWorld),
        (a.matShadow.value[l] = h),
        (a.samplerShadowMap.value[l] = u.useDepthTexture ? u.depthTexture : u);
    }
    (a.shadowDarkness.value = Math.sqrt(t.shadowDarkness)),
      (a.shadowBias.value = t.shadowBias),
      a.shadowMapSize.value.set(t.shadowMapWidth, t.shadowMapHeight);
  }),
  (XG.LightProxy.prototype.setupProjectedTexture = function () {
    var e = this.light,
      t = e.properties,
      a = new XG.OrthographicCamera(
        e.textureCameraLeft,
        e.textureCameraRight,
        e.textureCameraTop,
        e.textureCameraBottom,
        e.textureCameraNear,
        e.textureCameraFar
      );
    if (
      ((t.textureCamera = a),
        (t.textureMatrixDeferred = new XG.Matrix4()),
        e.castTransparentShadow)
    ) {
      var r = {
        minFilter: XG.LinearMipMapLinearFilter,
        magFilter: XG.LinearFilter,
        stencilBuffer: !1,
        format: XG.RGBAFormat,
        type: XG.UnsignedByteType,
      },
        i = new XG.RenderTarget(e.textureWidth, e.textureHeight, r);
      e.shadowCascade ||
        e.textureWidth !== e.shadowMapWidth ||
        e.textureHeight !== e.shadowMapHeight ||
        (i.shareDepthFrom = t.shadowMap[0]),
        (e.texture = i);
    }
  }),
  (XG.LightProxy.prototype.updateProjectedTexture = function (e) {
    var t = this.light,
      a = this.materials[0].uniforms,
      r = t.properties,
      i = r.textureMatrixDeferred,
      o = r.textureCamera;
    if (
      ((o.left = t.textureCameraLeft),
        (o.right = t.textureCameraRight),
        (o.top = t.textureCameraTop),
        (o.bottom = t.textureCameraBottom),
        (o.near = t.textureCameraNear),
        (o.far = t.textureCameraFar),
        o.updateProjectionMatrix(),
        r.gyro)
    )
      var n = r.nonGyroLight,
        s = r.nonGyroTarget;
    else
      var n = t,
        s = t.target;
    o.position.copy(n.matrixWorld.getPosition()),
      t.target && o.lookAt(s.matrixWorld.getPosition()),
      o.updateMatrixWorld(),
      o.matrixWorldInverse.getInverse(o.matrixWorld),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiplySelf(o.projectionMatrix),
      i.multiplySelf(o.matrixWorldInverse),
      i.multiplySelf(e.matrixWorld),
      (a.matTexture.value = i),
      (a.samplerTexture.value = t.texture),
      (a.textureBias.value = t.textureBias);
  }),
  (XG.LightProxy.geometryLightSphere = new XG.SphereGeometry(1, 16, 8)),
  (XG.LightProxy.geometryLightPlane = new XG.PlaneGeometry(2, 2)),
  (XG.LightProxy.geometryLightBox = new XG.BoxGeometry(1, 1, 1)),
  (XG.LightProxy.positionVS = new XG.Vector3()),
  (XG.LightProxy.directionVS = new XG.Vector3()),
  (XG.LightProxy.rightVS = new XG.Vector3()),
  (XG.LightProxy.normalVS = new XG.Vector3()),
  (XG.LightProxy.upVS = new XG.Vector3()),
  (XG.LightProxy.positionWS = new XG.Vector3()),
  (XG.LightProxy.rightWS = new XG.Vector3()),
  (XG.LightProxy.normalWS = new XG.Vector3()),
  (XG.LightProxy.upWS = new XG.Vector3()),
  (XG.LightProxy.tmpVec = new XG.Vector3()),
  (XG.LightProxy.biasMatrix = new XG.Matrix4(
    0.5,
    0,
    0,
    0.5,
    0,
    0.5,
    0,
    0.5,
    0,
    0,
    0.5,
    0.5,
    0,
    0,
    0,
    1
  )),
  (XG.SpotLightProxy = function (e, t) {
    XG.LightProxy.call(this, e, t);
    var a = XG.DeferredShaders.spotLight,
      r = XG.UniformsUtils.clone(a.uniforms),
      i = this.generateDefines(),
      o = {};
    t.skinHighQuality && (o.OES_standard_derivatives = !0);
    var n = new XG.ShaderMaterial({
      uniforms: r,
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      defines: i,
      extensions: o,
      blending: XG.AdditiveBlending,
      depthWrite: !1,
      depthTest: !1,
      transparent: !0,
    });
    this.setSamplers(n);
    var s = XG.LightProxy.geometryLightPlane;
    XG.Mesh.call(this, s, n);
    var l = e.properties;
    if (
      (e.castShadow && this.setupShadowmap(),
        e.texture || e.castTransparentShadow)
    ) {
      var h = e.textureCameraAspectScale;
      if (e.texture) {
        var d = e.texture.image;
        h *= d.width / d.height;
      }
      var c = new XG.PerspectiveCamera(
        e.textureCameraFov,
        h,
        e.textureCameraNear,
        e.textureCameraFar
      );
      if (
        ((l.textureCamera = c),
          (l.textureMatrixDeferred = new XG.Matrix4()),
          e.castTransparentShadow)
      ) {
        var u = {
          minFilter: XG.LinearMipMapLinearFilter,
          magFilter: XG.LinearFilter,
          stencilBuffer: !1,
          format: XG.RGBAFormat,
          type: XG.UnsignedByteType,
        },
          f = new XG.RenderTarget(e.textureWidth, e.textureHeight, u);
        e.shadowCascade ||
          e.textureWidth !== e.shadowMapWidth ||
          e.textureHeight !== e.shadowMapHeight ||
          (f.shareDepthFrom = l.shadowMap),
          (e.texture = f);
      }
    }
  }),
  (XG.SpotLightProxy.prototype = Object.create(XG.LightProxy.prototype)),
  (XG.SpotLightProxy.prototype.setupShadowmap = function () {
    var e = this.light,
      t = e.properties,
      a = this.getShadowMapParameters(),
      r = new XG.RenderTarget(e.shadowMapWidth, e.shadowMapHeight, a);
    (r.wrapS = XG.MirroredRepeatWrapping),
      (r.wrapT = XG.MirroredRepeatWrapping),
      (r.generateMipmaps = !1),
      (t.shadowMap = r);
    var i = e.shadowMapWidth / e.shadowMapHeight,
      o = new XG.PerspectiveCamera(
        e.shadowCameraFov,
        i,
        e.shadowCameraNear,
        e.shadowCameraFar
      );
    (t.shadowCamera = o),
      (t.shadowMatrixDeferred = new XG.Matrix4()),
      (t.shadowMatrixForward = new XG.Matrix4()),
      (t.shadowMapPars = [
        e.shadowMapWidth,
        e.shadowMapHeight,
        e.shadowDarkness,
        e.shadowBias,
      ]),
      (t.shadowCameraPars = [e.shadowCameraNear, e.shadowCameraFar]);
  }),
  (XG.SpotLightProxy.prototype.update = function (e) {
    XG.LightProxy.prototype.update.call(this, e);
    var t = this.light,
      a = this.materials[0].uniforms,
      r = e.matrixWorldInverse,
      i = t.matrixWorld,
      o = XG.LightProxy.positionVS,
      n = XG.LightProxy.directionVS;
    o.copy(i.getPosition()),
      r.multiplyVector3(o),
      n.copy(i.getPosition()),
      n.subSelf(t.target.matrixWorld.getPosition()),
      n.normalize(),
      r.rotateAxis(n),
      a.lightPositionVS.value.copy(o),
      a.lightDirectionVS.value.copy(n),
      (a.lightAngleCos.value = Math.cos(0.5 * t.angle)),
      (a.lightDistance.value = t.distance);
    var s = t.intensity * t.intensity;
    if (
      ((a.lightIntensity.value = s),
        a.lightColor.value.copyGammaToLinear(t.color),
        t.castShadow)
    ) {
      var l = t.properties.shadowMatrixDeferred,
        h = t.properties.shadowMatrixForward,
        d = t.properties.shadowCamera,
        c = t.properties.shadowMap;
      l.multiply(d.projectionMatrix, d.matrixWorldInverse),
        h.multiply(XG.LightProxy.biasMatrix, l),
        l.multiplySelf(e.matrixWorld),
        (a.matShadow.value = l),
        (a.samplerShadowMap.value = c.useDepthTexture ? c.depthTexture : c),
        (a.shadowDarkness.value = Math.sqrt(t.shadowDarkness)),
        (a.shadowBias.value = t.shadowBias),
        a.shadowMapSize.value.set(t.shadowMapWidth, t.shadowMapHeight);
    }
    if (t.texture) {
      var u = t.properties.textureMatrixDeferred,
        f = t.properties.textureCamera,
        p = t.texture.image ? t.texture.image : t.texture,
        m = p.width / p.height;
      (f.fov = t.textureCameraFov),
        (f.near = t.textureCameraNear),
        (f.far = t.textureCameraFar),
        (f.aspect = m * t.textureCameraAspectScale),
        f.updateProjectionMatrix(),
        f.position.copy(t.matrixWorld.getPosition()),
        t.target && f.lookAt(t.target.matrixWorld.getPosition()),
        f.updateMatrixWorld(),
        f.matrixWorldInverse.getInverse(f.matrixWorld),
        u.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
        u.multiplySelf(f.projectionMatrix),
        u.multiplySelf(f.matrixWorldInverse),
        u.multiplySelf(e.matrixWorld),
        (a.matTexture.value = u),
        (a.samplerTexture.value = t.texture),
        (a.textureBias.value = t.textureBias);
    }
  }),
  (XG.AreaLightProxy = function (e, t) {
    XG.LightProxy.call(this, e, t);
    var a = XG.DeferredShaders.areaLight,
      r = XG.UniformsUtils.clone(a.uniforms),
      i = this.generateDefines();
    i.AREA_TEXTURE = !!e.texture;
    var o = {};
    t.skinHighQuality && (o.OES_standard_derivatives = !0);
    var n = new XG.ShaderMaterial({
      uniforms: r,
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      defines: i,
      extensions: o,
      blending: XG.AdditiveBlending,
      depthWrite: !1,
      depthTest: !1,
      transparent: !0,
    });
    this.setSamplers(n);
    var s = XG.LightProxy.geometryLightPlane;
    XG.Mesh.call(this, s, n), e.castShadow && this.setupShadowmap();
  }),
  (XG.AreaLightProxy.prototype = Object.create(XG.LightProxy.prototype)),
  (XG.AreaLightProxy.prototype.setupShadowmap = function () {
    var e = this.light,
      t = e.properties,
      a = this.getShadowMapParameters(),
      r = new XG.RenderTarget(e.shadowMapWidth, e.shadowMapHeight, a);
    if (((r.generateMipmaps = !1), (t.shadowMap = r), e.shadowCameraOrtho))
      var i = new XG.OrthographicCamera(
        e.shadowCameraLeft,
        e.shadowCameraRight,
        e.shadowCameraTop,
        e.shadowCameraBottom,
        e.shadowCameraNear,
        e.shadowCameraFar
      );
    else
      var o = e.shadowMapWidth / e.shadowMapHeight,
        i = new XG.PerspectiveCamera(
          e.shadowCameraFov,
          o,
          e.shadowCameraNear,
          e.shadowCameraFar
        );
    (t.shadowCamera = i),
      (t.shadowMatrixDeferred = new XG.Matrix4()),
      (t.shadowMatrixForward = new XG.Matrix4()),
      (t.shadowMapPars = [
        e.shadowMapWidth,
        e.shadowMapHeight,
        e.shadowDarkness,
        e.shadowBias,
      ]),
      (t.shadowCameraPars = [e.shadowCameraNear, e.shadowCameraFar]);
  }),
  (XG.AreaLightProxy.prototype.update = function (e) {
    XG.LightProxy.prototype.update.call(this, e);
    var t = this.light,
      a = this.materials[0].uniforms,
      r = t.matrixWorld,
      i = e.matrixWorldInverse,
      o = XG.LightProxy.positionVS,
      n = XG.LightProxy.rightVS,
      s = XG.LightProxy.normalVS,
      l = XG.LightProxy.upVS;
    o.copy(r.getPosition()),
      i.multiplyVector3(o),
      a.lightPositionVS.value.copy(o),
      n.copy(t.right),
      s.copy(t.normal),
      r.rotateAxis(n),
      r.rotateAxis(s),
      i.rotateAxis(n),
      i.rotateAxis(s),
      l.cross(n, s),
      l.normalize(),
      a.lightRightVS.value.copy(n),
      a.lightNormalVS.value.copy(s),
      a.lightUpVS.value.copy(l),
      (a.lightWidth.value = t.width),
      (a.lightHeight.value = t.height),
      (a.constantAttenuation.value = t.constantAttenuation),
      (a.linearAttenuation.value = t.linearAttenuation),
      (a.quadraticAttenuation.value = t.quadraticAttenuation),
      (a.samplerTexture.value = t.texture);
    var h = t.intensity * t.intensity;
    if (
      ((a.lightIntensity.value = h),
        a.lightColor.value.copyGammaToLinear(t.color),
        t.castShadow)
    ) {
      var d = t.properties.shadowMatrixDeferred,
        c = t.properties.shadowMatrixForward,
        u = t.properties.shadowCamera,
        f = t.properties.shadowMap;
      d.multiply(u.projectionMatrix, u.matrixWorldInverse),
        c.multiply(XG.LightProxy.biasMatrix, d),
        d.multiplySelf(e.matrixWorld),
        (a.matShadow.value = d),
        (a.samplerShadowMap.value = f.useDepthTexture ? f.depthTexture : f),
        (a.shadowDarkness.value = Math.sqrt(t.shadowDarkness)),
        (a.shadowBias.value = t.shadowBias),
        a.shadowMapSize.value.set(t.shadowMapWidth, t.shadowMapHeight);
    }
  }),
  (XG.PolyLightProxy = function (e, t) {
    XG.LightProxy.call(this, e, t);
    var a = XG.DeferredShaders.polyLight,
      r = XG.UniformsUtils.clone(a.uniforms),
      i = this.generateDefines();
    i.POLY_TEXTURE = !!e.texture;
    var o = {};
    t.renderer.supportsShaderTextureLod() &&
      e.texture &&
      (o.EXT_shader_texture_lod = !0);
    var n = new XG.ShaderMaterial({
      uniforms: r,
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      defines: i,
      extensions: o,
      blending: XG.AdditiveBlending,
      depthWrite: !1,
      depthTest: !1,
      transparent: !0,
    });
    if (
      ((r.lightPoints.value = [
        new XG.Vector3(-10, 10, 0),
        new XG.Vector3(10, 10, 0),
        new XG.Vector3(10, -10, 0),
        new XG.Vector3(-10, -10, 0),
      ]),
        void 0 === XG.PolyLightProxy.samplerLtcMat)
    ) {
      var s = new Float32Array(XG.PolyLight.ltcMatData),
        l = new XG.DataTexture(
          s,
          64,
          64,
          XG.RGBAFormat,
          XG.FloatType,
          XG.ClampToEdgeWrapping,
          XG.ClampToEdgeWrapping,
          XG.LinearFilter,
          XG.NearestFilter
        );
      (l.flipY = !1),
        (l.generateMipmaps = !1),
        (l.needsUpdate = !0),
        (XG.PolyLightProxy.samplerLtcMat = l);
    }
    if (void 0 === XG.PolyLightProxy.samplerLtcMag) {
      var h = new Float32Array(XG.PolyLight.ltcMagData),
        d = new XG.DataTexture(
          h,
          32,
          32,
          XG.LuminanceAlphaFormat,
          XG.FloatType,
          XG.ClampToEdgeWrapping,
          XG.ClampToEdgeWrapping,
          XG.LinearFilter,
          XG.NearestFilter
        );
      (d.flipY = !1),
        (d.generateMipmaps = !1),
        (d.needsUpdate = !0),
        (XG.PolyLightProxy.samplerLtcMag = d);
    }
    (this.samplerLtcMat = XG.PolyLightProxy.samplerLtcMat),
      (this.samplerLtcMag = XG.PolyLightProxy.samplerLtcMag),
      this.setSamplers(n);
    var c = XG.LightProxy.geometryLightPlane;
    XG.Mesh.call(this, c, n), e.castShadow && this.setupShadowmap();
  }),
  (XG.PolyLightProxy.prototype = Object.create(XG.LightProxy.prototype)),
  (XG.PolyLightProxy.prototype.setupShadowmap = function () {
    var e = this.light,
      t = e.properties,
      a = this.getShadowMapParameters(),
      r = new XG.RenderTarget(e.shadowMapWidth, e.shadowMapHeight, a);
    if (((r.generateMipmaps = !1), (t.shadowMap = r), e.shadowCameraOrtho))
      var i = new XG.OrthographicCamera(
        e.shadowCameraLeft,
        e.shadowCameraRight,
        e.shadowCameraTop,
        e.shadowCameraBottom,
        e.shadowCameraNear,
        e.shadowCameraFar
      );
    else
      var o = e.shadowMapWidth / e.shadowMapHeight,
        i = new XG.PerspectiveCamera(
          e.shadowCameraFov,
          o,
          e.shadowCameraNear,
          e.shadowCameraFar
        );
    (t.shadowCamera = i),
      (t.shadowMatrixDeferred = new XG.Matrix4()),
      (t.shadowMatrixForward = new XG.Matrix4()),
      (t.shadowMapPars = [
        e.shadowMapWidth,
        e.shadowMapHeight,
        e.shadowDarkness,
        e.shadowBias,
      ]),
      (t.shadowCameraPars = [e.shadowCameraNear, e.shadowCameraFar]);
  }),
  (XG.PolyLightProxy.prototype.update = function (e) {
    XG.LightProxy.prototype.update.call(this, e);
    var t = this.light,
      a = this.materials[0].uniforms,
      r = t.matrixWorld,
      i = e.matrixWorldInverse,
      o = XG.LightProxy.positionWS,
      n = XG.LightProxy.rightWS,
      s = XG.LightProxy.normalWS,
      l = XG.LightProxy.upWS;
    o.copy(r.getPosition()),
      n.copy(t.right).normalize(),
      s.copy(t.normal).normalize(),
      r.rotateAxis(n),
      r.rotateAxis(s),
      l.cross(n, s),
      l.normalize(),
      n.multiplyScalar(t.width),
      l.multiplyScalar(t.height);
    var h = a.lightPoints.value,
      d = h[0];
    d.copy(o),
      d.subSelf(n),
      d.addSelf(l),
      i.multiplyVector3(d),
      (d = h[1]),
      d.copy(o),
      d.addSelf(n),
      d.addSelf(l),
      i.multiplyVector3(d),
      (d = h[2]),
      d.copy(o),
      d.addSelf(n),
      d.subSelf(l),
      i.multiplyVector3(d),
      (d = h[3]),
      d.copy(o),
      d.subSelf(n),
      d.subSelf(l),
      i.multiplyVector3(d),
      (a.lightTwoSided.value = t.twoSided);
    var c = t.intensity * t.intensity;
    if (
      ((a.lightIntensity.value = c),
        a.lightColor.value.copyGammaToLinear(t.color),
        (a.samplerLtcMat.value = this.samplerLtcMat),
        (a.samplerLtcMag.value = this.samplerLtcMag),
        (a.samplerTexture.value = t.texture),
        (a.samplerTextureSize.value = t.texture ? t.texture.getWidth() : 0),
        (a.samplerTextureBias.value = t.textureBias),
        t.castShadow)
    ) {
      var u = t.properties.shadowMatrixDeferred,
        f = t.properties.shadowMatrixForward,
        p = t.properties.shadowCamera,
        m = t.properties.shadowMap;
      u.multiply(p.projectionMatrix, p.matrixWorldInverse),
        f.multiply(XG.LightProxy.biasMatrix, u),
        u.multiplySelf(e.matrixWorld),
        (a.matShadow.value = u),
        (a.samplerShadowMap.value = m.useDepthTexture ? m.depthTexture : m),
        (a.shadowDarkness.value = Math.sqrt(t.shadowDarkness)),
        (a.shadowBias.value = t.shadowBias),
        a.shadowMapSize.value.set(t.shadowMapWidth, t.shadowMapHeight);
    }
  }),
  (XG.MultiPolyLightProxy = function (e) {
    XG.LightProxy.call(this, null, e), (this.lights = []);
  }),
  (XG.MultiPolyLightProxy.prototype = Object.create(XG.LightProxy.prototype)),
  (XG.MultiPolyLightProxy.prototype.init = function () {
    for (
      var e = this.lights,
      t = this.renderer,
      a = XG.DeferredShaders.polyLightMulti,
      r = XG.UniformsUtils.clone(a.uniforms),
      i = this.generateDefines(),
      o = !1,
      n = 0,
      s = e.length;
      s > n;
      n++
    ) {
      var l = e[n];
      o = o || !!l.texture;
    }
    i.POLY_TEXTURE = o;
    var h = {};
    t.renderer.supportsShaderTextureLod() &&
      o &&
      (h.EXT_shader_texture_lod = !0);
    for (
      var d = new XG.ShaderMaterial({
        uniforms: r,
        vertexShader: a.vertexShader,
        fragmentShader: a.fragmentShader,
        defines: i,
        extensions: h,
        blending: XG.AdditiveBlending,
        depthWrite: !1,
        depthTest: !1,
        transparent: !0,
      }),
      c = [],
      u = [],
      f = [],
      p = [],
      m = [],
      n = 0,
      s = e.length;
      s > n;
      n++
    ) {
      var l = e[n];
      (c[4 * n] = new XG.Vector3(0, 0, 0)),
        (c[4 * n + 1] = new XG.Vector3(0, 0, 0)),
        (c[4 * n + 2] = new XG.Vector3(0, 0, 0)),
        (c[4 * n + 3] = new XG.Vector3(0, 0, 0)),
        (u[3 * n] = 0),
        (u[3 * n + 1] = 0),
        (u[3 * n + 2] = 0),
        (f[n] = 0),
        (p[n] = l.texture),
        (m[2 * n] = l.texture ? l.texture.getWidth() : 0),
        (m[2 * n + 1] = l.textureBias);
    }
    if (
      ((r.polyLightPoints.value = c),
        (r.polyLightColor.value = u),
        (r.polyLightPars.value = f),
        (r.samplerTexture.value = p),
        (r.samplerTexturePars.value = m),
        void 0 === XG.MultiPolyLightProxy.samplerLtcMat)
    ) {
      var v = new Float32Array(XG.PolyLight.ltcMatData),
        g = new XG.DataTexture(
          v,
          64,
          64,
          XG.RGBAFormat,
          XG.FloatType,
          XG.ClampToEdgeWrapping,
          XG.ClampToEdgeWrapping,
          XG.LinearFilter,
          XG.NearestFilter
        );
      (g.flipY = !1),
        (g.generateMipmaps = !1),
        (g.needsUpdate = !0),
        (XG.MultiPolyLightProxy.samplerLtcMat = g);
    }
    if (void 0 === XG.MultiPolyLightProxy.samplerLtcMag) {
      var S = new Float32Array(XG.PolyLight.ltcMagData),
        x = new XG.DataTexture(
          S,
          32,
          32,
          XG.LuminanceAlphaFormat,
          XG.FloatType,
          XG.ClampToEdgeWrapping,
          XG.ClampToEdgeWrapping,
          XG.LinearFilter,
          XG.NearestFilter
        );
      (x.flipY = !1),
        (x.generateMipmaps = !1),
        (x.needsUpdate = !0),
        (XG.MultiPolyLightProxy.samplerLtcMag = x);
    }
    (this.samplerLtcMat = XG.MultiPolyLightProxy.samplerLtcMat),
      (this.samplerLtcMag = XG.MultiPolyLightProxy.samplerLtcMag),
      this.setSamplers(d);
    var G = XG.LightProxy.geometryLightPlane;
    XG.Mesh.call(this, G, d), this.setupShadowmap();
  }),
  (XG.MultiPolyLightProxy.prototype.addLight = function (e) {
    this.lights.push(e);
  }),
  (XG.MultiPolyLightProxy.prototype.generateDefines = function () {
    for (
      var e = this.lights,
      t = this.renderer,
      a = "webgl2" === t.renderer.getRenderingBackend(),
      r = t.shadowMapUseDepthTextures && t.renderer.supportsDepthTextures(),
      i = !1,
      o = t.shadowMapType,
      n = 0,
      s = e.length;
      s > n;
      n++
    ) {
      var l = e[n];
      (i = i || l.castShadow),
        void 0 !== l.shadowMapType && (o = Math.max(o, l.shadowMapType));
    }
    var h = {};
    if (t.shadowMapEnabled && i) {
      switch (((h.USE_SHADOWMAP = !0), o)) {
        case XG.BasicShadowMap:
          h.SHADOWMAP_TYPE_BASIC = !0;
          break;
        case XG.PCFSoftShadowMap:
          h.SHADOWMAP_TYPE_PCF_SOFT = !0;
          break;
        case XG.PCFSoftHQShadowMap:
          h.SHADOWMAP_TYPE_PCF_SOFT_HQ = !0;
      }
      (h.SLOPE_DEPTH_BIAS = t.shadowMapSlopeDepthBias),
        (h.SHADOWMAP_DEBUG = t.shadowMapDebug),
        (h.SHADOW_TEXTURE_DEPTH =
          t.shadowMapUseDepthTextures && t.renderer.supportsDepthTextures()),
        (h.USE_SHADOWSAMPLER = a && r);
    }
    return (
      (h.USE_MRT = t.getUseMultipleRenderTargets()),
      (h.TEXTURE_DEPTH = t.useDepthTexture),
      (h.MAX_POLY_LIGHTS_MULTI = e.length),
      h
    );
  }),
  (XG.MultiPolyLightProxy.prototype.setupShadowmap = function () {
    for (
      var e = this.getShadowMapParameters(),
      t = this.lights,
      a = 0,
      r = t.length;
      r > a;
      a++
    ) {
      var i = t[a];
      if (i.castShadow) {
        var o = i.properties,
          n = new XG.RenderTarget(i.shadowMapWidth, i.shadowMapHeight, e);
        if (((n.generateMipmaps = !1), (o.shadowMap = n), i.shadowCameraOrtho))
          var s = new XG.OrthographicCamera(
            i.shadowCameraLeft,
            i.shadowCameraRight,
            i.shadowCameraTop,
            i.shadowCameraBottom,
            i.shadowCameraNear,
            i.shadowCameraFar
          );
        else
          var l = i.shadowMapWidth / i.shadowMapHeight,
            s = new XG.PerspectiveCamera(
              i.shadowCameraFov,
              l,
              i.shadowCameraNear,
              i.shadowCameraFar
            );
        o.shadowCamera = s;
        var h = new XG.Matrix4(),
          d = new XG.Matrix4();
        (o.shadowMatrixDeferred = h),
          (o.shadowMatrixForward = d),
          (o.shadowMapPars = [
            i.shadowMapWidth,
            i.shadowMapHeight,
            i.shadowDarkness,
            i.shadowBias,
          ]),
          (o.shadowCameraPars = [i.shadowCameraNear, i.shadowCameraFar]);
      }
    }
  }),
  (XG.MultiPolyLightProxy.prototype.update = function (e) {
    XG.LightProxy.prototype.update.call(this, e);
    var t = this.lights,
      a = this.materials[0].uniforms;
    (a.samplerLtcMat.value = this.samplerLtcMat),
      (a.samplerLtcMag.value = this.samplerLtcMag);
    for (
      var r = a.polyLightPoints.value,
      i = a.polyLightColor.value,
      o = a.polyLightPars.value,
      n = a.samplerTexture.value,
      s = a.samplerTexturePars.value,
      l = a.samplerShadowMap.value,
      h = a.shadowMapPars.value,
      d = a.shadowMatrix.value,
      c = e.matrixWorldInverse,
      u = XG.MultiPolyLightProxy.tmpColor,
      f = XG.LightProxy.positionWS,
      p = XG.LightProxy.rightWS,
      m = XG.LightProxy.normalWS,
      v = XG.LightProxy.upWS,
      g = 0,
      S = t.length;
      S > g;
      g++
    ) {
      var x = t[g],
        G = x.matrixWorld,
        M = 3 * g,
        y = 4 * g;
      f.copy(G.getPosition()),
        p.copy(x.right).normalize(),
        m.copy(x.normal).normalize(),
        G.rotateAxis(p),
        G.rotateAxis(m),
        v.cross(p, m),
        v.normalize(),
        p.multiplyScalar(x.width),
        v.multiplyScalar(x.height);
      var w = r[y];
      w.copy(f),
        w.subSelf(p),
        w.addSelf(v),
        c.multiplyVector3(w),
        (w = r[y + 1]),
        w.copy(f),
        w.addSelf(p),
        w.addSelf(v),
        c.multiplyVector3(w),
        (w = r[y + 2]),
        w.copy(f),
        w.addSelf(p),
        w.subSelf(v),
        c.multiplyVector3(w),
        (w = r[y + 3]),
        w.copy(f),
        w.subSelf(p),
        w.subSelf(v),
        c.multiplyVector3(w),
        (o[g] = x.twoSided);
      var _ = x.intensity * x.intensity;
      if (
        (u.copyGammaToLinear(x.color),
          (i[M] = u.r * _),
          (i[M + 1] = u.g * _),
          (i[M + 2] = u.b * _),
          (n[g] = x.texture),
          (s[2 * g] = x.texture ? x.texture.getWidth() : 0),
          (s[2 * g + 1] = x.textureBias),
          x.castShadow)
      ) {
        var X = x.properties.shadowMatrixDeferred,
          D = x.properties.shadowMatrixForward,
          T = x.properties.shadowCamera,
          C = x.properties.shadowMap;
        X.multiply(T.projectionMatrix, T.matrixWorldInverse),
          D.multiply(XG.LightProxy.biasMatrix, X),
          X.multiplySelf(e.matrixWorld),
          (d[g] = X),
          (l[g] = C.useDepthTexture ? C.depthTexture : C),
          (h[y] = x.shadowMapWidth),
          (h[y + 1] = x.shadowMapHeight),
          (h[y + 2] = Math.sqrt(x.shadowDarkness)),
          (h[y + 3] = x.shadowBias);
      }
    }
  }),
  (XG.MultiPolyLightProxy.tmpColor = new XG.Color()),
  (XG.DayLightProxy = function (e, t) {
    XG.LightProxy.call(this, e, t);
    var a = XG.DeferredShaders.dayLight,
      r = XG.UniformsUtils.clone(a.uniforms),
      i = this.generateDefines(e),
      o = e.shadowCascade ? e.shadowCascadeCount : 1;
    i.SHADOWMAP_COUNT = o;
    var n = {};
    t.skinHighQuality && (n.OES_standard_derivatives = !0);
    var s = new XG.ShaderMaterial({
      uniforms: r,
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      defines: i,
      extensions: n,
      blending: XG.AdditiveBlending,
      depthWrite: !1,
      depthTest: !1,
      transparent: !0,
    });
    this.setSamplers(s);
    var l = XG.LightProxy.geometryLightPlane;
    XG.Mesh.call(this, l, s),
      e.castShadow && this.setupDirectionalShadowmap(o),
      (e.texture || e.castTransparentShadow) && this.setupProjectedTexture();
  }),
  (XG.DayLightProxy.prototype = Object.create(XG.LightProxy.prototype)),
  (XG.DayLightProxy.prototype.update = function (e) {
    XG.LightProxy.prototype.update.call(this, e);
    var t = this.light,
      a = this.materials[0].uniforms,
      r = XG.LightProxy.directionVS;
    r.copy(t.matrixWorld.getPosition()),
      r.subSelf(t.target.matrixWorld.getPosition()),
      r.normalize(),
      e.matrixWorldInverse.rotateAxis(r),
      a.lightDirectionVSSun.value.copy(r),
      r.copy(t.hemiPosition),
      r.normalize(),
      e.matrixWorldInverse.rotateAxis(r),
      a.lightDirectionVSHemi.value.copy(r);
    var i = t.sunIntensity * t.sunIntensity,
      o = t.hemiIntensity * t.hemiIntensity;
    (a.lightIntensitySun.value = i),
      (a.lightIntensityHemi.value = o),
      a.lightColorSun.value.copyGammaToLinear(t.color),
      a.lightColorSky.value.copyGammaToLinear(t.skyColor),
      a.lightColorGround.value.copyGammaToLinear(t.groundColor),
      t.castShadow && this.updateDirectionalShadowmap(e),
      t.texture && this.updateProjectedTexture(e);
  }),
  (XG.DayLightCubeProxy = function (e, t) {
    XG.LightProxy.call(this, e, t);
    var a = XG.DeferredShaders.dayLightCube,
      r = XG.UniformsUtils.clone(a.uniforms),
      i = this.generateDefines(e),
      o = {},
      n = e.shadowCascade ? e.shadowCascadeCount : 1;
    switch (
    ((i.SHADOWMAP_COUNT = n),
      e.local && (i.LIGHT_LOCAL = !0),
      e.textureEncoding)
    ) {
      case XG.rgba8Encoding:
        i.IBL_LDR_RGBA = !0;
        break;
      case XG.rgbm8Encoding:
        i.IBL_HDR_RGBM = !0;
        break;
      case XG.rgba16fEncoding:
        i.IBL_HDR_RGBA16F = !0;
        break;
      case XG.rgba32fEncoding:
        i.IBL_HDR_RGBA32F = !0;
    }
    var s = e.textureSpecular instanceof XG.RenderTargetCube;
    e.textureGamma && !s && (i.IBL_GAMMA_TEXTURE = !0),
      e.textureFixSeams && (i.FIX_SEAMS = !0),
      t.specularMipFix && (i.SPECULAR_MIP_FIX = !0),
      (t.skinHighQuality || t.specularMipFix) &&
      (o.OES_standard_derivatives = !0),
      t.renderer.supportsShaderTextureLod() &&
      ((o.EXT_shader_texture_lod = !0), (o.OES_standard_derivatives = !0));
    var l = new XG.ShaderMaterial({
      uniforms: r,
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      defines: i,
      extensions: o,
      blending: XG.AdditiveBlending,
      depthWrite: !1,
      depthTest: !1,
      transparent: !0,
    });
    this.setSamplers(l);
    var h = XG.LightProxy.geometryLightPlane;
    XG.Mesh.call(this, h, l),
      e.castShadow && this.setupDirectionalShadowmap(n),
      (e.texture || e.castTransparentShadow) && this.setupProjectedTexture();
  }),
  (XG.DayLightCubeProxy.prototype = Object.create(XG.LightProxy.prototype)),
  (XG.DayLightCubeProxy.prototype.update = function (e) {
    XG.LightProxy.prototype.update.call(this, e);
    var t = this.light,
      a = this.materials[0].uniforms,
      r = XG.LightProxy.directionVS;
    r.copy(t.matrixWorld.getPosition()),
      r.subSelf(t.target.matrixWorld.getPosition()),
      r.normalize(),
      e.matrixWorldInverse.rotateAxis(r),
      a.lightDirectionVSSun.value.copy(r),
      (a.samplerSpecular.value = t.textureSpecular),
      (a.samplerDiffuse.value = t.textureDiffuse),
      (a.samplerMip.value = t.textureMip),
      (a.maxMipSpecular.value = t.textureSpecular.mipmapCount);
    var i = t.textureSpecular.image ? t.textureSpecular.image[0] : null,
      o = i ? i.width : 0;
    if (((a.samplerSize.value = o), t.local)) {
      var n = t.size,
        s = t.cubePosition;
      this.position.copy(s),
        this.scale.copy(n),
        a.lightSize.value.copy(n).multiplyScalar(0.5),
        a.lightPositionWS.value.copy(s);
    }
    var l = t.intensity * t.intensity,
      h = t.ambientIntensity * t.ambientIntensity;
    (a.lightIntensitySun.value = l),
      (a.lightIntensityAmbient.value = h),
      a.lightColorSun.value.copyGammaToLinear(t.color),
      t.castShadow && this.updateDirectionalShadowmap(e),
      t.texture && this.updateProjectedTexture(e);
  }),
  (XG.DirectionalLightProxy = function (e, t) {
    XG.LightProxy.call(this, e, t);
    var a = XG.DeferredShaders.directionalLight,
      r = XG.UniformsUtils.clone(a.uniforms),
      i = this.generateDefines(e),
      o = {};
    t.skinHighQuality && (o.OES_standard_derivatives = !0);
    var n = e.shadowCascade ? e.shadowCascadeCount : 1;
    i.SHADOWMAP_COUNT = n;
    var s = new XG.ShaderMaterial({
      uniforms: r,
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      defines: i,
      extensions: o,
      blending: XG.AdditiveBlending,
      depthWrite: !1,
      depthTest: !1,
      transparent: !0,
    });
    this.setSamplers(s);
    var l = XG.LightProxy.geometryLightPlane;
    XG.Mesh.call(this, l, s),
      e.castShadow && this.setupDirectionalShadowmap(n),
      (e.texture || e.castTransparentShadow) && this.setupProjectedTexture();
  }),
  (XG.DirectionalLightProxy.prototype = Object.create(XG.LightProxy.prototype)),
  (XG.DirectionalLightProxy.prototype.update = function (e) {
    XG.LightProxy.prototype.update.call(this, e);
    var t = this.light,
      a = this.materials[0].uniforms,
      r = XG.LightProxy.directionVS;
    r.copy(t.matrixWorld.getPosition()),
      r.subSelf(t.target.matrixWorld.getPosition()),
      r.normalize(),
      e.matrixWorldInverse.rotateAxis(r),
      a.lightDirectionVS.value.copy(r);
    var i = t.intensity * t.intensity;
    (a.lightIntensity.value = i),
      a.lightColor.value.copyGammaToLinear(t.color),
      t.castShadow && this.updateDirectionalShadowmap(e),
      t.texture && this.updateProjectedTexture(e);
  }),
  (XG.HemisphereLightProxy = function (e, t) {
    XG.LightProxy.call(this, e, t);
    var a = XG.DeferredShaders.hemisphereLight,
      r = XG.UniformsUtils.clone(a.uniforms),
      i = this.generateDefines(e),
      o = {};
    t.skinHighQuality && (o.OES_standard_derivatives = !0);
    var n = new XG.ShaderMaterial({
      uniforms: r,
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      defines: i,
      extensions: o,
      blending: XG.AdditiveBlending,
      depthWrite: !1,
      depthTest: !1,
      transparent: !0,
    });
    this.setSamplers(n);
    var s = XG.LightProxy.geometryLightPlane;
    XG.Mesh.call(this, s, n);
  }),
  (XG.HemisphereLightProxy.prototype = Object.create(XG.LightProxy.prototype)),
  (XG.HemisphereLightProxy.prototype.update = function (e) {
    XG.LightProxy.prototype.update.call(this, e);
    var t = this.light,
      a = this.materials[0].uniforms,
      r = XG.LightProxy.directionVS;
    r.copy(t.matrixWorld.getPosition()),
      r.normalize(),
      e.matrixWorldInverse.rotateAxis(r),
      a.lightDirectionVS.value.copy(r);
    var i = t.intensity * t.intensity;
    (a.lightIntensity.value = i),
      a.lightColorSky.value.copyGammaToLinear(t.color),
      a.lightColorGround.value.copyGammaToLinear(t.groundColor);
  }),
  (XG.PointLightProxy = function (e, t) {
    XG.LightProxy.call(this, e, t);
    var a = XG.DeferredShaders.pointLight,
      r = XG.UniformsUtils.clone(a.uniforms),
      i = this.generateDefines(),
      o = {};
    t.skinHighQuality && (o.OES_standard_derivatives = !0);
    var n,
      s = new XG.ShaderMaterial({
        uniforms: r,
        vertexShader: a.vertexShader,
        fragmentShader: a.fragmentShader,
        defines: i,
        extensions: o,
        blending: XG.AdditiveBlending,
        depthWrite: !1,
        transparent: !0,
      });
    e.distance > 0
      ? ((n = XG.LightProxy.geometryLightSphere),
        (s.depthTest = !0),
        (s.side = XG.BackSide))
      : ((n = XG.LightProxy.geometryLightPlane),
        (s.depthTest = !1),
        (s.side = XG.FrontSide)),
      this.setSamplers(s),
      XG.Mesh.call(this, n, s),
      e.castShadow && this.setupShadowmap();
  }),
  (XG.PointLightProxy.prototype = Object.create(XG.LightProxy.prototype)),
  (XG.PointLightProxy.prototype.setupShadowmap = function () {
    var e = this.light,
      t = e.properties,
      a = this.getShadowMapParameters();
    t.shadowCamera = [];
    for (
      var r = [
        new XG.Vector3(0, -1, 0),
        new XG.Vector3(0, -1, 0),
        new XG.Vector3(0, 0, 1),
        new XG.Vector3(0, 0, -1),
        new XG.Vector3(0, -1, 0),
        new XG.Vector3(0, -1, 0),
      ],
      i = [
        new XG.Vector3(1, 0, 0),
        new XG.Vector3(-1, 0, 0),
        new XG.Vector3(0, 1, 0),
        new XG.Vector3(0, -1, 0),
        new XG.Vector3(0, 0, 1),
        new XG.Vector3(0, 0, -1),
      ],
      o = 0;
      6 > o;
      o++
    ) {
      var n = e.shadowMapWidth / e.shadowMapHeight,
        s = new XG.PerspectiveCamera(
          90,
          n,
          e.shadowCameraNear,
          e.shadowCameraFar
        );
      s.up.copy(r[o]), s.lookAt(i[o]), (t.shadowCamera[o] = s);
    }
    var l = new XG.RenderTarget(6 * e.shadowMapWidth, e.shadowMapHeight, a);
    (l.generateMipmaps = !1),
      (t.shadowMap = l),
      (t.shadowMatrixTranslation = new XG.Matrix4()),
      (t.shadowMapPars = [
        e.shadowMapWidth,
        e.shadowMapHeight,
        e.shadowDarkness,
        e.shadowBias,
      ]),
      (t.shadowCameraPars = [e.shadowCameraNear, e.shadowCameraFar]);
  }),
  (XG.PointLightProxy.prototype.update = function (e) {
    XG.LightProxy.prototype.update.call(this, e);
    var t = this.light,
      a = this.materials[0].uniforms,
      r = t.properties,
      i = t.distance;
    if (i > 0) {
      var o = XG.LightProxy.positionVS;
      this.scale.set(1, 1, 1).multiplyScalar(i),
        (a.lightDistance.value = i),
        o.copy(t.matrixWorld.getPosition()),
        e.matrixWorldInverse.multiplyVector3(o),
        a.lightPositionVS.value.copy(o),
        this.position.copy(t.matrixWorld.getPosition());
    } else a.lightDistance.value = 1 / 0;
    var n = t.intensity * t.intensity;
    if (
      ((a.lightIntensity.value = n),
        a.lightColor.value.copyGammaToLinear(t.color),
        t.castShadow)
    ) {
      var s = XG.LightProxy.tmpVec;
      s.copy(t.matrixWorld.getPosition()),
        a.lightPositionWS.value.copy(s),
        s.negate();
      var l = r.shadowMatrixTranslation;
      l.identity(), l.setPosition(s);
      var h = r.shadowMap;
      (a.samplerShadowMap.value = h.useDepthTexture ? h.depthTexture : h),
        a.shadowCameraPars.value.set(t.shadowCameraNear, t.shadowCameraFar),
        (a.shadowDarkness.value = Math.sqrt(t.shadowDarkness)),
        (a.shadowBias.value = t.shadowBias),
        a.shadowMapSize.value.set(t.shadowMapWidth, t.shadowMapHeight);
    }
  }),
  (XG.SphereLightProxy = function (e, t) {
    XG.LightProxy.call(this, e, t);
    var a = XG.DeferredShaders.sphereLight,
      r = XG.UniformsUtils.clone(a.uniforms),
      i = this.generateDefines(),
      o = {};
    t.skinHighQuality && (o.OES_standard_derivatives = !0);
    var n,
      s = new XG.ShaderMaterial({
        uniforms: r,
        vertexShader: a.vertexShader,
        fragmentShader: a.fragmentShader,
        defines: i,
        extensions: o,
        blending: XG.AdditiveBlending,
        depthWrite: !1,
        transparent: !0,
      });
    e.distance > 0
      ? ((n = XG.LightProxy.geometryLightSphere),
        (s.depthTest = !0),
        (s.side = XG.BackSide))
      : ((n = XG.LightProxy.geometryLightPlane),
        (s.depthTest = !1),
        (s.side = XG.FrontSide)),
      this.setSamplers(s),
      XG.Mesh.call(this, n, s),
      e.castShadow && this.setupShadowmap();
  }),
  (XG.SphereLightProxy.prototype = Object.create(XG.LightProxy.prototype)),
  (XG.SphereLightProxy.prototype.setupShadowmap = function () {
    var e = this.light,
      t = e.properties,
      a = this.getShadowMapParameters();
    t.shadowCamera = [];
    for (
      var r = [
        new XG.Vector3(0, -1, 0),
        new XG.Vector3(0, -1, 0),
        new XG.Vector3(0, 0, 1),
        new XG.Vector3(0, 0, -1),
        new XG.Vector3(0, -1, 0),
        new XG.Vector3(0, -1, 0),
      ],
      i = [
        new XG.Vector3(1, 0, 0),
        new XG.Vector3(-1, 0, 0),
        new XG.Vector3(0, 1, 0),
        new XG.Vector3(0, -1, 0),
        new XG.Vector3(0, 0, 1),
        new XG.Vector3(0, 0, -1),
      ],
      o = 0;
      6 > o;
      o++
    ) {
      var n = e.shadowMapWidth / e.shadowMapHeight,
        s = new XG.PerspectiveCamera(
          90,
          n,
          e.shadowCameraNear,
          e.shadowCameraFar
        );
      s.up.copy(r[o]), s.lookAt(i[o]), (t.shadowCamera[o] = s);
    }
    var l = new XG.RenderTarget(6 * e.shadowMapWidth, e.shadowMapHeight, a);
    (l.generateMipmaps = !1),
      (t.shadowMap = l),
      (t.shadowMatrixTranslation = new XG.Matrix4()),
      (t.shadowMapPars = [
        e.shadowMapWidth,
        e.shadowMapHeight,
        e.shadowDarkness,
        e.shadowBias,
      ]),
      (t.shadowCameraPars = [e.shadowCameraNear, e.shadowCameraFar]);
  }),
  (XG.SphereLightProxy.prototype.update = function (e) {
    XG.LightProxy.prototype.update.call(this, e);
    var t = this.light,
      a = this.materials[0].uniforms,
      r = t.properties,
      i = t.distance;
    if (i > 0) {
      var o = XG.LightProxy.positionVS;
      this.scale.set(1, 1, 1).multiplyScalar(i),
        (a.lightDistance.value = i),
        o.copy(t.matrixWorld.getPosition()),
        e.matrixWorldInverse.multiplyVector3(o),
        a.lightPositionVS.value.copy(o),
        this.position.copy(t.matrixWorld.getPosition());
    } else a.lightDistance.value = 1 / 0;
    a.lightRadius.value = t.radius;
    var n = t.intensity * t.intensity;
    if (
      ((a.lightIntensity.value = n),
        a.lightColor.value.copyGammaToLinear(t.color),
        t.castShadow)
    ) {
      var s = XG.LightProxy.tmpVec;
      s.copy(t.matrixWorld.getPosition()),
        a.lightPositionWS.value.copy(s),
        s.negate();
      var l = r.shadowMatrixTranslation;
      l.identity(), l.setPosition(s);
      var h = r.shadowMap;
      (a.samplerShadowMap.value = h.useDepthTexture ? h.depthTexture : h),
        a.shadowCameraPars.value.set(t.shadowCameraNear, t.shadowCameraFar),
        (a.shadowDarkness.value = Math.sqrt(t.shadowDarkness)),
        (a.shadowBias.value = t.shadowBias),
        a.shadowMapSize.value.set(t.shadowMapWidth, t.shadowMapHeight);
    }
  }),
  (XG.TubeLightProxy = function (e, t) {
    XG.LightProxy.call(this, e, t);
    var a = XG.DeferredShaders.tubeLight,
      r = XG.UniformsUtils.clone(a.uniforms),
      i = this.generateDefines();
    e.occlusionEnabled && (i.OCCLUSION_ENABLED = !0);
    var o = new XG.ShaderMaterial({
      uniforms: r,
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      defines: i,
      blending: XG.AdditiveBlending,
      depthWrite: !1,
      depthTest: !1,
      transparent: !0,
      side: XG.FrontSide,
    }),
      n = XG.LightProxy.geometryLightPlane;
    this.setSamplers(o), XG.Mesh.call(this, n, o);
  }),
  (XG.TubeLightProxy.prototype = Object.create(XG.LightProxy.prototype)),
  (XG.TubeLightProxy.prototype.update = function (e) {
    XG.LightProxy.prototype.update.call(this, e);
    var t = this.light,
      a = this.materials[0].uniforms,
      r = XG.LightProxy.positionVS;
    r.copy(t.endPoint0.matrixWorld.getPosition()),
      e.matrixWorldInverse.multiplyVector3(r),
      a.lightPosition0VS.value.copy(r),
      r.copy(t.endPoint1.matrixWorld.getPosition()),
      e.matrixWorldInverse.multiplyVector3(r),
      a.lightPosition1VS.value.copy(r),
      (a.lightDistance.value = t.distance),
      (a.lightRadius.value = t.radius);
    var i = t.intensity * t.intensity;
    (a.lightIntensity.value = i), a.lightColor.value.copyGammaToLinear(t.color);
  }),
  (XG.ImageLightProxy = function (e, t) {
    XG.LightProxy.call(this, e, t);
    var a = XG.DeferredShaders.imageLight,
      r = XG.UniformsUtils.clone(a.uniforms),
      i = this.generateDefines(),
      o = {};
    switch ((e.local && (i.LIGHT_LOCAL = !0), e.textureEncoding)) {
      case XG.rgba8Encoding:
        i.IBL_LDR_RGBA = !0;
        break;
      case XG.rgbm8Encoding:
        i.IBL_HDR_RGBM = !0;
        break;
      case XG.rgba16fEncoding:
        i.IBL_HDR_RGBA16F = !0;
        break;
      case XG.rgba32fEncoding:
        i.IBL_HDR_RGBA32F = !0;
    }
    var n = e.textureSpecular instanceof XG.RenderTargetCube;
    e.textureGamma && !n && (i.IBL_GAMMA_TEXTURE = !0),
      e.textureFixSeams && (i.FIX_SEAMS = !0),
      t.specularMipFix &&
      ((i.SPECULAR_MIP_FIX = !0), (o.OES_standard_derivatives = !0)),
      t.renderer.supportsShaderTextureLod() &&
      ((o.EXT_shader_texture_lod = !0), (o.OES_standard_derivatives = !0));
    var s = new XG.ShaderMaterial({
      uniforms: r,
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      defines: i,
      extensions: o,
      blending: XG.AdditiveBlending,
      depthWrite: !1,
      transparent: !0,
    });
    this.setSamplers(s);
    var l;
    e.local
      ? ((l = XG.LightProxy.geometryLightBox),
        (s.depthTest = !0),
        (s.side = XG.BackSide))
      : ((l = XG.LightProxy.geometryLightPlane),
        (s.depthTest = !1),
        (s.side = XG.FrontSide)),
      XG.Mesh.call(this, l, s);
  }),
  (XG.ImageLightProxy.prototype = Object.create(XG.LightProxy.prototype)),
  (XG.ImageLightProxy.prototype.update = function (e) {
    XG.LightProxy.prototype.update.call(this, e);
    var t = this.light,
      a = this.materials[0].uniforms;
    (a.samplerSpecular.value = t.textureSpecular),
      (a.samplerDiffuse.value = t.textureDiffuse),
      (a.samplerMip.value = t.textureMip),
      (a.maxMipSpecular.value = t.textureSpecular.mipmapCount);
    var r = t.intensity * t.intensity;
    a.lightIntensity.value = r;
    var i = t.textureSpecular.image ? t.textureSpecular.image[0] : null,
      o = i ? i.width : 0;
    if (((a.samplerSize.value = o), t.local)) {
      var n = t.size,
        s = t.matrixWorld.getPosition();
      this.position.copy(s),
        this.scale.copy(n),
        a.lightSize.value.copy(n).multiplyScalar(0.5),
        a.lightPositionWS.value.copy(s);
    }
  }),
  (XG.FirstPersonControls = function (e, t) {
    var a = this;
    (this.element = t),
      (this.enabled = !1),
      (this.movementSpeed = 1),
      (this.decaySpeed = 1),
      (this.lookSpeed = 0.1),
      (this.amplitude = 0.1),
      (this.frequency = 2);
    var r = new XG.Node();
    r.add(e);
    var i = new XG.Node();
    i.add(r);
    var o = new XG.Node();
    o.add(i);
    var n = !1,
      s = !1,
      l = !1,
      h = !1,
      d = new XG.Vector3(),
      c = 0,
      u = Math.PI / 2,
      f = function (e) {
        var t = 0.001;
        if (a.enabled !== !1) {
          var r = e.movementX || e.mozMovementX || e.webkitMovementX || 0,
            n = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
          (o.rotation.y -= r * a.lookSpeed * t),
            (i.rotation.x -= n * a.lookSpeed * t),
            (i.rotation.x = XG.Math.clamp(i.rotation.x, -u, u));
        }
      },
      p = function (e) {
        switch (e.keyCode) {
          case 38:
          case 87:
            n = !0;
            break;
          case 37:
          case 65:
            l = !0;
            break;
          case 40:
          case 83:
            s = !0;
            break;
          case 39:
          case 68:
            h = !0;
        }
      },
      m = function (e) {
        switch (e.keyCode) {
          case 38:
          case 87:
            n = !1;
            break;
          case 37:
          case 65:
            l = !1;
            break;
          case 40:
          case 83:
            s = !1;
            break;
          case 39:
          case 68:
            h = !1;
        }
      },
      v = function () {
        a.enabled =
          document.pointerLockElement === a.element ||
            document.mozPointerLockElement === a.element ||
            document.webkitPointerLockElement === a.element
            ? !0
            : !1;
      };
    document.addEventListener("mousemove", f, !1),
      document.addEventListener("keydown", p, !1),
      document.addEventListener("keyup", m, !1),
      document.addEventListener("click", function () {
        var e =
          "pointerLockElement" in document ||
          "mozPointerLockElement" in document ||
          "webkitPointerLockElement" in document;
        if (!e) return void console.warn("Pointer lock not available");
        var t = a.element;
        t.requestPointerLock =
          t.requestPointerLock ||
          t.mozRequestPointerLock ||
          t.webkitRequestPointerLock;
        var r = /Firefox/i.test(navigator.userAgent);
        if (r) {
          var i = function () {
            (document.fullscreenElement === t ||
              document.mozFullscreenElement === t ||
              document.mozFullScreenElement === t) &&
              (document.removeEventListener("fullscreenchange", i),
                document.removeEventListener("mozfullscreenchange", i),
                t.requestPointerLock());
          };
          document.addEventListener("fullscreenchange", i, !1),
            document.addEventListener("mozfullscreenchange", i, !1),
            (t.requestFullscreen =
              t.requestFullscreen ||
              t.mozRequestFullscreen ||
              t.mozRequestFullScreen ||
              t.webkitRequestFullscreen),
            t.requestFullscreen();
        } else t.requestPointerLock();
        document.addEventListener("pointerlockchange", v, !1),
          document.addEventListener("mozpointerlockchange", v, !1),
          document.addEventListener("webkitpointerlockchange", v, !1);
      }),
      (this.getRoot = function () {
        return o;
      }),
      (this.attachCamera = function (e) {
        r.add(e);
      }),
      (this.lookAt = function (e) {
        o.updateMatrixWorld(),
          o.lookAt(e),
          (o.rotation.x = 0),
          (o.rotation.z = 0),
          (o.rotation.y *= -1);
      }),
      (this.update = function (e) {
        if (((c += e), a.enabled !== !1)) {
          var t = a.movementSpeed,
            i = a.decaySpeed;
          (d.x += -d.x * i * e), (d.z += -d.z * i * e);
          var u = Math.sqrt(d.x * d.x + d.z * d.z);
          (r.position.y = u * a.amplitude * Math.sin(c * a.frequency)),
            n && (d.z -= t * e),
            s && (d.z += t * e),
            l && (d.x -= t * e),
            h && (d.x += t * e),
            o.translateX(d.x),
            o.translateY(d.y),
            o.translateZ(d.z);
        }
      });
  }),
  (XG.Loader = function (e) {
    (this.showStatus = e),
      (this.statusDomElement = e
        ? XG.Loader.prototype.addStatusElement()
        : null),
      (this.onLoadStart = function () { }),
      (this.onLoadProgress = function () { }),
      (this.onLoadComplete = function () { }),
      (this.textureMap = {});
  }),
  (XG.Loader.prototype = {
    constructor: XG.Loader,
    crossOrigin: "anonymous",
    addStatusElement: function () {
      var e = document.createElement("div");
      return (
        (e.style.position = "absolute"),
        (e.style.right = "0px"),
        (e.style.top = "0px"),
        (e.style.fontSize = "0.8em"),
        (e.style.textAlign = "left"),
        (e.style.background = "rgba(0,0,0,0.25)"),
        (e.style.color = "#fff"),
        (e.style.width = "120px"),
        (e.style.padding = "0.5em 0.5em 0.5em 0.5em"),
        (e.style.zIndex = 1e3),
        (e.innerHTML = "Loading ..."),
        e
      );
    },
    updateProgress: function (e) {
      var t = "Loaded ";
      (t += e.total
        ? ((100 * e.loaded) / e.total).toFixed(0) + "%"
        : (e.loaded / 1e3).toFixed(2) + " KB"),
        (this.statusDomElement.innerHTML = t);
    },
    extractUrlBase: function (e) {
      var t = e.split("/");
      return t.pop(), (t.length < 1 ? "." : t.join("/")) + "/";
    },
    initMaterials: function (e, t) {
      for (var a = [], r = 0; r < e.length; ++r)
        a[r] = this.createMaterial(e[r], t);
      return a;
    },
    needsTangents: function (e) {
      for (var t = 0, a = e.length; a > t; t++) {
        var r = e[t];
        if (r instanceof XG.ShaderMaterial) return !0;
      }
      return !1;
    },
    createMaterial: function (e, t, a) {
      function r(e) {
        var t = Math.log(e) / Math.LN2;
        return Math.floor(t) == t;
      }
      function i(e) {
        var t = Math.log(e) / Math.LN2;
        return Math.pow(2, Math.round(t));
      }
      function o(e, t) {
        var a = new Image();
        (a.onload = function () {
          if (r(this.width) && r(this.height)) e.image = this;
          else {
            var t = i(this.width),
              a = i(this.height),
              o = document.createElement("canvas");
            (o.width = t),
              (o.height = a),
              o.getContext("2d").drawImage(this, 0, 0, t, a),
              (e.image = o);
          }
          e.needsUpdate = !0;
        }),
          (a.crossOrigin = d.crossOrigin),
          (a.src = t);
      }
      function n(e, t) {
        return "/" === e[e.length - 1] ? e + t : e + "/" + t;
      }
      function s(e, t, a, r, i) {
        var o = e;
        return (
          t && (o += "_R[" + t[0] + "_" + t[1] + "]"),
          a && (o += "_O[" + a[0] + "_" + a[1] + "]"),
          r && (o += "_W[" + r[0] + "_" + r[1] + "]"),
          i && (o += "_A[" + i + "]"),
          o
        );
      }
      function l(e, r, i, l, h, c, u) {
        var f,
          p = n(t, i),
          m = s(p, l, h, c, u);
        if (void 0 === d.textureMap[m]) {
          var v,
            g = i.toLowerCase().endsWith(".dds"),
            S = i.toLowerCase().endsWith(".crn");
          if (
            (g
              ? a
                ? ((v = new XG.CompressedTexture()),
                  (f = v),
                  XG.ImageUtils.generateDummyCompressedTexture(v))
                : (v = XG.ImageUtils.loadCompressedTexture(p))
              : S
                ? a
                  ? ((v = new XG.CompressedTexture()),
                    (f = v),
                    XG.ImageUtils.generateDummyCompressedTexture(v))
                  : (v = XG.ImageUtils.loadCRNTexture(p))
                : ((v = new XG.Texture()), o(v, p)),
              (v.sourceFile = i),
              l &&
              (v.repeat.set(l[0], l[1]),
                1 !== l[0] && (v.wrapS = XG.RepeatWrapping),
                1 !== l[1] && (v.wrapT = XG.RepeatWrapping)),
              h && v.offset.set(h[0], h[1]),
              c)
          ) {
            var x = {
              repeat: XG.RepeatWrapping,
              mirror: XG.MirroredRepeatWrapping,
            };
            void 0 !== x[c[0]] && (v.wrapS = x[c[0]]),
              void 0 !== x[c[1]] && (v.wrapT = x[c[1]]);
          }
          u && (v.anisotropy = u), (d.textureMap[m] = v);
        }
        return (e[r] = d.textureMap[m]), f;
      }
      function h(e) {
        return ((255 * e[0]) << 16) + ((255 * e[1]) << 8) + 255 * e[2];
      }
      var d = this,
        c = "PhongMaterial",
        u = {
          color: 15658734,
          opacity: 1,
          map: null,
          lightMap: null,
          normalMap: null,
          bumpMap: null,
        };
      if (e.shading) {
        var f = e.shading.toLowerCase();
        "phong" === f
          ? (c = "PhongMaterial")
          : "basic" === f && (c = "EmissiveMaterial");
      }
      void 0 !== e.blending &&
        void 0 !== XG[e.blending] &&
        (u.blending = XG[e.blending]),
        (void 0 !== e.transparent || e.transparency < 1) &&
        (u.transparent = e.transparent),
        void 0 !== e.depthTest && (u.depthTest = e.depthTest),
        void 0 !== e.depthWrite && (u.depthWrite = e.depthWrite),
        void 0 !== e.visible && (u.visible = e.visible),
        void 0 !== e.flipSided && (u.side = XG.BackSide),
        void 0 !== e.doubleSided && (u.side = XG.DoubleSide),
        void 0 !== e.vertexColors && (u.vertexColors = e.vertexColors),
        void 0 !== e.skinning && (u.skinning = e.skinning),
        void 0 !== e.wrapAround && (u.wrapAround = e.wrapAround),
        void 0 !== e.wrapRGB &&
        (u.wrapRGB = new XG.Vector3(
          e.wrapRGB[0],
          e.wrapRGB[1],
          e.wrapRGB[2]
        )),
        e.colorDiffuse
          ? (u.color = h(e.colorDiffuse))
          : e.DbgColor && (u.color = e.DbgColor),
        e.colorSpecular && (u.specular = h(e.colorSpecular)),
        e.colorAmbient && (u.ambient = h(e.colorAmbient)),
        e.transparency && (u.opacity = e.transparency),
        e.specularCoef && (u.shininess = e.specularCoef);
      var p,
        m = [];
      e.mapDiffuse &&
        t &&
        ((p = l(
          u,
          "map",
          e.mapDiffuse,
          e.mapDiffuseRepeat,
          e.mapDiffuseOffset,
          e.mapDiffuseWrap,
          e.mapDiffuseAnisotropy
        )),
          p && m.push([p, e.mapDiffuse])),
        e.mapLight &&
        t &&
        ((p = l(
          u,
          "lightMap",
          e.mapLight,
          e.mapLightRepeat,
          e.mapLightOffset,
          e.mapLightWrap,
          e.mapLightAnisotropy
        )),
          p && m.push([p, e.mapLight])),
        e.mapBump &&
        t &&
        ((p = l(
          u,
          "bumpMap",
          e.mapBump,
          e.mapBumpRepeat,
          e.mapBumpOffset,
          e.mapBumpWrap,
          e.mapBumpAnisotropy
        )),
          p && m.push([p, e.mapBump])),
        e.mapNormal &&
        t &&
        ((p = l(
          u,
          "normalMap",
          e.mapNormal,
          e.mapNormalRepeat,
          e.mapNormalOffset,
          e.mapNormalWrap,
          e.mapNormalAnisotropy
        )),
          p && m.push([p, e.mapNormal])),
        e.mapSpecular &&
        t &&
        ((p = l(
          u,
          "specularMap",
          e.mapSpecular,
          e.mapSpecularRepeat,
          e.mapSpecularOffset,
          e.mapSpecularWrap,
          e.mapSpecularAnisotropy
        )),
          p && m.push([p, e.mapSpecular])),
        e.mapGloss &&
        t &&
        ((p = l(
          u,
          "glossMap",
          e.mapGloss,
          e.mapGlossRepeat,
          e.mapGlossOffset,
          e.mapGlossWrap,
          e.mapGlossAnisotropy
        )),
          p && m.push([p, e.mapGloss])),
        e.mapNormalGloss &&
        t &&
        ((p = l(
          u,
          "normalGlossMap",
          e.mapNormalGloss,
          e.mapNormalGlossRepeat,
          e.mapNormalGlossOffset,
          e.mapNormalGlossWrap,
          e.mapNormalGlossAnisotropy
        )),
          p && m.push([p, e.mapNormalGloss])),
        e.mapBumpScale && (u.bumpScale = e.mapBumpScale),
        e.mapNormalScale &&
        (u.normalScale = new XG.Vector2(
          e.mapNormalScale[0],
          e.mapNormalScale[1]
        ));
      var v = new XG[c](u);
      return (
        void 0 !== e.DbgName && (v.name = e.DbgName),
        (v.properties = { texturesToLoad: m }),
        v
      );
    },
  }),
  (XG.UTF8Loader = function () { }),
  (XG.UTF8Loader.prototype.load = function (e, t, a) {
    this.downloadModelJson(e, a, t);
  }),
  (XG.UTF8Loader.MaterialCreator = function (e, t) {
    (this.materials = {}), (this.textureMap = {});
    for (var a in t) this.createMaterial(a, t[a], e);
  }),
  (XG.UTF8Loader.MaterialCreator.prototype.get = function (e) {
    return this.materials[e];
  }),
  (XG.UTF8Loader.MaterialCreator.prototype.createMaterial = function (e, t, a) {
    var r = this,
      i = function (e) {
        var t = a + e;
        if (void 0 === r.textureMap[t]) {
          var i,
            o = e.toLowerCase().endsWith(".dds"),
            n = e.toLowerCase().endsWith(".crn");
          (i = o
            ? XG.ImageUtils.loadCompressedTexture(t)
            : n
              ? XG.ImageUtils.loadCRNTexture(t)
              : XG.ImageUtils.loadTexture(t)),
            (r.textureMap[t] = i);
        }
        return r.textureMap[t];
      },
      o = {};
    for (var n in t) {
      var s = t[n];
      switch (n.toLowerCase()) {
        case "kd":
          o.color = new XG.Color().setRGB(s[0] / 255, s[1] / 255, s[2] / 255);
          break;
        case "ka":
          o.ambient = new XG.Color().setRGB(s[0] / 255, s[1] / 255, s[2] / 255);
          break;
        case "ks":
          o.specular = new XG.Color().setRGB(
            s[0] / 255,
            s[1] / 255,
            s[2] / 255
          );
          break;
        case "map_kd":
          o.map = i(s);
          break;
        case "map_ks":
          o.specularMap = i(s);
          break;
        case "map_light":
          o.lightMap = i(s);
          break;
        case "map_normal":
          o.normalMap = i(s);
          break;
        case "map_bump":
          o.bumpMap = i(s);
          break;
        case "map_gloss":
          o.glossMap = i(s);
          break;
        case "ns":
          o.shininess = s;
          break;
        case "side":
          var l = s.toLowerCase();
          o.side =
            "double" === l
              ? XG.DoubleSide
              : "back" === l
                ? XG.BackSide
                : XG.FrontSide;
          break;
        case "alphatest":
          o.alphaTest = s;
          break;
        case "d":
          1 > s && ((o.opacity = s), (o.transparent = !0));
      }
    }
    !o.ambient && o.color && (o.ambient = o.color);
    var h = new XG.PhongMaterial(o);
    (h.name = e), (this.materials[e] = h);
  }),
  (XG.UTF8Loader.GeometryCreator = function () { }),
  (XG.UTF8Loader.GeometryCreator.prototype.create = function (e, t) {
    var a,
      r,
      i,
      o,
      n,
      s,
      l,
      h,
      d = new XG.Geometry(),
      c = e.length / 8,
      u = new Float32Array(3 * c),
      f = new Float32Array(3 * c),
      p = new Float32Array(2 * c),
      m = e.length,
      v = 8;
    for (r = 0, i = 0, a = i; m > a; a += v)
      (o = e[a]),
        (n = e[a + 1]),
        (s = e[a + 2]),
        (u[r++] = o),
        (u[r++] = n),
        (u[r++] = s);
    for (r = 0, i = 3, a = i; m > a; a += v)
      (l = e[a]), (h = e[a + 1]), (p[r++] = l), (p[r++] = h);
    for (r = 0, i = 5, a = i; m > a; a += v)
      (o = e[a]),
        (n = e[a + 1]),
        (s = e[a + 2]),
        (f[r++] = o),
        (f[r++] = n),
        (f[r++] = s);
    return (
      d.addAttributeArray("index", t, 1),
      d.addAttributeArray("position", u, 3),
      d.addAttributeArray("normal", f, 3),
      d.addAttributeArray("uv", p, 2),
      (d.numVertices = u.length / 3),
      (d.numPrimitives = t.length / 3),
      (d.offsets = [{ start: 0, count: t.length, index: 0 }]),
      d.computeBoundingSphere(),
      d
    );
  });
var DEFAULT_DECODE_PARAMS = {
  decodeOffsets: [-4095, -4095, -4095, 0, 0, -511, -511, -511],
  decodeScales: [
    1 / 8191,
    1 / 8191,
    1 / 8191,
    1 / 1023,
    1 / 1023,
    1 / 1023,
    1 / 1023,
    1 / 1023,
  ],
};
(XG.UTF8Loader.prototype.decompressAttribsInner_ = function (
  e,
  t,
  a,
  r,
  i,
  o,
  n,
  s
) {
  for (var l = 0, h = t; a > h; h++) {
    var d = e.charCodeAt(h);
    (l += (d >> 1) ^ -(1 & d)), (r[i] = s * (l + n)), (i += o);
  }
}),
  (XG.UTF8Loader.prototype.decompressIndices_ = function (e, t, a, r, i) {
    for (var o = 0, n = 0; a > n; n++) {
      var s = e.charCodeAt(t++);
      (r[i++] = o - s), 0 === s && o++;
    }
  }),
  (XG.UTF8Loader.prototype.decompressAABBs_ = function (e, t, a, r, i) {
    for (
      var o = 6 * a, n = t + o, s = 0, l = new Float32Array(o), h = t;
      n > h;
      h += 6
    ) {
      var d = e.charCodeAt(h + 0) + r[0],
        c = e.charCodeAt(h + 1) + r[1],
        u = e.charCodeAt(h + 2) + r[2],
        f = (e.charCodeAt(h + 3) + 1) >> 1,
        p = (e.charCodeAt(h + 4) + 1) >> 1,
        m = (e.charCodeAt(h + 5) + 1) >> 1;
      (l[s++] = i[0] * (d + f)),
        (l[s++] = i[1] * (c + p)),
        (l[s++] = i[2] * (u + m)),
        (l[s++] = i[0] * f),
        (l[s++] = i[1] * p),
        (l[s++] = i[2] * m);
    }
    return l;
  }),
  (XG.UTF8Loader.prototype.decompressMesh = function (e, t, a, r, i, o) {
    for (
      var n = a.decodeScales.length,
      s = a.decodeOffsets,
      l = a.decodeScales,
      h = t.attribRange[0],
      d = t.attribRange[1],
      c = h,
      u = new Float32Array(n * d),
      f = 0;
      n > f;
      f++
    ) {
      var p = c + d,
        m = l[f];
      m && this.decompressAttribsInner_(e, c, p, u, f, n, s[f], m), (c = p);
    }
    var v = 3 * t.indexRange[1],
      g = new Uint16Array(v);
    this.decompressIndices_(e, c, v, g, 0);
    var S = void 0,
      x = t.bboxes;
    x && (S = this.decompressAABBs_(e, x, t.names.length, s, l)),
      o(r, i, u, g, S, t);
  }),
  (XG.UTF8Loader.prototype.copyAttrib = function (e, t, a, r) {
    for (var i = 0; e > i; i++) a[i] = t[e * r + i];
  }),
  (XG.UTF8Loader.prototype.decodeAttrib2 = function (
    e,
    t,
    a,
    r,
    i,
    o,
    n,
    s,
    l,
    h
  ) {
    for (var d = 0; 5 > d; d++) {
      var c = e.charCodeAt(i + o * d + h),
        u = (c >> 1) ^ -(1 & c);
      (l[d] += u), (s[t * h + d] = l[d]), (n[t * h + d] = r[d] * (l[d] + a[d]));
    }
  }),
  (XG.UTF8Loader.prototype.accumulateNormal = function (e, t, a, r, i) {
    var o = r[8 * e],
      n = r[8 * e + 1],
      s = r[8 * e + 2],
      l = r[8 * t],
      h = r[8 * t + 1],
      d = r[8 * t + 2],
      c = r[8 * a],
      u = r[8 * a + 1],
      f = r[8 * a + 2];
    (l -= o),
      (h -= n),
      (d -= s),
      (c -= o),
      (u -= n),
      (f -= s),
      (o = h * f - d * u),
      (n = d * c - l * f),
      (s = l * u - h * c),
      (i[3 * e] += o),
      (i[3 * e + 1] += n),
      (i[3 * e + 2] += s),
      (i[3 * t] += o),
      (i[3 * t + 1] += n),
      (i[3 * t + 2] += s),
      (i[3 * a] += o),
      (i[3 * a + 1] += n),
      (i[3 * a + 2] += s);
  }),
  (XG.UTF8Loader.prototype.decompressMesh2 = function (e, t, a, r, i, o) {
    for (
      var n = 96,
      s = a.decodeScales.length,
      l = a.decodeOffsets,
      h = a.decodeScales,
      d = t.attribRange[0],
      c = t.attribRange[1],
      u = t.codeRange[0],
      f = (t.codeRange[1], 3 * t.codeRange[2]),
      p = new Uint16Array(f),
      m = new Int32Array(3 * c),
      v = new Uint16Array(s),
      g = new Uint16Array(s * c),
      S = new Float32Array(s * c),
      x = 0,
      G = 0,
      M = 0;
      f > M;
      M += 3
    ) {
      var y = e.charCodeAt(u++),
        w = Math.min(M, n);
      if (w > y) {
        var _,
          X,
          D,
          T = y % 3,
          C = M - (y - T);
        switch (T) {
          case 0:
            (_ = p[C + 2]), (X = p[C + 1]), (D = p[C + 0]);
            break;
          case 1:
            (_ = p[C + 0]), (X = p[C + 2]), (D = p[C + 1]);
            break;
          case 2:
            (_ = p[C + 1]), (X = p[C + 0]), (D = p[C + 2]);
        }
        (p[G++] = _), (p[G++] = X), (y = e.charCodeAt(u++));
        var A = x - y;
        if (((p[G++] = A), 0 === y)) {
          for (var P = 0; 5 > P; P++) {
            var L = e.charCodeAt(d + c * P + x),
              b =
                ((L >> 1) ^ -(1 & L)) +
                g[s * _ + P] +
                g[s * X + P] -
                g[s * D + P];
            (v[P] = b), (g[s * x + P] = b), (S[s * x + P] = h[P] * (b + l[P]));
          }
          x++;
        } else this.copyAttrib(s, g, v, A);
        this.accumulateNormal(_, X, A, g, m);
      } else {
        var E = x - (y - w);
        (p[G++] = E),
          y === w
            ? this.decodeAttrib2(e, s, l, h, d, c, S, g, v, x++)
            : this.copyAttrib(s, g, v, E),
          (y = e.charCodeAt(u++));
        var F = x - y;
        (p[G++] = F),
          0 === y
            ? this.decodeAttrib2(e, s, l, h, d, c, S, g, v, x++)
            : this.copyAttrib(s, g, v, F),
          (y = e.charCodeAt(u++));
        var R = x - y;
        if (((p[G++] = R), 0 === y)) {
          for (var P = 0; 5 > P; P++) v[P] = (g[s * E + P] + g[s * F + P]) / 2;
          this.decodeAttrib2(e, s, l, h, d, c, S, g, v, x++);
        } else this.copyAttrib(s, g, v, R);
        this.accumulateNormal(E, F, R, g, m);
      }
    }
    for (var M = 0; c > M; M++) {
      var U = m[3 * M],
        I = m[3 * M + 1],
        N = m[3 * M + 2],
        B = 511 / Math.sqrt(U * U + I * I + N * N),
        O = e.charCodeAt(d + 5 * c + M),
        V = e.charCodeAt(d + 6 * c + M),
        k = e.charCodeAt(d + 7 * c + M);
      (S[s * M + 5] = B * U + ((O >> 1) ^ -(1 & O))),
        (S[s * M + 6] = B * I + ((V >> 1) ^ -(1 & V))),
        (S[s * M + 7] = B * N + ((k >> 1) ^ -(1 & k)));
    }
    o(r, i, S, p, void 0, t);
  }),
  (XG.UTF8Loader.prototype.downloadMesh = function (e, t, a, r, i) {
    function o(e) {
      for (; s < a.length;) {
        var o = a[s],
          l = o.indexRange;
        if (l) {
          var h = l[0] + 3 * l[1];
          if (e.responseText.length < h) break;
          n.decompressMesh(e.responseText, o, r, t, s, i);
        } else {
          var d = o.codeRange,
            h = d[0] + d[1];
          if (e.responseText.length < h) break;
          n.decompressMesh2(e.responseText, o, r, t, s, i);
        }
        ++s;
      }
    }
    var n = this,
      s = 0;
    getHttpRequest(
      e,
      function (e, t) {
        (200 === e.status || 0 === e.status) && o(e, t);
      },
      o
    );
  }),
  (XG.UTF8Loader.prototype.downloadMeshes = function (e, t, a, r) {
    for (var i in t) {
      var o = t[i];
      this.downloadMesh(e + i, i, o, a, r);
    }
  }),
  (XG.UTF8Loader.prototype.createMeshCallback = function (e, t, a) {
    var r = 0,
      i = 0,
      o = {},
      n = {},
      s = t.urls;
    for (var l in s) (o[l] = s[l].length), (n[l] = 0), i++;
    var h = [],
      d = [],
      c = new XG.PhongMaterial(),
      u = new XG.UTF8Loader.MaterialCreator(e, t.materials, this),
      f = new XG.UTF8Loader.GeometryCreator(),
      p = function (e, t, s, l, p, m) {
        var v = f.create(s, l),
          g = u.get(m.material);
        g || (g = c),
          h.push(v),
          d.push(g),
          n[e]++,
          n[e] === o[e] && (r++, r === i && a(h, d));
      };
    return p;
  }),
  (XG.UTF8Loader.prototype.downloadModel = function (e, t, a, r) {
    var i = this.createMeshCallback(t, a, r);
    this.downloadMeshes(e, a.urls, a.decodeParams, i);
  }),
  (XG.UTF8Loader.prototype.downloadModelJson = function (e, t, a) {
    getJsonRequest(
      e,
      function (r) {
        r.decodeParams ||
          (r.decodeParams =
            t && t.decodeParams ? t.decodeParams : DEFAULT_DECODE_PARAMS),
          (r.options = t);
        var i = e.substr(0, e.lastIndexOf("/") + 1),
          o = i;
        t &&
          t.geometryBase &&
          ((i = t.geometryBase), "/" !== i.charAt(i.length - 1) && (i += "/")),
          t &&
          t.materialBase &&
          ((o = t.materialBase),
            "/" !== o.charAt(o.length - 1) && (o += "/")),
          this.downloadModel(i, o, r, a);
      }.bind(this)
    );
  }),
  (XG.CTMLoader = function (e) {
    XG.Loader.call(this, e),
      (this.maxWorkerCount = 4),
      (this.workerPool = []),
      (this.workerState = []),
      (this.workerFreeCallbacks = []),
      (window.URL = window.URL || window.webkitURL);
    for (
      var t = new Blob([XG.CTMLoader.workerString], {
        type: "application/x-javascript",
      }),
      a = window.URL.createObjectURL(t),
      r = 0;
      r < this.maxWorkerCount;
      r++
    ) {
      var i = new Worker(a);
      (i.index = r), (this.workerPool[r] = i), (this.workerState[r] = 0);
    }
  }),
  (XG.CTMLoader.prototype = Object.create(XG.Loader.prototype)),
  (XG.CTMLoader.prototype.loadParts = function (e, t, a) {
    var r = this,
      i = void 0 !== a && a.basePath ? a.basePath : this.extractUrlBase(e),
      o = void 0 !== a && void 0 !== a.useCrunchWorker ? a.useCrunchWorker : !0,
      n = void 0 !== a ? a.callbackGeometriesLoaded : null,
      s = void 0 !== a ? a.callbackProgress : null,
      l = function (e, t, a, r) {
        for (var i = {}, n = 0, s = t.length; s > n; n++) {
          var l = t[n],
            h = l[0],
            d = l[1],
            c = l[2];
          i[h] = [d, c];
        }
        for (var u = [], n = 0, s = a.length; s > n; n++) {
          var f = a[n];
          if (f.properties.texturesToLoad)
            for (
              var p = 0, m = f.properties.texturesToLoad.length;
              m > p;
              p++
            ) {
              var v = f.properties.texturesToLoad[p],
                g = v[0],
                S = v[1],
                l = i[S];
              if (l) {
                var x = S.toLowerCase().endsWith(".crn");
                if (x) {
                  var d = l[0],
                    c = l[1];
                  o
                    ? u.push([g, d, c])
                    : XG.ImageUtils.loadCRNTextureFromPack(g, e, d, c);
                } else {
                  var d = l[0];
                  XG.ImageUtils.loadCompressedTextureFromPack(g, e, d);
                }
              }
            }
        }
        if (o && u.length > 0) {
          var G = function () {
            r();
          };
          XG.ImageUtils.loadMultipleCRNTexturesFromPack(u, e, G);
        } else r();
      },
      h = function (e, t, a, r, i) {
        var o = new XMLHttpRequest();
        (o.onreadystatechange = function () {
          if (4 === o.readyState && (200 === o.status || 0 === o.status)) {
            var e = o.response;
            l(e, t, a, r);
          }
        }),
          i &&
          (o.onprogress = function (t) {
            var a = { url: e, loaded: t.loaded, total: t.total };
            i(a);
          }),
          o.open("GET", e, !0),
          (o.responseType = "arraybuffer"),
          o.send(null);
      },
      d = function (e) {
        function a() {
          u && f && t(c, d);
        }
        function o(t) {
          (p += 1),
            c.push(t),
            p === e.offsets.length && ((u = !0), n && n(c, d), a());
        }
        function l() {
          (m += 1), m === e.textures.length && ((f = !0), a());
        }
        for (
          var d = [],
          c = [],
          u = !1,
          f = !1,
          p = 0,
          m = 0,
          v = e.textures && e.textureOffsets,
          g = 0;
          g < e.materials.length;
          g++
        )
          d[g] = r.createMaterial(e.materials[g], i, v);
        var S = i + e.data,
          x = { offsets: e.offsets, callbackProgress: s };
        if ((r.load(S, o, x), v))
          for (var g = 0, G = e.textures.length; G > g; g++) {
            var M = i + e.textures[g],
              y = e.textureOffsets[g];
            h(M, y, d, l, s);
          }
        else f = !0;
      },
      c = new XMLHttpRequest();
    (c.onreadystatechange = function () {
      if (4 === c.readyState && (200 === c.status || 0 === c.status)) {
        var e = JSON.parse(c.responseText);
        d(e);
      }
    }),
      c.open("GET", e, !0),
      c.overrideMimeType &&
      c.overrideMimeType("text/plain; charset=x-user-defined"),
      c.setRequestHeader("Content-Type", "text/plain"),
      c.send(null);
  }),
  (XG.CTMLoader.prototype.getWorker = function (e) {
    for (var t, a = 0, r = this.workerPool.length; r > a; a++) {
      var i = this.workerState[a];
      if (0 === i) {
        (t = this.workerPool[a]), (this.workerState[a] = 1);
        break;
      }
    }
    void 0 === t ? this.workerFreeCallbacks.push(e) : e(t);
  }),
  (XG.CTMLoader.prototype.releaseWorker = function (e) {
    var t = this.workerFreeCallbacks.shift();
    t ? t(e) : (this.workerState[e.index] = 0);
  }),
  (XG.CTMLoader.prototype.load = function (e, t, a) {
    var r = this,
      i = void 0 !== a && void 0 !== a.offsets ? a.offsets : [0],
      o =
        void 0 !== a && void 0 !== a.callbackProgress
          ? a.callbackProgress
          : null,
      n = new XMLHttpRequest();
    (n.onreadystatechange = function () {
      if (4 === n.readyState)
        if (200 === n.status || 0 === n.status) {
          var a = n.response,
            o = function (e) {
              e.onmessage = function (a) {
                for (var i = a.data.f, o = 0; o < i.length; o++) {
                  var n = i[o];
                  r.createModelBuffers(n, t);
                }
                Date.now();
                r.releaseWorker(e);
              };
              Date.now();
              (e.postMessage = e.webkitPostMessage || e.postMessage),
                e.postMessage({ data: a, offsets: i }, [a]);
            };
          r.getWorker(o);
        } else
          console.error(
            "XG.CTMLoader: Couldn't load [" + e + "] [" + n.status + "]"
          );
    }),
      o &&
      (n.onprogress = function (t) {
        var a = { url: e, loaded: t.loaded, total: t.total };
        o(a);
      }),
      n.open("GET", e, !0),
      (n.responseType = "arraybuffer"),
      n.send(null);
  }),
  (XG.CTMLoader.prototype.createModelBuffers = function (e, t) {
    var a = function () {
      var t = this,
        a = !0;
      XG.Geometry.call(this);
      var r,
        i,
        o = e.body.indices,
        n = e.body.vertices,
        s = e.body.normals;
      if (
        (void 0 !== e.body.uvMaps &&
          e.body.uvMaps.length > 0 &&
          (r = e.body.uvMaps[0].uv),
          void 0 !== e.body.attrMaps &&
          e.body.attrMaps.length > 0 &&
          "Color" === e.body.attrMaps[0].name &&
          (i = e.body.attrMaps[0].attr),
          a)
      ) {
        var l,
          h,
          d,
          c = new Uint32Array(o.length),
          u = new Float32Array(n.length);
        s && (l = new Float32Array(s.length)),
          r && (h = new Float32Array(r.length)),
          i && (d = new Float32Array(i.length));
        for (
          var f,
          p,
          m,
          v = {},
          g = 0,
          S = function (e) {
            if (void 0 === v[e]) {
              v[e] = g;
              var t = 3 * e,
                a = 3 * e + 1,
                o = 3 * e + 2,
                c = 3 * g,
                f = 3 * g + 1,
                p = 3 * g + 2;
              (u[c] = n[t]),
                (u[f] = n[a]),
                (u[p] = n[o]),
                s && ((l[c] = s[t]), (l[f] = s[a]), (l[p] = s[o])),
                r && ((h[2 * g] = r[2 * e]), (h[2 * g + 1] = r[2 * e + 1])),
                i &&
                ((d[4 * g] = i[4 * e]),
                  (d[4 * g + 1] = i[4 * e + 1]),
                  (d[4 * g + 2] = i[4 * e + 2]),
                  (d[4 * g + 3] = i[4 * e + 3])),
                (g += 1);
            }
          },
          x = 0;
          x < o.length;
          x += 3
        )
          (f = o[x]),
            (p = o[x + 1]),
            (m = o[x + 2]),
            S(f),
            S(p),
            S(m),
            (c[x] = v[f]),
            (c[x + 1] = v[p]),
            (c[x + 2] = v[m]);
        (o = c), (n = u), s && (s = l), r && (r = h), i && (i = d);
      }
      t.offsets = [];
      for (
        var G = o, M = 0, y = n.length, w = 0, _ = y, x = 0;
        x < G.length;

      ) {
        for (var X = 0; 3 > X; ++X) {
          var D = G[x++];
          y > D && (y = D), D > w && (w = D);
        }
        if (w - y > 65534) {
          x -= 3;
          for (var T = M; x > T; ++T) G[T] -= _;
          t.offsets.push({ start: M, count: x - M, index: _ }),
            (M = x),
            (y = n.length),
            (w = 0);
        }
        _ = y;
      }
      for (var T = M; x > T; ++T) G[T] -= _;
      t.offsets.push({ start: M, count: x - M, index: _ });
      var C = new Uint16Array(o);
      t.addAttributeArray("index", C, 1),
        t.addAttributeArray("position", n, 3),
        void 0 !== s && t.addAttributeArray("normal", s, 3),
        void 0 !== r && t.addAttributeArray("uv", r, 2),
        void 0 !== i && t.addAttributeArray("color", i, 4),
        (t.numVertices = n.length / 3),
        (t.numPrimitives = C.length / 3);
    };
    a.prototype = Object.create(XG.Geometry.prototype);
    var r = new a();
    void 0 === r.attributes.normal && r.computeVertexNormals(), t(r);
  }),
  (XG.CTMLoader.workerString = [
    "var LZMA = LZMA || {};",
    "",
    "LZMA.OutWindow = function(){",
    "  this._windowSize = 0;",
    "};",
    "",
    "LZMA.OutWindow.prototype.create = function(windowSize){",
    "  if ( (!this._buffer) || (this._windowSize !== windowSize) ){",
    "    this._buffer = [];",
    "  }",
    "  this._windowSize = windowSize;",
    "  this._pos = 0;",
    "  this._streamPos = 0;",
    "};",
    "",
    "LZMA.OutWindow.prototype.flush = function(){",
    "  var size = this._pos - this._streamPos;",
    "  if (size !== 0){",
    "    while(size --){",
    "      this._stream.writeByte(this._buffer[this._streamPos ++]);",
    "    }",
    "    if (this._pos >= this._windowSize){",
    "      this._pos = 0;",
    "    }",
    "    this._streamPos = this._pos;",
    "  }",
    "};",
    "",
    "LZMA.OutWindow.prototype.releaseStream = function(){",
    "  this.flush();",
    "  this._stream = null;",
    "};",
    "",
    "LZMA.OutWindow.prototype.setStream = function(stream){",
    "  this.releaseStream();",
    "  this._stream = stream;",
    "};",
    "",
    "LZMA.OutWindow.prototype.init = function(solid){",
    "  if (!solid){",
    "    this._streamPos = 0;",
    "    this._pos = 0;",
    "  }",
    "};",
    "",
    "LZMA.OutWindow.prototype.copyBlock = function(distance, len){",
    "  var pos = this._pos - distance - 1;",
    "  if (pos < 0){",
    "    pos += this._windowSize;",
    "  }",
    "  while(len --){",
    "    if (pos >= this._windowSize){",
    "      pos = 0;",
    "    }",
    "    this._buffer[this._pos ++] = this._buffer[pos ++];",
    "    if (this._pos >= this._windowSize){",
    "      this.flush();",
    "    }",
    "  }",
    "};",
    "",
    "LZMA.OutWindow.prototype.putByte = function(b){",
    "  this._buffer[this._pos ++] = b;",
    "  if (this._pos >= this._windowSize){",
    "    this.flush();",
    "  }",
    "};",
    "",
    "LZMA.OutWindow.prototype.getByte = function(distance){",
    "  var pos = this._pos - distance - 1;",
    "  if (pos < 0){",
    "    pos += this._windowSize;",
    "  }",
    "  return this._buffer[pos];",
    "};",
    "",
    "LZMA.RangeDecoder = function(){",
    "};",
    "",
    "LZMA.RangeDecoder.prototype.setStream = function(stream){",
    "  this._stream = stream;",
    "};",
    "",
    "LZMA.RangeDecoder.prototype.releaseStream = function(){",
    "  this._stream = null;",
    "};",
    "",
    "LZMA.RangeDecoder.prototype.init = function(){",
    "  var i = 5;",
    "",
    "  this._code = 0;",
    "  this._range = -1;",
    "",
    "  while(i --){",
    "    this._code = (this._code << 8) | this._stream.readByte();",
    "  }",
    "};",
    "",
    "LZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){",
    "  var result = 0, i = numTotalBits, t;",
    "",
    "  while(i --){",
    "    this._range >>>= 1;",
    "    t = (this._code - this._range) >>> 31;",
    "    this._code -= this._range & (t - 1);",
    "    result = (result << 1) | (1 - t);",
    "",
    "    if ( (this._range & 0xff000000) === 0){",
    "      this._code = (this._code << 8) | this._stream.readByte();",
    "      this._range <<= 8;",
    "    }",
    "  }",
    "",
    "  return result;",
    "};",
    "",
    "LZMA.RangeDecoder.prototype.decodeBit = function(probs, index){",
    "  var prob = probs[index],",
    "      newBound = (this._range >>> 11) * prob;",
    "",
    "  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){",
    "    this._range = newBound;",
    "    probs[index] += (2048 - prob) >>> 5;",
    "    if ( (this._range & 0xff000000) === 0){",
    "      this._code = (this._code << 8) | this._stream.readByte();",
    "      this._range <<= 8;",
    "    }",
    "    return 0;",
    "  }",
    "",
    "  this._range -= newBound;",
    "  this._code -= newBound;",
    "  probs[index] -= prob >>> 5;",
    "  if ( (this._range & 0xff000000) === 0){",
    "    this._code = (this._code << 8) | this._stream.readByte();",
    "    this._range <<= 8;",
    "  }",
    "  return 1;",
    "};",
    "",
    "LZMA.initBitModels = function(probs, len){",
    "  while(len --){",
    "    probs[len] = 1024;",
    "  }",
    "};",
    "",
    "LZMA.BitTreeDecoder = function(numBitLevels){",
    "  this._models = [];",
    "  this._numBitLevels = numBitLevels;",
    "};",
    "",
    "LZMA.BitTreeDecoder.prototype.init = function(){",
    "  LZMA.initBitModels(this._models, 1 << this._numBitLevels);",
    "};",
    "",
    "LZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){",
    "  var m = 1, i = this._numBitLevels;",
    "",
    "  while(i --){",
    "    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);",
    "  }",
    "  return m - (1 << this._numBitLevels);",
    "};",
    "",
    "LZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){",
    "  var m = 1, symbol = 0, i = 0, bit;",
    "",
    "  for (; i < this._numBitLevels; ++ i){",
    "    bit = rangeDecoder.decodeBit(this._models, m);",
    "    m = (m << 1) | bit;",
    "    symbol |= bit << i;",
    "  }",
    "  return symbol;",
    "};",
    "",
    "LZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){",
    "  var m = 1, symbol = 0, i = 0, bit;",
    "",
    "  for (; i < numBitLevels; ++ i){",
    "    bit = rangeDecoder.decodeBit(models, startIndex + m);",
    "    m = (m << 1) | bit;",
    "    symbol |= bit << i;",
    "  }",
    "  return symbol;",
    "};",
    "",
    "LZMA.LenDecoder = function(){",
    "  this._choice = [];",
    "  this._lowCoder = [];",
    "  this._midCoder = [];",
    "  this._highCoder = new LZMA.BitTreeDecoder(8);",
    "  this._numPosStates = 0;",
    "};",
    "",
    "LZMA.LenDecoder.prototype.create = function(numPosStates){",
    "  for (; this._numPosStates < numPosStates; ++ this._numPosStates){",
    "    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);",
    "    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);",
    "  }",
    "};",
    "",
    "LZMA.LenDecoder.prototype.init = function(){",
    "  var i = this._numPosStates;",
    "  LZMA.initBitModels(this._choice, 2);",
    "  while(i --){",
    "    this._lowCoder[i].init();",
    "    this._midCoder[i].init();",
    "  }",
    "  this._highCoder.init();",
    "};",
    "",
    "LZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){",
    "  if (rangeDecoder.decodeBit(this._choice, 0) === 0){",
    "    return this._lowCoder[posState].decode(rangeDecoder);",
    "  }",
    "  if (rangeDecoder.decodeBit(this._choice, 1) === 0){",
    "    return 8 + this._midCoder[posState].decode(rangeDecoder);",
    "  }",
    "  return 16 + this._highCoder.decode(rangeDecoder);",
    "};",
    "",
    "LZMA.Decoder2 = function(){",
    "  this._decoders = [];",
    "};",
    "",
    "LZMA.Decoder2.prototype.init = function(){",
    "  LZMA.initBitModels(this._decoders, 0x300);",
    "};",
    "",
    "LZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){",
    "  var symbol = 1;",
    "",
    "  do{",
    "    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);",
    "  }while(symbol < 0x100);",
    "",
    "  return symbol & 0xff;",
    "};",
    "",
    "LZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){",
    "  var symbol = 1, matchBit, bit;",
    "",
    "  do{",
    "    matchBit = (matchByte >> 7) & 1;",
    "    matchByte <<= 1;",
    "    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);",
    "    symbol = (symbol << 1) | bit;",
    "    if (matchBit !== bit){",
    "      while(symbol < 0x100){",
    "        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);",
    "      }",
    "      break;",
    "    }",
    "  }while(symbol < 0x100);",
    "",
    "  return symbol & 0xff;",
    "};",
    "",
    "LZMA.LiteralDecoder = function(){",
    "};",
    "",
    "LZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){",
    "  var i;",
    "",
    "  if (this._coders",
    "    && (this._numPrevBits === numPrevBits)",
    "    && (this._numPosBits === numPosBits) ){",
    "    return;",
    "  }",
    "  this._numPosBits = numPosBits;",
    "  this._posMask = (1 << numPosBits) - 1;",
    "  this._numPrevBits = numPrevBits;",
    "",
    "  this._coders = [];",
    "",
    "  i = 1 << (this._numPrevBits + this._numPosBits);",
    "  while(i --){",
    "    this._coders[i] = new LZMA.Decoder2();",
    "  }",
    "};",
    "",
    "LZMA.LiteralDecoder.prototype.init = function(){",
    "  var i = 1 << (this._numPrevBits + this._numPosBits);",
    "  while(i --){",
    "    this._coders[i].init();",
    "  }",
    "};",
    "",
    "LZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){",
    "  return this._coders[( (pos & this._posMask) << this._numPrevBits)",
    "    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];",
    "};",
    "",
    "LZMA.Decoder = function(){",
    "  this._outWindow = new LZMA.OutWindow();",
    "  this._rangeDecoder = new LZMA.RangeDecoder();",
    "  this._isMatchDecoders = [];",
    "  this._isRepDecoders = [];",
    "  this._isRepG0Decoders = [];",
    "  this._isRepG1Decoders = [];",
    "  this._isRepG2Decoders = [];",
    "  this._isRep0LongDecoders = [];",
    "  this._posSlotDecoder = [];",
    "  this._posDecoders = [];",
    "  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);",
    "  this._lenDecoder = new LZMA.LenDecoder();",
    "  this._repLenDecoder = new LZMA.LenDecoder();",
    "  this._literalDecoder = new LZMA.LiteralDecoder();",
    "  this._dictionarySize = -1;",
    "  this._dictionarySizeCheck = -1;",
    "",
    "  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);",
    "  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);",
    "  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);",
    "  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);",
    "};",
    "",
    "LZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){",
    "  if (dictionarySize < 0){",
    "    return false;",
    "  }",
    "  if (this._dictionarySize !== dictionarySize){",
    "    this._dictionarySize = dictionarySize;",
    "    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);",
    "    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );",
    "  }",
    "  return true;",
    "};",
    "",
    "LZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){",
    "  var numPosStates = 1 << pb;",
    "",
    "  if (lc > 8 || lp > 4 || pb > 4){",
    "    return false;",
    "  }",
    "",
    "  this._literalDecoder.create(lp, lc);",
    "",
    "  this._lenDecoder.create(numPosStates);",
    "  this._repLenDecoder.create(numPosStates);",
    "  this._posStateMask = numPosStates - 1;",
    "",
    "  return true;",
    "};",
    "",
    "LZMA.Decoder.prototype.init = function(){",
    "  var i = 4;",
    "",
    "  this._outWindow.init(false);",
    "",
    "  LZMA.initBitModels(this._isMatchDecoders, 192);",
    "  LZMA.initBitModels(this._isRep0LongDecoders, 192);",
    "  LZMA.initBitModels(this._isRepDecoders, 12);",
    "  LZMA.initBitModels(this._isRepG0Decoders, 12);",
    "  LZMA.initBitModels(this._isRepG1Decoders, 12);",
    "  LZMA.initBitModels(this._isRepG2Decoders, 12);",
    "  LZMA.initBitModels(this._posDecoders, 114);",
    "",
    "  this._literalDecoder.init();",
    "",
    "  while(i --){",
    "    this._posSlotDecoder[i].init();",
    "  }",
    "",
    "  this._lenDecoder.init();",
    "  this._repLenDecoder.init();",
    "  this._posAlignDecoder.init();",
    "  this._rangeDecoder.init();",
    "};",
    "",
    "LZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){",
    "  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,",
    "      posState, decoder2, len, distance, posSlot, numDirectBits;",
    "",
    "  this._rangeDecoder.setStream(inStream);",
    "  this._outWindow.setStream(outStream);",
    "",
    "  this.init();",
    "",
    "  while(outSize < 0 || nowPos64 < outSize){",
    "    posState = nowPos64 & this._posStateMask;",
    "",
    "    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){",
    "      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);",
    "",
    "      if (state >= 7){",
    "        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );",
    "      }else{",
    "        prevByte = decoder2.decodeNormal(this._rangeDecoder);",
    "      }",
    "      this._outWindow.putByte(prevByte);",
    "",
    "      state = state < 4? 0: state - (state < 10? 3: 6);",
    "",
    "    }else{",
    "",
    "      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){",
    "        len = 0;",
    "        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){",
    "          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){",
    "            state = state < 7? 9: 11;",
    "            len = 1;",
    "          }",
    "        }else{",
    "          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){",
    "            distance = rep1;",
    "          }else{",
    "            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){",
    "              distance = rep2;",
    "            }else{",
    "              distance = rep3;",
    "              rep3 = rep2;",
    "            }",
    "            rep2 = rep1;",
    "          }",
    "          rep1 = rep0;",
    "          rep0 = distance;",
    "        }",
    "        if (len === 0){",
    "          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);",
    "          state = state < 7? 8: 11;",
    "        }",
    "      }else{",
    "        rep3 = rep2;",
    "        rep2 = rep1;",
    "        rep1 = rep0;",
    "",
    "        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);",
    "        state = state < 7? 7: 10;",
    "",
    "        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);",
    "        if (posSlot >= 4){",
    "",
    "          numDirectBits = (posSlot >> 1) - 1;",
    "          rep0 = (2 | (posSlot & 1) ) << numDirectBits;",
    "",
    "          if (posSlot < 14){",
    "            rep0 += LZMA.reverseDecode2(this._posDecoders,",
    "                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);",
    "          }else{",
    "            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;",
    "            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);",
    "            if (rep0 < 0){",
    "              if (rep0 === -1){",
    "                break;",
    "              }",
    "              return false;",
    "            }",
    "          }",
    "        }else{",
    "          rep0 = posSlot;",
    "        }",
    "      }",
    "",
    "      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){",
    "        return false;",
    "      }",
    "",
    "      this._outWindow.copyBlock(rep0, len);",
    "      nowPos64 += len;",
    "      prevByte = this._outWindow.getByte(0);",
    "    }",
    "  }",
    "",
    "  this._outWindow.flush();",
    "  this._outWindow.releaseStream();",
    "  this._rangeDecoder.releaseStream();",
    "",
    "  return true;",
    "};",
    "",
    "LZMA.Decoder.prototype.setDecoderProperties = function(properties){",
    "  var value, lc, lp, pb, dictionarySize;",
    "",
    "  if (properties.size < 5){",
    "    return false;",
    "  }",
    "",
    "  value = properties.readByte();",
    "  lc = value % 9;",
    "  value = ~~(value / 9);",
    "  lp = value % 5;",
    "  pb = ~~(value / 5);",
    "",
    "  if ( !this.setLcLpPb(lc, lp, pb) ){",
    "    return false;",
    "  }",
    "",
    "  dictionarySize = properties.readByte();",
    "  dictionarySize |= properties.readByte() << 8;",
    "  dictionarySize |= properties.readByte() << 16;",
    "  dictionarySize += properties.readByte() * 16777216;",
    "",
    "  return this.setDictionarySize(dictionarySize);",
    "};",
    "",
    "LZMA.decompress = function(properties, inStream, outStream, outSize){",
    "  var decoder = new LZMA.Decoder();",
    "",
    "  if ( !decoder.setDecoderProperties(properties) ){",
    '    throw "Incorrect stream properties";',
    "  }",
    "",
    "  if ( !decoder.decode(inStream, outStream, outSize) ){",
    '    throw "Error in data stream";',
    "  }",
    "",
    "  return true;",
    "};",
    "",
    "LZMA.decompressFile = function(inStream, outStream){",
    "  var decoder = new LZMA.Decoder(), outSize;",
    "",
    "  if ( !decoder.setDecoderProperties(inStream) ){",
    '    throw "Incorrect stream properties";',
    "  }",
    "",
    "  outSize = inStream.readByte();",
    "  outSize |= inStream.readByte() << 8;",
    "  outSize |= inStream.readByte() << 16;",
    "  outSize += inStream.readByte() * 16777216;",
    "",
    "  inStream.readByte();",
    "  inStream.readByte();",
    "  inStream.readByte();",
    "  inStream.readByte();",
    "",
    "  if ( !decoder.decode(inStream, outStream, outSize) ){",
    '    throw "Error in data stream";',
    "  }",
    "",
    "  return true;",
    "};",
    "",
    "var CTM = CTM || {};",
    "",
    "CTM.CompressionMethod = {",
    "  RAW: 0x00574152,",
    "  MG1: 0x0031474d,",
    "  MG2: 0x0032474d",
    "};",
    "",
    "CTM.Flags = {",
    "  NORMALS: 0x00000001",
    "};",
    "",
    "CTM.File = function(stream){",
    "  this.load(stream);",
    "};",
    "",
    "CTM.File.prototype.load = function(stream){",
    "  this.header = new CTM.FileHeader(stream);",
    "",
    "  this.body = new CTM.FileBody(this.header);",
    "",
    "  this.getReader().read(stream, this.body);",
    "};",
    "",
    "CTM.File.prototype.getReader = function(){",
    "  var reader;",
    "",
    "  switch(this.header.compressionMethod){",
    "    case CTM.CompressionMethod.RAW:",
    "      reader = new CTM.ReaderRAW();",
    "      break;",
    "    case CTM.CompressionMethod.MG1:",
    "      reader = new CTM.ReaderMG1();",
    "      break;",
    "    case CTM.CompressionMethod.MG2:",
    "      reader = new CTM.ReaderMG2();",
    "      break;",
    "  }",
    "",
    "  return reader;",
    "};",
    "",
    "CTM.FileHeader = function(stream){",
    '  stream.readInt32(); //magic "OCTM"',
    "  this.fileFormat = stream.readInt32();",
    "  this.compressionMethod = stream.readInt32();",
    "  this.vertexCount = stream.readInt32();",
    "  this.triangleCount = stream.readInt32();",
    "  this.uvMapCount = stream.readInt32();",
    "  this.attrMapCount = stream.readInt32();",
    "  this.flags = stream.readInt32();",
    "  this.comment = stream.readString();",
    "};",
    "",
    "CTM.FileHeader.prototype.hasNormals = function(){",
    "  return this.flags & CTM.Flags.NORMALS;",
    "};",
    "",
    "CTM.FileBody = function(header){",
    "  var i = header.triangleCount * 3,",
    "      v = header.vertexCount * 3,",
    "      n = header.hasNormals()? header.vertexCount * 3: 0,",
    "      u = header.vertexCount * 2,",
    "      a = header.vertexCount * 4,",
    "      j = 0;",
    "",
    "  var data = new ArrayBuffer(",
    "    (i + v + n + (u * header.uvMapCount) + (a * header.attrMapCount) ) * 4);",
    "",
    "  this.indices = new Uint32Array(data, 0, i);",
    "",
    "  this.vertices = new Float32Array(data, i * 4, v);",
    "",
    "  if ( header.hasNormals() ){",
    "    this.normals = new Float32Array(data, (i + v) * 4, n);",
    "  }",
    "",
    "  if (header.uvMapCount){",
    "    this.uvMaps = [];",
    "    for (j = 0; j < header.uvMapCount; ++ j){",
    "      this.uvMaps[j] = {uv: new Float32Array(data,",
    "        (i + v + n + (j * u) ) * 4, u) };",
    "    }",
    "  }",
    "",
    "  if (header.attrMapCount){",
    "    this.attrMaps = [];",
    "    for (j = 0; j < header.attrMapCount; ++ j){",
    "      this.attrMaps[j] = {attr: new Float32Array(data,",
    "        (i + v + n + (u * header.uvMapCount) + (j * a) ) * 4, a) };",
    "    }",
    "  }",
    "};",
    "",
    "CTM.FileMG2Header = function(stream){",
    '  stream.readInt32(); //magic "MG2H"',
    "  this.vertexPrecision = stream.readFloat32();",
    "  this.normalPrecision = stream.readFloat32();",
    "  this.lowerBoundx = stream.readFloat32();",
    "  this.lowerBoundy = stream.readFloat32();",
    "  this.lowerBoundz = stream.readFloat32();",
    "  this.higherBoundx = stream.readFloat32();",
    "  this.higherBoundy = stream.readFloat32();",
    "  this.higherBoundz = stream.readFloat32();",
    "  this.divx = stream.readInt32();",
    "  this.divy = stream.readInt32();",
    "  this.divz = stream.readInt32();",
    "",
    "  this.sizex = (this.higherBoundx - this.lowerBoundx) / this.divx;",
    "  this.sizey = (this.higherBoundy - this.lowerBoundy) / this.divy;",
    "  this.sizez = (this.higherBoundz - this.lowerBoundz) / this.divz;",
    "};",
    "",
    "CTM.ReaderRAW = function(){",
    "};",
    "",
    "CTM.ReaderRAW.prototype.read = function(stream, body){",
    "  this.readIndices(stream, body.indices);",
    "  this.readVertices(stream, body.vertices);",
    "",
    "  if (body.normals){",
    "    this.readNormals(stream, body.normals);",
    "  }",
    "  if (body.uvMaps){",
    "    this.readUVMaps(stream, body.uvMaps);",
    "  }",
    "  if (body.attrMaps){",
    "    this.readAttrMaps(stream, body.attrMaps);",
    "  }",
    "};",
    "",
    "CTM.ReaderRAW.prototype.readIndices = function(stream, indices){",
    '  stream.readInt32(); //magic "INDX"',
    "  stream.readArrayInt32(indices);",
    "};",
    "",
    "CTM.ReaderRAW.prototype.readVertices = function(stream, vertices){",
    '  stream.readInt32(); //magic "VERT"',
    "  stream.readArrayFloat32(vertices);",
    "};",
    "",
    "CTM.ReaderRAW.prototype.readNormals = function(stream, normals){",
    '  stream.readInt32(); //magic "NORM"',
    "  stream.readArrayFloat32(normals);",
    "};",
    "",
    "CTM.ReaderRAW.prototype.readUVMaps = function(stream, uvMaps){",
    "  var i = 0;",
    "  for (; i < uvMaps.length; ++ i){",
    '    stream.readInt32(); //magic "TEXC"',
    "",
    "    uvMaps[i].name = stream.readString();",
    "    uvMaps[i].filename = stream.readString();",
    "    stream.readArrayFloat32(uvMaps[i].uv);",
    "  }",
    "};",
    "",
    "CTM.ReaderRAW.prototype.readAttrMaps = function(stream, attrMaps){",
    "  var i = 0;",
    "  for (; i < attrMaps.length; ++ i){",
    '    stream.readInt32(); //magic "ATTR"',
    "",
    "    attrMaps[i].name = stream.readString();",
    "    stream.readArrayFloat32(attrMaps[i].attr);",
    "  }",
    "};",
    "",
    "CTM.ReaderMG1 = function(){",
    "};",
    "",
    "CTM.ReaderMG1.prototype.read = function(stream, body){",
    "  this.readIndices(stream, body.indices);",
    "  this.readVertices(stream, body.vertices);",
    "",
    "  if (body.normals){",
    "    this.readNormals(stream, body.normals);",
    "  }",
    "  if (body.uvMaps){",
    "    this.readUVMaps(stream, body.uvMaps);",
    "  }",
    "  if (body.attrMaps){",
    "    this.readAttrMaps(stream, body.attrMaps);",
    "  }",
    "};",
    "",
    "CTM.ReaderMG1.prototype.readIndices = function(stream, indices){",
    '  stream.readInt32(); //magic "INDX"',
    "  stream.readInt32(); //packed size",
    "",
    "  var interleaved = new CTM.InterleavedStream(indices, 3);",
    "  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);",
    "",
    "  CTM.restoreIndices(indices, indices.length);",
    "};",
    "",
    "CTM.ReaderMG1.prototype.readVertices = function(stream, vertices){",
    '  stream.readInt32(); //magic "VERT"',
    "  stream.readInt32(); //packed size",
    "",
    "  var interleaved = new CTM.InterleavedStream(vertices, 1);",
    "  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);",
    "};",
    "",
    "CTM.ReaderMG1.prototype.readNormals = function(stream, normals){",
    '  stream.readInt32(); //magic "NORM"',
    "  stream.readInt32(); //packed size",
    "",
    "  var interleaved = new CTM.InterleavedStream(normals, 3);",
    "  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);",
    "};",
    "",
    "CTM.ReaderMG1.prototype.readUVMaps = function(stream, uvMaps){",
    "  var i = 0;",
    "  for (; i < uvMaps.length; ++ i){",
    '    stream.readInt32(); //magic "TEXC"',
    "",
    "    uvMaps[i].name = stream.readString();",
    "    uvMaps[i].filename = stream.readString();",
    "",
    "    stream.readInt32(); //packed size",
    "",
    "    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);",
    "    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);",
    "  }",
    "};",
    "",
    "CTM.ReaderMG1.prototype.readAttrMaps = function(stream, attrMaps){",
    "  var i = 0;",
    "  for (; i < attrMaps.length; ++ i){",
    '    stream.readInt32(); //magic "ATTR"',
    "",
    "    attrMaps[i].name = stream.readString();",
    "",
    "    stream.readInt32(); //packed size",
    "",
    "    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);",
    "    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);",
    "  }",
    "};",
    "",
    "CTM.ReaderMG2 = function(){",
    "};",
    "",
    "CTM.ReaderMG2.prototype.read = function(stream, body){",
    "  this.MG2Header = new CTM.FileMG2Header(stream);",
    "",
    "  this.readVertices(stream, body.vertices);",
    "  this.readIndices(stream, body.indices);",
    "",
    "  if (body.normals){",
    "    this.readNormals(stream, body);",
    "  }",
    "  if (body.uvMaps){",
    "    this.readUVMaps(stream, body.uvMaps);",
    "  }",
    "  if (body.attrMaps){",
    "    this.readAttrMaps(stream, body.attrMaps);",
    "  }",
    "};",
    "",
    "CTM.ReaderMG2.prototype.readVertices = function(stream, vertices){",
    '  stream.readInt32(); //magic "VERT"',
    "  stream.readInt32(); //packed size",
    "",
    "  var interleaved = new CTM.InterleavedStream(vertices, 3);",
    "  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);",
    "",
    "  var gridIndices = this.readGridIndices(stream, vertices);",
    "",
    "  CTM.restoreVertices(vertices, this.MG2Header, gridIndices, this.MG2Header.vertexPrecision);",
    "};",
    "",
    "CTM.ReaderMG2.prototype.readGridIndices = function(stream, vertices){",
    '  stream.readInt32(); //magic "GIDX"',
    "  stream.readInt32(); //packed size",
    "",
    "  var gridIndices = new Uint32Array(vertices.length / 3);",
    "",
    "  var interleaved = new CTM.InterleavedStream(gridIndices, 1);",
    "  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);",
    "",
    "  CTM.restoreGridIndices(gridIndices, gridIndices.length);",
    "",
    "  return gridIndices;",
    "};",
    "",
    "CTM.ReaderMG2.prototype.readIndices = function(stream, indices){",
    '  stream.readInt32(); //magic "INDX"',
    "  stream.readInt32(); //packed size",
    "",
    "  var interleaved = new CTM.InterleavedStream(indices, 3);",
    "  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);",
    "",
    "  CTM.restoreIndices(indices, indices.length);",
    "};",
    "",
    "CTM.ReaderMG2.prototype.readNormals = function(stream, body){",
    '  stream.readInt32(); //magic "NORM"',
    "  stream.readInt32(); //packed size",
    "",
    "  var interleaved = new CTM.InterleavedStream(body.normals, 3);",
    "  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);",
    "",
    "  var smooth = CTM.calcSmoothNormals(body.indices, body.vertices);",
    "",
    "  CTM.restoreNormals(body.normals, smooth, this.MG2Header.normalPrecision);",
    "};",
    "",
    "CTM.ReaderMG2.prototype.readUVMaps = function(stream, uvMaps){",
    "  var i = 0;",
    "  for (; i < uvMaps.length; ++ i){",
    '    stream.readInt32(); //magic "TEXC"',
    "",
    "    uvMaps[i].name = stream.readString();",
    "    uvMaps[i].filename = stream.readString();",
    "",
    "    var precision = stream.readFloat32();",
    "",
    "    stream.readInt32(); //packed size",
    "",
    "    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);",
    "    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);",
    "",
    "    CTM.restoreMap(uvMaps[i].uv, 2, precision);",
    "  }",
    "};",
    "",
    "CTM.ReaderMG2.prototype.readAttrMaps = function(stream, attrMaps){",
    "  var i = 0;",
    "  for (; i < attrMaps.length; ++ i){",
    '    stream.readInt32(); //magic "ATTR"',
    "",
    "    attrMaps[i].name = stream.readString();",
    "",
    "    var precision = stream.readFloat32();",
    "",
    "    stream.readInt32(); //packed size",
    "",
    "    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);",
    "    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);",
    "",
    "    CTM.restoreMap(attrMaps[i].attr, 4, precision);",
    "  }",
    "};",
    "",
    "CTM.restoreIndices = function(indices, len){",
    "  var i = 3;",
    "  if (len > 0){",
    "    indices[2] += indices[0];",
    "    indices[1] += indices[0];",
    "  }",
    "  for (; i < len; i += 3){",
    "    indices[i] += indices[i - 3];",
    "",
    "    if (indices[i] === indices[i - 3]){",
    "      indices[i + 1] += indices[i - 2];",
    "    }else{",
    "      indices[i + 1] += indices[i];",
    "    }",
    "",
    "    indices[i + 2] += indices[i];",
    "  }",
    "};",
    "",
    "CTM.restoreGridIndices = function(gridIndices, len){",
    "  var i = 1;",
    "  for (; i < len; ++ i){",
    "    gridIndices[i] += gridIndices[i - 1];",
    "  }",
    "};",
    "",
    "CTM.restoreVertices = function(vertices, grid, gridIndices, precision){",
    "  var gridIdx, delta, x, y, z,",
    "      intVertices = new Uint32Array(vertices.buffer, vertices.byteOffset, vertices.length),",
    "      ydiv = grid.divx, zdiv = ydiv * grid.divy,",
    "      prevGridIdx = 0x7fffffff, prevDelta = 0,",
    "      i = 0, j = 0, len = gridIndices.length;",
    "",
    "  for (; i < len; j += 3){",
    "    x = gridIdx = gridIndices[i ++];",
    "",
    "    z = ~~(x / zdiv);",
    "    x -= ~~(z * zdiv);",
    "    y = ~~(x / ydiv);",
    "    x -= ~~(y * ydiv);",
    "",
    "    delta = intVertices[j];",
    "    if (gridIdx === prevGridIdx){",
    "      delta += prevDelta;",
    "    }",
    "",
    "    vertices[j]     = grid.lowerBoundx +",
    "      x * grid.sizex + precision * delta;",
    "    vertices[j + 1] = grid.lowerBoundy +",
    "      y * grid.sizey + precision * intVertices[j + 1];",
    "    vertices[j + 2] = grid.lowerBoundz +",
    "      z * grid.sizez + precision * intVertices[j + 2];",
    "",
    "    prevGridIdx = gridIdx;",
    "    prevDelta = delta;",
    "  }",
    "};",
    "",
    "CTM.restoreNormals = function(normals, smooth, precision){",
    "  var ro, phi, theta, sinPhi,",
    "      nx, ny, nz, by, bz, len,",
    "      intNormals = new Uint32Array(normals.buffer, normals.byteOffset, normals.length),",
    "      i = 0, k = normals.length,",
    "      PI_DIV_2 = 3.141592653589793238462643 * 0.5;",
    "",
    "  for (; i < k; i += 3){",
    "    ro = intNormals[i] * precision;",
    "    phi = intNormals[i + 1];",
    "",
    "    if (phi === 0){",
    "      normals[i]     = smooth[i]     * ro;",
    "      normals[i + 1] = smooth[i + 1] * ro;",
    "      normals[i + 2] = smooth[i + 2] * ro;",
    "    }else{",
    "",
    "      if (phi <= 4){",
    "        theta = (intNormals[i + 2] - 2) * PI_DIV_2;",
    "      }else{",
    "        theta = ( (intNormals[i + 2] * 4 / phi) - 2) * PI_DIV_2;",
    "      }",
    "",
    "      phi *= precision * PI_DIV_2;",
    "      sinPhi = ro * Math.sin(phi);",
    "",
    "      nx = sinPhi * Math.cos(theta);",
    "      ny = sinPhi * Math.sin(theta);",
    "      nz = ro * Math.cos(phi);",
    "",
    "      bz = smooth[i + 1];",
    "      by = smooth[i] - smooth[i + 2];",
    "",
    "      len = Math.sqrt(2 * bz * bz + by * by);",
    "      if (len > 1e-20){",
    "        by /= len;",
    "        bz /= len;",
    "      }",
    "",
    "      normals[i]     = smooth[i]     * nz +",
    "        (smooth[i + 1] * bz - smooth[i + 2] * by) * ny - bz * nx;",
    "      normals[i + 1] = smooth[i + 1] * nz -",
    "        (smooth[i + 2]      + smooth[i]   ) * bz  * ny + by * nx;",
    "      normals[i + 2] = smooth[i + 2] * nz +",
    "        (smooth[i]     * by + smooth[i + 1] * bz) * ny + bz * nx;",
    "    }",
    "  }",
    "};",
    "",
    "CTM.restoreMap = function(map, count, precision){",
    "  var delta, value,",
    "      intMap = new Uint32Array(map.buffer, map.byteOffset, map.length),",
    "      i = 0, j, len = map.length;",
    "",
    "  for (; i < count; ++ i){",
    "    delta = 0;",
    "",
    "    for (j = i; j < len; j += count){",
    "      value = intMap[j];",
    "",
    "      delta += value & 1? -( (value + 1) >> 1): value >> 1;",
    "",
    "      map[j] = delta * precision;",
    "    }",
    "  }",
    "};",
    "",
    "CTM.calcSmoothNormals = function(indices, vertices){",
    "  var smooth = new Float32Array(vertices.length),",
    "      indx, indy, indz, nx, ny, nz,",
    "      v1x, v1y, v1z, v2x, v2y, v2z, len,",
    "      i, k;",
    "",
    "  for (i = 0, k = indices.length; i < k;){",
    "    indx = indices[i ++] * 3;",
    "    indy = indices[i ++] * 3;",
    "    indz = indices[i ++] * 3;",
    "",
    "    v1x = vertices[indy]     - vertices[indx];",
    "    v2x = vertices[indz]     - vertices[indx];",
    "    v1y = vertices[indy + 1] - vertices[indx + 1];",
    "    v2y = vertices[indz + 1] - vertices[indx + 1];",
    "    v1z = vertices[indy + 2] - vertices[indx + 2];",
    "    v2z = vertices[indz + 2] - vertices[indx + 2];",
    "",
    "    nx = v1y * v2z - v1z * v2y;",
    "    ny = v1z * v2x - v1x * v2z;",
    "    nz = v1x * v2y - v1y * v2x;",
    "",
    "    len = Math.sqrt(nx * nx + ny * ny + nz * nz);",
    "    if (len > 1e-10){",
    "      nx /= len;",
    "      ny /= len;",
    "      nz /= len;",
    "    }",
    "",
    "    smooth[indx]     += nx;",
    "    smooth[indx + 1] += ny;",
    "    smooth[indx + 2] += nz;",
    "    smooth[indy]     += nx;",
    "    smooth[indy + 1] += ny;",
    "    smooth[indy + 2] += nz;",
    "    smooth[indz]     += nx;",
    "    smooth[indz + 1] += ny;",
    "    smooth[indz + 2] += nz;",
    "  }",
    "",
    "  for (i = 0, k = smooth.length; i < k; i += 3){",
    "    len = Math.sqrt(smooth[i] * smooth[i] +",
    "      smooth[i + 1] * smooth[i + 1] +",
    "      smooth[i + 2] * smooth[i + 2]);",
    "",
    "    if(len > 1e-10){",
    "      smooth[i]     /= len;",
    "      smooth[i + 1] /= len;",
    "      smooth[i + 2] /= len;",
    "    }",
    "  }",
    "",
    "  return smooth;",
    "};",
    "",
    "CTM.isLittleEndian = (function(){",
    "  var buffer = new ArrayBuffer(2),",
    "      bytes = new Uint8Array(buffer),",
    "      ints = new Uint16Array(buffer);",
    "",
    "  bytes[0] = 1;",
    "",
    "  return ints[0] === 1;",
    "}());",
    "",
    "CTM.InterleavedStream = function(data, count){",
    "  this.data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);",
    "  this.offset = CTM.isLittleEndian? 3: 0;",
    "  this.count = count * 4;",
    "  this.len = this.data.length;",
    "};",
    "",
    "CTM.InterleavedStream.prototype.writeByte = function(value){",
    "  this.data[this.offset] = value;",
    "",
    "  this.offset += this.count;",
    "  if (this.offset >= this.len){",
    "",
    "    this.offset -= this.len - 4;",
    "    if (this.offset >= this.count){",
    "",
    "      this.offset -= this.count + (CTM.isLittleEndian? 1: -1);",
    "    }",
    "  }",
    "};",
    "",
    "CTM.Stream = function(data){",
    "  this.data = data;",
    "  this.chardata = new DataView(data);",
    "  this.offset = 0;",
    "};",
    "",
    "CTM.Stream.prototype.TWO_POW_MINUS23 = Math.pow(2, -23);",
    "",
    "CTM.Stream.prototype.TWO_POW_MINUS126 = Math.pow(2, -126);",
    "",
    "CTM.Stream.prototype.readByte = function(){",
    "  return this.chardata.getUint8(this.offset++);",
    "};",
    "",
    "CTM.Stream.prototype.readInt32 = function(){",
    "var v = this.chardata.getInt32(this.offset, CTM.isLittleEndian);",
    "this.offset += 4;",
    "return v;",
    "};",
    "",
    "CTM.Stream.prototype.readFloat32 = function(){",
    "var v = this.chardata.getFloat32(this.offset, CTM.isLittleEndian);",
    "this.offset += 4;",
    "return v;",
    "};",
    "",
    "CTM.Stream.prototype.readString = function(){",
    "  var len = this.readInt32();",
    "",
    "  this.offset += len;",
    "",
    "	var tmp = new Uint8Array(this.data,this.offset - len, len);",
    "	return String.fromCharCode.apply(null,tmp);",
    "};",
    "",
    "CTM.Stream.prototype.readArrayInt32 = function(array){",
    "  var i = 0, len = array.length;",
    "",
    "  while(i < len){",
    "    array[i ++] = this.readInt32();",
    "  }",
    "",
    "  return array;",
    "};",
    "",
    "CTM.Stream.prototype.readArrayFloat32 = function(array){",
    "  var i = 0, len = array.length;",
    "",
    "  while(i < len){",
    "    array[i ++] = this.readFloat32();",
    "  }",
    "",
    "  return array;",
    "};",
    "",
    "self.onmessage = function( event ) {",
    "var s = Date.now();",
    "",
    "	var files = [];",
    "",
    "	for ( var i = 0; i < event.data.offsets.length; i ++ ) {",
    "",
    "		var stream = new CTM.Stream( event.data.data );",
    "		stream.offset = event.data.offsets[ i ];",
    "",
    "		files[ i ] = new CTM.File( stream );",
    "",
    "	}",
    "",
    "var e = Date.now();",
    '	self.postMessage( {"f":files,"t":e-s} );',
    "",
    "}",
  ].join("\n")),
  (XG.JSONLoader = function (e) {
    XG.Loader.call(this, e), (this.withCredentials = !1);
  }),
  (XG.JSONLoader.prototype = Object.create(XG.Loader.prototype)),
  (XG.JSONLoader.prototype.load = function (e, t, a) {
    this.onLoadStart(), this.loadAjaxJSON(this, e, t, a);
  }),
  (XG.JSONLoader.prototype.loadAjaxJSON = function (e, t, a, r) {
    void 0 === r && (r = {});
    var i = r.texturePath ? r.texturePath : this.extractUrlBase(t),
      o = r.mergeMaterials,
      n = r.callbackProgress,
      s = new XMLHttpRequest(),
      l = 0;
    (s.onreadystatechange = function () {
      if (s.readyState === s.DONE)
        if (200 === s.status || 0 === s.status) {
          if (s.responseText) {
            var r = JSON.parse(s.responseText);
            e.createModel(r, a, i, o);
          } else
            console.warn(
              "XG.JSONLoader: [" +
              t +
              "] seems to be unreachable or file there is empty"
            );
          e.onLoadComplete();
        } else
          console.error(
            "XG.JSONLoader: Couldn't load [" + t + "] [" + s.status + "]"
          );
      else
        s.readyState === s.LOADING
          ? n &&
          (0 === l && (l = s.getResponseHeader("Content-Length")),
            n({ total: l, loaded: s.responseText.length }))
          : s.readyState === s.HEADERS_RECEIVED &&
          (l = s.getResponseHeader("Content-Length"));
    }),
      s.open("GET", t, !0),
      (s.withCredentials = this.withCredentials),
      s.send(null);
  }),
  (XG.JSONLoader.prototype.generateMaterialChunks = function (e, t, a) {
    function r(e, t) {
      return e & (1 << t);
    }
    for (
      var i,
      o,
      n,
      s,
      l,
      h,
      d,
      c,
      u,
      f,
      p,
      m,
      v = [],
      g = e.faces,
      S = g.length,
      x = 0;
      S > x;

    ) {
      (i = g[x++]),
        (o = r(i, 0)),
        (n = r(i, 1)),
        (l = r(i, 2)),
        (h = r(i, 3)),
        (d = r(i, 4)),
        (c = r(i, 5)),
        (u = r(i, 6)),
        (f = r(i, 7)),
        o ? ((p = 2), (m = 4)) : ((p = 1), (m = 3)),
        (x += m),
        n ? ((s = g[x++]), a && (s = 0)) : (s = 0),
        void 0 === v[s]
          ? (v[s] = {
            nTriangles: p,
            hasNormals: !1,
            hasUvs: !1,
            hasColors: !1,
            hasIndices: !1,
            indexOffset: 0,
            vertexOffset: 0,
            positionOffset: 0,
            normalOffset: 0,
            colorOffset: 0,
            uvOffset: [],
            skinWeightOffset: 0,
            skinIndexOffset: 0,
            indexMap: {},
          })
          : (v[s].nTriangles += p);
      var G = v[s];
      l && (x += t),
        h && (x += t * m),
        d && (x += 1),
        c && (x += m),
        u && (x += 1),
        f && (x += m),
        (d || c) && (G.hasNormals |= !0),
        (l || h) && (G.hasUvs |= !0),
        (u || f) && (G.hasColors |= !0);
    }
    return v;
  }),
  (XG.JSONLoader.prototype.generateGeometries = function (e, t, a) {
    for (var r = [], i = 0, o = e.length; o > i; i++) {
      var n = e[i];
      if (void 0 !== n) {
        var s = new XG.Geometry();
        (s.numPrimitives = n.nTriangles), (s.numVertices = 3 * n.nTriangles);
        var l = Uint16Array;
        if (
          (s.numVertices > 65536 &&
            (l = XG.elementIndexUintAvailable ? Uint32Array : null),
            null !== l &&
            (s.addIndex("index", l, 3),
              s.offsets.push({ start: 0, index: 0, count: 3 * n.nTriangles }),
              (n.hasIndices = !0)),
            s.addAttribute("position", Float32Array, 3),
            n.hasUvs && s.addAttribute("uv", Float32Array, 2),
            n.hasColors && s.addAttribute("color", Float32Array, 3),
            s.addAttribute("normal", Float32Array, 3),
            n.hasUvs)
        ) {
          n.uvOffset[0] = 0;
          for (var h = 1; a > h; h++)
            s.addAttribute("uv" + (h + 1), Float32Array, 2),
              (n.uvOffset[h] = 0);
        }
        if (
          (t.skinWeights && s.addAttribute("skinWeight", Float32Array, 4),
            t.skinIndices && s.addAttribute("skinIndex", Float32Array, 4),
            void 0 === t.morphTargets && (t.morphTargets = []),
            void 0 === t.morphColors && (t.morphColors = []),
            t.morphTargets.length > 0)
        ) {
          s.addVirtualAttribute("morphTarget0"),
            s.addVirtualAttribute("morphTarget1"),
            s.addVirtualAttribute("morphTarget2"),
            s.addVirtualAttribute("morphTarget3"),
            s.addVirtualAttribute("morphNormal0"),
            s.addVirtualAttribute("morphNormal1"),
            s.addVirtualAttribute("morphNormal2"),
            s.addVirtualAttribute("morphNormal3");
          for (var h = 0, d = t.morphTargets.length; d > h; h++) {
            var c = t.morphTargets[h].name;
            s.addUnattachedAttribute("mp_" + h, Float32Array, 3),
              s.addUnattachedAttribute("mn_" + h, Float32Array, 3),
              (s.morphTargets[h] = {
                name: c,
                index: s.attributesList.length - 2,
              });
          }
        }
        if (t.morphColors.length > 0) {
          for (var h = 0, d = t.morphColors.length; d > h; h++) {
            {
              var u = t.morphColors[h],
                c = u.name;
              u.colors;
            }
            s.addUnattachedAttribute("mc_" + h, Float32Array, 3),
              (s.morphColors[h] = {
                name: c,
                index: s.attributesList.length - 1,
                faceColors: !0,
              });
          }
          n.hasColors ||
            (s.addVirtualAttribute("color"),
              (s.virtualAttributes.color.mapped =
                s.attributesList[s.morphColors[0].index]));
        }
        (r[i] = s), (s.bones = t.bones);
        var f = [];
        t.animations && (f = t.animations),
          t.animation && f.push(t.animation),
          (s.animations = f);
      }
    }
    return r;
  }),
  (XG.JSONLoader.prototype.fillGeometries = function (e, t, a, r, i) {
    function o(e, t) {
      return e & (1 << t);
    }
    function n(e, t, a, r, i) {
      (e[t] = a[3 * r] * i),
        (e[t + 1] = a[3 * r + 1] * i),
        (e[t + 2] = a[3 * r + 2] * i);
    }
    function s(e, t, a, r) {
      (e[t] = a[3 * r]), (e[t + 1] = a[3 * r + 1]), (e[t + 2] = a[3 * r + 2]);
    }
    function l(e, t, a, r, i) {
      (ce = e[3 * t]),
        (ue = e[3 * t + 1]),
        (fe = e[3 * t + 2]),
        pe.set(ce, ue, fe),
        (ce = e[3 * a]),
        (ue = e[3 * a + 1]),
        (fe = e[3 * a + 2]),
        me.set(ce, ue, fe),
        (ce = e[3 * r]),
        (ue = e[3 * r + 1]),
        (fe = e[3 * r + 2]),
        ve.set(ce, ue, fe),
        ge.sub(ve, me),
        Se.sub(pe, me),
        ge.crossSelf(Se),
        (i[3 * t] += xe[0]),
        (i[3 * t + 1] += xe[1]),
        (i[3 * t + 2] += xe[2]),
        (i[3 * a] += xe[0]),
        (i[3 * a + 1] += xe[1]),
        (i[3 * a + 2] += xe[2]),
        (i[3 * r] += xe[0]),
        (i[3 * r + 1] += xe[1]),
        (i[3 * r + 2] += xe[2]);
    }
    var h,
      d,
      c,
      u,
      f,
      p,
      m,
      v,
      g,
      S,
      x,
      G,
      M,
      y,
      w,
      _,
      X,
      D,
      T,
      C,
      A,
      P,
      L,
      b,
      E,
      F,
      R,
      U,
      I,
      N,
      B,
      O,
      V,
      k,
      z,
      H,
      W,
      j,
      q,
      Y,
      K,
      Z,
      Q,
      J,
      $,
      ee,
      te = void 0 !== a.scale ? 1 / a.scale : 1,
      ae = new XG.Color(),
      re = a.faces,
      ie = a.vertices,
      oe = a.normals,
      ne = a.colors,
      se = a.skinWeights,
      le = a.skinIndices,
      he = new Float32Array(a.vertices.length);
    if (void 0 !== a.morphTargets) {
      var de = [];
      for ($ = 0, ee = a.morphTargets.length; ee > $; $++)
        de[$] = new Float32Array(a.vertices.length);
    }
    for (
      var ce,
      ue,
      fe,
      pe = new XG.Vector3(),
      me = new XG.Vector3(),
      ve = new XG.Vector3(),
      ge = new XG.Vector3(),
      Se = new XG.Vector3(),
      xe = ge.data,
      Ge = 0,
      Me = 0,
      ye = re.length;
      ye > Me;

    ) {
      (f = re[Me++]),
        (p = o(f, 0)),
        (m = o(f, 1)),
        (v = o(f, 2)),
        (g = o(f, 3)),
        (S = o(f, 4)),
        (x = o(f, 5)),
        (G = o(f, 6)),
        (M = o(f, 7)),
        p
          ? ((A = re[Me++]),
            (P = re[Me++]),
            (L = re[Me++]),
            (b = re[Me++]),
            (Z = 4))
          : ((A = re[Me++]), (P = re[Me++]), (L = re[Me++]), (Z = 3)),
        m ? ((u = re[Me++]), i && (u = 0)) : (u = 0),
        (F = t[u]),
        (E = e[u]),
        F.hasIndices && (R = E.attributes.index.array),
        (U = E.attributes.position.array),
        F.hasNormals && (I = E.attributes.normal.array),
        F.hasUvs && (N = E.attributes.uv.array),
        F.hasColors && (B = E.attributes.color.array),
        (k = F.indexOffset),
        (z = F.positionOffset),
        (q = F.vertexOffset);
      var we = F.indexMap;
      if (
        (p
          ? (F.hasIndices
            ? ((R[k] = q),
              (R[k + 1] = q + 1),
              (R[k + 2] = q + 3),
              (R[k + 3] = q + 1),
              (R[k + 4] = q + 2),
              (R[k + 5] = q + 3),
              (F.positionOffset += 12))
            : (F.positionOffset += 18),
            (F.indexOffset += 6),
            (F.vertexOffset += 4))
          : (F.hasIndices &&
            ((R[k] = q), (R[k + 1] = q + 1), (R[k + 2] = q + 2)),
            (F.indexOffset += 3),
            (F.vertexOffset += 3),
            (F.positionOffset += 9)),
          F.hasIndices)
      ) {
        for (
          n(U, z, ie, A, te),
          n(U, z + 3, ie, P, te),
          n(U, z + 6, ie, L, te),
          we[z] = A,
          we[z + 3] = P,
          we[z + 6] = L,
          l(ie, A, P, L, he),
          p && (n(U, z + 9, ie, b, te), (we[z + 9] = b)),
          Q = 0,
          J = a.morphTargets.length;
          J > Q;
          Q++
        ) {
          var _e = E.attributes["mp_" + Q].array,
            Xe = a.morphTargets[Q].vertices;
          n(_e, z, Xe, A, te),
            n(_e, z + 3, Xe, P, te),
            n(_e, z + 6, Xe, L, te),
            l(Xe, A, P, L, de[Q]),
            p && n(_e, z + 9, Xe, b, te);
        }
        for (Q = 0, J = a.morphColors.length; J > Q; Q++) {
          var De = E.attributes["mc_" + Q].array,
            Te = a.morphColors[Q].colors;
          s(De, z, Te, Ge),
            s(De, z + 3, Te, Ge),
            s(De, z + 6, Te, Ge),
            p && s(_e, z + 9, Te, Ge);
        }
      } else if (p) {
        for (
          n(U, z, ie, A, te),
          n(U, z + 3, ie, P, te),
          n(U, z + 6, ie, b, te),
          n(U, z + 9, ie, P, te),
          n(U, z + 12, ie, L, te),
          n(U, z + 15, ie, b, te),
          we[z] = A,
          we[z + 3] = P,
          we[z + 6] = b,
          we[z + 9] = P,
          we[z + 12] = L,
          we[z + 15] = b,
          Q = 0,
          J = a.morphTargets.length;
          J > Q;
          Q++
        ) {
          var _e = E.attributes["mp_" + Q].array,
            Xe = a.morphTargets[Q].vertices;
          n(_e, z, Xe, A, te),
            n(_e, z + 3, Xe, P, te),
            n(_e, z + 6, Xe, b, te),
            n(_e, z + 9, Xe, P, te),
            n(_e, z + 12, Xe, L, te),
            n(_e, z + 15, Xe, b, te);
        }
        for (Q = 0, J = a.morphColors.length; J > Q; Q++) {
          var De = E.attributes["mc_" + Q].array,
            Te = a.morphColors[Q].colors;
          s(De, z, Te, Ge),
            s(De, z + 3, Te, Ge),
            s(De, z + 6, Te, Ge),
            s(De, z + 9, Te, Ge),
            s(De, z + 12, Te, Ge),
            s(De, z + 15, Te, Ge);
        }
      } else {
        for (
          n(U, z, ie, A, te),
          n(U, z + 3, ie, P, te),
          n(U, z + 6, ie, L, te),
          we[z] = A,
          we[z + 3] = P,
          we[z + 6] = L,
          Q = 0,
          J = a.morphTargets.length;
          J > Q;
          Q++
        ) {
          var _e = E.attributes["mp_" + Q].array,
            Xe = a.morphTargets[Q].vertices;
          n(_e, z, Xe, A, te), n(_e, z + 3, Xe, P, te), n(_e, z + 6, Xe, L, te);
        }
        for (Q = 0, J = a.morphColors.length; J > Q; Q++) {
          var De = E.attributes["mc_" + Q].array,
            Te = a.morphColors[Q].colors;
          s(De, z, Te, Ge), s(De, z + 3, Te, Ge), s(De, z + 6, Te, Ge);
        }
      }
      if (
        (a.skinWeights &&
          ((O = E.attributes.skinWeight.array),
            (Y = F.skinWeightOffset),
            (O[Y] = se[2 * A]),
            (O[Y + 1] = se[2 * A + 1]),
            (O[Y + 2] = 0),
            (O[Y + 3] = 0),
            (O[Y + 4] = se[2 * P]),
            (O[Y + 5] = se[2 * P + 1]),
            (O[Y + 6] = 0),
            (O[Y + 7] = 0),
            (O[Y + 8] = se[2 * L]),
            (O[Y + 9] = se[2 * L + 1]),
            (O[Y + 10] = 0),
            (O[Y + 11] = 0),
            p
              ? ((O[Y + 12] = se[2 * b]),
                (O[Y + 13] = se[2 * b + 1]),
                (O[Y + 14] = 0),
                (O[Y + 15] = 0),
                (F.skinWeightOffset += 16))
              : (F.skinWeightOffset += 12)),
          a.skinIndices &&
          ((V = E.attributes.skinIndex.array),
            (K = F.skinIndexOffset),
            (V[K] = le[2 * A]),
            (V[K + 1] = le[2 * A + 1]),
            (V[K + 2] = 0),
            (V[K + 3] = 0),
            (V[K + 4] = le[2 * P]),
            (V[K + 5] = le[2 * P + 1]),
            (V[K + 6] = 0),
            (V[K + 7] = 0),
            (V[K + 8] = le[2 * L]),
            (V[K + 9] = le[2 * L + 1]),
            (V[K + 10] = 0),
            (V[K + 11] = 0),
            p
              ? ((V[K + 12] = le[2 * b]),
                (V[K + 13] = le[2 * b + 1]),
                (V[K + 14] = 0),
                (V[K + 15] = 0),
                (F.skinIndexOffset += 16))
              : (F.skinIndexOffset += 12)),
          v)
      )
        for (Q = 0; r > Q; Q++)
          for (
            y = a.uvs[Q],
            c = re[Me++],
            w = y[2 * c],
            _ = y[2 * c + 1],
            X = 0 === Q ? N : E.attributes["uv" + (Q + 1)].array,
            $ = 0;
            Z > $;
            $++
          )
            (W = F.uvOffset[Q]),
              (X[W] = w),
              (X[W + 1] = _),
              (F.uvOffset[Q] += 2);
      if (g)
        for (Q = 0; r > Q; Q++) {
          for (
            y = a.uvs[Q],
            X = 0 === Q ? N : E.attributes["uv" + (Q + 1)].array,
            $ = 0;
            Z > $;
            $++
          )
            (W = F.uvOffset[Q]),
              (c = re[Me++]),
              (w = y[2 * c]),
              (_ = y[2 * c + 1]),
              (X[W] = w),
              (X[W + 1] = _),
              (F.uvOffset[Q] += 2);
          if (p && !F.hasIndices) {
            var Ce = F.uvOffset[Q] - 4,
              Ae = X[Ce],
              Pe = X[Ce + 1];
            (X[Ce] = w),
              (X[Ce + 1] = _),
              (X[Ce + 2] = X[Ce - 2]),
              (X[Ce + 3] = X[Ce - 1]),
              (X[Ce + 4] = Ae),
              (X[Ce + 5] = Pe),
              (X[Ce + 6] = w),
              (X[Ce + 7] = _),
              (F.uvOffset[Q] += 4);
          }
        }
      if (S)
        for (
          d = 3 * re[Me++], D = oe[d++], T = oe[d++], C = oe[d], $ = 0;
          Z > $;
          $++
        )
          (H = F.normalOffset),
            (I[H] = D),
            (I[H + 1] = T),
            (I[H + 2] = C),
            (F.normalOffset += 3);
      if (x) {
        for (Q = 0; Z > Q; Q++)
          (H = F.normalOffset),
            (d = 3 * re[Me++]),
            (D = oe[d++]),
            (T = oe[d++]),
            (C = oe[d]),
            (I[H] = D),
            (I[H + 1] = T),
            (I[H + 2] = C),
            (F.normalOffset += 3);
        if (p && !F.hasIndices) {
          var Ce = F.normalOffset - 6,
            Le = I[Ce],
            be = I[Ce + 1],
            Ee = I[Ce + 2];
          (I[Ce] = D),
            (I[Ce + 1] = T),
            (I[Ce + 2] = C),
            (I[Ce + 3] = I[Ce - 3]),
            (I[Ce + 4] = I[Ce - 2]),
            (I[Ce + 5] = I[Ce - 1]),
            (I[Ce + 6] = Le),
            (I[Ce + 7] = be),
            (I[Ce + 8] = Ee),
            (I[Ce + 9] = D),
            (I[Ce + 10] = T),
            (I[Ce + 11] = C),
            (F.normalOffset += 6);
        }
      }
      if (G)
        for (
          j = F.colorOffset, h = re[Me++], ae.setHex(ne[h]), $ = 0;
          Z > $;
          $++
        )
          (B[j] = ae.r),
            (B[j + 1] = ae.g),
            (B[j + 2] = ae.b),
            (F.colorOffset += 3);
      if (M) {
        for (j = F.colorOffset, Q = 0; Z > Q; Q++)
          (h = re[Me++]),
            ae.setHex(ne[h]),
            (B[j] = ae.r),
            (B[j + 1] = ae.g),
            (B[j + 2] = ae.b),
            (F.colorOffset += 3);
        if (p && !F.hasIndices) {
          var Ce = F.colorOffset - 6,
            Le = B[Ce],
            be = B[Ce + 1],
            Ee = B[Ce + 2];
          (B[Ce] = D),
            (B[Ce + 1] = T),
            (B[Ce + 2] = C),
            (B[Ce + 3] = B[Ce - 3]),
            (B[Ce + 4] = B[Ce - 2]),
            (B[Ce + 5] = B[Ce - 1]),
            (B[Ce + 6] = Le),
            (B[Ce + 7] = be),
            (B[Ce + 8] = Ee),
            (B[Ce + 9] = D),
            (B[Ce + 10] = T),
            (B[Ce + 11] = C),
            (F.colorOffset += 6);
        }
      }
      Ge += 1;
    }
    var Fe;
    for (Q = 0, J = he.length; J > Q; Q += 3)
      (D = he[Q]),
        (T = he[Q + 1]),
        (C = he[Q + 2]),
        (Fe = 1 / Math.sqrt(D * D + T * T + C * C)),
        (he[Q] *= Fe),
        (he[Q + 1] *= Fe),
        (he[Q + 2] *= Fe);
    if (void 0 !== a.morphTargets)
      for ($ = 0, ee = a.morphTargets.length; ee > $; $++) {
        var Re = de[$];
        for (Q = 0, J = Re.length; J > Q; Q += 3)
          (D = Re[Q]),
            (T = Re[Q + 1]),
            (C = Re[Q + 2]),
            (Fe = 1 / Math.sqrt(D * D + T * T + C * C)),
            (Re[Q] *= Fe),
            (Re[Q + 1] *= Fe),
            (Re[Q + 2] *= Fe);
      }
    for (Q = 0, J = t.length; J > Q; Q++) {
      var Ue = t[Q];
      if (!Ue.hasNormals) {
        (E = e[Q]), (I = E.attributes.normal.array);
        for (Me in Ue.indexMap) {
          var Ie = Ue.indexMap[Me];
          (Me = parseInt(Me)),
            (I[Me + 0] = he[3 * Ie]),
            (I[Me + 1] = he[3 * Ie + 1]),
            (I[Me + 2] = he[3 * Ie + 2]);
        }
        if (void 0 !== a.morphTargets)
          for ($ = 0, ee = a.morphTargets.length; ee > $; $++) {
            var Re = de[$],
              Ne = E.attributes["mn_" + $].array;
            for (Me in Ue.indexMap) {
              var Ie = Ue.indexMap[Me];
              (Me = parseInt(Me)),
                (Ne[Me + 0] = Re[3 * Ie]),
                (Ne[Me + 1] = Re[3 * Ie + 1]),
                (Ne[Me + 2] = Re[3 * Ie + 2]);
            }
          }
      }
    }
  }),
  (XG.JSONLoader.prototype.createModel = function (e, t, a, r) {
    for (var i = 0, o = 0; o < e.uvs.length; o++) e.uvs[o].length && i++;
    var n = this.generateMaterialChunks(e, i, r),
      s = this.generateGeometries(n, e, i);
    this.fillGeometries(s, n, e, i, r);
    var l = this.initMaterials(e.materials, a);
    t(s, l);
  }),
  (XG.RenderTarget = function (e, t, a) {
    (this.id = XG.TextureIdCount++),
      (this.width = e),
      (this.height = t),
      (a = a || {}),
      (this.wrapS = void 0 !== a.wrapS ? a.wrapS : XG.ClampToEdgeWrapping),
      (this.wrapT = void 0 !== a.wrapT ? a.wrapT : XG.ClampToEdgeWrapping),
      (this.magFilter = void 0 !== a.magFilter ? a.magFilter : XG.LinearFilter),
      (this.minFilter =
        void 0 !== a.minFilter ? a.minFilter : XG.LinearMipMapLinearFilter),
      (this.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1),
      (this.offset = new XG.Vector2(0, 0)),
      (this.repeat = new XG.Vector2(1, 1)),
      (this.internalFormat =
        void 0 !== a.internalFormat ? a.internalFormat : XG.RGBAFormat),
      (this.format = void 0 !== a.format ? a.format : XG.RGBAFormat),
      (this.type = void 0 !== a.type ? a.type : XG.UnsignedByteType),
      (this.depthBuffer = void 0 !== a.depthBuffer ? a.depthBuffer : !0),
      (this.stencilBuffer = void 0 !== a.stencilBuffer ? a.stencilBuffer : !0),
      (this.mipmapCount = 0),
      (this.generateMipmaps = !0),
      (this.shareDepthFrom = null),
      (this.useDepthTexture =
        void 0 !== a.useDepthTexture ? a.useDepthTexture : !1),
      (this.depthTextureType =
        void 0 !== a.depthTextureType
          ? a.depthTextureType
          : XG.UnsignedIntType),
      (this.depthTexture = null),
      (this.useColorTexture =
        void 0 !== a.useColorTexture ? a.useColorTexture : !0),
      (this.mrtColorAttachment = null),
      (this.needsUpdate = !0),
      (this.onUpdate = null);
  }),
  (XG.RenderTarget.prototype.setSize = function (e, t) {
    (this.width = e), (this.height = t), (this.needsUpdate = !0);
  }),
  (XG.RenderTarget.prototype.clone = function () {
    var e = new XG.RenderTarget(this.width, this.height);
    return (
      (e.wrapS = this.wrapS),
      (e.wrapT = this.wrapT),
      (e.magFilter = this.magFilter),
      (e.minFilter = this.minFilter),
      (e.anisotropy = this.anisotropy),
      e.offset.copy(this.offset),
      e.repeat.copy(this.repeat),
      (e.internalFormat = this.internalFormat),
      (e.format = this.format),
      (e.type = this.type),
      (e.depthBuffer = this.depthBuffer),
      (e.stencilBuffer = this.stencilBuffer),
      (e.mipmapCount = this.mipmapCount),
      (e.generateMipmaps = this.generateMipmaps),
      (e.shareDepthFrom = this.shareDepthFrom),
      (e.useDepthTexture = this.useDepthTexture),
      (e.depthTextureType = this.depthTextureType),
      (e.depthTexture = this.depthTexture),
      (e.useColorTexture = this.useColorTexture),
      (e.mrtColorAttachment = this.mrtColorAttachment),
      e
    );
  }),
  (XG.RenderTarget3D = function (e, t, a, r) {
    (this.id = XG.TextureIdCount++),
      (this.width = e),
      (this.height = t),
      (this.depth = a),
      (r = r || {}),
      (this.wrapR = void 0 !== r.wrapR ? r.wrapR : XG.ClampToEdgeWrapping),
      (this.wrapS = void 0 !== r.wrapS ? r.wrapS : XG.ClampToEdgeWrapping),
      (this.wrapT = void 0 !== r.wrapT ? r.wrapT : XG.ClampToEdgeWrapping),
      (this.magFilter = void 0 !== r.magFilter ? r.magFilter : XG.LinearFilter),
      (this.minFilter =
        void 0 !== r.minFilter ? r.minFilter : XG.LinearMipMapLinearFilter),
      (this.anisotropy = void 0 !== r.anisotropy ? r.anisotropy : 1),
      (this.offset = new XG.Vector3(0, 0, 0)),
      (this.repeat = new XG.Vector3(1, 1, 1)),
      (this.internalFormat =
        void 0 !== r.internalFormat ? r.internalFormat : XG.RGBAFormat),
      (this.format = void 0 !== r.format ? r.format : XG.RGBAFormat),
      (this.type = void 0 !== r.type ? r.type : XG.UnsignedByteType),
      (this.depthBuffer = void 0 !== r.depthBuffer ? r.depthBuffer : !0),
      (this.stencilBuffer = void 0 !== r.stencilBuffer ? r.stencilBuffer : !0),
      (this.mipmapCount = 0),
      (this.generateMipmaps = !0),
      (this.shareDepthFrom = null),
      (this.useDepthTexture =
        void 0 !== r.useDepthTexture ? r.useDepthTexture : !1),
      (this.depthTextureType =
        void 0 !== r.depthTextureType
          ? r.depthTextureType
          : XG.UnsignedIntType),
      (this.depthTexture = null),
      (this.useColorTexture =
        void 0 !== r.useColorTexture ? r.useColorTexture : !0),
      (this.mrtColorAttachment = null),
      (this.needsUpdate = !0),
      (this.onUpdate = null),
      (this.activeLayer = 0),
      (this.useMRT = !1),
      (this.numMRT = 0);
  }),
  (XG.RenderTarget3D.prototype.setSize = function (e, t, a) {
    (this.width = e),
      (this.height = t),
      (this.depth = a),
      (this.needsUpdate = !0);
  }),
  (XG.RenderTarget3D.prototype.clone = function () {
    var e = new XG.RenderTarget3D(this.width, this.height, this.depth);
    return (
      (e.wrapR = this.wrapR),
      (e.wrapS = this.wrapS),
      (e.wrapT = this.wrapT),
      (e.magFilter = this.magFilter),
      (e.minFilter = this.minFilter),
      (e.anisotropy = this.anisotropy),
      e.offset.copy(this.offset),
      e.repeat.copy(this.repeat),
      (e.internalFormat = this.internalFormat),
      (e.format = this.format),
      (e.type = this.type),
      (e.depthBuffer = this.depthBuffer),
      (e.stencilBuffer = this.stencilBuffer),
      (e.mipmapCount = this.mipmapCount),
      (e.generateMipmaps = this.generateMipmaps),
      (e.shareDepthFrom = this.shareDepthFrom),
      (e.useDepthTexture = this.useDepthTexture),
      (e.depthTextureType = this.depthTextureType),
      (e.depthTexture = this.depthTexture),
      (e.useColorTexture = this.useColorTexture),
      (e.mrtColorAttachment = this.mrtColorAttachment),
      (e.useMRT = this.useMRT),
      (e.numMRT = this.numMRT),
      e
    );
  }),
  (XG.RenderTargetCube = function (e, t, a) {
    XG.RenderTarget.call(this, e, t, a), (this.activeCubeFace = 0);
  }),
  (XG.RenderTargetCube.prototype = Object.create(XG.RenderTarget.prototype)),
  (XG.RenderTargetArray = function (e, t, a, r, i) {
    (i = i || {}),
      (this.width = e),
      (this.height = t),
      (this.colorTexture = []),
      (this.depthTexture = null);
    for (var o = 0; a > o; o++)
      this.colorTexture.push(new XG.RenderTarget(e, t, i));
    r &&
      (this.depthTexture = new XG.RenderTarget(e, t, {
        magFilter: XG.LinearFilter,
        minFilter: XG.LinearFilter,
      })),
      (this.depthBuffer = void 0 !== i.depthBuffer ? i.depthBuffer : !0),
      (this.stencilBuffer = void 0 !== i.stencilBuffer ? i.stencilBuffer : !0),
      (this.generateMipmaps = !0),
      (this.needsUpdate = !0),
      (this.onUpdate = null);
  }),
  (XG.RenderTargetArray.prototype.clone = function () {
    for (
      var e = new XG.RenderTargetArray(this.width, this.height),
      t = this.colorTexture.length,
      a = 0;
      t > a;
      a++
    )
      e.colorTexture.push(this.colorTexture[a].clone());
    return (
      this.depthTexture && (e.depthTexture = this.depthTexture.clone()),
      (e.generateMipmaps = this.generateMipmaps),
      (e.depthBuffer = this.depthBuffer),
      (e.stencilBuffer = this.stencilBuffer),
      e
    );
  }),
  (XG.RenderTargetArray.prototype.setSize = function (e, t) {
    (this.width = e), (this.height = t);
    for (var a = this.colorTexture.length, r = 0; a > r; r++)
      this.colorTexture[r].setSize(e, t);
    this.depthTexture && this.depthTexture.setSize(e, t),
      (this.needsUpdate = !0);
  }),
  (XG.DebugUtils = {}),
  (XG.DebugUtils.parseTranslatedShaderErrorLog = function (e) {
    for (
      var t, a, r, i, o, n = /\((\d+),(\d+)-(\d+)\): (.*)/g, s = {};
      (t = n.exec(e));

    )
      t.length < 5 ||
        ((a = t[1]),
          (r = t[2] - 1),
          (i = t[3] - 1),
          (o = t[4]),
          void 0 === s[a]
            ? (s[a] = { start: r, end: i, lineText: o })
            : (s[a].text += ", " + o));
    return s;
  }),
  (XG.DebugUtils.parseGLSLShaderErrorLog = function (e) {
    for (
      var t,
      a,
      r,
      i,
      o,
      n = e.split("\n").join("").split("WARNING").join("\nWARNING"),
      s = /(ERROR|WARNING): (\d+):(\d+): (.*)/g,
      l = {};
      (t = s.exec(n));

    )
      t.length < 4 ||
        ((o = t[1]),
          (a = t[2]),
          (r = t[3]),
          (i = t[4]),
          void 0 === l[r]
            ? (l[r] = { fileNum: a, lineText: i, type: o })
            : (l[r].text += ", " + i));
    return l;
  }),
  (XG.DebugUtils.printHighlightedLine = function (e, t, a, r, i) {
    var o = "%c" + i.substring(0, 1).toUpperCase() + i.substring(1) + "\n",
      n = "%c" + r + ":",
      s = "%c" + e.substring(0, t),
      l = "%c" + e.substring(t, a + 1),
      h = "%c" + e.substring(a + 1);
    console.warn(
      o + n + s + l + h,
      "color:saddlebrown",
      "color:gray",
      "color:gray",
      "color:goldenrod",
      "color:gray"
    );
  }),
  (XG.DebugUtils.prettyPrintTranslatedShaderErrors = function (e, t) {
    for (var a = e.split("\n"), r = 0, i = a.length; i > r; r++) {
      var o = a[r],
        n = r + 1;
      t[n] &&
        XG.DebugUtils.printHighlightedLine(
          o,
          t[n].start,
          t[n].end,
          n,
          t[n].lineText
        );
    }
  }),
  (XG.DebugUtils.prettyPrintShaderErrors = function (e, t) {
    for (var a = [], r = e.split("\n"), i = 0, o = r.length; o > i; i++) {
      var n = i + 1,
        s = n + ": " + r[i];
      if (t[n]) {
        a.length > 0 && (console.log(a.join("\n")), (a = []));
        var l = t[n].lineText,
          h = t[n].type;
        "ERROR" === h
          ? console.error("ERROR: " + l + "\n" + s)
          : console.warn("WARNING: " + l + "\n" + s);
      }
    }
    console.log(a.join("\n"));
  }),
  (XG.DebugUtils.addLineNumbers = function (e) {
    for (var t = e.split("\n"), a = 0, r = t.length; r > a; a++)
      t[a] = a + 1 + ": " + t[a];
    return t.join("\n");
  }),
  (XG.DebugUtils.translateGLErrorCode = function (e) {
    switch (e) {
      case 0:
        return "NO_ERROR";
      case 1280:
        return "INVALID_ENUM";
      case 1281:
        return "INVALID_VALUE";
      case 1282:
        return "INVALID_OPERATION";
      case 1283:
        return "STACK_OVERFLOW";
      case 1284:
        return "STACK_UNDERFLOW";
      case 1285:
        return "OUT_OF_MEMORY";
      case 1286:
        return "INVALID_FRAMEBUFFER_OPERATION";
    }
    return "UNKNOWN_ERROR [" + e + "]";
  }),
  (XG.ImageUtils = {
    crossOrigin: "anonymous",
    halfFloatType: XG.HalfFloatType1,
    canvasCache: null,
    canvasCacheContext: null,
  }),
  (XG.ImageUtils.getImageData = function (e) {
    var t = XG.ImageUtils.canvasCache,
      a = XG.ImageUtils.canvasCacheContext;
    if (!t) {
      var r = document.createElement("canvas"),
        i = r.getContext("2d");
      (XG.ImageUtils.canvasCache = r),
        (XG.ImageUtils.canvasCacheContext = i),
        (t = r),
        (a = i);
    }
    var o = e.width,
      n = e.height;
    (t.width = o), (t.height = n), a.drawImage(e, 0, 0);
    var s = a.getImageData(0, 0, o, n).data;
    return s;
  }),
  (XG.ImageUtils.loadTexture = function (e, t, a) {
    var r = new Image(),
      i = new XG.Texture(r);
    return (
      (r.onload = function () {
        (i.image = r), (i.needsUpdate = !0), t && t(i);
      }),
      a && (r.onerror = a),
      (r.crossOrigin = this.crossOrigin),
      (r.src = e),
      (i.sourceFile = e),
      i
    );
  }),
  (XG.ImageUtils.loadTexture3D = function (e, t, a, r, i, o) {
    var n = new Image(),
      s = new XG.DataTexture3D();
    return (
      (n.onload = function () {
        (s.image = n), (s.needsUpdate = !0);
        var e = n.width,
          o = n.height,
          l = e * o;
        if (void 0 === t || void 0 === a || void 0 === r) {
          var h = Math.round(Math.pow(l, 1 / 3));
          (s.width = h), (s.height = h), (s.depth = h);
        } else (s.width = t), (s.height = a), (s.depth = r);
        var d = XG.ImageUtils.getImageData(n),
          c = new Uint8Array(d);
        (s.image.data = c),
          (s.format = XG.RGBAFormat),
          (s.flipY = !1),
          i && i(s);
      }),
      o && (n.onerror = o),
      (n.crossOrigin = this.crossOrigin),
      (n.src = e),
      (s.sourceFile = e),
      s
    );
  }),
  (XG.ImageUtils.loadMultipleCRNTexturesFromPack = function (e, t, a) {
    for (var r = !1, i = [], o = [], n = 0, s = e.length; s > n; n++) {
      var l = e[n],
        h = l[0],
        d = l[1],
        c = l[2];
      i.push([d, c]), o.push(h);
    }
    if (r);
    else var u = new Worker("js/crunch/CrunchWorker.js");
    (u.onmessage = function (e) {
      for (var t = e.data.textureData, r = 0, i = t.length; i > r; r++) {
        var n = t[r],
          s = o[r];
        (s.format = n.format),
          (s.mipmaps = n.mipmaps),
          (s.image.width = n.width),
          (s.image.height = n.height),
          (s.generateMipmaps = !1),
          (s.needsUpdate = !0);
      }
      a && a();
    }),
      u.postMessage({ buffer: t, offsets: i }, [t]);
  }),
  (XG.ImageUtils.loadCRNTextureFromPack = function (e, t, a, r, i) {
    var o = !0,
      n = XG.ImageUtils.parseCRN(t, o, a, r);
    return (
      (e.format = n.format),
      (e.mipmaps = n.mipmaps),
      (e.image.width = n.width),
      (e.image.height = n.height),
      (e.generateMipmaps = !1),
      (e.needsUpdate = !0),
      i && i(e),
      e
    );
  }),
  (XG.ImageUtils.loadCompressedTextureFromPack = function (e, t, a, r) {
    var i = !0,
      o = XG.ImageUtils.parseDDS(t, i, a);
    return (
      (e.format = o.format),
      (e.type = o.type),
      (e.mipmaps = o.mipmaps),
      (e.image.width = o.width),
      (e.image.height = o.height),
      (e.generateMipmaps = !1),
      (e.needsUpdate = !0),
      r && r(e),
      e
    );
  }),
  (XG.ImageUtils.loadCompressedTexture = function (e, t, a) {
    var r = new XG.CompressedTexture(),
      i = new XMLHttpRequest();
    return (
      (i.onload = function () {
        var e = i.response,
          a = !0,
          o = 0,
          n = XG.ImageUtils.parseDDS(e, a, o);
        (r.format = n.format),
          (r.type = n.type),
          (r.mipmaps = n.mipmaps),
          (r.image.width = n.width),
          (r.image.height = n.height),
          (r.generateMipmaps = !1),
          (r.needsUpdate = !0),
          t && t(r);
      }),
      (i.onerror = a),
      i.open("GET", e, !0),
      (i.responseType = "arraybuffer"),
      i.send(null),
      r
    );
  }),
  (XG.ImageUtils.loadPVRTexture = function (e, t, a) {
    var r = new XG.CompressedTexture(),
      i = new XMLHttpRequest();
    return (
      (i.onload = function () {
        var e = i.response,
          a = !0,
          o = 0,
          n = XG.ImageUtils.parsePVR(e, a, o);
        (r.format = n.format),
          (r.type = n.type),
          (r.mipmaps = n.mipmaps),
          (r.image.width = n.width),
          (r.image.height = n.height),
          (r.generateMipmaps = !1),
          (r.needsUpdate = !0),
          t && t(r);
      }),
      (i.onerror = a),
      i.open("GET", e, !0),
      (i.responseType = "arraybuffer"),
      i.send(null),
      r
    );
  }),
  (XG.ImageUtils.loadATCTexture = function () { }),
  (XG.ImageUtils.loadETCTexture = function () { }),
  (XG.ImageUtils.loadCRNTexture = function (e, t, a) {
    var r = new XG.CompressedTexture(),
      i = new XMLHttpRequest();
    return (
      (i.onload = function () {
        var e = i.response,
          a = !0,
          o = XG.ImageUtils.parseCRN(e, a, 0);
        (r.format = o.format),
          (r.type = o.type),
          (r.mipmaps = o.mipmaps),
          (r.image.width = o.width),
          (r.image.height = o.height),
          (r.generateMipmaps = !1),
          (r.needsUpdate = !0),
          t && t(r);
      }),
      (i.onerror = a),
      i.open("GET", e, !0),
      (i.responseType = "arraybuffer"),
      i.send(null),
      r
    );
  }),
  (XG.ImageUtils.loadTextureCube = function (e, t, a) {
    var r = [];
    r.loadCount = 0;
    var i = new XG.Texture();
    (i.image = r), (i.flipY = !1);
    for (var o = 0, n = e.length; n > o; ++o) {
      var s = new Image();
      (r[o] = s),
        (s.onload = function () {
          (r.loadCount += 1),
            6 === r.loadCount &&
            ((i.needsUpdate = !0), (i.mipmapCount = 0), t && t(i));
        }),
        (s.onerror = a),
        (s.crossOrigin = this.crossOrigin),
        (s.src = e[o]);
    }
    return i;
  }),
  (XG.ImageUtils.loadCompressedTextureCube = function (e, t, a) {
    var r = [];
    r.loadCount = 0;
    var i = new XG.CompressedTexture();
    (i.image = r), (i.flipY = !1), (i.generateMipmaps = !1);
    var o = function (e, a) {
      return function () {
        var o = e.response,
          n = !0,
          s = 0,
          l = XG.ImageUtils.parseDDS(o, n, s);
        (a.format = l.format),
          (a.type = l.type),
          (a.mipmaps = l.mipmaps),
          (a.width = l.width),
          (a.height = l.height),
          (r.loadCount += 1),
          6 === r.loadCount &&
          ((i.format = l.format),
            (i.type = l.type),
            (i.mipmapCount = l.mipmapCount),
            (i.needsUpdate = !0),
            t && t(i));
      };
    };
    if (e instanceof Array)
      for (var n = 0, s = e.length; s > n; ++n) {
        var l = {};
        r[n] = l;
        var h = new XMLHttpRequest();
        (h.onload = o(h, l)), (h.onerror = a);
        var d = e[n];
        h.open("GET", d, !0), (h.responseType = "arraybuffer"), h.send(null);
      }
    else {
      var d = e,
        h = new XMLHttpRequest();
      (h.onload = function () {
        var e = h.response,
          a = !0,
          o = 0,
          n = XG.ImageUtils.parseDDS(e, a, o);
        if (n.isCubemap) {
          for (var s = n.mipmaps.length / n.mipmapCount, l = 0; s > l; l++) {
            r[l] = { mipmaps: [] };
            for (var d = 0; d < n.mipmapCount; d++)
              r[l].mipmaps.push(n.mipmaps[l * n.mipmapCount + d]),
                (r[l].format = n.format),
                (r[l].type = n.type),
                (r[l].width = n.width),
                (r[l].height = n.height);
          }
          (i.format = n.format),
            (i.type = n.type),
            (i.mipmapCount = n.mipmapCount),
            (i.needsUpdate = !0),
            t && t(i);
        }
      }),
        (h.onerror = a),
        h.open("GET", d, !0),
        (h.responseType = "arraybuffer"),
        h.send(null);
    }
    return i;
  }),
  (XG.ImageUtils.loadCRNTextureCube = function (e, t, a) {
    var r = [];
    r.loadCount = 0;
    var i = new XG.CompressedTexture();
    (i.image = r), (i.flipY = !1), (i.generateMipmaps = !1);
    var o = function (e, a) {
      return function () {
        var o = e.response,
          n = !0,
          s = 0,
          l = XG.ImageUtils.parseCRN(o, n, s);
        (a.format = l.format),
          (a.type = l.type),
          (a.mipmaps = l.mipmaps),
          (a.width = l.width),
          (a.height = l.height),
          (r.loadCount += 1),
          6 === r.loadCount &&
          ((i.format = l.format),
            (i.type = l.type),
            (i.mipmapCount = l.mipmapCount),
            (i.needsUpdate = !0),
            t && t(i));
      };
    };
    if (e instanceof Array)
      for (var n = 0, s = e.length; s > n; ++n) {
        var l = {};
        r[n] = l;
        var h = new XMLHttpRequest();
        (h.onload = o(h, l)), (h.onerror = a);
        var d = e[n];
        h.open("GET", d, !0), (h.responseType = "arraybuffer"), h.send(null);
      }
    else console.warn("Loading cubemap from cube CRN file not implemented!");
    return i;
  }),
  (XG.ImageUtils.textureLevelSize = function (e, t, a) {
    switch (e) {
      case XG.RGB_S3TC_DXT1_Format:
      case XG.RGB_ATC_Format:
      case XG.RGB_ETC1_Format:
        return ((t + 3) >> 2) * ((a + 3) >> 2) * 8;
      case XG.RGBA_S3TC_DXT3_Format:
      case XG.RGBA_S3TC_DXT5_Format:
      case XG.RGBA_ATC_EXPLICIT_ALPHA_Format:
      case XG.RGBA_ATC_INTERPOLATED_ALPHA_Format:
        return ((t + 3) >> 2) * ((a + 3) >> 2) * 16;
      case XG.RGB_PVRTC_4BPPV1_Format:
      case XG.RGBA_PVRTC_4BPPV1_Format:
        return Math.floor((Math.max(t, 8) * Math.max(a, 8) * 4 + 7) / 8);
      case XG.RGB_PVRTC_2BPPV1_Format:
      case XG.RGBA_PVRTC_2BPPV1_Format:
        return Math.floor((Math.max(t, 16) * Math.max(a, 8) * 2 + 7) / 8);
      default:
        return 0;
    }
  }),
  (XG.ImageUtils.parsePVR = function (e, t, a) {
    void 0 === a && (a = 0);
    var r = {
      mipmaps: [],
      width: 0,
      height: 0,
      format: null,
      type: XG.UnsignedByteType,
      mipmapCount: 1,
    },
      i = 0,
      o = 1,
      n = 2,
      s = 3,
      l = 6,
      h = 7,
      d = 9,
      c = 5,
      u = 13,
      f = 55727696,
      p = 0,
      m = 2,
      v = 6,
      g = 7,
      S = 11,
      x = 12,
      G = new Int32Array(e, 0, u);
    G[p] !== f &&
      console.error(
        "ImageUtils.parsePVR(): Invalid magic number in PVR header"
      );
    var M,
      y = G[m];
    switch (y) {
      case i:
        M = XG.RGB_PVRTC_2BPPV1_Format;
        break;
      case o:
        M = XG.RGBA_PVRTC_2BPPV1_Format;
        break;
      case n:
        M = XG.RGB_PVRTC_4BPPV1_Format;
        break;
      case s:
        M = XG.RGBA_PVRTC_4BPPV1_Format;
        break;
      case l:
        M = XG.RGB_ETC1_Format;
        break;
      case h:
        M = XG.RGB_S3TC_DXT1_Format;
        break;
      case d:
        M = XG.RGBA_S3TC_DXT3_Format;
        break;
      case c:
        M = XG.RGBA_S3TC_DXT5_Format;
        break;
      default:
        console.error("Unsupported PVR format: " + y);
    }
    r.format = M;
    for (
      var w = G[g],
      _ = G[v],
      X = G[S],
      D = G[x] + 52,
      T = new Uint8Array(e, D),
      C = 0,
      A = 4,
      P = 0;
      X > P;
      ++P
    ) {
      var L = XG.ImageUtils.textureLevelSize(M, w, _),
        b = new Uint8Array(T.buffer, T.byteOffset + C, L),
        E = { data: b, width: w, height: _, unpackAlignment: A };
      r.mipmaps.push(E), (w >>= 1), (_ >>= 1), (C += L);
    }
    return r;
  }),
  (XG.ImageUtils.parseDDS = function (e, t, a) {
    function r(e) {
      return (
        e.charCodeAt(0) +
        (e.charCodeAt(1) << 8) +
        (e.charCodeAt(2) << 16) +
        (e.charCodeAt(3) << 24)
      );
    }
    function i(e) {
      return String.fromCharCode(
        255 & e,
        (e >> 8) & 255,
        (e >> 16) & 255,
        (e >> 24) & 255
      );
    }
    void 0 === a && (a = 0);
    var o = {
      mipmaps: [],
      width: 0,
      height: 0,
      format: null,
      type: null,
      mipmapCount: 1,
    },
      n = 542327876,
      s = 131072,
      l = 512,
      h = 4,
      d = 64,
      c = 64,
      u = 65,
      f = XG.ImageUtils.halfFloatType,
      p = r("DXT1"),
      m = r("DXT3"),
      v = r("DXT5"),
      g = r("DX10"),
      S = 116,
      x = 113,
      G = 3,
      M = 2,
      y = 10,
      w = 16,
      _ = 34,
      X = 41,
      D = 54,
      T = 31,
      C = 0,
      A = 1,
      P = 2,
      L = 3,
      b = 4,
      E = 7,
      F = 20,
      R = 21,
      U = 28,
      I = new Uint32Array(e, a, T);
    if (I[C] !== n)
      return (
        console.error(
          "ImageUtils.parseDDS(): Invalid magic number in DDS header"
        ),
        o
      );
    if (!I[F] & h)
      return (
        console.error(
          "ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"
        ),
        o
      );
    var N = !0,
      B = 0,
      O = I[R];
    switch (O) {
      case p:
        (B = 8),
          (o.format = XG.RGB_S3TC_DXT1_Format),
          (o.type = XG.UnsignedByteType);
        break;
      case m:
        (B = 16),
          (o.format = XG.RGBA_S3TC_DXT3_Format),
          (o.type = XG.UnsignedByteType);
        break;
      case v:
        (B = 16),
          (o.format = XG.RGBA_S3TC_DXT5_Format),
          (o.type = XG.UnsignedByteType);
        break;
      case S:
        (o.format = XG.RGBAFormat), (o.type = XG.FloatType), (N = !1);
        break;
      case x:
        (o.format = XG.RGBAFormat), (o.type = f), (N = !1);
        break;
      case g:
        {
          var V = a + 128,
            k = new Uint32Array(e, V, 5),
            z = k[0],
            H = k[1];
          k[2], k[3], k[4];
        }
        if (H === G && z === M)
          (o.format = XG.RGBAFormat), (o.type = XG.FloatType), (N = !1);
        else if (H === G && z === w)
          (o.format = XG.LuminanceAlphaFormat),
            (o.type = XG.FloatType),
            (N = !1);
        else if (H === G && z === X)
          (o.format = XG.LuminanceFormat), (o.type = XG.FloatType), (N = !1);
        else if (H === G && z === y)
          (o.format = XG.RGBAFormat), (o.type = f), (N = !1);
        else if (H === G && z === _)
          (o.format = XG.LuminanceAlphaFormat), (o.type = f), (N = !1);
        else {
          if (H !== G || z !== D)
            return (
              console.error(
                "ImageUtils.parseDDS(): unsupported DX10 texture format " + z
              ),
              o
            );
          (o.format = XG.LuminanceFormat), (o.type = f), (N = !1);
        }
        break;
      default:
        if (!(I[F] & d))
          return (
            console.error(
              "ImageUtils.parseDDS(): Unsupported FourCC code: ",
              O,
              i(O)
            ),
            o
          );
        if (I[20] === u)
          (o.format = XG.RGBAFormat), (o.type = XG.UnsignedByteType), (N = !1);
        else {
          if (I[20] !== c)
            return (
              console.error(
                "ImageUtils.parseDDS(): Unsupported uncompressed format"
              ),
              o
            );
          (o.format = XG.RGBFormat), (o.type = XG.UnsignedByteType), (N = !1);
        }
    }
    (o.isCubemap = I[U] & l ? !0 : !1), (o.width = I[b]), (o.height = I[L]);
    var W = 1,
      j = 1;
    if (I[P] & s && t !== !1) {
      var q = Math.max(o.width, o.height);
      (W = Math.log(q) / Math.log(2) + 1),
        (j = Math.max(1, I[E])),
        (o.mipmapCount = j),
        W > j &&
        console.warn(
          "ImageUtils.parseDDS(): requiredMipLevels:",
          W,
          "imgMipLevels:",
          j
        );
    }
    var Y = a + I[A] + 4;
    O === g && (Y += 20);
    for (
      var K,
      Z,
      Q,
      J,
      $ = o.width,
      ee = o.height,
      te = o.isCubemap ? 6 : 1,
      ae = 0;
      te > ae;
      ae++
    ) {
      for (var re = 0; re < o.mipmapCount; re++) {
        var ie = 4;
        if (o.type === XG.UnsignedByteType) {
          if (
            ((Z = N
              ? (((Math.max(4, $) / 4) * Math.max(4, ee)) / 4) * B
              : $ * ee * 4),
              (Q = new Uint8Array(e, Y, Z)),
              N)
          )
            J = Q;
          else if (o.format === XG.RGBAFormat) {
            J = Q;
            for (var oe = 0; Z > oe; oe += 4) {
              var ne = J[oe];
              (J[oe] = J[oe + 2]), (J[oe + 2] = ne);
            }
          } else if (o.format === XG.RGBFormat) {
            (J = new Uint8Array($ * ee * 3)), J.length % 16 !== 0 && (ie = 1);
            for (var se = 0, oe = 0; Z > oe; oe += 4) {
              var le = Q[oe],
                he = Q[oe + 1],
                de = Q[oe + 2];
              (J[se++] = de), (J[se++] = he), (J[se++] = le);
            }
          }
        } else
          o.type === XG.FloatType
            ? (o.format === XG.RGBAFormat
              ? ((Z = $ * ee * 16), (K = $ * ee * 4))
              : o.format === XG.LuminanceAlphaFormat
                ? ((Z = $ * ee * 8), (K = $ * ee * 2))
                : o.format === XG.LuminanceFormat
                  ? ((Z = $ * ee * 4), (K = $ * ee * 1))
                  : console.error(
                    "ImageUtils.parseDDS(): unsupported DX10 texture format " +
                    z +
                    " for float texture"
                  ),
              (J = new Float32Array(e, Y, K)))
            : o.type === f &&
            (o.format === XG.RGBAFormat
              ? ((Z = $ * ee * 8), (K = $ * ee * 4))
              : o.format === XG.LuminanceAlphaFormat
                ? ((Z = $ * ee * 4), (K = $ * ee * 2))
                : o.format === XG.LuminanceFormat
                  ? ((Z = $ * ee * 2), (K = $ * ee * 1))
                  : console.error(
                    "ImageUtils.parseDDS(): unsupported DX10 texture format " +
                    z +
                    " for half-float texture"
                  ),
              (J = new Uint16Array(e, Y, K)));
        var ce = { data: J, width: $, height: ee, unpackAlignment: ie };
        o.mipmaps.push(ce),
          (Y += Z),
          ($ = Math.max(0.5 * $, 1)),
          (ee = Math.max(0.5 * ee, 1));
      }
      ($ = o.width), (ee = o.height);
    }
    return o;
  }),
  (XG.ImageUtils.parseCRN = function (e, t, a, r) {
    void 0 === a && (a = 0), void 0 === r && (r = e.byteLength);
    var i = {
      mipmaps: [],
      width: 0,
      height: 0,
      format: null,
      type: XG.UnsignedByteType,
      mipmapCount: 1,
    },
      o = 0,
      n = 1,
      s = 2,
      l = function (e, t, a) {
        t.set(e, a);
      },
      h = new Uint8Array(e, a, r),
      d = r,
      c = Module._malloc(d);
    l(h, Module.HEAPU8, c, d);
    var u,
      f = Module._crn_get_dxt_format(c, d);
    switch (f) {
      case o:
        u = XG.RGB_S3TC_DXT1_Format;
        break;
      case n:
        u = XG.RGBA_S3TC_DXT3_Format;
        break;
      case s:
        u = XG.RGBA_S3TC_DXT5_Format;
        break;
      default:
        return (
          console.error("ImageUtils.parseCRN(): Unsupported image format"), 0
        );
    }
    var p = Module._crn_get_width(c, d),
      m = Module._crn_get_height(c, d),
      v = Module._crn_get_levels(c, d);
    (i.format = u), (i.width = p), (i.height = m), (i.mipmapCount = v);
    for (
      var g = 4,
      S = Module._crn_get_uncompressed_size(c, d, 0),
      x = Module._malloc(S),
      G = 0;
      v > G;
      ++G
    ) {
      G && (S = Module._crn_get_uncompressed_size(c, d, G)),
        Module._crn_decompress(c, d, x, S, G);
      var M = Module.HEAPU8.buffer.slice(x, x + S),
        y = new Uint8Array(M),
        w = { data: y, width: p, height: m, unpackAlignment: g };
      i.mipmaps.push(w), (p = Math.max(0.5 * p, 1)), (m = Math.max(0.5 * m, 1));
    }
    return Module._free(c), Module._free(x), i;
  }),
  (XG.ImageUtils.getNormalMap = function (e, t) {
    var a = function (e, t) {
      return [
        e[1] * t[2] - e[2] * t[1],
        e[2] * t[0] - e[0] * t[2],
        e[0] * t[1] - e[1] * t[0],
      ];
    },
      r = function (e, t) {
        return [e[0] - t[0], e[1] - t[1], e[2] - t[2]];
      },
      i = function (e) {
        var t = Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
        return [e[0] / t, e[1] / t, e[2] / t];
      };
    t = 1 | t;
    var o = e.width,
      n = e.height,
      s = document.createElement("canvas");
    (s.width = o), (s.height = n);
    var l = s.getContext("2d");
    l.drawImage(e, 0, 0);
    for (
      var h = l.getImageData(0, 0, o, n).data,
      d = l.createImageData(o, n),
      c = d.data,
      u = 0;
      o > u;
      u++
    )
      for (var f = 0; n > f; f++) {
        var p = 0 > f - 1 ? 0 : f - 1,
          m = f + 1 > n - 1 ? n - 1 : f + 1,
          v = 0 > u - 1 ? 0 : u - 1,
          g = u + 1 > o - 1 ? o - 1 : u + 1,
          S = [],
          x = [0, 0, (h[4 * (f * o + u)] / 255) * t];
        S.push([-1, 0, (h[4 * (f * o + v)] / 255) * t]),
          S.push([-1, -1, (h[4 * (p * o + v)] / 255) * t]),
          S.push([0, -1, (h[4 * (p * o + u)] / 255) * t]),
          S.push([1, -1, (h[4 * (p * o + g)] / 255) * t]),
          S.push([1, 0, (h[4 * (f * o + g)] / 255) * t]),
          S.push([1, 1, (h[4 * (m * o + g)] / 255) * t]),
          S.push([0, 1, (h[4 * (m * o + u)] / 255) * t]),
          S.push([-1, 1, (h[4 * (m * o + v)] / 255) * t]);
        for (var G = [], M = S.length, y = 0; M > y; y++) {
          var w = S[y],
            _ = S[(y + 1) % M];
          (w = r(w, x)), (_ = r(_, x)), G.push(i(a(w, _)));
        }
        for (var X = [0, 0, 0], y = 0; y < G.length; y++)
          (X[0] += G[y][0]), (X[1] += G[y][1]), (X[2] += G[y][2]);
        (X[0] /= G.length), (X[1] /= G.length), (X[2] /= G.length);
        var D = 4 * (f * o + u);
        (c[D] = (((X[0] + 1) / 2) * 255) | 0),
          (c[D + 1] = (((X[1] + 1) / 2) * 255) | 0),
          (c[D + 2] = (255 * X[2]) | 0),
          (c[D + 3] = 255);
      }
    return l.putImageData(d, 0, 0), s;
  }),
  (XG.ImageUtils.generateDataTexture = function (e, t, a) {
    for (
      var r = e * t,
      i = new Uint8Array(3 * r),
      o = Math.floor(255 * a.r),
      n = Math.floor(255 * a.g),
      s = Math.floor(255 * a.b),
      l = 0;
      r > l;
      l++
    )
      (i[3 * l] = o), (i[3 * l + 1] = n), (i[3 * l + 2] = s);
    var h = new XG.DataTexture(i, e, t, XG.RGBFormat);
    return (h.needsUpdate = !0), h;
  }),
  (XG.ImageUtils.generateNoiseTexture = function (e, t) {
    for (var a = e * t, r = new Uint8Array(3 * a), i = 0; a > i; i++)
      (r[3 * i] = Math.floor(255 * Math.random())),
        (r[3 * i + 1] = Math.floor(255 * Math.random())),
        (r[3 * i + 2] = Math.floor(255 * Math.random()));
    var o = new XG.DataTexture(r, e, t, XG.RGBFormat);
    return (o.needsUpdate = !0), o;
  }),
  (XG.ImageUtils.generateDummyCompressedTexture = function (e) {
    var t = [
      542327876,
      124,
      659463,
      4,
      4,
      8,
      0,
      3,
      1347242311,
      1396982829,
      131585,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      32,
      4,
      827611204,
      24,
      16711680,
      65280,
      255,
      0,
      4198408,
      0,
      0,
      0,
      0,
      38066,
      2863311530,
      38066,
      2863311530,
      38066,
      2863311530,
    ],
      a = new Uint32Array(t),
      r = !0,
      i = 0,
      o = XG.ImageUtils.parseDDS(a.buffer, r, i);
    (e.format = o.format),
      (e.type = o.type),
      (e.mipmaps = o.mipmaps),
      (e.image.width = o.width),
      (e.image.height = o.height),
      (e.generateMipmaps = !1),
      (e.needsUpdate = !0);
  }),
  (XG.ImageUtils.generateMipTexture = function (e, t) {
    function a(e, t, a) {
      for (var r = e * t, i = new Uint8Array(r), o = 16 * a, n = 0; r > n; n++)
        i[n] = o;
      var s = { width: e, height: t, data: i };
      return s;
    }
    (XG.Math.isPowerOfTwo(e) && XG.Math.isPowerOfTwo(t)) ||
      console.error(
        "XG.ImageUtils.generateMipTexture: dimensions [",
        e,
        "x",
        t,
        "] are not power of two."
      );
    for (
      var r = Math.log(Math.max(e, t)) / Math.LN2, i = e, o = t, n = [], s = 0;
      r >= s;
      s++
    )
      (n[s] = a(i, o, s)),
        (i = Math.max(Math.ceil(0.5 * i), 1)),
        (o = Math.max(Math.ceil(0.5 * o), 1));
    var l = n[0],
      h = new XG.DataTexture(l.data, e, t, XG.LuminanceFormat);
    return (h.mipmaps = n), (h.unpackAlignment = 1), (h.needsUpdate = !0), h;
  }),
  (XG.ImageUtils.convertHalfFloatToFloatMipChain = function (e) {
    for (var t = XG.Math.convertHalfToFloat, a = 0, r = e.length; r > a; a++) {
      for (
        var i = e[a], o = i.data, n = o.length, s = new Float32Array(n), l = 0;
        n > l;
        l++
      ) {
        var h = o[l];
        s[l] = t(h);
      }
      i.data = s;
    }
  }),
  (XG.ImageUtils.convertHalfFloatToFloatTexture = function (e) {
    if (e.type !== XG.ImageUtils.halfFloatType)
      return void console.warn(
        "XG.ImageUtils.convertHalfFloatToFloatTexture: source texture not using half-floats"
      );
    var t = XG.ImageUtils.convertHalfFloatToFloatMipChain;
    if (e.image instanceof Array)
      for (var a = e.image, r = 0, i = a.length; i > r; r++) {
        var o = a[r];
        t(o.mipmaps), (o.type = XG.FloatType);
      }
    else t(e.image.mipmaps);
    e.type = XG.FloatType;
  }),
  (XG.UniformsUtils = {
    merge: function (e) {
      var t,
        a,
        r,
        i = {};
      for (t = 0; t < e.length; t++) {
        r = this.clone(e[t]);
        for (a in r) i[a] = r[a];
      }
      return i;
    },
    clone: function (e) {
      var t,
        a,
        r,
        i = {};
      for (t in e) {
        i[t] = {};
        for (a in e[t])
          (r = e[t][a]),
            (i[t][a] =
              r instanceof XG.Color ||
                r instanceof XG.Vector2 ||
                r instanceof XG.Vector3 ||
                r instanceof XG.Vector4 ||
                r instanceof XG.Quaternion ||
                r instanceof XG.Matrix3 ||
                r instanceof XG.Matrix4 ||
                r instanceof XG.Texture
                ? r.clone()
                : r instanceof Array
                  ? r.slice()
                  : r);
      }
      return i;
    },
    cloneDefines: function (e) {
      var t,
        a = {};
      for (t in e) a[t] = e[t];
      return a;
    },
  }),
  (XG.AtmosphericFog = function (e, t, a) {
    (this.name = ""),
      (this.color = new XG.Color(e)),
      (this.start = void 0 !== t ? t : 100),
      (this.strength = void 0 !== a ? a : 0.1);
  }),
  (XG.AtmosphericFog.prototype.clone = function () {
    return new XG.AtmosphericFog(
      this.color.getHex(),
      this.start,
      this.strength
    );
  }),
  (XG.LinearFog = function (e, t, a) {
    (this.name = ""),
      (this.color = new XG.Color(e)),
      (this.near = void 0 !== t ? t : 1),
      (this.far = void 0 !== a ? a : 1e3);
  }),
  (XG.LinearFog.prototype.clone = function () {
    return new XG.LinearFog(this.color.getHex(), this.near, this.far);
  }),
  (XG.ExponentialFog = function (e, t) {
    (this.name = ""),
      (this.color = new XG.Color(e)),
      (this.density = void 0 !== t ? t : 25e-5);
  }),
  (XG.ExponentialFog.prototype.clone = function () {
    return new XG.ExponentialFog(this.color.getHex(), this.density);
  }),
  (XG.HeightFog = function (e) {
    (e = e || {}),
      (this.name = ""),
      (this.height = void 0 !== e.height ? e.height : -15),
      (this.visibilityDistance =
        void 0 !== e.visibilityDistance ? e.visibilityDistance : 50),
      (this.fadeSpeed = void 0 !== e.fadeSpeed ? e.fadeSpeed : 0.15),
      (this.shallowDepthColor =
        void 0 !== e.shallowDepthColor
          ? e.shallowDepthColor
          : new XG.Color().setRGB(0.0078, 0.5176, 0.7)),
      (this.deepDepthColor =
        void 0 !== e.deepDepthColor
          ? e.deepDepthColor
          : new XG.Color().setRGB(0.0039, 0.00196, 0.145)),
      (this.rgbExtinctionDistance =
        void 0 !== e.rgbExtinctionDistance
          ? e.rgbExtinctionDistance
          : new XG.Vector3(7, 30, 40));
  }),
  (XG.HeightFog.prototype.clone = function () {
    var e = new XG.HeightFog();
    return (
      (e.height = this.height),
      (e.visibilityDistance = this.visibilityDistance),
      (e.fadeSpeed = this.fadeSpeed),
      e.shallowDepthColor.copy(this.shallowDepthColor),
      e.deepDepthColor.copy(this.deepDepthColor),
      e.rgbExtinctionDistance.copy(this.rgbExtinctionDistance),
      e
    );
  }),
  (XG.LightProbe = function (e, t, a, r, i) {
    this.bounces = 0;
    var o,
      n = void 0 !== a ? a : XG.FloatType,
      s = void 0 !== r ? r : XG.RGBAFormat;
    i
      ? n === XG.FloatType && s === XG.RGBAFormat
        ? (o = XG.RGBA32F)
        : n === XG.FloatType && s === XG.RGBFormat
          ? (o = XG.RGB32F)
          : n === XG.HalfFloatType2 && s === XG.RGBAFormat
            ? (o = XG.RGBA16F)
            : n === XG.HalfFloatType2 && s === XG.RGBFormat
              ? (o = XG.RGB16F)
              : n === XG.UnsignedByteType && (o = s)
      : (o = s);
    var l = {
      format: s,
      internalFormat: o,
      type: n,
      magFilter: XG.LinearFilter,
      minFilter: XG.LinearMipMapLinearFilter,
      stencilBuffer: !1,
    },
      h = {
        format: s,
        internalFormat: o,
        type: n,
        magFilter: XG.LinearFilter,
        minFilter: XG.LinearFilter,
        stencilBuffer: !1,
      };
    (this.specularCube = new XG.RenderTargetCube(e, e, l)),
      (this.diffuseCube = new XG.RenderTargetCube(t, t, h));
    var d = XG.IBLDiffuseProbeShader,
      c = XG.UniformsUtils.clone(d.uniforms);
    c.tCube.value = this.diffuseCube;
    var u = new XG.ShaderMaterial({
      vertexShader: d.vertexShader,
      fragmentShader: d.fragmentShader,
      uniforms: c,
      transparent: !0,
    }),
      f = XG.IBLDiffuseConvolutionShader,
      p = XG.UniformsUtils.clone(f.uniforms);
    (p.tCube.value = this.specularCube),
      (this.diffuseConvolutionMaterial = new XG.ShaderMaterial({
        vertexShader: f.vertexShader,
        fragmentShader: f.fragmentShader,
        uniforms: p,
        side: XG.BackSide,
        transparent: !0,
      }));
    var m = XG.LightProbe.sphereGeometry;
    XG.Mesh.call(this, m, u), (this.renderDepth = 1);
  }),
  (XG.LightProbe.prototype = Object.create(XG.Mesh.prototype)),
  (XG.LightProbe.sphereGeometry = new XG.SphereGeometry(1, 32, 16)),
  (XG.LightProbesManager = function (e, t, a) {
    (this.renderer = e),
      (this.scene = t),
      (this.dynamicObjects = a),
      (this.defaultSpecularSize = 128),
      (this.defaultDiffuseSize = 16),
      (this.defaultProbeTextureType = XG.FloatType),
      (this.probesList = []),
      (this.convolutionScene = new XG.Scene()),
      (this.sceneCamera = new XG.CubeCamera(1, 1e3)),
      (this.convolutionCamera = new XG.CubeCamera(1, 1e3)),
      this.scene.add(this.sceneCamera),
      this.convolutionScene.add(this.convolutionCamera);
    var r = new XG.SphereGeometry(2, 8, 4);
    (this.convolutionMesh = new XG.Mesh(r, null)),
      this.convolutionScene.add(this.convolutionMesh),
      (this.maxBounces = 1),
      (this.maxProbesPerFrame = 1),
      (this.isES3 = "webgl2" === e.getRenderingBackend());
  }),
  (XG.LightProbesManager.prototype.createProbe = function (e, t) {
    void 0 === e && (e = this.defaultSpecularSize),
      void 0 === t && (t = this.defaultDiffuseSize);
    var a = this.renderer.renderer ? this.renderer.renderer : this.renderer,
      r = a.supportsRGBFloatRenderTarget() ? XG.RGBFormat : XG.RGBAFormat,
      i = this.defaultProbeTextureType,
      o = new XG.LightProbe(e, t, i, r, this.isES3);
    return this.probesList.push(o), this.dynamicObjects.push(o), o;
  }),
  (XG.LightProbesManager.prototype.update = function () {
    var e,
      t,
      a,
      r = this.dynamicObjects;
    for (e = 0, t = r.length; t > e; e++)
      (a = r[e]), (a.properties.oldVisible = a.visible), (a.visible = !1);
    var i = this.renderer,
      o = this.probesList,
      n = 0;
    for (e = 0, t = o.length; t > e; e++) {
      var s = o[e];
      if (!(s.bounces >= this.maxBounces)) {
        var l = s.specularCube,
          h = s.diffuseCube;
        if (
          (this.sceneCamera.position.copy(s.position),
            (this.convolutionMesh.materials[0] = s.diffuseConvolutionMaterial),
            i.renderCube(this.scene, this.sceneCamera, l),
            i.renderCube(this.convolutionScene, this.convolutionCamera, h),
            (s.bounces += 1),
            (n += 1),
            n >= this.maxProbesPerFrame)
        )
          break;
      }
    }
    for (e = 0, t = r.length; t > e; e++)
      (a = r[e]), (a.visible = a.properties.oldVisible);
  }),
  (XG.LightProbesManager.prototype.refreshProbes = function () {
    for (var e = this.probesList, t = 0, a = e.length; a > t; t++) {
      var r = e[t];
      r.bounces = 0;
    }
  }),
  (XG.Material = function () {
    (this.id = XG.MaterialIdCount++),
      (this.name = ""),
      (this.side = XG.FrontSide),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blending = XG.NormalBlending),
      (this.blendSrcColor = XG.SrcAlphaFactor),
      (this.blendDstColor = XG.OneMinusSrcAlphaFactor),
      (this.blendSrcAlpha = XG.OneFactor),
      (this.blendDstAlpha = XG.OneMinusSrcAlphaFactor),
      (this.blendEquation = XG.AddEquation),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.alphaTest = 0),
      (this.particle = !1),
      (this.particleSize = 1),
      (this.instances = !1),
      (this.visible = !0),
      (this.enabled = !0),
      (this.needsUpdate = !0);
  }),
  (XG.Material.prototype.setValues = function (e) {
    if (void 0 !== e)
      for (var t in e) {
        var a = e[t];
        if (void 0 !== a) {
          if (t in this) {
            var r = this[t];
            r instanceof XG.Color && a instanceof XG.Color
              ? r.copy(a)
              : r instanceof XG.Color
                ? r.set(a)
                : r instanceof XG.Vector2 && a instanceof XG.Vector2
                  ? r.copy(a)
                  : r instanceof XG.Vector3 && a instanceof XG.Vector3
                    ? r.copy(a)
                    : (this[t] = a);
          }
        } else console.warn("XG.Material: '" + t + "' parameter is undefined.");
      }
  }),
  (XG.Material.prototype.clone = function (e) {
    return (
      void 0 === e && (e = new XG.Material()),
      (e.name = this.name),
      (e.side = this.side),
      (e.opacity = this.opacity),
      (e.transparent = this.transparent),
      (e.blending = this.blending),
      (e.blendSrcColor = this.blendSrcColor),
      (e.blendDstColor = this.blendDstColor),
      (e.blendSrcAlpha = this.blendSrcAlpha),
      (e.blendDstAlpha = this.blendDstAlpha),
      (e.blendEquation = this.blendEquation),
      (e.depthTest = this.depthTest),
      (e.depthWrite = this.depthWrite),
      (e.polygonOffset = this.polygonOffset),
      (e.polygonOffsetFactor = this.polygonOffsetFactor),
      (e.polygonOffsetUnits = this.polygonOffsetUnits),
      (e.alphaTest = this.alphaTest),
      (e.particle = this.particle),
      (e.particleSize = this.particleSize),
      (e.instances = this.instances),
      (e.visible = this.visible),
      e
    );
  }),
  (XG.MaterialIdCount = 0),
  (XG.EmissiveMaterial = function (e) {
    XG.Material.call(this),
      (this.color = new XG.Color(16777215)),
      (this.intensity = 1),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapGamma = !1),
      (this.displacementMap = null),
      (this.displacementDirection = XG.DisplaceByNormal),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.displacementNormalScale = 1),
      (this.fog = !0),
      (this.vertexColors = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.particleSize = 1),
      (this.particleSizeAttenuation = !0),
      this.setValues(e);
  }),
  (XG.EmissiveMaterial.prototype = Object.create(XG.Material.prototype)),
  (XG.EmissiveMaterial.prototype.clone = function () {
    var e = new XG.EmissiveMaterial();
    return (
      XG.Material.prototype.clone.call(this, e),
      e.color.copy(this.color),
      (e.intensity = this.intensity),
      (e.map = this.map),
      (e.lightMap = this.lightMap),
      (e.lightMapGamma = this.lightMapGamma),
      (e.displacementMap = this.displacementMap),
      (e.displacementScale = this.displacementScale),
      (e.displacementBias = this.displacementBias),
      (e.displacementNormalScale = this.displacementNormalScale),
      (e.fog = this.fog),
      (e.vertexColors = this.vertexColors),
      (e.skinning = this.skinning),
      (e.morphTargets = this.morphTargets),
      (e.particleSize = this.particleSize),
      (e.particleSizeAttenuation = this.particleSizeAttenuation),
      e
    );
  }),
  (XG.PhongMaterial = function (e) {
    XG.Material.call(this),
      (this.color = new XG.Color(16777215)),
      (this.specular = new XG.Color(1118481)),
      (this.shininess = 30),
      (this.metal = !1),
      (this.parallax = !1),
      (this.parallaxScale = 1),
      (this.parallaxRefineSteps = 3),
      (this.wrapAround = !1),
      (this.wrapAroundSkin = !1),
      (this.wrapRGB = new XG.Vector3(1, 1, 1)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapGamma = !1),
      (this.lightMapSecondaryUV = !1),
      (this.displacementMap = null),
      (this.displacementDirection = XG.DisplaceByNormal),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.displacementNormalScale = 1),
      (this.glossMap = null),
      (this.specularMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalGlossMap = null),
      (this.normalScale = new XG.Vector2(1, 1)),
      (this.bumpDetailMap = null),
      (this.normalDetailMap = null),
      (this.detailScale = 1),
      (this.detailRepeat = new XG.Vector2(1, 1)),
      (this.fog = !0),
      (this.vertexColors = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      (this.lights = !0),
      (this.forceShadow = !1),
      (this.wireframe = !1),
      (this.wireframeDiffuse = new XG.Color(0)),
      (this.wireframeSpecular = new XG.Color(0)),
      (this.wireframeShininess = 0),
      (this.wireframeThickness = 1.5),
      this.setValues(e);
  }),
  (XG.PhongMaterial.prototype = Object.create(XG.Material.prototype)),
  (XG.PhongMaterial.prototype.clone = function () {
    var e = new XG.PhongMaterial();
    return (
      XG.Material.prototype.clone.call(this, e),
      e.color.copy(this.color),
      e.specular.copy(this.specular),
      (e.shininess = this.shininess),
      (e.metal = this.metal),
      (e.parallax = this.parallax),
      (e.parallaxScale = this.parallaxScale),
      (e.parallaxRefineSteps = this.parallaxRefineSteps),
      (e.wrapAround = this.wrapAround),
      (e.wrapAroundSkin = this.wrapAroundSkin),
      e.wrapRGB.copy(this.wrapRGB),
      (e.map = this.map),
      (e.lightMap = this.lightMap),
      (e.lightMapGamma = this.lightMapGamma),
      (e.lightMapSecondaryUV = this.lightMapSecondaryUV),
      (e.bumpMap = this.bumpMap),
      (e.bumpScale = this.bumpScale),
      (e.displacementMap = this.displacementMap),
      (e.displacementScale = this.displacementScale),
      (e.displacementBias = this.displacementBias),
      (e.displacementNormalScale = this.displacementNormalScale),
      (e.normalMap = this.normalMap),
      (e.normalGlossMap = this.normalGlossMap),
      e.normalScale.copy(this.normalScale),
      (e.bumpDetailMap = this.bumpDetailMap),
      (e.normalDetailMap = this.normalDetailMap),
      (e.detailScale = this.detailScale),
      e.detailRepeat.copy(this.detailRepeat),
      (e.glossMap = this.glossMap),
      (e.specularMap = this.specularMap),
      (e.fog = this.fog),
      (e.vertexColors = this.vertexColors),
      (e.skinning = this.skinning),
      (e.morphTargets = this.morphTargets),
      (e.morphNormals = this.morphNormals),
      (e.lights = this.lights),
      (e.forceShadow = this.forceShadow),
      (e.wireframe = this.wireframe),
      e.wireframeDiffuse.copy(this.wireframeDiffuse),
      e.wireframeSpecular.copy(this.wireframeSpecular),
      (e.wireframeShininess = this.wireframeShininess),
      (e.wireframeThickness = this.wireframeThickness),
      e
    );
  }),
  (XG.DynamicParticleMaterial = function (e) {
    XG.Material.call(this),
      (this.color = new XG.Color(16777215)),
      (this.intensity = 1),
      (this.map = null),
      (this.fog = !0),
      (this.vertexColors = !1),
      (this.particle = !0),
      (this.particleSize = 1),
      (this.particleSizeAttenuation = !0),
      (this.time = 0),
      (this.timeRange = 1),
      (this.timeOffset = 0),
      (this.numFrames = 1),
      (this.frameDuration = 1),
      (this.frameScaleOffset = new XG.Vector4(1, 1, 0, 0)),
      (this.interpolateFrames = !0),
      (this.additiveFactor = 0),
      (this.lights = !1),
      this.setValues(e);
  }),
  (XG.DynamicParticleMaterial.prototype = Object.create(XG.Material.prototype)),
  (XG.DynamicParticleMaterial.prototype.clone = function () {
    var e = new XG.DynamicParticleMaterial();
    return (
      XG.Material.prototype.clone.call(this, e),
      e.color.copy(this.color),
      (e.intensity = this.intensity),
      (e.map = this.map),
      (e.fog = this.fog),
      (e.vertexColors = this.vertexColors),
      (e.particleSize = this.particleSize),
      (e.particleSizeAttenuation = this.particleSizeAttenuation),
      (e.time = this.time),
      (e.timeRange = this.timeRange),
      (e.timeOffset = this.timeOffset),
      (e.numFrames = this.numFrames),
      (e.frameDuration = this.frameDuration),
      e.frameScaleOffset.copy(this.frameScaleOffset),
      (e.interpolateFrames = this.interpolateFrames),
      (e.additiveFactor = this.additiveFactor),
      (e.lights = this.lights),
      e
    );
  }),
  (XG.ShaderMaterial = function (e) {
    XG.Material.call(this),
      (this.fragmentShader = "void main() {}"),
      (this.vertexShader = "void main() {}"),
      (this.uniforms = {}),
      (this.defines = {}),
      (this.extensions = {}),
      (this.attributes = null),
      (this.fog = !1),
      (this.lights = !1),
      (this.vertexColors = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      (this.forceShadow = !1),
      this.setValues(e);
  }),
  (XG.ShaderMaterial.prototype = Object.create(XG.Material.prototype)),
  (XG.ShaderMaterial.prototype.clone = function () {
    var e = new XG.ShaderMaterial();
    return (
      XG.Material.prototype.clone.call(this, e),
      (e.fragmentShader = this.fragmentShader),
      (e.vertexShader = this.vertexShader),
      (e.uniforms = XG.UniformsUtils.clone(this.uniforms)),
      (e.defines = this.defines),
      (e.extensions = this.extensions),
      (e.attributes = this.attributes),
      (e.fog = this.fog),
      (e.lights = this.lights),
      (e.vertexColors = this.vertexColors),
      (e.skinning = this.skinning),
      (e.morphTargets = this.morphTargets),
      (e.morphNormals = this.morphNormals),
      (e.forceShadow = this.forceShadow),
      e
    );
  }),
  (XG.SpriteMaterial = function (e) {
    void 0 === e && (e = {});
    var t = void 0 !== e.billboard ? e.billboard : !0,
      a = void 0 !== e.antialias ? e.antialias : !1,
      r = void 0 !== e.sdf ? e.sdf : !0,
      i = void 0 !== e.fog ? e.fog : !0,
      o = void 0 !== e.alphaTest ? e.alphaTest : a ? 0.01 : 0.5,
      n = void 0 !== e.epsilon ? e.epsilon : 0.1,
      s = void 0 !== e.fogDensity ? e.fogDensity : 0.015,
      l = void 0 !== e.fogColor ? e.fogColor : 0,
      h = void 0 !== e.color ? e.color : 16777215,
      d = XG.SpriteShader,
      c = { BILLBOARD: t, ANTIALIAS: a, SDF: r, FOG: i },
      u = XG.UniformsUtils.clone(d.uniforms);
    (u.map.value = e.textureAtlas),
      (u.alphaTest.value = o),
      (u.epsilon.value = n),
      (u.fogDensity.value = s),
      u.fogColor.value.setHex(l),
      u.baseColor.value.setHex(h),
      a && (e.transparent = !0),
      (e.alphaTest = o),
      (e.vertexShader = d.vertexShader),
      (e.fragmentShader = d.fragmentShader),
      (e.extensions = d.extensions),
      (e.uniforms = u),
      XG.ShaderMaterial.call(this, e),
      (this.defines = c),
      (this.uniforms = u);
  }),
  (XG.SpriteMaterial.prototype = Object.create(XG.ShaderMaterial.prototype)),
  (XG.Texture = function (e, t, a, r, i, o, n, s) {
    (this.id = XG.TextureIdCount++),
      (this.name = ""),
      (this.image = e),
      (this.mipmaps = []),
      (this.mipmapCount = 0),
      (this.wrapS = void 0 !== t ? t : XG.ClampToEdgeWrapping),
      (this.wrapT = void 0 !== a ? a : XG.ClampToEdgeWrapping),
      (this.magFilter = void 0 !== r ? r : XG.LinearFilter),
      (this.minFilter = void 0 !== i ? i : XG.LinearMipMapLinearFilter),
      (this.anisotropy = void 0 !== s ? s : 1),
      (this.format = void 0 !== o ? o : XG.RGBAFormat),
      (this.type = void 0 !== n ? n : XG.UnsignedByteType),
      (this.offset = new XG.Vector2(0, 0)),
      (this.repeat = new XG.Vector2(1, 1)),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.needsUpdate = !1),
      (this.onUpdate = null);
  }),
  (XG.Texture.prototype = {
    constructor: XG.Texture,
    clone: function (e) {
      return (
        void 0 === e && (e = new XG.Texture()),
        (e.image = this.image),
        (e.mipmaps = this.mipmaps.slice(0)),
        (e.wrapS = this.wrapS),
        (e.wrapT = this.wrapT),
        (e.magFilter = this.magFilter),
        (e.minFilter = this.minFilter),
        (e.anisotropy = this.anisotropy),
        (e.format = this.format),
        (e.type = this.type),
        e.offset.copy(this.offset),
        e.repeat.copy(this.repeat),
        (e.generateMipmaps = this.generateMipmaps),
        (e.premultiplyAlpha = this.premultiplyAlpha),
        (e.flipY = this.flipY),
        (e.unpackAlignment = this.unpackAlignment),
        e
      );
    },
    getWidth: function () {
      return "VIDEO" === this.image.tagName
        ? this.image.videoWidth
        : this.image.width;
    },
  }),
  (XG.TextureIdCount = 0),
  (XG.Texture3D = function (e, t, a, r, i, o, n, s, l, h, d, c) {
    XG.Texture.call(this, e, s, l, h, d, i, o, c),
      (this.width = t),
      (this.height = a),
      (this.depth = r),
      (this.wrapR = void 0 !== n ? n : XG.ClampToEdgeWrapping),
      (this.unpackImageHeight = 0);
  }),
  (XG.Texture3D.prototype = Object.create(XG.Texture.prototype)),
  (XG.Texture3D.prototype.clone = function () {
    var e = new XG.Texture3D();
    return (
      XG.Texture.prototype.clone.call(this, e),
      (e.width = this.width),
      (e.height = this.height),
      (e.depth = this.depth),
      (e.wrapR = this.wrapR),
      (e.unpackImageHeight = this.unpackImageHeight),
      e
    );
  }),
  (XG.CompressedTexture = function (e, t, a, r, i, o, n, s, l, h) {
    XG.Texture.call(this, null, o, n, s, l, r, i, h),
      (this.image = { width: t, height: a }),
      (this.mipmaps = e),
      (this.generateMipmaps = !1);
  }),
  (XG.CompressedTexture.prototype = Object.create(XG.Texture.prototype)),
  (XG.CompressedTexture.prototype.clone = function () {
    var e = new XG.CompressedTexture();
    return XG.Texture.prototype.clone.call(this, e), e;
  }),
  (XG.CompressedTexture3D = function (e, t, a, r, i, o, n, s, l, h, d, c) {
    XG.Texture.call(this, null, s, l, h, d, r, o, c),
      (this.width = t),
      (this.height = a),
      (this.depth = i),
      (this.wrapR = void 0 !== n ? n : XG.ClampToEdgeWrapping),
      (this.unpackImageHeight = 0),
      (this.mipmaps = e),
      (this.generateMipmaps = !1);
  }),
  (XG.CompressedTexture3D.prototype = Object.create(XG.Texture.prototype)),
  (XG.CompressedTexture3D.prototype.clone = function () {
    var e = new XG.CompressedTexture3D();
    return (
      XG.Texture.prototype.clone.call(this, e),
      (e.width = this.width),
      (e.height = this.height),
      (e.depth = this.depth),
      (e.wrapR = this.wrapR),
      (e.unpackImageHeight = this.unpackImageHeight),
      e
    );
  }),
  (XG.DataTexture = function (e, t, a, r, i, o, n, s, l, h) {
    XG.Texture.call(this, null, o, n, s, l, r, i, h),
      (this.image = { data: e, width: t, height: a });
  }),
  (XG.DataTexture.prototype = Object.create(XG.Texture.prototype)),
  (XG.DataTexture.prototype.clone = function () {
    var e = new XG.DataTexture();
    return XG.Texture.prototype.clone.call(this, e), e;
  }),
  (XG.DataTexture3D = function (e, t, a, r, i, o, n, s, l, h, d, c) {
    XG.Texture.call(this, null, s, l, h, d, i, o, c),
      (this.image = { data: e }),
      (this.width = t),
      (this.height = a),
      (this.depth = r),
      (this.wrapR = void 0 !== n ? n : XG.ClampToEdgeWrapping),
      (this.unpackImageHeight = 0);
  }),
  (XG.DataTexture3D.prototype = Object.create(XG.Texture.prototype)),
  (XG.DataTexture3D.prototype.clone = function () {
    var e = new XG.DataTexture3D();
    return (
      XG.Texture.prototype.clone.call(this, e),
      (e.width = this.width),
      (e.height = this.height),
      (e.depth = this.depth),
      (e.wrapR = this.wrapR),
      (e.unpackImageHeight = this.unpackImageHeight),
      e
    );
  }),
  (XG.ShaderChunk = {}),
  (XG.UniformsLib = {}),
  (XG.ShaderLib = {}),
  (XG.UniformsLib.common = {
    map: { type: "t", value: null },
    offsetRepeat: { type: "v4", value: new XG.Vector4(0, 0, 1, 1) },
    lightMap: { type: "t", value: null },
    brightness: { type: "f", value: 1 },
    whitePoint: { type: "f", value: 1 },
  }),
  (XG.UniformsLib.displacement = {
    displacementMap: { type: "t", value: null },
    displacementScaleBias: { type: "v2", value: new XG.Vector2(1, 0) },
    displacementNormalScale: { type: "f", value: 1 },
  }),
  (XG.UniformsLib.bump = {
    bumpMap: { type: "t", value: null },
    bumpScale: { type: "f", value: 1 },
    bumpDetailMap: { type: "t", value: null },
  }),
  (XG.UniformsLib.normalmap = {
    normalMap: { type: "t", value: null },
    normalScale: { type: "v2", value: new XG.Vector2(1, 1) },
    normalDetailMap: { type: "t", value: null },
  }),
  (XG.UniformsLib.particle = {
    particleSize: { type: "f", value: 1 },
    screenWidth: { type: "f", value: 1920 },
  }),
  (XG.UniformsLib.fogAtmo = {
    fogColor: { type: "c", value: new XG.Color(0) },
    fogStrength: { type: "f", value: 0.1 },
    fogStart: { type: "f", value: 100 },
  }),
  (XG.ShaderChunk.fogAtmoFragmentPars = [
    "#ifdef FOG_ENABLED",
    "uniform vec3 fogColor;",
    "uniform float fogStrength;",
    "uniform float fogStart;",
    "vec3 addFog( vec3 color, float depth ) {",
    "float fogFactor = depth / ( cameraNearFar.y - cameraNearFar.x );",
    "fogFactor *= smoothstep( 0.0, fogStart, depth );",
    "fogFactor = clamp( fogFactor, 0.0, fogStrength );",
    "return mix( color, fogColor, fogFactor );",
    "}",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.linearDepthFragmentPars = [
    "float linearizeDepth( float depth, vec2 cameraNearFar ) {",
    "return -cameraNearFar.y * cameraNearFar.x / ( depth * ( cameraNearFar.y - cameraNearFar.x ) - cameraNearFar.y );",
    "}",
    "float vectorToDepth( vec3 vec, float n, float f ) {",
    "vec3 absVec = abs( vec );",
    "float localZcomp = max( absVec.x, max( absVec.y, absVec.z ) );",
    "float normZComp = ( f + n ) / ( f - n ) - ( 2.0 * f * n ) / ( localZcomp * ( f - n ) );",
    "return ( normZComp + 1.0 ) * 0.5;",
    "}",
  ].join("\n")),
  (XG.ShaderChunk.color_pars_fragment = [
    "#ifdef USE_COLOR",
    "varying vec3 vColor;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.color_fragment = [
    "#ifdef USE_COLOR",
    "mgl_FragColor.rgb *= vColor;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.color_pars_vertex = [
    "#ifdef USE_COLOR",
    "varying vec3 vColor;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.color_vertex = [
    "#ifdef USE_COLOR",
    "#ifdef GAMMA_INPUT",
    "vColor = color * color;",
    "#else",
    "vColor = color;",
    "#endif",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.map_pars_vertex = [
    "#if !defined( PARTICLE ) && ( defined( USE_MAP ) || defined( USE_LIGHTMAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined ( USE_NORMALGLOSSMAP ) || defined ( USE_GLOSSMAP ) || defined( USE_SPECULARMAP ) || defined( USE_DISPLACEMENTMAP ) )",
    "varying vec2 vUv;",
    "uniform vec4 offsetRepeat;",
    "#endif",
    "#if defined( USE_LIGHTMAP ) && defined( LIGHTMAP_SECONDARY_UV )",
    "varying vec2 vUv2;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.map_pars_fragment = [
    "#if !defined( PARTICLE ) && ( defined( USE_MAP ) || defined( USE_LIGHTMAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP ) || defined ( USE_GLOSSMAP ) || defined( USE_SPECULARMAP ) || defined( USE_DISPLACEMENTMAP ) )",
    "varying vec2 vUv;",
    "#endif",
    "#if defined( USE_LIGHTMAP ) && defined( LIGHTMAP_SECONDARY_UV )",
    "varying vec2 vUv2;",
    "#endif",
    "#ifdef USE_MAP",
    "uniform sampler2D map;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.map_vertex = [
    "#if !defined( PARTICLE ) && ( defined( USE_MAP ) || defined( USE_LIGHTMAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_BUMPDETAILMAP ) || defined( USE_NORMALDETAILMAP ) || defined( USE_NORMALGLOSSMAP ) || defined ( USE_GLOSSMAP ) || defined( USE_SPECULARMAP ) || defined( USE_DISPLACEMENTMAP ) )",
    "vec2 transformedUV = uv * offsetRepeat.zw + offsetRepeat.xy;",
    "vUv = transformedUV;",
    "#endif",
    "#if defined( USE_LIGHTMAP ) && defined( LIGHTMAP_SECONDARY_UV )",
    "vUv2 = uv2;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.map_fragment = [
    "#ifdef USE_MAP",
    "vec2 texCoord;",
    "#ifdef PARTICLE",
    "texCoord = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );",
    "#else",
    "texCoord = uvCoord;",
    "#endif",
    "vec4 texelColor = texture2D( map, texCoord );",
    "#ifdef GAMMA_INPUT",
    "texelColor.xyz *= texelColor.xyz;",
    "#endif",
    "mgl_FragColor = mgl_FragColor * texelColor;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.specularmap_pars_fragment = [
    "#ifdef USE_SPECULARMAP",
    "uniform sampler2D specularMap;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.specularmap_fragment = [
    "vec3 specularMapColor;",
    "#ifdef USE_SPECULARMAP",
    "vec4 texelSpecular = texture2D( specularMap, uvCoord );",
    "specularMapColor = texelSpecular.rgb;",
    "#else",
    "specularMapColor = vec3( 1.0 );",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.glossmap_pars_fragment = [
    "#ifdef USE_GLOSSMAP",
    "uniform sampler2D glossMap;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.lightmap_pars_fragment = [
    "#ifdef USE_LIGHTMAP",
    "uniform sampler2D lightMap;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.lightmap_fragment = [
    "#ifdef USE_LIGHTMAP",
    "#ifdef LIGHTMAP_SECONDARY_UV",
    "float lightMapIntensity = texture2D( lightMap, uvCoord2 ).r;",
    "#else",
    "float lightMapIntensity = texture2D( lightMap, uvCoord ).r;",
    "#endif",
    "#ifdef LIGHTMAP_GAMMA",
    "lightMapIntensity *= lightMapIntensity;",
    "#endif",
    "#else",
    "float lightMapIntensity = 1.0;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.bumpmap_pars_fragment = [
    "#ifdef USE_BUMPDETAILMAP",
    "uniform sampler2D bumpDetailMap;",
    "#endif",
    "#ifdef USE_BUMPMAP",
    "uniform sampler2D bumpMap;",
    "uniform float bumpScale;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.derivativemap_pars_fragment = [
    "#if defined( USE_BUMPMAP ) || defined( USE_DISPLACEMENTMAP )",
    "vec2 dHdxy_fwd( const in sampler2D sourceMap, const in vec2 texCoord, const in float sourceScale ) {",
    "vec2 dSTdx = dFdx( texCoord );",
    "vec2 dSTdy = dFdy( texCoord );",
    "float Hll = sourceScale * texture2D( sourceMap, texCoord ).x;",
    "float dBx = sourceScale * texture2D( sourceMap, texCoord + dSTdx ).x - Hll;",
    "float dBy = sourceScale * texture2D( sourceMap, texCoord + dSTdy ).x - Hll;",
    "return vec2( dBx, dBy );",
    "}",
    "vec3 perturbNormalArb( const in vec3 surf_pos, const in vec3 surf_norm, const in vec2 dHdxy ) {",
    "vec3 vSigmaX = dFdx( surf_pos );",
    "vec3 vSigmaY = dFdy( surf_pos );",
    "vec3 vN = surf_norm;",
    "vec3 R1 = cross( vSigmaY, vN );",
    "vec3 R2 = cross( vN, vSigmaX );",
    "float fDet = dot( vSigmaX, R1 );",
    "vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
    "return normalize( abs( fDet ) * surf_norm - vGrad );",
    "}",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.normalmap_pars_fragment = [
    "#ifdef USE_NORMALDETAILMAP",
    "uniform sampler2D normalDetailMap;",
    "#endif",
    "#if defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP ) || defined( USE_NORMALDETAILMAP )",
    "uniform sampler2D normalMap;",
    "uniform vec2 normalScale;",
    "vec3 perturbNormal2Arb( const in vec3 eye_pos, const in vec3 surf_norm, const in vec3 normal_pixel, const in vec2 texCoord ) {",
    "vec3 q0 = dFdx( eye_pos.xyz );",
    "vec3 q1 = dFdy( eye_pos.xyz );",
    "vec2 st0 = dFdx( texCoord.st );",
    "vec2 st1 = dFdy( texCoord.st );",
    "vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
    "vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
    "vec3 N = normalize( surf_norm );",
    "vec3 mapN = normal_pixel * 2.0 - 1.0;",
    "mapN.xy = normalScale * mapN.xy;",
    "mat3 tsn = mat3( S, T, N );",
    "return normalize( tsn * mapN );",
    "}",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.parallax_pars_fragment = [
    "#if defined( USE_PARALLAX ) && defined( USE_BUMPMAP )",
    "uniform float parallaxScale;",
    "vec2 computeParallaxProjection( const in vec3 surf_pos, const in vec3 surf_norm, const in vec3 surf_view, const in vec2 texCoord ) {",
    "vec2 TexDx = dFdx( texCoord );",
    "vec2 TexDy = dFdy( texCoord );",
    "vec3 vSigmaX = dFdx( surf_pos );",
    "vec3 vSigmaY = dFdy( surf_pos );",
    "vec3 vN = surf_norm;",
    "vec3 vR1 = cross( vSigmaY, vN );",
    "vec3 vR2 = cross( vN, vSigmaX );",
    "float fDet = dot( vSigmaX, vR1 );",
    "vec3 vV = surf_view;",
    "vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, vV ), dot( vR2, vV ) );",
    "vec2 vProjVtex = TexDx * vProjVscr.x + TexDy * vProjVscr.y;",
    "return vProjVtex;",
    "}",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.parallax_fragment = [
    "#if defined( USE_PARALLAX ) && defined( USE_BUMPMAP )",
    "float height = parallaxScale * ( 2.0 * texture2D( bumpMap, vUv ).x - 1.0 );",
    "vec2 parallaxProjection = computeParallaxProjection( vViewPosition, normal, eyeVector, vUv );",
    "vec2 uvOffset = parallaxProjection * height;",
    "uvCoord += uvOffset;",
    "#ifdef PARALLAX_REFINE_STEPS",
    "for ( int i = 0; i < PARALLAX_REFINE_STEPS; i ++ ) {",
    "height += parallaxScale * ( texture2D( bumpMap, uvCoord ).x - 1.0 );",
    "uvOffset = parallaxProjection * height;",
    "uvCoord = vUv + uvOffset;",
    "}",
    "#endif",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.instances_pars_vertex = [
    "#if defined( USE_INSTANCES )",
    "attribute vec3 offset;",
    "attribute vec4 rotation;",
    "vec3 rotateVectorByQuaternion( vec3 v, vec4 q ) {",
    "return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );",
    "}",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.begin_pos_vertex = [
    "vec4 transformedPosition = vec4( position, 1.0 );",
  ].join("\n")),
  (XG.ShaderChunk.displacementmap_pars_fragment = [
    "#ifdef USE_DISPLACEMENTMAP",
    "uniform sampler2D displacementMap;",
    "uniform float displacementNormalScale;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.displacement_pars_vertex = [
    "#ifdef USE_DISPLACEMENTMAP",
    "uniform sampler2D displacementMap;",
    "uniform vec2 displacementScaleBias;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.displacement_vertex = [
    "#ifdef USE_DISPLACEMENTMAP",
    "vec3 displacementValue = texture2D( displacementMap, transformedUV ).xyz;",
    "float scaledDisplacement = displacementValue.x * displacementScaleBias.x + displacementScaleBias.y;",
    "vec3 displaced = transformedPosition.xyz;",
    "#ifdef DISPLACE_BY_POSITION",
    "displaced += normalize( transformedPosition.xyz ) * scaledDisplacement;",
    "#endif",
    "#ifdef DISPLACE_BY_NORMAL",
    "displaced += normalize( normal ) * scaledDisplacement;",
    "#endif",
    "transformedPosition.xyz = displaced;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.skinning_pars_vertex = [
    "#ifdef USE_SKINNING",
    "#ifdef BONE_TEXTURE",
    "uniform sampler2D boneTexture;",
    "mat4 getBoneMatrix( const in float i ) {",
    "float j = i * 4.0;",
    "float x = mod( j, N_BONE_PIXEL_X );",
    "float y = floor( j / N_BONE_PIXEL_X );",
    "const float dx = 1.0 / N_BONE_PIXEL_X;",
    "const float dy = 1.0 / N_BONE_PIXEL_Y;",
    "y = dy * ( y + 0.5 );",
    "vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
    "vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
    "vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
    "vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",
    "mat4 bone = mat4( v1, v2, v3, v4 );",
    "return bone;",
    "}",
    "#else",
    "uniform mat4 boneGlobalMatrices[ MAX_BONES ];",
    "mat4 getBoneMatrix( const in float i ) {",
    "mat4 bone = boneGlobalMatrices[ int(i) ];",
    "return bone;",
    "}",
    "#endif",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.skinbase_vertex = [
    "#ifdef USE_SKINNING",
    "mat4 boneMatX = getBoneMatrix( skinIndex.x );",
    "mat4 boneMatY = getBoneMatrix( skinIndex.y );",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.skinning_vertex = [
    "#ifdef USE_SKINNING",
    "vec4 skinned  = boneMatX * transformedPosition * skinWeight.x;",
    "skinned 	  += boneMatY * transformedPosition * skinWeight.y;",
    "transformedPosition = skinned;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.morphtarget_pars_vertex = [
    "#ifdef USE_MORPHTARGETS",
    "uniform float morphTargetInfluences[ 4 ];",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.morphtarget_vertex = [
    "#ifdef USE_MORPHTARGETS",
    "vec3 morphed = vec3( 0.0 );",
    "morphed += ( morphTarget0 - transformedPosition.xyz ) * morphTargetInfluences[ 0 ];",
    "#if MAX_MORPHTARGETS > 1",
    "morphed += ( morphTarget1 - transformedPosition.xyz ) * morphTargetInfluences[ 1 ];",
    "#if MAX_MORPHTARGETS > 2",
    "morphed += ( morphTarget2 - transformedPosition.xyz ) * morphTargetInfluences[ 2 ];",
    "#if MAX_MORPHTARGETS > 3",
    "morphed += ( morphTarget3 - transformedPosition.xyz ) * morphTargetInfluences[ 3 ];",
    "#endif",
    "#endif",
    "#endif",
    "morphed += transformedPosition.xyz;",
    "transformedPosition.xyz = morphed;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.end_pos_vertex = [
    "vec4 mvPosition;",
    "#if defined( USE_INSTANCES )",
    "transformedPosition.xyz = rotateVectorByQuaternion( transformedPosition.xyz, rotation ) + offset;",
    "#endif",
    "mvPosition = modelViewMatrix * transformedPosition;",
    "gl_Position = projectionMatrix * mvPosition;",
  ].join("\n")),
  (XG.ShaderChunk.begin_nor_vertex = ["vec3 transformedNormal = normal;"].join(
    "\n"
  )),
  (XG.ShaderChunk.morphnormal_vertex = [
    "#ifdef USE_MORPHNORMALS",
    "vec3 morphedNormal = vec3( 0.0 );",
    "morphedNormal +=  ( morphNormal0 - transformedNormal ) * morphTargetInfluences[ 0 ];",
    "#if MAX_MORPHNORMALS > 1",
    "morphedNormal +=  ( morphNormal1 - transformedNormal ) * morphTargetInfluences[ 1 ];",
    "#if MAX_MORPHNORMALS > 2",
    "morphedNormal +=  ( morphNormal2 - transformedNormal ) * morphTargetInfluences[ 2 ];",
    "#if MAX_MORPHNORMALS > 3",
    "morphedNormal +=  ( morphNormal3 - transformedNormal ) * morphTargetInfluences[ 3 ];",
    "#endif",
    "#endif",
    "#endif",
    "morphedNormal += transformedNormal;",
    "transformedNormal = morphedNormal;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.skinnormal_vertex = [
    "#ifdef USE_SKINNING",
    "mat4 skinMatrix = skinWeight.x * boneMatX;",
    "skinMatrix 	+= skinWeight.y * boneMatY;",
    "vec4 skinnedNormal = skinMatrix * vec4( transformedNormal, 0.0 );",
    "transformedNormal = skinnedNormal.xyz;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.end_nor_vertex = [
    "#if defined( USE_INSTANCES )",
    "transformedNormal = rotateVectorByQuaternion( transformedNormal, rotation );",
    "#endif",
    "#ifdef FLIP_SIDED",
    "transformedNormal = -transformedNormal;",
    "#endif",
    "transformedNormal = normalize( normalMatrix * transformedNormal );",
  ].join("\n")),
  (XG.ShaderChunk.particle_pars_vertex = [
    "#ifdef PARTICLE",
    "uniform float particleSize;",
    "uniform float screenWidth;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.particle_vertex = [
    "#ifdef PARTICLE",
    "#ifdef USE_PARTICLE_SIZEATTENUATION",
    "vec4 projectedCorner = projectionMatrix * vec4( 0.5 * particleSize, 0.5 * particleSize, mvPosition.z, mvPosition.w );",
    "gl_PointSize = screenWidth * projectedCorner.x / projectedCorner.w;",
    "#else",
    "gl_PointSize = particleSize;",
    "#endif",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.utils_pars_fragment = [
    "float saturate( float x ) {",
    "return clamp( x, 0.0, 1.0 );",
    "}",
    "vec3 saturate( vec3 x ) {",
    "return clamp( x, vec3( 0.0 ), vec3( 1.0 ) );",
    "}",
  ].join("\n")),
  (XG.ShaderChunk.polylights_pars_fragment = [
    "const int   NUM_SAMPLES = 8;",
    "const float LUT_SIZE64  = 64.0;",
    "const float LUT_SCALE64 = ( LUT_SIZE64 - 1.0 ) / LUT_SIZE64;",
    "const float LUT_BIAS64  = 0.5 / LUT_SIZE64;",
    "const float LUT_SIZE32  = 32.0;",
    "const float LUT_SCALE32 = ( LUT_SIZE32 - 1.0 ) / LUT_SIZE32;",
    "const float LUT_BIAS32  = 0.5 / LUT_SIZE32;",
    "const float PI = 3.14159265;",
    "#if __VERSION__ < 300",
    "mat3 transpose( mat3 v ) {",
    "mat3 tmp;",
    "tmp[0] = vec3( v[0].x, v[1].x, v[2].x );",
    "tmp[1] = vec3( v[0].y, v[1].y, v[2].y );",
    "tmp[2] = vec3( v[0].z, v[1].z, v[2].z );",
    "return tmp;",
    "}",
    "#endif",
    "vec3 mul( mat3 m, vec3 v ) {",
    "return m * v;",
    "}",
    "mat3 mul( mat3 m1, mat3 m2 ) {",
    "return m1 * m2;",
    "}",
    "float IntegrateEdge( vec3 v1, vec3 v2 ) {",
    "float cosTheta = dot( v1, v2 );",
    "cosTheta = clamp( cosTheta, -0.9999, 0.9999 );",
    "float theta = acos( cosTheta );",
    "float res = cross( v1, v2 ).z * theta / sin( theta );",
    "return res;",
    "}",
    "void ClipQuadToHorizon( inout vec3 L[5], out int n ) {",
    "int config = 0;",
    "if ( L[0].z > 0.0 ) config += 1;",
    "if ( L[1].z > 0.0 ) config += 2;",
    "if ( L[2].z > 0.0 ) config += 4;",
    "if ( L[3].z > 0.0 ) config += 8;",
    "n = 0;",
    "if ( config == 0 ) {",
    "} else if ( config == 1 ) {",
    "n = 3;",
    "L[1] = -L[1].z * L[0] + L[0].z * L[1];",
    "L[2] = -L[3].z * L[0] + L[0].z * L[3];",
    "} else if ( config == 2 ) {",
    "n = 3;",
    "L[0] = -L[0].z * L[1] + L[1].z * L[0];",
    "L[2] = -L[2].z * L[1] + L[1].z * L[2];",
    "} else if ( config == 3 ) {",
    "n = 4;",
    "L[2] = -L[2].z * L[1] + L[1].z * L[2];",
    "L[3] = -L[3].z * L[0] + L[0].z * L[3];",
    "} else if ( config == 4 ) {",
    "n = 3;",
    "L[0] = -L[3].z * L[2] + L[2].z * L[3];",
    "L[1] = -L[1].z * L[2] + L[2].z * L[1];",
    "} else if ( config == 5 ) {",
    "n = 0;",
    "} else if ( config == 6 ) {",
    "n = 4;",
    "L[0] = -L[0].z * L[1] + L[1].z * L[0];",
    "L[3] = -L[3].z * L[2] + L[2].z * L[3];",
    "} else if ( config == 7 ) {",
    "n = 5;",
    "L[4] = -L[3].z * L[0] + L[0].z * L[3];",
    "L[3] = -L[3].z * L[2] + L[2].z * L[3];",
    "} else if ( config == 8 ) {",
    "n = 3;",
    "L[0] = -L[0].z * L[3] + L[3].z * L[0];",
    "L[1] = -L[2].z * L[3] + L[3].z * L[2];",
    "L[2] =  L[3];",
    "} else if ( config == 9 ) {",
    "n = 4;",
    "L[1] = -L[1].z * L[0] + L[0].z * L[1];",
    "L[2] = -L[2].z * L[3] + L[3].z * L[2];",
    "} else if ( config == 10 ) {",
    "n = 0;",
    "} else if ( config == 11 ) {",
    "n = 5;",
    "L[4] = L[3];",
    "L[3] = -L[2].z * L[3] + L[3].z * L[2];",
    "L[2] = -L[2].z * L[1] + L[1].z * L[2];",
    "} else if ( config == 12 ) {",
    "n = 4;",
    "L[1] = -L[1].z * L[2] + L[2].z * L[1];",
    "L[0] = -L[0].z * L[3] + L[3].z * L[0];",
    "} else if ( config == 13 ) {",
    "n = 5;",
    "L[4] = L[3];",
    "L[3] = L[2];",
    "L[2] = -L[1].z * L[2] + L[2].z * L[1];",
    "L[1] = -L[1].z * L[0] + L[0].z * L[1];",
    "} else if ( config == 14 ) {",
    "n = 5;",
    "L[4] = -L[0].z * L[3] + L[3].z * L[0];",
    "L[0] = -L[0].z * L[1] + L[1].z * L[0];",
    "} else if ( config == 15 ) {",
    "n = 4;",
    "}",
    "if ( n == 3 ) L[3] = L[0];",
    "if ( n == 4 ) L[4] = L[0];",
    "}",
    "mat3 computeOrthoBasis( float dotNV, vec3 N, vec3 V ) {",
    "vec3 T1, T2;",
    "T1 = normalize( V - N * dotNV );",
    "T2 = cross( N, T1 );",
    "return transpose( mat3( T1, T2, N ) );",
    "}",
    "#ifdef POLY_TEXTURE",
    "vec3 FetchDiffuseFilteredTexture( sampler2D texLightFiltered, float texSize, float texBias, vec3 p1_, vec3 p2_, vec3 p3_, vec3 p4_ ) {",
    "vec3 V1 = p2_ - p1_;",
    "vec3 V2 = p4_ - p1_;",
    "vec3 planeOrtho = cross( V1, V2 );",
    "float planeAreaSquared = dot( planeOrtho, planeOrtho );",
    "float planeDistxPlaneArea = dot( planeOrtho, p1_ );",
    "vec3 P = planeDistxPlaneArea * planeOrtho / planeAreaSquared - p1_;",
    "float dot_V1_V2 = dot( V1, V2 );",
    "float inv_dot_V1_V1 = 1.0 / dot( V1, V1 );",
    "vec3 V2_ = V2 - V1 * dot_V1_V2 * inv_dot_V1_V1;",
    "vec2 Puv;",
    "Puv.y = dot( V2_, P ) / dot( V2_, V2_ );",
    "Puv.x = dot( V1, P ) * inv_dot_V1_V1 - dot_V1_V2 * inv_dot_V1_V1 * Puv.y;",
    "float d = abs( planeDistxPlaneArea ) / pow( planeAreaSquared, 0.75 );",
    "#ifdef SUPPORTS_TEXTURE_LOD",
    "vec3 texColor = texture2DLodEXT( texLightFiltered, vec2( 0.125, 0.125 ) + 0.75 * Puv, log( texSize * d ) / log( 3.0 ) + texBias ).rgb;",
    "#else",
    "vec3 texColor = texture2D( texLightFiltered, vec2( 0.125, 0.125 ) + 0.75 * Puv, log( texSize * d ) / log( 3.0 ) + texBias ).rgb;",
    "#endif",
    "texColor.rgb *= texColor.rgb;",
    "return texColor;",
    "}",
    "vec3 LTC_Evaluate_opt_tex( vec3 P, mat3 Minv, vec3 points[4], bool twoSided, sampler2D texFilteredMap, float texSize, float texBias ) {",
    "vec3 L[ 5 ];",
    "L[ 0 ] = mul( Minv, points[ 0 ] - P );",
    "L[ 1 ] = mul( Minv, points[ 1 ] - P );",
    "L[ 2 ] = mul( Minv, points[ 2 ] - P );",
    "L[ 3 ] = mul( Minv, points[ 3 ] - P );",
    "vec3 textureLight = FetchDiffuseFilteredTexture( texFilteredMap, texSize, texBias, L[0], L[1], L[2], L[3] );",
    "int n;",
    "ClipQuadToHorizon( L, n );",
    "if ( n == 0 ) return vec3( 0.0 );",
    "L[0] = normalize( L[0] );",
    "L[1] = normalize( L[1] );",
    "L[2] = normalize( L[2] );",
    "L[3] = normalize( L[3] );",
    "L[4] = normalize( L[4] );",
    "float sum = 0.0;",
    "sum += IntegrateEdge( L[0], L[1] );",
    "sum += IntegrateEdge( L[1], L[2] );",
    "sum += IntegrateEdge( L[2], L[3] );",
    "if ( n >= 4 ) sum += IntegrateEdge( L[3], L[4] );",
    "if ( n == 5 ) sum += IntegrateEdge( L[4], L[0] );",
    "sum = twoSided ? abs( sum ) : max( 0.0, -sum );",
    "vec3 Lo_i = vec3( sum );",
    "Lo_i *= textureLight;",
    "return Lo_i;",
    "}",
    "vec3 LTC_Evaluate_tex( vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 points[4], bool twoSided, sampler2D texFilteredMap, float texSize, float texBias ) {",
    "vec3 T1, T2;",
    "T1 = normalize( V - N * dot( V, N ) );",
    "T2 = cross( N, T1 );",
    "Minv = mul( Minv, transpose( mat3( T1, T2, N ) ) );",
    "vec3 L[ 5 ];",
    "L[ 0 ] = mul( Minv, points[ 0 ] - P );",
    "L[ 1 ] = mul( Minv, points[ 1 ] - P );",
    "L[ 2 ] = mul( Minv, points[ 2 ] - P );",
    "L[ 3 ] = mul( Minv, points[ 3 ] - P );",
    "vec3 textureLight = FetchDiffuseFilteredTexture( texFilteredMap, texSize, texBias, L[0], L[1], L[2], L[3] );",
    "int n;",
    "ClipQuadToHorizon( L, n );",
    "if ( n == 0 ) return vec3( 0, 0, 0 );",
    "L[0] = normalize( L[0] );",
    "L[1] = normalize( L[1] );",
    "L[2] = normalize( L[2] );",
    "L[3] = normalize( L[3] );",
    "L[4] = normalize( L[4] );",
    "float sum = 0.0;",
    "sum += IntegrateEdge( L[0], L[1] );",
    "sum += IntegrateEdge( L[1], L[2] );",
    "sum += IntegrateEdge( L[2], L[3] );",
    "if ( n >= 4 ) sum += IntegrateEdge( L[3], L[4] );",
    "if ( n == 5 ) sum += IntegrateEdge( L[4], L[0] );",
    "sum = twoSided ? abs( sum ) : max( 0.0, -sum );",
    "vec3 Lo_i = vec3( sum, sum, sum );",
    "Lo_i *= textureLight;",
    "return Lo_i;",
    "}",
    "#endif",
    "vec3 LTC_Evaluate_opt( vec3 P, mat3 Minv, vec3 points[4], bool twoSided ) {",
    "vec3 L[ 5 ];",
    "L[ 0 ] = mul( Minv, points[ 0 ] - P );",
    "L[ 1 ] = mul( Minv, points[ 1 ] - P );",
    "L[ 2 ] = mul( Minv, points[ 2 ] - P );",
    "L[ 3 ] = mul( Minv, points[ 3 ] - P );",
    "int n;",
    "ClipQuadToHorizon( L, n );",
    "if ( n == 0 ) return vec3( 0.0 );",
    "L[0] = normalize( L[0] );",
    "L[1] = normalize( L[1] );",
    "L[2] = normalize( L[2] );",
    "L[3] = normalize( L[3] );",
    "L[4] = normalize( L[4] );",
    "float sum = 0.0;",
    "sum += IntegrateEdge( L[0], L[1] );",
    "sum += IntegrateEdge( L[1], L[2] );",
    "sum += IntegrateEdge( L[2], L[3] );",
    "if ( n >= 4 ) sum += IntegrateEdge( L[3], L[4] );",
    "if ( n == 5 ) sum += IntegrateEdge( L[4], L[0] );",
    "sum = twoSided ? abs( sum ) : max( 0.0, -sum );",
    "vec3 Lo_i = vec3( sum );",
    "return Lo_i;",
    "}",
    "vec3 LTC_Evaluate( vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 points[4], bool twoSided ) {",
    "vec3 T1, T2;",
    "T1 = normalize( V - N * dot( V, N ) );",
    "T2 = cross( N, T1 );",
    "Minv = mul( Minv, transpose( mat3( T1, T2, N ) ) );",
    "vec3 L[ 5 ];",
    "L[ 0 ] = mul( Minv, points[ 0 ] - P );",
    "L[ 1 ] = mul( Minv, points[ 1 ] - P );",
    "L[ 2 ] = mul( Minv, points[ 2 ] - P );",
    "L[ 3 ] = mul( Minv, points[ 3 ] - P );",
    "int n;",
    "ClipQuadToHorizon( L, n );",
    "if ( n == 0 ) return vec3( 0, 0, 0 );",
    "L[0] = normalize( L[0] );",
    "L[1] = normalize( L[1] );",
    "L[2] = normalize( L[2] );",
    "L[3] = normalize( L[3] );",
    "L[4] = normalize( L[4] );",
    "float sum = 0.0;",
    "sum += IntegrateEdge( L[0], L[1] );",
    "sum += IntegrateEdge( L[1], L[2] );",
    "sum += IntegrateEdge( L[2], L[3] );",
    "if ( n >= 4 ) sum += IntegrateEdge( L[3], L[4] );",
    "if ( n == 5 ) sum += IntegrateEdge( L[4], L[0] );",
    "sum = twoSided ? abs( sum ) : max( 0.0, -sum );",
    "vec3 Lo_i = vec3( sum, sum, sum );",
    "return Lo_i;",
    "}",
  ].join("\n")),
  (XG.ShaderChunk.skin_pars_fragment = [
    "vec3 PSSFitFunction( in float NdotL, in float r ) {",
    "const vec3 a0 = vec3( 0.0605, 0.2076, 0.2243 );",
    "const vec3 a1 = vec3( 0.0903, 0.1687, 0.2436 );",
    "const vec3 a2 = vec3( -0.0210, -0.0942, -0.1116 );",
    "const vec3 a3 = vec3( 0.6896, 0.6762, 0.6480 );",
    "const vec3 a4 = vec3( -0.1110, -0.5023, -0.6703 );",
    "const vec3 a5 = vec3( 0.8177, 0.9119, 0.9209 );",
    "vec3 t = vec3( NdotL ) * ( a0 * r + a1 ) + ( a2 * r + a3 );",
    "vec3 fade = saturate( a4 * r + a5 );",
    "return t * t * t * fade + saturate( NdotL ) * ( 1.0 - fade );",
    "}",
  ].join("\n")),
  (XG.ShaderChunk.tonemappingFragmentPars = [
    "#ifdef TONEMAPPING",
    "const vec3 GAMMA = vec3( 1.0 / 2.2 );",
    "const vec3 GAMMA_INVERSE = vec3( 2.2 );",
    "const vec3 LUMA = vec3( 0.2126, 0.7152, 0.0722 );",
    "uniform float brightness;",
    "uniform float whitePoint;",
    "#ifdef TONEMAP_UNCHARTED",
    "const float A = 0.15;",
    "const float B = 0.50;",
    "const float C = 0.10;",
    "const float D = 0.20;",
    "const float E = 0.02;",
    "const float F = 0.30;",
    "const float W = 11.2;",
    "vec3 Uncharted2Tonemap( vec3 x ) {",
    "return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;",
    "}",
    "vec3 Uncharted2TonemapInverse( vec3 x ) {",
    "return -( 1.66667 * ( x - 0.0333333 ) ) / ( x - 0.933333 ) + ( 0.0111111 * sqrt( 19260.0 * x * x + 1524.0 * x + 25.0 ) ) / ( x - 0.933333 );",
    "}",
    "#endif",
    "vec3 inverseTonemapping( vec3 inColor, float inBrightness, float inWhitePoint ) {",
    "vec3 outColor = inColor;",
    "#if defined( TONEMAP_SIMPLE )",
    "outColor *= outColor;",
    "#elif defined( TONEMAP_LINEAR )",
    "outColor = pow( outColor, GAMMA_INVERSE );",
    "#elif defined( TONEMAP_REINHARD )",
    "outColor = pow( outColor, GAMMA_INVERSE );",
    "outColor = outColor / ( 1.0 - outColor );",
    "#elif defined( TONEMAP_REINHARD_LUMA )",
    "float toneMappedLuma = dot( outColor, LUMA );",
    "float luma = toneMappedLuma / ( 1.0 - toneMappedLuma );",
    "outColor = pow( max( outColor, vec3( 0.0 ) ), GAMMA_INVERSE );",
    "outColor *= luma / toneMappedLuma;",
    "#elif defined( TONEMAP_REINHARD_WHITE )",
    "float whiteK = 2.0 * inWhitePoint;",
    "whiteK *= whiteK;",
    "float toneMappedLuma = dot( outColor, LUMA );",
    "float y1 = 1.0 - toneMappedLuma;",
    "float luma = ( - y1 + sqrt( y1 * y1 + 4.0 * toneMappedLuma * whiteK ) ) / ( 2.0 * whiteK );",
    "outColor = pow( outColor, GAMMA_INVERSE );",
    "outColor *= luma / toneMappedLuma;",
    "#elif defined( TONEMAP_FILMIC )",
    "outColor = -( 0.137097 * ( outColor - 0.294118 ) ) / ( outColor - 1.0 ) - ( 0.00360656 * sqrt( 701.0 * outColor * outColor - 106.0 * outColor + 125.0 ) ) / ( outColor - 1.0 );",
    "outColor += 0.004;",
    "outColor = max( outColor, vec3( 0.0 ) );",
    "#elif defined( TONEMAP_FILMIC_2015 )",
    "float iva = 1.425 * inWhitePoint + 0.05;",
    "float inverseWhitePoint = ( ( inWhitePoint * iva + 0.004 ) / ( ( inWhitePoint * ( iva + 0.55 ) + 0.0491 ) ) ) - 0.0821;",
    "outColor = pow( max( outColor, vec3( 0.0 ) ), GAMMA_INVERSE );",
    "outColor = outColor * inverseWhitePoint + 0.0821;",
    "outColor = - ( 0.210526 * ( outColor - 0.0833333 ) ) / ( outColor - 1.0 ) - ( 0.00110957 * sqrt( 8013.0 * outColor * outColor + 24267.0 * outColor - 2030.0 ) ) / ( outColor - 1.0 );",
    "outColor = max( outColor, vec3( 0.0 ) );",
    "#elif defined( TONEMAP_PHOTOGRAPHIC )",
    "const float exposureBias = 3.0;",
    "const float saturationBias = 1.3;",
    "outColor = pow( outColor, vec3( 2.2 / saturationBias ) );",
    "outColor = - ( log( 1.0 - outColor ) / ( exposureBias * log( 2.0 ) ) );",
    "outColor = max( outColor, vec3( 0.0 ) );",
    "#elif defined( TONEMAP_UNCHARTED )",
    "float exposureBias = 2.0;",
    "outColor = pow( max( outColor, vec3( 0.0 ) ), GAMMA_INVERSE );",
    "outColor *= Uncharted2Tonemap( vec3( W * inWhitePoint ) );",
    "outColor = Uncharted2TonemapInverse( outColor );",
    "outColor /= exposureBias;",
    "outColor = max( outColor, vec3( 0.0 ) );",
    "#endif",
    "outColor /= inBrightness;",
    "return outColor;",
    "}",
    "vec3 applyTonemapping( vec3 inColor, float inBrightness, float inWhitePoint ) {",
    "vec3 outColor = inColor * inBrightness;",
    "#if defined( TONEMAP_SIMPLE )",
    "outColor = sqrt( max( outColor, vec3( 0.0 ) ) );",
    "#elif defined( TONEMAP_LINEAR )",
    "outColor = pow( max( outColor, vec3( 0.0 ) ), GAMMA );",
    "#elif defined( TONEMAP_REINHARD )",
    "outColor = outColor / ( 1.0 + outColor );",
    "outColor = pow( max( outColor, vec3( 0.0 ) ), GAMMA );",
    "#elif defined( TONEMAP_REINHARD_LUMA )",
    "float luma = dot( outColor, LUMA );",
    "float toneMappedLuma = luma / ( 1.0 + luma );",
    "outColor *= toneMappedLuma / luma;",
    "outColor = pow( max( outColor, vec3( 0.0 ) ), GAMMA );",
    "#elif defined( TONEMAP_REINHARD_WHITE )",
    "float white = 2.0 * inWhitePoint;",
    "float luma = dot( outColor, LUMA );",
    "float toneMappedLuma = luma * ( 1.0 + luma / ( white * white ) ) / ( 1.0 + luma );",
    "outColor *= toneMappedLuma / luma;",
    "outColor = pow( max( outColor, vec3( 0.0 ) ), GAMMA );",
    "#elif defined( TONEMAP_FILMIC )",
    "vec3 x = max( vec3( 0.0 ), outColor - 0.004 );",
    "outColor = ( x * ( 6.2 * x + 0.5 ) ) / ( x * ( 6.2 * x + 1.7 ) + 0.06 );",
    "outColor = max( outColor, vec3( 0.0 ) );",
    "#elif defined( TONEMAP_FILMIC_2015 )",
    "vec4 vh = vec4( outColor, inWhitePoint );",
    "vec4 va = ( 1.425 * vh ) + 0.05;",
    "vec4 vf = ( ( vh * va + 0.004 ) / ( ( vh * ( va + 0.55 ) + 0.0491 ) ) ) - 0.0821;",
    "outColor = vf.rgb / vf.www;",
    "outColor = pow( max( outColor, vec3( 0.0 ) ), GAMMA );",
    "#elif defined( TONEMAP_PHOTOGRAPHIC )",
    "const float exposureBias = 3.0;",
    "const float saturationBias = 1.3;",
    "outColor = 1.0 - exp2( -exposureBias * outColor );",
    "outColor = pow( max( outColor, vec3( 0.0 ) ), vec3( saturationBias / 2.2 ) );",
    "#elif defined( TONEMAP_UNCHARTED )",
    "float exposureBias = 2.0;",
    "vec3 curr = Uncharted2Tonemap( exposureBias * outColor );",
    "float white = W * inWhitePoint;",
    "vec3 whiteScale = vec3( 1.0 ) / Uncharted2Tonemap( vec3( white ) );",
    "vec3 color = curr * whiteScale;",
    "outColor = pow( max( color, vec3( 0.0 ) ), GAMMA );",
    "#endif",
    "return outColor;",
    "}",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.ditheringFragmentPars = [
    "#ifdef DITHERING_ENABLED",
    "float nrand( vec2 n ) {",
    "return fract( sin( dot( n.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );",
    "}",
    "vec3 applyDithering( vec3 inColor, vec2 rndSeed ) {",
    "float rnd = nrand( rndSeed ) - 0.5;",
    "inColor.rgb += rnd/255.0;",
    "return inColor;",
    "}",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.encodingUtils = [
    "#if __VERSION__ < 300",
    "float round( in float f ) {",
    "return floor( f + 0.5 );",
    "}",
    "#endif",
    "float signNotZero( in float k ) {",
    "return k >= 0.0 ? 1.0 : -1.0;",
    "}",
    "vec2 signNotZero( in vec2 v ) {",
    "return vec2( signNotZero( v.x ), signNotZero( v.y ) );",
    "}",
    "float packSnorm12Float( float f ) {",
    "return round( clamp( f + 1.0, 0.0, 2.0 ) * float( 2047 ) );",
    "}",
    "vec3 twoNorm12sEncodedAs3Unorm8sInVec3Format( vec2 s ) {",
    "vec3 u;",
    "u.x = s.x * ( 1.0 / 16.0 );",
    "float t = floor( s.y * ( 1.0 / 256.0 ) );",
    "u.y = ( fract( u.x ) * 256.0 ) + t;",
    "u.z = s.y - ( t * 256.0 );",
    "return floor( u ) * ( 1.0 / 255.0 );",
    "}",
    "vec3 vec2To2Snorm12sEncodedAs3Unorm8sInVec3Format( vec2 v ) {",
    "vec2 s = vec2( packSnorm12Float( v.x ), packSnorm12Float( v.y ) );",
    "return twoNorm12sEncodedAs3Unorm8sInVec3Format( s );",
    "}",
    "vec2 octEncode( in vec3 v ) {",
    "float l1norm = abs( v.x ) + abs( v.y ) + abs( v.z );",
    "vec2 result = v.xy * ( 1.0 / l1norm );",
    "if ( v.z < 0.0 ) {",
    "result = ( 1.0 - abs( result.yx ) ) * signNotZero( result.xy );",
    "}",
    "return result;",
    "}",
    "vec3 encodeNormalOct24( in vec3 v ) {",
    "return vec2To2Snorm12sEncodedAs3Unorm8sInVec3Format( octEncode( v ) );",
    "}",
  ].join("\n")),
  (XG.ShaderChunk.decodingUtils = [
    "float signNotZero( in float k ) {",
    "return k >= 0.0 ? 1.0 : -1.0;",
    "}",
    "vec2 signNotZero( in vec2 v ) {",
    "return vec2( signNotZero( v.x ), signNotZero( v.y ) );",
    "}",
    "float unpackSnorm12( float f ) {",
    "return clamp( ( float( f ) / float( 2047 ) ) - 1.0, -1.0, 1.0 );",
    "}",
    "vec2 twoNorm12sEncodedAsUVec3InVec3FormatToPackedVec2( vec3 v ) {",
    "vec2 s;",
    "float temp = v.y * ( 255.0 / 16.0 );",
    "s.x = v.x * ( 255.0 * 16.0 ) + floor( temp );",
    "s.y =  fract( temp ) * float( 16 * 256 ) + ( v.z * 255.0 );",
    "return s;",
    "}",
    "vec2 twoSnorm12sEncodedAsUVec3InVec3FormatToVec2( vec3 v ) {",
    "vec2 s = twoNorm12sEncodedAsUVec3InVec3FormatToPackedVec2( v );",
    "return vec2( unpackSnorm12( s.x ), unpackSnorm12( s.y ) );",
    "}",
    "vec3 finalDecode( float x, float y ) {",
    "vec3 v = vec3( x, y, 1.0 - abs( x ) - abs( y ) );",
    "if ( v.z < 0.0 ) {",
    "v.xy = ( 1.0 - abs( v.yx ) ) * signNotZero( v.xy );",
    "}",
    "return normalize( v );",
    "}",
    "vec3 decodeNormalOct24( in vec3 p ) {",
    "vec2 v = twoSnorm12sEncodedAsUVec3InVec3FormatToVec2( p );",
    "return finalDecode( v.x, v.y );",
    "}",
  ].join("\n")),
  (XG.ShaderChunk.vertexShaderFullscreenTriangle = [
    "void main() {",
    "gl_Position = vec4( position.xyz, 1.0 );",
    "}",
  ].join("\n")),
  (XG.ShaderChunk.vertexShaderFullscreenTriangleUV = [
    "varying vec2 vUv;",
    "void main() {",
    "vUv = uv;",
    "gl_Position = vec4( position.xyz, 1.0 );",
    "}",
  ].join("\n")),
  (XG.ShaderChunk.vertexShaderGeometry = [
    "void main() { ",
    "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
    "gl_Position = projectionMatrix * mvPosition;",
    "}",
  ].join("\n")),
  (XG.ShaderChunk.fog_pars_fragment = [
    "#ifdef USE_FOG",
    "uniform vec3 fogColor;",
    "#if defined( EXPONENTIAL_FOG )",
    "uniform float fogDensity;",
    "#elif defined( LINEAR_FOG )",
    "uniform vec2 fogNearFar;",
    "#elif defined( ATMOSPHERIC_FOG )",
    "uniform vec2 fogStartStrength;",
    "#endif",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.fog_fragment = [
    "#ifdef USE_FOG",
    "float depth = gl_FragCoord.z / gl_FragCoord.w;",
    "float fogFactor = 0.0;",
    "#if defined( EXPONENTIAL_FOG )",
    "const float LOG2 = 1.442695;",
    "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
    "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
    "#elif defined( LINEAR_FOG )",
    "fogFactor = smoothstep( fogNearFar.x, fogNearFar.y, depth );",
    "#elif defined( ATMOSPHERIC_FOG )",
    "float linearDepth = linearizeDepth( vClipPosition.z / vClipPosition.w, cameraNearFar );",
    "fogFactor = linearDepth / ( cameraNearFar.y - cameraNearFar.x );",
    "fogFactor *= smoothstep( 0.0, fogStartStrength.x, linearDepth );",
    "fogFactor = clamp( fogFactor, 0.0, fogStartStrength.y );",
    "#endif",
    "mgl_FragColor = mix( mgl_FragColor, vec4( fogColor, mgl_FragColor.w ), fogFactor );",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.height_fog_pars_fragment = [
    "#ifdef USE_HEIGHT_FOG",
    "uniform float fogHeight;",
    "uniform float fogVisibilityDistance;",
    "uniform float fogFadeSpeed;",
    "uniform vec3 fogShallowDepthColor;",
    "uniform vec3 fogDeepDepthColor;",
    "uniform vec3 fogRgbExtinctionDistance;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.height_fog_fragment = [
    "#ifdef USE_HEIGHT_FOG",
    "vec3 u = vertexPositionWS.xyz - cameraPosition;",
    "vec3 w = cameraPosition - vec3( 0.0, fogHeight, 0.0 );",
    "vec3 n = vec3( 0.0, 1.0, 0.0 );",
    "float D = dot( n, u );",
    "float N = -dot( n, w );",
    "float sI = N / D;",
    "vec3 intersectionPosition = cameraPosition + sI * u;",
    "float fogThickness = length( intersectionPosition - vertexPositionWS.xyz );",
    "if ( vertexPositionWS.y > fogHeight ) {",
    "fogThickness = 0.0;",
    "}",
    "float fogThickness2 = intersectionPosition.y - vertexPositionWS.y;",
    "if ( cameraPosition.y < fogHeight ) {",
    "}",
    "float r1 = clamp( fogFadeSpeed * fogThickness / fogVisibilityDistance, 0.0, 1.0 );",
    "vec3 r2 = clamp( fogThickness2 / fogRgbExtinctionDistance, 0.0, 1.0 );",
    "mgl_FragColor.xyz = mix( mix( mgl_FragColor.xyz, fogShallowDepthColor * globalLightFactor, r1 ), fogDeepDepthColor * globalLightFactor, r2 );",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.worldpos_vertex = [
    "#if defined( USE_SHADOWMAP )",
    "vec4 worldPosition = modelMatrix * transformedPosition;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.area_lights_utils = [
    "#if MAX_AREA_LIGHTS > 0",
    "vec3 projectOnPlane( vec3 point, vec3 planeCenter, vec3 planeNorm ) {",
    "return point - dot( point - planeCenter, planeNorm ) * planeNorm;",
    "}",
    "bool sideOfPlane( vec3 point, vec3 planeCenter, vec3 planeNorm ) {",
    "return ( dot( point - planeCenter, planeNorm ) >= 0.0 );",
    "}",
    "vec3 linePlaneIntersect( vec3 lp, vec3 lv, vec3 pc, vec3 pn ) {",
    "return lp + lv * ( dot( pn, pc - lp ) / dot( pn, lv ) );",
    "}",
    "float calculateAttenuation( float dist, float constantAttenuation, float linearAttenuation, float quadraticAttenuation ) {",
    "return ( 1.0 / ( constantAttenuation + linearAttenuation * dist + quadraticAttenuation * dist * dist ) );",
    "}",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.lights_phong_pars_fragment = [
    "#if MAX_DIR_LIGHTS > 0",
    "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
    "uniform vec3 directionalLightDirectionVS[ MAX_DIR_LIGHTS ];",
    "uniform int directionalLightPars[ MAX_DIR_LIGHTS ];",
    "#endif",
    "#if MAX_HEMI_LIGHTS > 0",
    "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
    "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
    "uniform vec3 hemisphereLightDirectionVS[ MAX_HEMI_LIGHTS ];",
    "#endif",
    "#if MAX_POINT_LIGHTS > 0",
    "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
    "uniform vec3 pointLightPositionVS[ MAX_POINT_LIGHTS ];",
    "uniform vec2 pointLightPars[ MAX_POINT_LIGHTS ];",
    "#endif",
    "#if MAX_SPHERE_LIGHTS > 0",
    "uniform vec3 sphereLightColor[ MAX_SPHERE_LIGHTS ];",
    "uniform vec3 sphereLightPositionVS[ MAX_SPHERE_LIGHTS ];",
    "uniform vec3 sphereLightPars[ MAX_SPHERE_LIGHTS ];",
    "#endif",
    "#if MAX_TUBE_LIGHTS > 0",
    "uniform vec3 tubeLightColor[ MAX_TUBE_LIGHTS ];",
    "uniform vec3 tubeLightPosition0VS[ MAX_TUBE_LIGHTS ];",
    "uniform vec3 tubeLightPosition1VS[ MAX_TUBE_LIGHTS ];",
    "uniform vec2 tubeLightPars[ MAX_TUBE_LIGHTS ];",
    "#endif",
    "#if MAX_SPOT_LIGHTS > 0",
    "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
    "uniform vec3 spotLightPositionVS[ MAX_SPOT_LIGHTS ];",
    "uniform vec3 spotLightDirectionVS[ MAX_SPOT_LIGHTS ];",
    "uniform vec4 spotLightPars[ MAX_SPOT_LIGHTS ];",
    "#endif",
    "#if MAX_AREA_LIGHTS > 0",
    "uniform vec3 areaLightColor[ MAX_AREA_LIGHTS ];",
    "uniform vec3 areaLightPosition[ MAX_AREA_LIGHTS ];",
    "uniform vec3 areaLightNormal[ MAX_AREA_LIGHTS ];",
    "uniform vec3 areaLightRight[ MAX_AREA_LIGHTS ];",
    "uniform vec3 areaLightUp[ MAX_AREA_LIGHTS ];",
    "uniform vec4 areaLightPars[ MAX_AREA_LIGHTS ];",
    "uniform vec3 areaLightAttenuation[ MAX_AREA_LIGHTS ];",
    "#ifdef AREA_TEXTURE",
    "uniform sampler2D areaLightTexture[ MAX_AREA_LIGHTS ];",
    "#endif",
    "#endif",
    "#if MAX_POLY_LIGHTS > 0",
    "uniform vec3 polyLightColor[ MAX_POLY_LIGHTS ];",
    "uniform vec3 polyLightPoints[ MAX_POLY_LIGHTS * 4 ];",
    "uniform vec2 polyLightPars[ MAX_POLY_LIGHTS ];",
    "uniform sampler2D samplerLtcMat;",
    "uniform sampler2D samplerLtcMag;",
    "#ifdef POLY_TEXTURE",
    "uniform sampler2D polyLightTexture[ MAX_POLY_LIGHTS ];",
    "uniform vec2 polyLightTexturePars[ MAX_POLY_LIGHTS ];",
    "#endif",
    XG.ShaderChunk.polylights_pars_fragment,
    "#endif",
    "#if MAX_IMAGE_LIGHTS > 0",
    "vec3 fix_cube_lookup( vec3 v, float mipLevelClamp, float cubeSize ) {",
    "float M = max( max( abs( v.x ), abs( v.y ) ), abs( v.z ) );",
    "float scale = 1.0 - exp2( mipLevelClamp ) / cubeSize;",
    "if ( abs( v.x ) != M ) v.x *= scale;",
    "if ( abs( v.y ) != M ) v.y *= scale;",
    "if ( abs( v.z ) != M ) v.z *= scale;",
    "return v;",
    "}",
    "#if !defined( SUPPORTS_TEXTURE_LOD )",
    "uniform samplerCube imageLightTextureMip[ MAX_IMAGE_LIGHTS ];",
    "#endif",
    "uniform samplerCube imageLightTextureDiffuse[ MAX_IMAGE_LIGHTS ];",
    "uniform samplerCube imageLightTextureSpecular[ MAX_IMAGE_LIGHTS ];",
    "uniform vec4 imageLightPars[ MAX_IMAGE_LIGHTS ];",
    "uniform vec3 imageLightPositionWS[ MAX_IMAGE_LIGHTS ];",
    "uniform vec4 imageLightSize[ MAX_IMAGE_LIGHTS ];",
    "#endif",
    "#if MAX_IMAGE_LIGHTS > 0 || defined( USE_HEIGHT_FOG )",
    "uniform mat4 viewInverseMatrix;",
    "#endif",
    "#if MAX_IMAGE_LIGHTS > 0 || MAX_HEMI_LIGHTS > 0 || defined( TRANSPARENT )",
    "vec3 EnvironmentBRDF( float gloss, float dotNV, vec3 rf0 ) {",
    "vec4 t = vec4( 1.0 / 0.96, 0.475, ( 0.0275 - 0.25 * 0.04 ) / 0.96, 0.25 );",
    "t *= vec4( gloss );",
    "t += vec4( 0.0, 0.0, ( 0.015 - 0.75 * 0.04 ) / 0.96, 0.75 );",
    "float a0 = t.x * min( t.y, exp2( -9.28 * dotNV ) ) + t.z;",
    "float a1 = t.w;",
    "return clamp( a0 + rf0 * ( a1 - a0 ), 0.0, 1.0 );",
    "}",
    "#endif",
    "#ifdef WRAP_AROUND",
    "uniform vec3 wrapRGB;",
    "#endif",
    "float SmithGeometryFactor1( vec3 L, vec3 V, vec3 N, float shininess ) {",
    "vec3 H = L + V;",
    "float dotVN = dot( V, N );",
    "float dotVH = dot( V, H );",
    "if ( ( dotVH / dotVN ) <= 0.0 ) return 0.0;",
    "float f = acos( dotVN );",
    "float a = sqrt( 0.5 * shininess + 1.0 ) / tan( f );",
    "float G = 1.0;",
    "if ( a < 1.6 )",
    "G = ( 3.535 * a + 2.181 * a * a ) / ( 1.0 + 2.276 * a + 2.577 * a * a );",
    "return G;",
    "}",
    "float SmithGeometryFactor2( float dotLN, vec3 V, vec3 N, float shininess ) {",
    "float dotNV = max( dot( N, V ), 0.0 );",
    "float a = 1.0 / ( sqrt( 0.7854 * shininess + 1.571 ) );",
    "return 1.0 / ( ( dotLN * ( 1.0 - a ) + a ) * ( dotNV * ( 1.0 - a ) + a ) );",
    "}",
    "float KelemenGeometryFactor( float dotLH ) {",
    "return 1.0 / ( dotLH * dotLH );",
    "}",
    "float GGX_SchlickGeometryFactor_V1( in float k, in float dotNX ) {",
    "return dotNX / ( dotNX * ( 1.0 - k ) + k );",
    "}",
    "float GGX_SchlickGeometryFactor_V2( in float k, in float dotNX ) {",
    "return 1.0 / ( dotNX + sqrt( k + ( 1.0 - k ) * dotNX * dotNX ) );",
    "}",
    "float GGX_Specular( in float m, in vec3 n, in vec3 h, in vec3 v, in vec3 l ) {",
    "float nDotH = saturate( dot( n, h ) );",
    "float nDotL = saturate( dot( n, l ) );",
    "float nDotV = saturate( dot( n, v ) );",
    "float nDotH2 = nDotH * nDotH;",
    "float m2 = pow( m, 4.0 );",
    "float d = m2 / ( pow( nDotH * nDotH * ( m2 - 1.0 ) + 1.0, 2.0 ) );",
    "float v1i = GGX_SchlickGeometryFactor_V2( m2, nDotL );",
    "float v1o = GGX_SchlickGeometryFactor_V2( m2, nDotV );",
    "float vis = v1i * v1o;",
    "return d * vis;",
    "}",
    "float BlinnPhong_Specular( in float shininess, in float dotLN, in float dotNormalHalf, in vec3 eyeVector, in vec3 normal ) {",
    "float geo = SmithGeometryFactor2( dotLN, eyeVector, normal, shininess );",
    "return geo * max( pow( dotNormalHalf, shininess ), 0.0 );",
    "}",
    "float computeSpecOcclusion( float NdotV, float AO, float roughness ) {",
    "return saturate( pow( NdotV + AO, exp2( -16.0 * roughness - 1.0 ) ) - 1.0 + AO );",
    "}",
    "varying vec3 vViewPosition;",
    "varying vec3 vNormal;",
  ].join("\n")),
  (XG.ShaderChunk.lights_phong_fragment = [
    "#ifdef DOUBLE_SIDED",
    "normal *= ( 2.0 * float( gl_FrontFacing ) - 1.0 );",
    "#endif",
    "#if defined( USE_DISPLACEMENTMAP )",
    "normal = perturbNormalArb( vViewPosition, normal, dHdxy_fwd( displacementMap, uvCoord, displacementNormalScale ) );",
    "#endif",
    "#if defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP )",
    "vec4 normalGlossMap = texture2D( normalMap, uvCoord );",
    "#endif",
    "#if defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP )",
    "normal = perturbNormal2Arb( vViewPosition, normal, normalGlossMap.xyz, uvCoord );",
    "#elif defined( USE_BUMPMAP )",
    "normal = perturbNormalArb( vViewPosition, normal, dHdxy_fwd( bumpMap, uvCoord, bumpScale ) );",
    "#endif",
    "#ifdef USE_BUMPDETAILMAP",
    "normal = perturbNormalArb( vViewPosition, normal, dHdxy_fwd( bumpDetailMap, uvCoord * detailRepeatScale.xy, detailRepeatScale.z ) );",
    "#endif",
    "#if defined( USE_GLOSSMAP )",
    "vec4 glossMap = texture2D( glossMap, uvCoord );",
    "float glossMapValue = exp2( 13.0 * glossMap.x + 1.0 );",
    "#elif defined( USE_NORMALGLOSSMAP )",
    "float glossMapValue = exp2( 13.0 * normalGlossMap.a + 1.0 );",
    "#else",
    "float glossMapValue = 1.0;",
    "#endif",
    "vec3 globalLightFactor = vec3( 0.0 );",
    "#if MAX_IMAGE_LIGHTS > 0 || defined( USE_HEIGHT_FOG )",
    "vec4 vertexPositionWS = viewInverseMatrix * vec4( vertexPosition, 1.0 );",
    "#endif",
    "float shininess = glossMapValue * specular.a;",
    "float specularNormalization = shininess * 0.125 + 0.25;",
    "vec3 specularColor = specular.rgb * specularMapColor;",
    "const float maxShininess = 8192.0;",
    "float gloss = clamp( shininess / maxShininess, 0.0, 1.0 );",
    "float roughness = saturate( sqrt( 8.0 / ( shininess + 7.0 ) ) );",
    "#if defined( WRAP_AROUND ) && defined( WRAP_AROUND_SKIN )",
    "float curvature = length( fwidth( vNormal.xyz ) ) / length( fwidth( vertexPosition.xyz ) );",
    "#endif",
    "#if MAX_POINT_LIGHTS > 0",
    "vec3 pointDiffuse  = vec3( 0.0 );",
    "vec3 pointSpecular = vec3( 0.0 );",
    "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
    "vec3 lightPosition = pointLightPositionVS[ i ];",
    "vec3 lightVector = lightPosition - vViewPosition;",
    "float lightDistance = length( lightVector );",
    "float pointLightDistance = pointLightPars[ i ].x;",
    "float attenuation = 1.0;",
    "if ( pointLightDistance > 0.0 ) {",
    "float cutoff = 0.3;",
    "float denom = lightDistance / pointLightDistance + 1.0;",
    "attenuation = 1.0 / ( denom * denom );",
    "attenuation = ( attenuation - cutoff ) / ( 1.0 - cutoff );",
    "attenuation = max( attenuation, 0.0 );",
    "attenuation *= attenuation;",
    "}",
    "lightVector = lightVector / lightDistance;",
    "float dotLNUnclamped = dot( normal, lightVector );",
    "float dotLN = max( dotLNUnclamped, 0.0 );",
    "#ifdef WRAP_AROUND",
    "#ifdef WRAP_AROUND_SKIN",
    "vec3 pointDiffuseWeight = PSSFitFunction( dot( vNormal, lightVector ), curvature );",
    "#else",
    "float pointDiffuseWeightFull = dotLN;",
    "float pointDiffuseWeightHalf = max( 0.25 * dotLNUnclamped + 0.25, 0.0 );",
    "vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",
    "#endif",
    "#else",
    "float pointDiffuseWeight = dotLN;",
    "#endif",
    "pointDiffuseWeight *= attenuation;",
    "vec3 diffuseTerm = ( diffuse.rgb * pointLightColor[ i ] ) * pointDiffuseWeight;",
    "vec3 specularTerm;",
    "vec3 pointHalfVector = normalize( lightVector + eyeVector );",
    "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
    "#ifdef PHYSICALLY_BASED_SHADING",
    "float dotLH = max( dot( lightVector, pointHalfVector ), 0.0 );",
    "vec3 fresnel = specularColor + ( 1.0 - specularColor ) * pow( 1.0 - dotLH, 5.0 );",
    "#if defined( BRDF_BLINN_PHONG )",
    "specularTerm = attenuation * specularNormalization * BlinnPhong_Specular( shininess, dotLN, pointDotNormalHalf, eyeVector, normal ) * ( fresnel * dotLN ) * pointLightColor[ i ];",
    "#elif defined( BRDF_GGX )",
    "specularTerm = attenuation * GGX_Specular( roughness, normal, pointHalfVector, eyeVector, lightVector ) * ( fresnel * dotLN ) * pointLightColor[ i ];",
    "#endif",
    "#else",
    "float pointSpecularWeight = max( pow( pointDotNormalHalf, shininess ), 0.0 );",
    "specularTerm = attenuation * ( pointSpecularWeight * dotLN ) * ( specularColor * pointLightColor[ i ] );",
    "#endif",
    "#ifdef USE_SHADOWMAP",
    "int shadowIndex = int( pointLightPars[ i ].y );",
    "if ( i == shadowIndex ) {",
    "diffuseTerm  *= occlusion[ POINT_INDEX_OFFSET + i ];",
    "specularTerm *= occlusion[ POINT_INDEX_OFFSET + i ];",
    "}",
    "#endif",
    "pointSpecular += specularTerm;",
    "#ifdef PHYSICALLY_BASED_SHADING",
    "pointDiffuse  += ( 1.0 - fresnel ) * diffuseTerm;",
    "#else",
    "pointDiffuse  += diffuseTerm;",
    "#endif",
    "globalLightFactor += pointLightColor[ i ] * attenuation;",
    "}",
    "#endif",
    "#if MAX_SPHERE_LIGHTS > 0",
    "vec3 sphereDiffuse  = vec3( 0.0 );",
    "vec3 sphereSpecular = vec3( 0.0 );",
    "for ( int i = 0; i < MAX_SPHERE_LIGHTS; i ++ ) {",
    "vec3 lightPosition = sphereLightPositionVS[ i ];",
    "vec3 lightVectorFull = lightPosition - vViewPosition;",
    "float lightDistance = length( lightVectorFull );",
    "float attenuation = 1.0;",
    "float maxDistance = sphereLightPars[ i ].x;",
    "float lightRadius = sphereLightPars[ i ].y;",
    "if ( maxDistance > 0.0 ) {",
    "float cutoff = 0.3;",
    "float denom = lightDistance / maxDistance + 1.0;",
    "attenuation = 1.0 / ( denom * denom );",
    "attenuation = ( attenuation - cutoff ) / ( 1.0 - cutoff );",
    "attenuation = max( attenuation, 0.0 );",
    "attenuation *= attenuation;",
    "}",
    "vec3 lightVector = lightVectorFull / lightDistance;",
    "float dotLNUnclamped = dot( normal, lightVector );",
    "float dotLN = max( dotLNUnclamped, 0.0 );",
    "#ifdef WRAP_AROUND",
    "#ifdef WRAP_AROUND_SKIN",
    "vec3 sphereDiffuseWeight = PSSFitFunction( dot( vNormal, lightVector ), curvature );",
    "#else",
    "float sphereDiffuseWeightFull = dotLN;",
    "float sphereDiffuseWeightHalf = max( 0.25 * dotLNUnclamped + 0.25, 0.0 );",
    "vec3 sphereDiffuseWeight = mix( vec3( sphereDiffuseWeightFull ), vec3( sphereDiffuseWeightHalf ), wrapRGB );",
    "#endif",
    "#else",
    "float sphereDiffuseWeight = dotLN;",
    "#endif",
    "sphereDiffuseWeight *= attenuation;",
    "vec3 diffuseTerm = ( diffuse.rgb * sphereLightColor[ i ] ) * sphereDiffuseWeight;",
    "vec3 specularTerm;",
    "vec3 reflectVS1 = reflect( eyeVector, normal );",
    "vec3 centerToRay = lightVectorFull - dot( lightVectorFull, reflectVS1 ) * reflectVS1;",
    "vec3 closestPoint = lightVectorFull - centerToRay * saturate( lightRadius / length( centerToRay ) );",
    "lightVector = normalize( closestPoint );",
    "dotLN = max( dot( lightVector, normal ), 0.0 );",
    "float alpha = roughness * roughness;",
    "float alphaPrime = saturate( alpha + 0.5 * saturate( lightRadius / lightDistance ) );",
    "float sphereNormalization = alpha / alphaPrime;",
    "sphereNormalization *= sphereNormalization;",
    "vec3 sphereHalfVector = normalize( lightVector + eyeVector );",
    "float sphereDotNormalHalf = max( dot( normal, sphereHalfVector ), 0.0 );",
    "#ifdef PHYSICALLY_BASED_SHADING",
    "float dotLH = max( dot( lightVector, sphereHalfVector ), 0.0 );",
    "vec3 fresnel = specularColor + ( 1.0 - specularColor ) * pow( 1.0 - dotLH, 5.0 );",
    "#if defined( BRDF_BLINN_PHONG )",
    "specularTerm = sphereNormalization * attenuation * BlinnPhong_Specular( shininess, dotLN, sphereDotNormalHalf, eyeVector, normal ) * ( fresnel * dotLN ) * sphereLightColor[ i ];",
    "#elif defined( BRDF_GGX )",
    "specularTerm = sphereNormalization * attenuation * GGX_Specular( roughness, normal, sphereHalfVector, eyeVector, lightVector ) * ( fresnel * dotLN ) * sphereLightColor[ i ];",
    "#endif",
    "#else",
    "float sphereSpecularWeight = max( pow( sphereDotNormalHalf, shininess ), 0.0 );",
    "specularTerm = attenuation * ( sphereSpecularWeight * dotLN ) * ( specularColor * sphereLightColor[ i ] );",
    "#endif",
    "#ifdef USE_SHADOWMAP",
    "int shadowIndex = int( sphereLightPars[ i ].z );",
    "if ( i == shadowIndex ) {",
    "diffuseTerm  *= occlusion[ SPHERE_INDEX_OFFSET + i ];",
    "specularTerm *= occlusion[ SPHERE_INDEX_OFFSET + i ];",
    "}",
    "#endif",
    "sphereSpecular += specularTerm;",
    "#ifdef PHYSICALLY_BASED_SHADING",
    "sphereDiffuse  += ( 1.0 - fresnel ) * diffuseTerm;",
    "#else",
    "sphereDiffuse  += diffuseTerm;",
    "#endif",
    "globalLightFactor += sphereLightColor[ i ] * attenuation;",
    "}",
    "#endif",
    "#if MAX_TUBE_LIGHTS > 0",
    "vec3 tubeDiffuse  = vec3( 0.0 );",
    "vec3 tubeSpecular = vec3( 0.0 );",
    "for ( int i = 0; i < MAX_TUBE_LIGHTS; i ++ ) {",
    "vec3 lightPosition0 = tubeLightPosition0VS[ i ];",
    "vec3 lightPosition1 = tubeLightPosition1VS[ i ];",
    "float attenuation = 1.0;",
    "float maxDistance = tubeLightPars[ i ].x;",
    "float lightRadius = tubeLightPars[ i ].y;",
    "vec3 lightVector0 = lightPosition0 - vertexPosition;",
    "vec3 lightVector1 = lightPosition1 - vertexPosition;",
    "float length0 = length( lightVector0 );",
    "float length1 = length( lightVector1 );",
    "float a = saturate( 0.5 * ( dot( normal, lightVector0 ) / length0 + dot( normal, lightVector1 ) / length1 ) );",
    "float b = ( length0 * length1 + dot( lightVector0, lightVector1 ) ) * 0.5 + 1.0;",
    "float dotLN = a;",
    "vec3 tubeDiffuseWeight = vec3( dotLN );",
    "vec3 diffuseTerm = ( diffuse.rgb * tubeLightColor[ i ] ) * tubeDiffuseWeight;",
    "vec3 reflectVS1 = reflect( eyeVector, normal );",
    "vec3 lightVectorD = lightVector1 - lightVector0;",
    "float lengthD = length( lightVectorD );",
    "float dotRD = dot( reflectVS1, lightVectorD );",
    "float ta = dot( reflectVS1, lightVector0 ) * dotRD - dot( lightVector0, lightVectorD );",
    "float tb = lengthD * lengthD - dotRD * dotRD;",
    "float t = ta / tb;",
    "vec3 closestPoint = lightVector0 + saturate( t ) * lightVectorD;",
    "vec3 lightVectorClosest = closestPoint;",
    "vec3 centerToRay = lightVectorClosest - dot( lightVectorClosest, reflectVS1 ) * reflectVS1;",
    "closestPoint = lightVectorClosest - centerToRay * saturate( lightRadius / length( centerToRay ) );",
    "vec3 lightVector = normalize( closestPoint );",
    "vec3 lightVectorFull = ( lightPosition0 + lightPosition1 ) * 0.5 - vertexPosition.xyz;",
    "float distance = length( lightVectorFull );",
    "float alpha = roughness * roughness;",
    "float alphaPrime = saturate( alpha + 0.5 * saturate( lightRadius / distance ) );",
    "float sphereNormalization = alpha / alphaPrime;",
    "sphereNormalization *= sphereNormalization;",
    "float alphaPrimeLine = saturate( alpha + 0.5 * saturate( lengthD / distance ) );",
    "float lineNormalization = alpha / alphaPrimeLine;",
    "float tubeNormalization = sphereNormalization * lineNormalization;",
    "if ( maxDistance > 0.0 ) {",
    "attenuation = 1.0 / b;",
    "}",
    "vec3 sphereHalfVector = normalize( lightVector + eyeVector );",
    "float sphereDotNormalHalf = max( dot( normal, sphereHalfVector ), 0.0 );",
    "#ifdef PHYSICALLY_BASED_SHADING",
    "float dotLH = max( dot( lightVector, sphereHalfVector ), 0.0 );",
    "vec3 fresnel = specularColor + ( 1.0 - specularColor ) * pow( 1.0 - dotLH, 5.0 );",
    "#if defined( BRDF_BLINN_PHONG )",
    "tubeSpecular += tubeNormalization * attenuation * BlinnPhong_Specular( shininess, dotLN, sphereDotNormalHalf, eyeVector, normal ) * ( fresnel * dotLN ) * tubeLightColor[ i ];",
    "#elif defined( BRDF_GGX )",
    "tubeSpecular += tubeNormalization * attenuation * GGX_Specular( roughness, normal, sphereHalfVector, eyeVector, lightVector ) * ( fresnel * dotLN ) * tubeLightColor[ i ];",
    "#endif",
    "#else",
    "float sphereSpecularWeight = max( pow( sphereDotNormalHalf, shininess ), 0.0 );",
    "sphereSpecular += attenuation * ( sphereSpecularWeight * dotLN ) * ( specularColor * sphereLightColor[ i ] );",
    "#endif",
    "#ifdef PHYSICALLY_BASED_SHADING",
    "tubeDiffuse  += ( 1.0 - fresnel ) * diffuseTerm * attenuation;",
    "#else",
    "tubeDiffuse  += diffuseTerm * attenuation;",
    "#endif",
    "globalLightFactor += tubeLightColor[ i ] * attenuation;",
    "}",
    "#endif",
    "#if MAX_SPOT_LIGHTS > 0",
    "vec3 spotDiffuse  = vec3( 0.0 );",
    "vec3 spotSpecular = vec3( 0.0 );",
    "for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
    "vec3 lightPosition = spotLightPositionVS[ i ];",
    "vec3 lightVector = lightPosition - vViewPosition;",
    "float lightDistance = length( lightVector );",
    "float spotLightAngleCos = spotLightPars[ i ].x;",
    "float spotLightExponent = spotLightPars[ i ].y;",
    "float spotLightDistance = spotLightPars[ i ].z;",
    "float attenuation = 1.0;",
    "if ( spotLightDistance > 0.0 )",
    "attenuation = 1.0 - min( lightDistance / spotLightDistance, 1.0 );",
    "lightVector = lightVector / lightDistance;",
    "float rho = dot( spotLightDirectionVS[ i ], lightVector );",
    "if ( rho > spotLightAngleCos ) {;",
    "float theta = spotLightAngleCos + 0.0001;",
    "float phi = spotLightAngleCos + 0.05;",
    "const float falloff = 4.0;",
    "float spotEffect = 0.0;",
    "if ( rho >= phi ) {",
    "spotEffect = 1.0;",
    "} else if ( rho <= theta ) {",
    "spotEffect = 0.0;",
    "} else { ",
    "spotEffect = pow( ( rho - theta ) / ( phi - theta ), falloff );",
    "}",
    "attenuation *= spotEffect;",
    "float dotLNUnclamped = dot( normal, lightVector );",
    "float dotLN = max( dotLNUnclamped, 0.0 );",
    "#ifdef WRAP_AROUND",
    "#ifdef WRAP_AROUND_SKIN",
    "vec3 spotDiffuseWeight = PSSFitFunction( dot( vNormal, lightVector ), curvature );",
    "#else",
    "float spotDiffuseWeightFull = dotLN;",
    "float spotDiffuseWeightHalf = max( 0.25 * dotLNUnclamped + 0.25, 0.0 );",
    "vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",
    "#endif",
    "#else",
    "float spotDiffuseWeight = dotLN;",
    "#endif",
    "spotDiffuseWeight *= attenuation;",
    "vec3 diffuseTerm = spotDiffuseWeight * ( diffuse.rgb * spotLightColor[ i ] );",
    "vec3 spotHalfVector = normalize( lightVector + eyeVector );",
    "float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
    "#ifdef PHYSICALLY_BASED_SHADING",
    "float dotLH = max( dot( lightVector, spotHalfVector ), 0.0 );",
    "vec3 fresnel = specularColor + ( 1.0 - specularColor ) * pow( 1.0 - dotLH, 5.0 );",
    "#if defined( BRDF_BLINN_PHONG )",
    "vec3 specularTerm = attenuation * specularNormalization * BlinnPhong_Specular( shininess, dotLN, spotDotNormalHalf, eyeVector, normal ) * ( fresnel * dotLN ) * spotLightColor[ i ];",
    "#elif defined( BRDF_GGX )",
    "vec3 specularTerm = attenuation * GGX_Specular( roughness, normal, spotHalfVector, eyeVector, lightVector ) * ( fresnel * dotLN ) * spotLightColor[ i ];",
    "#endif",
    "#else",
    "float spotSpecularWeight = max( pow( spotDotNormalHalf, shininess ), 0.0 );",
    "vec3 specularTerm = attenuation * ( spotSpecularWeight * dotLN ) * ( specularColor * spotLightColor[ i ] );",
    "#endif",
    "#ifdef USE_SHADOWMAP",
    "int shadowIndex = int( spotLightPars[ i ].w );",
    "if ( i == shadowIndex ) {",
    "diffuseTerm  *= occlusion[ SPOT_INDEX_OFFSET + i ];",
    "specularTerm *= occlusion[ SPOT_INDEX_OFFSET + i ];",
    "}",
    "#endif",
    "#ifdef PHYSICALLY_BASED_SHADING",
    "spotDiffuse  += ( 1.0 - fresnel ) * diffuseTerm;",
    "#else",
    "spotDiffuse  += diffuseTerm;",
    "#endif",
    "spotSpecular += specularTerm;",
    "globalLightFactor += spotLightColor[ i ] * attenuation;",
    "}",
    "}",
    "#endif",
    "#if MAX_DIR_LIGHTS > 0",
    "vec3 dirDiffuse  = vec3( 0.0 );",
    "vec3 dirSpecular = vec3( 0.0 );",
    "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",
    "vec3 lightDirection = directionalLightDirectionVS[ i ];",
    "vec3 lightVector = normalize( lightDirection );",
    "float dotLNUnclamped = dot( normal, lightVector );",
    "float dotLN = max( dotLNUnclamped, 0.0 );",
    "#ifdef WRAP_AROUND",
    "#ifdef WRAP_AROUND_SKIN",
    "vec3 dirDiffuseWeight = PSSFitFunction( dot( vNormal, lightVector ), curvature );",
    "#else",
    "float dirDiffuseWeightFull = dotLN;",
    "float dirDiffuseWeightHalf = max( 0.25 * dotLNUnclamped + 0.25, 0.0 );",
    "vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",
    "#endif",
    "#else",
    "float dirDiffuseWeight = dotLN;",
    "#endif",
    "vec3 diffuseTerm = diffuse.rgb * directionalLightColor[ i ] * dirDiffuseWeight;",
    "vec3 dirHalfVector = normalize( lightVector + eyeVector );",
    "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
    "#ifdef PHYSICALLY_BASED_SHADING",
    "float dotLH = max( dot( lightVector, dirHalfVector ), 0.0 );",
    "vec3 fresnel = specularColor + ( 1.0 - specularColor ) * pow( 1.0 - dotLH, 5.0 );",
    "#if defined( BRDF_BLINN_PHONG )",
    "vec3 specularTerm = specularNormalization * BlinnPhong_Specular( shininess, dotLN, dirDotNormalHalf, eyeVector, normal ) * ( fresnel * dotLN ) * directionalLightColor[ i ];",
    "#elif defined( BRDF_GGX )",
    "vec3 specularTerm = GGX_Specular( roughness, normal, dirHalfVector, eyeVector, lightVector ) * ( fresnel * dotLN ) * directionalLightColor[ i ];",
    "#endif",
    "#else",
    "float dirSpecularWeight = max( pow( dirDotNormalHalf, shininess ), 0.0 );",
    "vec3 specularTerm = ( dirSpecularWeight * dotLN ) * ( specularColor * directionalLightColor[ i ] );",
    "#endif",
    "#ifdef USE_SHADOWMAP",
    "int shadowIndex = directionalLightPars[ i ];",
    "if ( i == shadowIndex ) {",
    "diffuseTerm  *= occlusion[ DIR_INDEX_OFFSET + i ];",
    "specularTerm *= occlusion[ DIR_INDEX_OFFSET + i ];",
    "}",
    "#endif",
    "#ifdef PHYSICALLY_BASED_SHADING",
    "dirDiffuse  += ( 1.0 - fresnel ) * diffuseTerm;",
    "#else",
    "dirDiffuse  += diffuseTerm;",
    "#endif",
    "dirSpecular += specularTerm;",
    "globalLightFactor += directionalLightColor[ i ];",
    "}",
    "#endif",
    "#if MAX_HEMI_LIGHTS > 0",
    "vec3 hemiDiffuse  = vec3( 0.0 );",
    "vec3 hemiSpecular = vec3( 0.0 );",
    "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
    "vec3 lightDirection = hemisphereLightDirectionVS[ i ];",
    "vec3 lightVector = normalize( lightDirection.xyz );",
    "vec3 halfVector = normalize( lightVector + eyeVector );",
    "vec3 fresnelHemi = EnvironmentBRDF( gloss, dot( eyeVector, halfVector ), specularColor );",
    "float dotProductHemi = dot( normal, lightVector );",
    "float hemiDiffuseWeightUnclamped = 0.5 * dotProductHemi;",
    "float hemiDiffuseWeight = clamp( hemiDiffuseWeightUnclamped, 0.0, 1.0 );",
    "#ifdef WRAP_AROUND",
    "float hemiDiffuseWeightUnclamped2 = -0.5 * dotProductHemi + 0.5;",
    "float hemiDiffuseWeight2 = clamp( hemiDiffuseWeightUnclamped2, 0.0, 1.0 );",
    "vec3 diffuseHemi = 0.75 * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight ) + 0.25 * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight2 );",
    "#else",
    "vec3 diffuseHemi = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
    "#endif",
    "diffuseHemi *= ( 1.0 - fresnelHemi );",
    "vec3 R = reflect( -eyeVector, normal );",
    "R = normalize( R );",
    "float hemiSpecularWeight = clamp( dot( R, lightVector ) * 0.5 + 0.5, 0.0, 1.0 );",
    "vec3 specularHemi = fresnelHemi * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiSpecularWeight );",
    "hemiDiffuse += diffuse.rgb * diffuseHemi;",
    "hemiSpecular += specularHemi;",
    "globalLightFactor += hemisphereLightSkyColor[ i ];",
    "}",
    "#endif",
    "#if MAX_AREA_LIGHTS > 0",
    "vec3 areaDiffuse  = vec3( 0.0 );",
    "vec3 areaSpecular = vec3( 0.0 );",
    "for( int i = 0; i < MAX_AREA_LIGHTS; i ++ ) {",
    "float w = areaLightPars[ i ].x;",
    "float h = areaLightPars[ i ].y;",
    "vec3 proj = projectOnPlane( vertexPosition, areaLightPosition[ i ], areaLightNormal[ i ] );",
    "vec3 dir = proj - areaLightPosition[ i ];",
    "vec2 diagonal = vec2( dot( dir, areaLightRight[ i ] ), dot( dir, areaLightUp[ i ] ) );",
    "vec2 nearest2D = vec2( clamp( diagonal.x, -w, w ), clamp( diagonal.y, -h, h ) );",
    "vec3 nearestPointInside = areaLightPosition[ i ] + ( areaLightRight[ i ] * nearest2D.x + areaLightUp[ i ] * nearest2D.y );",
    "vec3 lightDir = normalize( nearestPointInside - vertexPosition );",
    "float NdotL = max( dot( areaLightNormal[ i ], -lightDir ), 0.0 );",
    "float NdotL2 = max( dot( normal, lightDir ), 0.0 );",
    "float dotLN = sqrt( NdotL * NdotL2 );",
    "vec3 areaDiffuseWeight = vec3( dotLN );",
    "#ifdef WRAP_AROUND",
    "if ( NdotL > 0.0 ) {",
    "#ifdef WRAP_AROUND_SKIN",
    "areaDiffuseWeight = PSSFitFunction( sqrt( NdotL * dot( vNormal, lightDir ) ), curvature );",
    "#else",
    "float dotLNHalf = max( 0.25 * dotLN + 0.25, 0.0 );",
    "areaDiffuseWeight = mix( areaDiffuseWeight, vec3( dotLNHalf ), wrapRGB );",
    "#endif",
    "}",
    "#endif",
    "float dist = distance( vertexPosition, nearestPointInside );",
    "float attenuation = calculateAttenuation( dist, areaLightAttenuation[ i ].x, areaLightAttenuation[ i ].y, areaLightAttenuation[ i ].z );",
    "areaDiffuseWeight *= attenuation;",
    "vec3 areaDiffuseTerm = areaDiffuseWeight * ( diffuse.rgb * areaLightColor[ i ] );",
    "#ifdef AREA_TEXTURE",
    "if ( areaLightPars[ i ].z > 0.0 ) {",
    "float d = distance( vertexPosition, nearestPointInside );",
    "vec2 co = ( diagonal.xy + vec2( w, h ) ) / ( 2.0 * vec2( w, h ) );",
    "co.y = 1.0 - co.y;",
    "vec3 ve = vertexPosition - areaLightPosition[ i ];",
    "vec4 diff = vec4( 0.0 );",
    "if ( dot( ve, areaLightNormal[ i ] ) < 0.0 ) {",
    "diff = vec4( 0.0 );",
    "} else {",
    "float lod = max( pow( d, 0.1 ), 0.0 ) * 5.0;",
    "vec4 t00 = texture2D( areaLightTexture[ i ], co, lod );",
    "vec4 t01 = texture2D( areaLightTexture[ i ], co, lod + 1.0 );",
    "diff = mix( t00, t01, 0.5 );",
    "}",
    "areaDiffuseTerm *= diff.xyz;",
    "}",
    "#endif",
    "vec3 areaSpecularTerm = vec3( 0.0 );",
    "vec3 fresnel = vec3( 0.0 );",
    "vec3 R = reflect( eyeVector, normal );",
    "vec3 E = linePlaneIntersect( vertexPosition, R, areaLightPosition[ i ], areaLightNormal[ i ] );",
    "float specAngle = dot( R, areaLightNormal[ i ] );",
    "if ( dot( vertexPosition - areaLightPosition[ i ], areaLightNormal[ i ] ) >= 0.0 && specAngle > 0.0 ) {",
    "vec3 dirSpec = E - areaLightPosition[ i ];",
    "vec2 dirSpec2D = vec2( dot( dirSpec, areaLightRight[ i ] ), dot( dirSpec, areaLightUp[ i ] ) );",
    "vec2 nearestSpec2D = vec2( clamp( dirSpec2D.x, -w, w ), clamp( dirSpec2D.y, -h, h ) );",
    "vec3 nearestPointInsideSpec = areaLightPosition[ i ] + ( areaLightRight[ i ] * nearestSpec2D.x + areaLightUp[ i ] * nearestSpec2D.y );",
    "vec3 lightDirSpec = normalize( nearestPointInsideSpec - vertexPosition );",
    "vec3 halfVectorSpec = normalize( lightDirSpec + eyeVector );",
    "float dotNormalHalf = max( dot( normal, halfVectorSpec ), 0.0 );",
    "float dotLH = max( dot( lightDirSpec, halfVectorSpec ), 0.0 );",
    "fresnel = specularColor + ( 1.0 - specularColor ) * pow( 1.0 - dotLH, 5.0 );",
    "#if defined( BRDF_BLINN_PHONG )",
    "areaSpecularTerm = specularNormalization * BlinnPhong_Specular( shininess, dotLN, dotNormalHalf, eyeVector, normal ) * ( fresnel * areaDiffuseWeight ) * specAngle * areaLightColor[ i ];",
    "#elif defined( BRDF_GGX )",
    "areaSpecularTerm = GGX_Specular( roughness, normal, halfVectorSpec, eyeVector, lightDirSpec ) * ( fresnel * areaDiffuseWeight ) * specAngle * areaLightColor[ i ];",
    "#endif",
    "#ifdef AREA_TEXTURE",
    "if ( areaLightPars[ i ].z > 0.0 ) {",
    "float areaHard = 16.0;",
    "float areaGloss = 16.0;",
    "vec3 specPlane = areaLightPosition[ i ] + ( areaLightRight[ i ] * dirSpec2D.x + areaLightUp[ i ] * dirSpec2D.y );",
    "float dist = max( distance( vertexPosition, specPlane ), 0.0 );",
    "float d = ( ( 1.0 / areaHard ) / 2.0 ) * ( dist / areaGloss );",
    "w = max( w, 0.0 );",
    "h = max( h, 0.0 );",
    "vec2 co = dirSpec2D / ( d + 1.0 );",
    "co /= 2.0 * vec2( w, h );",
    "co = co + vec2( 0.5 );",
    "co.y = 1.0 - co.y;",
    "float lod = ( 2.0 / areaHard * max( dist, 0.0 ) );",
    "vec4 t00 = texture2D( areaLightTexture[ i ], co, lod );",
    "vec4 t01 = texture2D( areaLightTexture[ i ], co, lod + 1.0 );",
    "vec4 spec = mix( t00, t01, 0.5 );",
    "areaSpecularTerm *= spec.xyz;",
    "}",
    "#endif",
    "}",
    "#ifdef USE_SHADOWMAP",
    "int shadowIndex = int( areaLightPars[ i ].w );",
    "if ( i == shadowIndex ) {",
    "areaDiffuseTerm  *= occlusion[ AREA_INDEX_OFFSET + i ];",
    "areaSpecularTerm *= occlusion[ AREA_INDEX_OFFSET + i ];",
    "}",
    "#endif",
    "areaDiffuse  += ( 1.0 - fresnel * specAngle ) * areaDiffuseTerm;",
    "areaSpecular += areaSpecularTerm;",
    "globalLightFactor += areaLightColor[ i ] * attenuation;",
    "}",
    "#endif",
    "#if  MAX_IMAGE_LIGHTS > 0 || defined( TRANSPARENT )",
    "vec3 fresnelEnv = EnvironmentBRDF( gloss, dot( eyeVector, normal ), specularColor );",
    "#endif",
    "#if MAX_IMAGE_LIGHTS > 0",
    "vec3 imageDiffuse  = vec3( 0.0 );",
    "vec3 imageSpecular = vec3( 0.0 );",
    "vec3 reflectVS = reflect( -eyeVector, normal );",
    "vec4 reflectWS = viewInverseMatrix * vec4( reflectVS, 0.0 );",
    "vec4 normalWS = viewInverseMatrix * vec4( normal, 0.0 );",
    "for( int i = 0; i < MAX_IMAGE_LIGHTS; i ++ ) {",
    "float maxMipSpecular = imageLightPars[ i ].x;",
    "float lightIntensity = imageLightPars[ i ].y;",
    "float lightLocal 	  = abs( imageLightPars[ i ].z ) - 1.0;",
    "float fixSeams		  = sign( imageLightPars[ i ].z );",
    "float samplerSize 	  = imageLightPars[ i ].w;",
    "float encodingType   = abs( imageLightSize[ i ].w ) - 1.0;",
    "float encodingGamma  = sign( imageLightSize[ i ].w );",
    "float localFade = 1.0;",
    "if ( lightLocal > 0.0 ) {",
    "vec3 lightPositionWS = imageLightPositionWS[ i ];",
    "vec3 lightSize = imageLightSize[ i ].xyz;",
    "vec3 BoxMin = lightPositionWS - lightSize;",
    "vec3 BoxMax = lightPositionWS + lightSize;",
    "vec3 FirstPlaneIntersect = ( BoxMax - vertexPositionWS.xyz ) / reflectWS.xyz;",
    "vec3 SecondPlaneIntersect = ( BoxMin - vertexPositionWS.xyz ) / reflectWS.xyz;",
    "vec3 FurthestPlane = max( FirstPlaneIntersect, SecondPlaneIntersect );",
    "float Distance = min( min( FurthestPlane.x, FurthestPlane.y ), FurthestPlane.z );",
    "vec3 IntersectPositionWS = vertexPositionWS.xyz + reflectWS.xyz * Distance;",
    "reflectWS.xyz = IntersectPositionWS - lightPositionWS;",
    "vec3 lightVectorWS = abs( lightPositionWS.xyz - vertexPositionWS.xyz );",
    "if ( lightVectorWS.x > lightSize.x || lightVectorWS.y > lightSize.y || lightVectorWS.z > lightSize.z ) {",
    "localFade = 0.0;",
    "} else {",
    "vec3 normLength = lightVectorWS / lightSize;",
    "float maxLength = max( normLength.x, max( normLength.y, normLength.z ) );",
    "localFade = max( 1.0 - maxLength, 0.0 );",
    "}",
    "}",
    "vec3 cubeCoord = reflectWS.xyz;",
    "float maxMipLevel = maxMipSpecular - 2.0;",
    "#ifdef SUPPORTS_TEXTURE_LOD",
    "float mipLod = 0.0;",
    "if ( encodingType > 0.0 ) {",
    "mipLod = ( maxMipLevel - 1.0 ) * ( 1.0 - gloss );",
    "} else {",
    "mipLod = max( ( maxMipLevel * ( 1.0 - gloss ) ), 1.5 );",
    "}",
    "if ( fixSeams > 0.0 ) {",
    "cubeCoord = fix_cube_lookup( cubeCoord, mipLod, samplerSize );",
    "}",
    "float cubeCurvature = length( fwidth( cubeCoord ) );",
    "mipLod += cubeCurvature * 0.01;",
    "vec4 cubeColorSpecularSample = textureCubeLodEXT( imageLightTextureSpecular[ i ], cubeCoord, mipLod );",
    "#else",
    "const float mipUnit = 255.0 / 16.0;",
    "float mipLevelMinification = mipUnit * textureCube( imageLightTextureMip[ i ], cubeCoord ).a;",
    "float mipLevelMagnification = mipUnit * textureCube( imageLightTextureMip[ i ], cubeCoord, maxMipSpecular - 1.0 ).a;",
    "float mipLevel;",
    "if ( mipLevelMinification == 0.0 ) {",
    "mipLevel = mipLevelMagnification - ( maxMipSpecular - 1.0 );",
    "} else {",
    "mipLevel = mipLevelMinification;",
    "}",
    "float mipBias = 0.0;",
    "if ( encodingType > 0.0 ) {",
    "mipBias = max( ( maxMipLevel - 1.0 ) * ( 1.0 - gloss ) - mipLevel, -3.0 );",
    "} else {",
    "mipBias = max( ( maxMipLevel * ( 1.0 - gloss ) ) - mipLevel, 0.0 );",
    "}",
    "if ( fixSeams > 0.0 ) {",
    "cubeCoord = fix_cube_lookup( cubeCoord, mipLevel, samplerSize );",
    "}",
    "vec4 cubeColorSpecularSample = textureCube( imageLightTextureSpecular[ i ], cubeCoord, mipBias );",
    "#endif",
    "vec4 cubeColorDiffuseSample = textureCube( imageLightTextureDiffuse[ i ], normalWS.xyz );",
    "vec3 cubeColorSpecular = cubeColorSpecularSample.rgb;",
    "vec3 cubeColorDiffuse = cubeColorDiffuseSample.rgb;",
    "if ( encodingType == 1.0 ) {",
    "cubeColorSpecular *= cubeColorSpecularSample.a * 5.0;",
    "cubeColorDiffuse *= cubeColorDiffuseSample.a * 5.0;",
    "}",
    "if ( encodingGamma > 0.0 ) {",
    "cubeColorSpecular *= cubeColorSpecular;",
    "cubeColorDiffuse *= cubeColorDiffuse;",
    "}",
    "imageSpecular += localFade * lightIntensity * cubeColorSpecular * fresnelEnv;",
    "imageDiffuse += localFade * lightIntensity * cubeColorDiffuse * ( 1.0 - fresnelEnv ) * diffuse.rgb;",
    "globalLightFactor += cubeColorDiffuse[ i ] * lightIntensity;",
    "}",
    "#endif",
    "#if MAX_POLY_LIGHTS > 0",
    "vec3 polyDiffuse  = vec3( 0.0 );",
    "vec3 polySpecular = vec3( 0.0 );",
    "vec3 lightPoints[ 4 ];",
    "float dotNV = dot( normal, eyeVector );",
    "float theta = acos( dotNV );",
    "vec2 uvBase = vec2( roughness, theta / ( 0.5 * PI ) );",
    "vec2 uv64 = uvBase * LUT_SCALE64 + LUT_BIAS64;",
    "vec2 uv32 = uvBase * LUT_SCALE32 + LUT_BIAS32;",
    "vec4 tMat = texture2D( samplerLtcMat, uv64 );",
    "mat3 MinvInitSpecular = mat3(",
    "vec3(   1,   0, tMat.y ),",
    "vec3(   0, tMat.z,   0 ),",
    "vec3( tMat.w,   0, tMat.x )",
    ");",
    "mat3 MinvInitDiffuse = mat3( 1.0 );",
    "mat3 orthoBasis = computeOrthoBasis( dotNV, normal, eyeVector );",
    "MinvInitSpecular = mul( MinvInitSpecular, orthoBasis );",
    "MinvInitDiffuse = mul( MinvInitDiffuse, orthoBasis );",
    "mat3 MinvSpecular;",
    "mat3 MinvDiffuse;",
    "vec4 schlick = texture2D( samplerLtcMag, uv32 );",
    "#if __VERSION__ < 300",
    "vec3 specIntensity = specularColor * schlick.x + ( 1.0 - specularColor ) * schlick.w;",
    "#else",
    "vec3 specIntensity = specularColor * schlick.x + ( 1.0 - specularColor ) * schlick.y;",
    "#endif",
    "for( int i = 0; i < MAX_POLY_LIGHTS; i ++ ) {",
    "bool lightTwoSided = bool( polyLightPars[ i ].x );",
    "lightPoints[ 0 ] = polyLightPoints[ i * 4 ];",
    "lightPoints[ 1 ] = polyLightPoints[ i * 4 + 1 ];",
    "lightPoints[ 2 ] = polyLightPoints[ i * 4 + 2 ];",
    "lightPoints[ 3 ] = polyLightPoints[ i * 4 + 3 ];",
    "MinvSpecular = MinvInitSpecular;",
    "MinvDiffuse = MinvInitDiffuse;",
    "#ifdef POLY_TEXTURE",
    "float texSize = polyLightTexturePars[ i ].x;",
    "float texBias = polyLightTexturePars[ i ].y;",
    "vec3 pSpecular = LTC_Evaluate_opt_tex( vertexPosition.xyz, MinvSpecular, lightPoints, lightTwoSided, polyLightTexture[ i ], texSize, texBias );",
    "vec3 pDiffuse  = LTC_Evaluate_opt_tex( vertexPosition.xyz, MinvDiffuse, lightPoints, lightTwoSided, polyLightTexture[ i ], texSize, texBias );",
    "#else",
    "vec3 pSpecular = LTC_Evaluate_opt( vertexPosition.xyz, MinvSpecular, lightPoints, lightTwoSided );",
    "vec3 pDiffuse  = LTC_Evaluate_opt( vertexPosition.xyz, MinvDiffuse, lightPoints, lightTwoSided );",
    "#endif",
    "vec3 polyDiffuseTerm = pDiffuse * polyLightColor[ i ];",
    "vec3 polySpecularTerm = pSpecular * polyLightColor[ i ];",
    "#ifdef USE_SHADOWMAP",
    "int shadowIndex = int( polyLightPars[ i ].y );",
    "if ( i == shadowIndex ) {",
    "polyDiffuseTerm  *= occlusion[ POLY_INDEX_OFFSET + i ];",
    "polySpecularTerm *= occlusion[ POLY_INDEX_OFFSET + i ];",
    "}",
    "#endif",
    "polyDiffuse += polyDiffuseTerm;",
    "polySpecular += polySpecularTerm;",
    "}",
    "polyDiffuse *= diffuse.rgb;",
    "polySpecular *= specIntensity;",
    "polyDiffuse *= ( 1.0 - specIntensity );",
    "polyDiffuse /= 2.0 * PI;",
    "polySpecular /= 2.0 * PI;",
    "#endif",
    "vec3 totalDiffuse = vec3( 0.0 );",
    "vec3 totalSpecular = vec3( 0.0 );",
    "#if MAX_HEMI_LIGHTS > 0 || MAX_IMAGE_LIGHTS > 0",
    "float NdotV = dot( normal, eyeVector );",
    "float specOcclusion = computeSpecOcclusion( NdotV, lightMapIntensity, roughness );",
    "#endif",
    "#if MAX_DIR_LIGHTS > 0",
    "totalDiffuse += dirDiffuse;",
    "totalSpecular += dirSpecular;",
    "#endif",
    "#if MAX_HEMI_LIGHTS > 0",
    "totalDiffuse += hemiDiffuse * lightMapIntensity;",
    "totalSpecular += hemiSpecular * specOcclusion;",
    "#endif",
    "#if MAX_POINT_LIGHTS > 0",
    "totalDiffuse += pointDiffuse;",
    "totalSpecular += pointSpecular;",
    "#endif",
    "#if MAX_SPHERE_LIGHTS > 0",
    "totalDiffuse += sphereDiffuse;",
    "totalSpecular += sphereSpecular;",
    "#endif",
    "#if MAX_TUBE_LIGHTS > 0",
    "totalDiffuse += tubeDiffuse;",
    "totalSpecular += tubeSpecular;",
    "#endif",
    "#if MAX_SPOT_LIGHTS > 0",
    "totalDiffuse += spotDiffuse;",
    "totalSpecular += spotSpecular;",
    "#endif",
    "#if MAX_AREA_LIGHTS > 0",
    "totalDiffuse += areaDiffuse;",
    "totalSpecular += areaSpecular;",
    "#endif",
    "#if MAX_IMAGE_LIGHTS > 0",
    "totalDiffuse += imageDiffuse * lightMapIntensity;",
    "totalSpecular += imageSpecular * specOcclusion;",
    "#endif",
    "#if MAX_POLY_LIGHTS > 0",
    "totalDiffuse += polyDiffuse;",
    "totalSpecular += polySpecular;",
    "#endif",
    "#ifdef TRANSPARENT",
    "float fresnelStrength = length( fresnelEnv );",
    "fresnelStrength = min( fresnelStrength, 1.0 );",
    "float reflection = mix( mgl_FragColor.a, 1.0, fresnelStrength );",
    "mgl_FragColor.a = reflection;",
    "totalDiffuse *= reflection;",
    "#endif",
    "#ifdef METAL",
    "mgl_FragColor.rgb = mgl_FragColor.rgb * ( totalDiffuse + totalSpecular );",
    "#else",
    "mgl_FragColor.rgb = mgl_FragColor.rgb * ( totalDiffuse ) + totalSpecular;",
    "#endif",
    "#ifdef TRANSPARENT",
    "mgl_FragColor.rgb *= mgl_FragColor.a;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.shadowmap_pars_fragment = [
    "#ifdef USE_SHADOWMAP",
    "varying vec4 vShadowCoord[ MAX_SHADOWS ];",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.shadowmap_pars_depth = [
    "#ifdef USE_SHADOWMAP",
    "#if defined( SHADOW_TEXTURE_DEPTH )",
    "float unpackDepthShadow( const in vec4 depth ) {",
    "return depth.x;",
    "}",
    "#elif defined( SHADOW_FLOAT_DEPTH )",
    "float unpackDepthShadow( const in vec4 depth ) {",
    "return depth.x * 0.5 + 0.5;",
    "}",
    "#elif defined( SHADOW_RGBA_DEPTH )",
    "float unpackDepthShadow( const in vec4 rgba_depth ) {",
    "const vec4 bit_shift = vec4( 1.0 / 16777216.0, 1.0 / 65536.0, 1.0 / 256.0, 1.0 );",
    "float depth = dot( rgba_depth, bit_shift );",
    "return depth;",
    "}",
    "#endif",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.shadowmap_pars_point = [
    "#ifdef USE_SHADOWMAP",
    "vec3 cubeToUV( vec3 r ) {",
    "float sc = 0.0;",
    "float tc = 0.0;",
    "float s = 0.0;",
    "float t = 0.0;",
    "float i = 0.0;",
    "float ma = 0.0;",
    "vec3 ar = abs( r );",
    "vec3 sr = sign( r );",
    "if ( ar.x >= ar.y && ar.x >= ar.z ) {",
    "if ( sr.x >= 0.0 ) {",
    "sc = -r.z;",
    "tc = -r.y;",
    "i = 0.0;",
    "} else {",
    "sc = +r.z;",
    "tc = -r.y;",
    "i = 1.0;",
    "}",
    "ma = ar.x;",
    "}",
    "if ( ar.y >= ar.x && ar.y >= ar.z ) {",
    "if ( sr.y >= 0.0 ) {",
    "sc = +r.x;",
    "tc = +r.z;",
    "i = 2.0;",
    "} else {",
    "sc = +r.x;",
    "tc = -r.z;",
    "i = 3.0;",
    "}",
    "ma = ar.y;",
    "}",
    "if ( ar.z >= ar.x && ar.z >= ar.y ) {",
    "if ( sr.z >= 0.0 ) {",
    "sc = +r.x;",
    "tc = -r.y;",
    "i = 4.0;",
    "} else {",
    "sc = -r.x;",
    "tc = -r.y;",
    "i = 5.0;",
    "}",
    "ma = ar.z;",
    "}",
    "s = ( ( sc / ma ) + 1.0 ) / 2.0;",
    "t = ( ( tc / ma ) + 1.0 ) / 2.0;",
    "return vec3( s, t, i );",
    "}",
    "#ifdef USE_SHADOWSAMPLER",
    "float sampleShadowPCFSoftAtlas( sampler2DShadow shadowMap, vec2 shadowMapSize, vec2 shadowCoord, float vertexDepth, vec2 minUV, vec2 maxUV ) {",
    "vec2 pixelOffset = vec2( 1.0 ) / shadowMapSize;",
    "float dx0 = -pixelOffset.x;",
    "float dy0 = -pixelOffset.y;",
    "float dx1 =  pixelOffset.x;",
    "float dy1 =  pixelOffset.y;",
    "float shadowValue = 0.0;",
    "shadowValue += texture( shadowMap, vec3( clamp( shadowCoord + vec2( dx0, dy0 ), minUV, maxUV ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( clamp( shadowCoord + vec2( 0.0, dy0 ), minUV, maxUV ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( clamp( shadowCoord + vec2( dx1, dy0 ), minUV, maxUV ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( clamp( shadowCoord + vec2( dx0, 0.0 ), minUV, maxUV ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( clamp( shadowCoord, minUV, maxUV ),					 vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( clamp( shadowCoord + vec2( dx1, 0.0 ), minUV, maxUV ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( clamp( shadowCoord + vec2( dx0, dy1 ), minUV, maxUV ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( clamp( shadowCoord + vec2( 0.0, dy1 ), minUV, maxUV ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( clamp( shadowCoord + vec2( dx1, dy1 ), minUV, maxUV ), vertexDepth ) );",
    "shadowValue /= 9.0;",
    "return 1.0 - shadowValue;",
    "}",
    "#else",
    "float sampleShadowPCFSoftAtlas( sampler2D shadowMap, vec2 shadowMapSize, vec2 shadowCoord, float vertexDepth, vec2 minUV, vec2 maxUV ) {",
    "vec2 pixelOffset = vec2( 1.0 ) / shadowMapSize;",
    "float dx0 = -pixelOffset.x;",
    "float dy0 = -pixelOffset.y;",
    "float dx1 =  pixelOffset.x;",
    "float dy1 =  pixelOffset.y;",
    "float shadowDepth;",
    "mat3 shadowKernel;",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, clamp( shadowCoord + vec2( dx0, dy0 ), minUV, maxUV ) ) );",
    "shadowKernel[0][0] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, clamp( shadowCoord + vec2( dx0, 0.0 ), minUV, maxUV ) ) );",
    "shadowKernel[0][1] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, clamp( shadowCoord + vec2( dx0, dy1 ), minUV, maxUV ) ) );",
    "shadowKernel[0][2] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, clamp( shadowCoord + vec2( 0.0, dy0 ), minUV, maxUV ) ) );",
    "shadowKernel[1][0] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, clamp( shadowCoord, minUV, maxUV ) ) );",
    "shadowKernel[1][1] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, clamp( shadowCoord + vec2( 0.0, dy1 ), minUV, maxUV ) ) );",
    "shadowKernel[1][2] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, clamp( shadowCoord + vec2( dx1, dy0 ), minUV, maxUV ) ) );",
    "shadowKernel[2][0] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, clamp( shadowCoord + vec2( dx1, 0.0 ), minUV, maxUV ) ) );",
    "shadowKernel[2][1] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, clamp( shadowCoord + vec2( dx1, dy1 ), minUV, maxUV ) ) );",
    "shadowKernel[2][2] = float( vertexDepth > shadowDepth );",
    "shadowKernel *= 0.25;",
    "vec2 fractionalCoord = 1.0 - fract( shadowCoord * shadowMapSize );",
    "shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
    "shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",
    "vec4 shadowValues;",
    "shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
    "shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
    "shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
    "shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",
    "float shadowValue = dot( shadowValues, vec4( 1.0 ) );",
    "return shadowValue;",
    "}",
    "#endif",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.shadowmap_pars_common = [
    XG.ShaderChunk.shadowmap_pars_depth,
    "#ifdef USE_SHADOWMAP",
    "#ifdef USE_SHADOWSAMPLER",
    "uniform sampler2DShadow shadowMap[ MAX_SHADOWS ];",
    "#else",
    "uniform sampler2D shadowMap[ MAX_SHADOWS ];",
    "#endif",
    "uniform vec4 shadowMapPars[ MAX_SHADOWS ];",
    "uniform vec2 shadowCameraPars[ MAX_SHADOWS ];",
    "#ifdef USE_SHADOWSAMPLER",
    "float sampleShadowPCFSoft( sampler2DShadow shadowMap, vec2 shadowMapSize, vec2 shadowCoord, float vertexDepth ) {",
    "vec2 pixelOffset = vec2( 1.0 ) / shadowMapSize;",
    "float dx0 = -pixelOffset.x;",
    "float dy0 = -pixelOffset.y;",
    "float dx1 =  pixelOffset.x;",
    "float dy1 =  pixelOffset.y;",
    "float shadowValue = 0.0;",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( dx0, dy0 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( 0.0, dy0 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( dx1, dy0 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( dx0, 0.0 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord, 				      vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( dx1, 0.0 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( dx0, dy1 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( 0.0, dy1 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( dx1, dy1 ), vertexDepth ) );",
    "shadowValue /= 9.0;",
    "return 1.0 - shadowValue;",
    "}",
    "#else",
    "float sampleShadowPCFSoft( sampler2D shadowMap, vec2 shadowMapSize, vec2 shadowCoord, float vertexDepth ) {",
    "vec2 pixelOffset = vec2( 1.0 ) / shadowMapSize;",
    "float dx0 = -pixelOffset.x;",
    "float dy0 = -pixelOffset.y;",
    "float dx1 =  pixelOffset.x;",
    "float dy1 =  pixelOffset.y;",
    "float shadowDepth;",
    "mat3 shadowKernel;",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, shadowCoord + vec2( dx0, dy0 ) ) );",
    "shadowKernel[0][0] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, shadowCoord + vec2( dx0, 0.0 ) ) );",
    "shadowKernel[0][1] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, shadowCoord + vec2( dx0, dy1 ) ) );",
    "shadowKernel[0][2] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, shadowCoord + vec2( 0.0, dy0 ) ) );",
    "shadowKernel[1][0] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, shadowCoord ) );",
    "shadowKernel[1][1] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, shadowCoord + vec2( 0.0, dy1 ) ) );",
    "shadowKernel[1][2] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, shadowCoord + vec2( dx1, dy0 ) ) );",
    "shadowKernel[2][0] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, shadowCoord + vec2( dx1, 0.0 ) ) );",
    "shadowKernel[2][1] = float( vertexDepth > shadowDepth );",
    "shadowDepth = unpackDepthShadow( texture2D( shadowMap, shadowCoord + vec2( dx1, dy1 ) ) );",
    "shadowKernel[2][2] = float( vertexDepth > shadowDepth );",
    "shadowKernel *= 0.25;",
    "vec2 fractionalCoord = 1.0 - fract( shadowCoord * shadowMapSize );",
    "shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
    "shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",
    "vec4 shadowValues;",
    "shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
    "shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
    "shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
    "shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",
    "float shadowValue = dot( shadowValues, vec4( 1.0 ) );",
    "return shadowValue;",
    "}",
    "#endif",
    "#endif",
    XG.ShaderChunk.shadowmap_pars_point,
  ].join("\n")),
  (XG.ShaderChunk.shadowmap_fragment = [
    "#ifdef USE_SHADOWMAP",
    "float occlusion[ MAX_SHADOWS ];",
    "#ifdef SHADOWMAP_DEBUG",
    "vec3 frustumColors[4];",
    "frustumColors[0] = vec3( 1.0, 0.5, 0.0 );",
    "frustumColors[1] = vec3( 0.0, 1.0, 0.8 );",
    "frustumColors[2] = vec3( 0.0, 0.5, 1.0 );",
    "frustumColors[3] = vec3( 1.0, 0.5, 1.0 );",
    "#endif",
    "#ifdef SHADOWMAP_CASCADE",
    "int inFrustumCount = 0;",
    "float combinedOcclusion = 1.0;",
    "#endif",
    "#if MAX_SHADOWS_2D > 0",
    "float shadowDepth;",
    "for( int i = 0; i < MAX_SHADOWS_2D; i ++ ) {",
    "occlusion[ i ] = 1.0;",
    "vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",
    "vec2 shadowMapSize = shadowMapPars[ i ].xy;",
    "float shadowDarkness = shadowMapPars[ i ].z;",
    "float shadowBias = shadowMapPars[ i ].w;",
    "float vertexDepth = shadowCoord.z;",
    "bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
    "bool inFrustum = all( inFrustumVec );",
    "#ifdef SHADOWMAP_CASCADE",
    "inFrustumCount += int( inFrustum );",
    "bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, vertexDepth <= 1.0 );",
    "#else",
    "bvec2 frustumTestVec = bvec2( inFrustum, vertexDepth <= 1.0 );",
    "#endif",
    "bool frustumTest = all( frustumTestVec );",
    "if ( frustumTest ) {",
    "shadowCoord.z += shadowBias;",
    "#if defined( SHADOWMAP_TYPE_PCF_SOFT )",
    "float shadowValue = sampleShadowPCFSoft( shadowMap[ i ], shadowMapSize, shadowCoord.xy, vertexDepth );",
    "#elif defined( SHADOWMAP_TYPE_PCF_SOFT_HQ )",
    "vec2 pixelOffset = vec2( 2.0 ) / shadowMapSize;",
    "float shadowValue0 = sampleShadowPCFSoft( shadowMap[ i ], shadowMapSize, shadowCoord.xy + vec2( -pixelOffset.x, 0.0 ), vertexDepth );",
    "float shadowValue1 = sampleShadowPCFSoft( shadowMap[ i ], shadowMapSize, shadowCoord.xy + vec2(  pixelOffset.x, 0.0 ), vertexDepth );",
    "float shadowValue2 = sampleShadowPCFSoft( shadowMap[ i ], shadowMapSize, shadowCoord.xy + vec2( 0.0, -pixelOffset.y ), vertexDepth );",
    "float shadowValue3 = sampleShadowPCFSoft( shadowMap[ i ], shadowMapSize, shadowCoord.xy + vec2( 0.0,  pixelOffset.y ), vertexDepth );",
    "float shadowValue = ( shadowValue0 + shadowValue1 + shadowValue2 + shadowValue3 ) * 0.25;",
    "#else",
    "#ifdef USE_SHADOWSAMPLER",
    "float shadowValue = 1.0 - texture( shadowMap[ i ], vec3( shadowCoord.xy, vertexDepth ) );",
    "#else",
    "vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );",
    "float shadowDepth = unpackDepthShadow( rgbaDepth );",
    "float shadowValue = float( vertexDepth > shadowDepth );",
    "#endif",
    "#endif",
    "occlusion[ i ] = 1.0 - shadowDarkness * shadowValue;",
    "#ifdef SHADOWMAP_CASCADE",
    "combinedOcclusion *= occlusion[ i ];",
    "#endif",
    "}",
    "#ifdef SHADOWMAP_DEBUG",
    "#ifdef SHADOWMAP_CASCADE",
    "if ( inFrustum && inFrustumCount == 1 ) mgl_FragColor.xyz *= frustumColors[ i ];",
    "#else",
    "if ( inFrustum ) mgl_FragColor.xyz *= frustumColors[ i ];",
    "#endif",
    "#endif",
    "}",
    "#ifdef SHADOWMAP_CASCADE",
    "occlusion[ DIR_INDEX_OFFSET ] = combinedOcclusion;",
    "#endif",
    "#endif",
    "#if MAX_SHADOWS_CUBE > 0",
    "for( int i = MAX_SHADOWS_2D; i < MAX_SHADOWS; i ++ ) {",
    "vec2 shadowMapSize   = shadowMapPars[ i ].xy;",
    "float shadowDarkness = shadowMapPars[ i ].z;",
    "float shadowBias 	  = shadowMapPars[ i ].w;",
    "float shadowCameraNear = shadowCameraPars[ i ].x;",
    "float shadowCameraFar  = shadowCameraPars[ i ].y;",
    "float pointOcclusion = 1.0;",
    "const vec2 cubeAtlasSize = vec2( 6.0, 1.0 );",
    "const vec2 cubeAtlasSizeInv = vec2( 1.0 / 6.0, 1.0 );",
    "vec3 lightToPosition = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",
    "vec3 shadowCoordCube = normalize( lightToPosition );",
    "float vertexDepth = vectorToDepth( lightToPosition, shadowCameraNear, shadowCameraFar );",
    "vertexDepth += shadowBias;",
    "vec3 shadowCoordStruct = cubeToUV( shadowCoordCube );",
    "vec2 atlasOffset = shadowCoordStruct.z * vec2( 1.0, 0.0 );",
    "#ifdef USE_SHADOWSAMPLER",
    "const float atlasPixelMargin = 0.5;",
    "#else",
    "const float atlasPixelMargin = 0.25;",
    "#endif",
    "vec2 minUV = vec2(   shadowCoordStruct.z         * vec2( 1.0 + atlasPixelMargin/shadowMapSize.x, 0.0 ) ) * cubeAtlasSizeInv;",
    "vec2 maxUV = vec2( ( shadowCoordStruct.z + 1.0 ) * vec2( 1.0 - atlasPixelMargin/shadowMapSize.x, 1.0 ) ) * cubeAtlasSizeInv;",
    "#if defined( SHADOWMAP_TYPE_PCF_SOFT )",
    "float shadowValue = sampleShadowPCFSoftAtlas( shadowMap[ i ], shadowMapSize * cubeAtlasSize, ( shadowCoordStruct.xy + atlasOffset ) * cubeAtlasSizeInv, vertexDepth, minUV, maxUV );",
    "#elif defined( SHADOWMAP_TYPE_PCF_SOFT_HQ )",
    "vec2 pixelOffset = vec2( 2.0 ) / shadowMapSize;",
    "float shadowValue0 = sampleShadowPCFSoftAtlas( shadowMap[ i ], shadowMapSize * cubeAtlasSize, ( shadowCoordStruct.xy + vec2( -pixelOffset.x, 0.0 ) + atlasOffset ) * cubeAtlasSizeInv, vertexDepth, minUV, maxUV );",
    "float shadowValue1 = sampleShadowPCFSoftAtlas( shadowMap[ i ], shadowMapSize * cubeAtlasSize, ( shadowCoordStruct.xy + vec2(  pixelOffset.x, 0.0 ) + atlasOffset ) * cubeAtlasSizeInv, vertexDepth, minUV, maxUV );",
    "float shadowValue2 = sampleShadowPCFSoftAtlas( shadowMap[ i ], shadowMapSize * cubeAtlasSize, ( shadowCoordStruct.xy + vec2( 0.0, -pixelOffset.y ) + atlasOffset ) * cubeAtlasSizeInv, vertexDepth, minUV, maxUV );",
    "float shadowValue3 = sampleShadowPCFSoftAtlas( shadowMap[ i ], shadowMapSize * cubeAtlasSize, ( shadowCoordStruct.xy + vec2( 0.0,  pixelOffset.y ) + atlasOffset ) * cubeAtlasSizeInv, vertexDepth, minUV, maxUV );",
    "float shadowValue = ( shadowValue0 + shadowValue1 + shadowValue2 + shadowValue3 ) * 0.25;",
    "#else",
    "vec2 shadowCoord = clamp( ( shadowCoordStruct.xy + shadowCoordStruct.z * vec2( 1.0, 0.0 ) ) * cubeAtlasSizeInv, minUV, maxUV );",
    "#ifdef USE_SHADOWSAMPLER",
    "float shadowValue = 1.0 - texture( shadowMap[ i ], vec3( shadowCoord, vertexDepth ) );",
    "#else",
    "vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord );",
    "float shadowDepth = unpackDepthShadow( rgbaDepth );",
    "float shadowValue = float( vertexDepth > shadowDepth );",
    "#endif",
    "#endif",
    "pointOcclusion = 1.0 - shadowDarkness * shadowValue;",
    "occlusion[ i ] = pointOcclusion;",
    "}",
    "#endif",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.shadowmap_pars_vertex = [
    "#ifdef USE_SHADOWMAP",
    "varying vec4 vShadowCoord[ MAX_SHADOWS ];",
    "uniform mat4 shadowMatrix[ MAX_SHADOWS ];",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.shadowmap_vertex = [
    "#ifdef USE_SHADOWMAP",
    "for( int i = 0; i < MAX_SHADOWS; i ++ ) {",
    "vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",
    "}",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.alphatest_fragment = [
    "#ifdef ALPHATEST",
    "if ( mgl_FragColor.a < ALPHATEST ) discard;",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.linear_to_gamma_fragment = [
    "#ifdef GAMMA_OUTPUT",
    "mgl_FragColor.xyz = sqrt( mgl_FragColor.xyz );",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.tonemapping_fragment = [
    "#ifdef TONEMAPPING",
    "mgl_FragColor.rgb = applyTonemapping( mgl_FragColor.rgb, brightness, whitePoint );",
    "#endif",
  ].join("\n")),
  (XG.ShaderChunk.dithering_fragment = [
    "#ifdef DITHERING_ENABLED",
    "mgl_FragColor.rgb = applyDithering( mgl_FragColor.rgb, gl_FragCoord.xy );",
    "#endif",
  ].join("\n")),
  (XG.UniformsLib.fog = {
    fogDensity: { type: "f", value: 25e-5, shared: !0 },
    fogNearFar: { type: "v2", value: new XG.Vector2(1, 2e3), shared: !0 },
    fogStartStrength: {
      type: "v2",
      value: new XG.Vector2(100, 0.1),
      shared: !0,
    },
    fogColor: { type: "c", value: new XG.Color(16777215), shared: !0 },
  }),
  (XG.UniformsLib.heightFog = {
    fogHeight: { type: "f", value: -15, shared: !0 },
    fogVisibilityDistance: { type: "f", value: 50, shared: !0 },
    fogFadeSpeed: { type: "f", value: 0.15, shared: !0 },
    fogShallowDepthColor: {
      type: "c",
      value: new XG.Color().setRGB(0.0078, 0.5176, 0.7),
      shared: !0,
    },
    fogDeepDepthColor: {
      type: "c",
      value: new XG.Color().setRGB(0.0039, 0.00196, 0.145),
      shared: !0,
    },
    fogRgbExtinctionDistance: {
      type: "v3",
      value: new XG.Vector3(7, 30, 40),
      shared: !0,
    },
  }),
  (XG.UniformsLib.lights = {
    directionalLightDirectionVS: { type: "fv3", value: [], shared: !0 },
    directionalLightColor: { type: "fv3", value: [], shared: !0 },
    directionalLightPars: { type: "iv1", value: [], shared: !0 },
    hemisphereLightDirectionVS: { type: "fv3", value: [], shared: !0 },
    hemisphereLightSkyColor: { type: "fv3", value: [], shared: !0 },
    hemisphereLightGroundColor: { type: "fv3", value: [], shared: !0 },
    pointLightColor: { type: "fv3", value: [], shared: !0 },
    pointLightPositionVS: { type: "fv3", value: [], shared: !0 },
    pointLightPars: { type: "fv2", value: [], shared: !0 },
    sphereLightColor: { type: "fv3", value: [], shared: !0 },
    sphereLightPositionVS: { type: "fv3", value: [], shared: !0 },
    sphereLightPars: { type: "fv3", value: [], shared: !0 },
    tubeLightColor: { type: "fv3", value: [], shared: !0 },
    tubeLightPosition0VS: { type: "fv3", value: [], shared: !0 },
    tubeLightPosition1VS: { type: "fv3", value: [], shared: !0 },
    tubeLightPars: { type: "fv2", value: [], shared: !0 },
    spotLightColor: { type: "fv3", value: [], shared: !0 },
    spotLightPositionVS: { type: "fv3", value: [], shared: !0 },
    spotLightDirectionVS: { type: "fv3", value: [], shared: !0 },
    spotLightPars: { type: "fv4", value: [], shared: !0 },
    areaLightColor: { type: "fv3", value: [], shared: !0 },
    areaLightPosition: { type: "fv3", value: [], shared: !0 },
    areaLightNormal: { type: "fv3", value: [], shared: !0 },
    areaLightRight: { type: "fv3", value: [], shared: !0 },
    areaLightUp: { type: "fv3", value: [], shared: !0 },
    areaLightPars: { type: "fv4", value: [], shared: !0 },
    areaLightAttenuation: { type: "fv3", value: [], shared: !0 },
    areaLightTexture: { type: "tv", value: [], shared: !0 },
    imageLightTextureDiffuse: { type: "tv", value: [], shared: !0 },
    imageLightTextureSpecular: { type: "tv", value: [], shared: !0 },
    imageLightTextureMip: { type: "tv", value: [], shared: !0 },
    imageLightPars: { type: "fv4", value: [], shared: !0 },
    imageLightPositionWS: { type: "fv3", value: [], shared: !0 },
    imageLightSize: { type: "fv4", value: [], shared: !0 },
    polyLightColor: { type: "fv3", value: [], shared: !0 },
    polyLightPoints: { type: "fv3", value: [], shared: !0 },
    polyLightPars: { type: "fv2", value: [], shared: !0 },
    polyLightTexture: { type: "tv", value: [], shared: !0 },
    polyLightTexturePars: { type: "fv2", value: [], shared: !0 },
    samplerLtcMat: { type: "t", value: null, shared: !0 },
    samplerLtcMag: { type: "t", value: null, shared: !0 },
  }),
  (XG.UniformsLib.dynamicParticle = {
    time: { type: "f", value: 0 },
    timeRange: { type: "f", value: 1.25 },
    timeOffset: { type: "f", value: 0 },
    numFrames: { type: "f", value: 1 },
    frameDuration: { type: "f", value: 1 },
    frameScaleOffset: { type: "v4", value: new XG.Vector4(1, 1, 0, 0) },
    tDepth: { type: "t", value: null, shared: !0 },
    viewSize: { type: "v2", value: new XG.Vector2(800, 600), shared: !0 },
  }),
  (XG.UniformsLib.shadowmap = {
    shadowMap: { type: "tv", value: [], shared: !0 },
    shadowMapPars: { type: "fv4", value: [], shared: !0 },
    shadowCameraPars: { type: "fv2", value: [], shared: !0 },
    shadowMatrix: { type: "m4v", value: [], shared: !0 },
  }),
  (XG.ShaderLib.emissive = {
    uniforms: XG.UniformsUtils.merge([
      { diffuse: { type: "v4", value: new XG.Vector4(0.9, 0.9, 0.9, 1) } },
      XG.UniformsLib.common,
      XG.UniformsLib.fog,
      XG.UniformsLib.particle,
      XG.UniformsLib.displacement,
    ]),
    vertexShader: [
      XG.ShaderChunk.instances_pars_vertex,
      XG.ShaderChunk.map_pars_vertex,
      XG.ShaderChunk.color_pars_vertex,
      XG.ShaderChunk.morphtarget_pars_vertex,
      XG.ShaderChunk.skinning_pars_vertex,
      XG.ShaderChunk.particle_pars_vertex,
      XG.ShaderChunk.displacement_pars_vertex,
      "void main() {",
      XG.ShaderChunk.map_vertex,
      XG.ShaderChunk.color_vertex,
      XG.ShaderChunk.skinbase_vertex,
      XG.ShaderChunk.begin_pos_vertex,
      XG.ShaderChunk.displacement_vertex,
      XG.ShaderChunk.morphtarget_vertex,
      XG.ShaderChunk.skinning_vertex,
      XG.ShaderChunk.end_pos_vertex,
      XG.ShaderChunk.worldpos_vertex,
      XG.ShaderChunk.particle_vertex,
      "}",
    ].join("\n"),
    fragmentShader: [
      "uniform vec4 diffuse;",
      XG.ShaderChunk.color_pars_fragment,
      XG.ShaderChunk.map_pars_fragment,
      XG.ShaderChunk.lightmap_pars_fragment,
      XG.ShaderChunk.fog_pars_fragment,
      XG.ShaderChunk.tonemappingFragmentPars,
      XG.ShaderChunk.ditheringFragmentPars,
      XG.ShaderChunk.linearDepthFragmentPars,
      "void main() {",
      "mgl_FragColor = diffuse;",
      "#if !defined( PARTICLE ) && ( defined( USE_MAP ) || defined( USE_LIGHTMAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined ( USE_NORMALGLOSSMAP ) || defined ( USE_GLOSSMAP ) || defined( USE_SPECULARMAP ) )",
      "vec2 uvCoord = vUv;",
      "#endif",
      "#if defined( USE_LIGHTMAP ) && defined( LIGHTMAP_SECONDARY_UV )",
      "vec2 uvCoord2 = vUv2;",
      "#endif",
      XG.ShaderChunk.map_fragment,
      XG.ShaderChunk.alphatest_fragment,
      XG.ShaderChunk.lightmap_fragment,
      XG.ShaderChunk.color_fragment,
      "mgl_FragColor.xyz *= lightMapIntensity;",
      XG.ShaderChunk.fog_fragment,
      XG.ShaderChunk.linear_to_gamma_fragment,
      XG.ShaderChunk.tonemapping_fragment,
      XG.ShaderChunk.dithering_fragment,
      "}",
    ].join("\n"),
  }),
  (XG.ShaderLib.phong = {
    uniforms: XG.UniformsUtils.merge([
      XG.UniformsLib.common,
      XG.UniformsLib.bump,
      XG.UniformsLib.normalmap,
      XG.UniformsLib.fog,
      XG.UniformsLib.heightFog,
      XG.UniformsLib.lights,
      XG.UniformsLib.shadowmap,
      XG.UniformsLib.displacement,
      {
        diffuse: { type: "v4", value: new XG.Vector4(0.9, 0.9, 0.9, 1) },
        specular: { type: "v4", value: new XG.Vector4(0.1, 0.1, 0.1, 30) },
        wrapRGB: { type: "v3", value: new XG.Vector3(1, 1, 1) },
        glossMap: { type: "t", value: null },
        specularMap: { type: "t", value: null },
        parallaxScale: { type: "f", value: 1 },
        detailRepeatScale: { type: "v3", value: new XG.Vector3(1, 1, 1) },
        cameraNearFar: { type: "v2", value: new XG.Vector2(1, 500) },
      },
    ]),
    vertexShader: [
      "varying vec3 vViewPosition;",
      "varying vec3 vNormal;",
      "#if defined( ATMOSPHERIC_FOG )",
      "varying vec4 vClipPosition;",
      "#endif",
      XG.ShaderChunk.instances_pars_vertex,
      XG.ShaderChunk.map_pars_vertex,
      XG.ShaderChunk.color_pars_vertex,
      XG.ShaderChunk.morphtarget_pars_vertex,
      XG.ShaderChunk.skinning_pars_vertex,
      XG.ShaderChunk.shadowmap_pars_vertex,
      XG.ShaderChunk.displacement_pars_vertex,
      "void main() {",
      XG.ShaderChunk.map_vertex,
      XG.ShaderChunk.color_vertex,
      XG.ShaderChunk.begin_nor_vertex,
      XG.ShaderChunk.morphnormal_vertex,
      XG.ShaderChunk.skinbase_vertex,
      XG.ShaderChunk.skinnormal_vertex,
      XG.ShaderChunk.end_nor_vertex,
      "vNormal = transformedNormal;",
      XG.ShaderChunk.begin_pos_vertex,
      XG.ShaderChunk.displacement_vertex,
      XG.ShaderChunk.morphtarget_vertex,
      XG.ShaderChunk.skinning_vertex,
      XG.ShaderChunk.end_pos_vertex,
      "vViewPosition = mvPosition.xyz;",
      XG.ShaderChunk.worldpos_vertex,
      XG.ShaderChunk.shadowmap_vertex,
      "#if defined( ATMOSPHERIC_FOG )",
      "vClipPosition = gl_Position;",
      "#endif",
      "}",
    ].join("\n"),
    fragmentShader: [
      "uniform vec4 diffuse;",
      "uniform vec4 specular;",
      XG.ShaderChunk.color_pars_fragment,
      XG.ShaderChunk.map_pars_fragment,
      XG.ShaderChunk.lightmap_pars_fragment,
      XG.ShaderChunk.fog_pars_fragment,
      XG.ShaderChunk.height_fog_pars_fragment,
      XG.ShaderChunk.area_lights_utils,
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.lights_phong_pars_fragment,
      XG.ShaderChunk.skin_pars_fragment,
      XG.ShaderChunk.shadowmap_pars_fragment,
      XG.ShaderChunk.shadowmap_pars_common,
      XG.ShaderChunk.bumpmap_pars_fragment,
      XG.ShaderChunk.derivativemap_pars_fragment,
      XG.ShaderChunk.normalmap_pars_fragment,
      XG.ShaderChunk.parallax_pars_fragment,
      XG.ShaderChunk.displacementmap_pars_fragment,
      XG.ShaderChunk.specularmap_pars_fragment,
      XG.ShaderChunk.glossmap_pars_fragment,
      XG.ShaderChunk.tonemappingFragmentPars,
      XG.ShaderChunk.ditheringFragmentPars,
      XG.ShaderChunk.linearDepthFragmentPars,
      "#if defined( USE_BUMPDETAILMAP ) || defined( USE_NORMALDETAILMAP )",
      "uniform vec3 detailRepeatScale;",
      "#endif",
      "#if defined( ATMOSPHERIC_FOG )",
      "uniform vec2 cameraNearFar;",
      "varying vec4 vClipPosition;",
      "#endif",
      "void main() {",
      "mgl_FragColor = vec4( vec3 ( 1.0 ), diffuse.a );",
      "#if !defined( PARTICLE ) && ( defined( USE_MAP ) || defined( USE_LIGHTMAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_BUMPDETAILMAP ) || defined( USE_NORMALDETAILMAP ) || defined ( USE_NORMALGLOSSMAP ) || defined ( USE_GLOSSMAP ) || defined( USE_SPECULARMAP ) || defined( USE_DISPLACEMENTMAP ) )",
      "vec2 uvCoord = vUv;",
      "#endif",
      "#if defined( USE_LIGHTMAP ) && defined( LIGHTMAP_SECONDARY_UV )",
      "vec2 uvCoord2 = vUv2;",
      "#endif",
      "vec3 normal = normalize( vNormal );",
      "vec3 vertexPosition = vViewPosition;",
      "vec3 eyeVector = normalize( -vertexPosition );",
      XG.ShaderChunk.parallax_fragment,
      XG.ShaderChunk.map_fragment,
      XG.ShaderChunk.alphatest_fragment,
      XG.ShaderChunk.color_fragment,
      XG.ShaderChunk.specularmap_fragment,
      XG.ShaderChunk.shadowmap_fragment,
      XG.ShaderChunk.lightmap_fragment,
      XG.ShaderChunk.lights_phong_fragment,
      XG.ShaderChunk.height_fog_fragment,
      XG.ShaderChunk.fog_fragment,
      XG.ShaderChunk.linear_to_gamma_fragment,
      XG.ShaderChunk.tonemapping_fragment,
      XG.ShaderChunk.dithering_fragment,
      "vec4 pixelColor = mgl_FragColor;",
      "#if defined( TRANSLUCENT_PASS )",
      "mgl_FragColor = vec4( pixelColor.a );",
      "#endif",
      "}",
    ].join("\n"),
  }),
  (XG.ShaderLib.dynamicParticle = {
    uniforms: XG.UniformsUtils.merge([
      {
        diffuse: { type: "v4", value: new XG.Vector4(0.9, 0.9, 0.9, 1) },
        cameraNearFar: { type: "v2", value: new XG.Vector2(1, 500) },
        additiveFactor: { type: "f", value: 0 },
        directionalLightPositionVS: { type: "fv4", value: [], shared: !0 },
      },
      XG.UniformsLib.common,
      XG.UniformsLib.fog,
      XG.UniformsLib.particle,
      XG.UniformsLib.dynamicParticle,
      XG.UniformsLib.lights,
      XG.UniformsLib.shadowmap,
      XG.UniformsLib.fogAtmo,
    ]),
    vertexShader: [
      XG.ShaderChunk.linearDepthFragmentPars,
      XG.ShaderChunk.particle_pars_vertex,
      XG.ShaderChunk.shadowmap_pars_common,
      "uniform float time;",
      "uniform float timeRange;",
      "uniform float timeOffset;",
      "#ifdef OFFSCREEN_PARTICLES",
      "varying vec4 vClipPosition;",
      "#endif",
      "#ifdef USE_LIGHTS",
      "#if MAX_DIR_LIGHTS > 0",
      "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
      "uniform vec4 directionalLightPositionVS[ MAX_DIR_LIGHTS ];",
      "uniform int directionalLightPars[ MAX_DIR_LIGHTS ];",
      "#endif",
      "#if MAX_POINT_LIGHTS > 0",
      "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
      "uniform vec3 pointLightPositionVS[ MAX_POINT_LIGHTS ];",
      "uniform vec2 pointLightPars[ MAX_POINT_LIGHTS ];",
      "#endif",
      "#if MAX_SPHERE_LIGHTS > 0",
      "uniform vec3 sphereLightColor[ MAX_SPHERE_LIGHTS ];",
      "uniform vec3 sphereLightPositionVS[ MAX_SPHERE_LIGHTS ];",
      "uniform vec3 sphereLightPars[ MAX_SPHERE_LIGHTS ];",
      "#endif",
      "#if MAX_SPOT_LIGHTS > 0",
      "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
      "uniform vec3 spotLightPositionVS[ MAX_SPOT_LIGHTS ];",
      "uniform vec3 spotLightDirectionVS[ MAX_SPOT_LIGHTS ];",
      "uniform vec4 spotLightPars[ MAX_SPOT_LIGHTS ];",
      "#endif",
      "#if MAX_POLY_LIGHTS > 0",
      "uniform vec3 polyLightColor[ MAX_POLY_LIGHTS ];",
      "uniform vec3 polyLightPoints[ MAX_POLY_LIGHTS * 4 ];",
      "uniform vec2 polyLightPars[ MAX_POLY_LIGHTS ];",
      "#ifdef POLY_TEXTURE",
      "uniform sampler2D polyLightTexture[ MAX_POLY_LIGHTS ];",
      "uniform vec2 polyLightTexturePars[ MAX_POLY_LIGHTS ];",
      "#endif",
      XG.ShaderChunk.polylights_pars_fragment,
      "#endif",
      "#if MAX_TUBE_LIGHTS > 0",
      "uniform vec3 tubeLightColor[ MAX_TUBE_LIGHTS ];",
      "uniform vec3 tubeLightPosition0VS[ MAX_TUBE_LIGHTS ];",
      "uniform vec3 tubeLightPosition1VS[ MAX_TUBE_LIGHTS ];",
      "uniform vec2 tubeLightPars[ MAX_TUBE_LIGHTS ];",
      XG.ShaderChunk.utils_pars_fragment,
      "#endif",
      "float computeAttenuation( float distanceToLight, float lightRange ) {",
      "const float cutoff = 0.3;",
      "float denom = distanceToLight / lightRange + 1.0;",
      "float attenuation = 1.0 / ( denom * denom );",
      "attenuation = ( attenuation - cutoff ) / ( 1.0 - cutoff );",
      "attenuation = max( attenuation, 0.0 );",
      "attenuation *= attenuation;",
      "return attenuation;",
      "}",
      "varying vec3 vLightColor;",
      "#endif",
      "#ifdef USE_SHADOWMAP",
      "uniform mat4 shadowMatrix[ MAX_SHADOWS ];",
      "#endif",
      "varying vec4 vSpinLifeTime;",
      "attribute vec4 velocitySpinStart;",
      "attribute vec4 accelerationSpinSpeed;",
      "attribute vec4 startSizeEndSizeStartTimeLifeTime;",
      "void main() {",
      "float startSize = startSizeEndSizeStartTimeLifeTime.x;",
      "float endSize = startSizeEndSizeStartTimeLifeTime.y;",
      "float startTime = startSizeEndSizeStartTimeLifeTime.z;",
      "float lifeTime = startSizeEndSizeStartTimeLifeTime.w;",
      "vec3 velocity = velocitySpinStart.xyz;",
      "float spinStart = velocitySpinStart.w;",
      "vec3 acceleration = accelerationSpinSpeed.xyz;",
      "float spinSpeed = accelerationSpinSpeed.w;",
      "float localTime = mod( ( time - timeOffset - startTime ), timeRange );",
      "float percentLife = localTime / lifeTime;",
      "vec3 newPosition = position + velocity * localTime + acceleration * localTime * localTime;",
      "vec4 mvPosition = modelViewMatrix * vec4( newPosition, 1.0 );",
      "gl_Position = projectionMatrix * mvPosition;",
      "float currentSize = 0.5 * particleSize * mix( startSize, endSize, percentLife );",
      "currentSize *= step( 0.0, percentLife );",
      "currentSize *= step( -1.0, -percentLife );",
      "if ( currentSize == 0.0 ) gl_Position = vec4( -100000000.0 );",
      "#ifdef OFFSCREEN_PARTICLES",
      "vClipPosition = gl_Position;",
      "#endif",
      "#ifdef USE_SHADOWMAP",
      "vec4 worldPosition = modelMatrix * vec4( newPosition, 1.0 );",
      "vec4 vShadowCoord[ MAX_SHADOWS ];",
      "for( int i = 0; i < MAX_SHADOWS; i ++ ) {",
      "vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",
      "}",
      "#endif",
      XG.ShaderChunk.shadowmap_fragment,
      "#ifdef USE_LIGHTS",
      "vec3 vertexPosition = mvPosition.xyz;",
      "vec3 accumulatedColor = vec3( 0.0 );",
      "#if MAX_DIR_LIGHTS > 0",
      "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",
      "vec3 lightColor = directionalLightColor[ i ];",
      "vec4 lightPositionDistance = directionalLightPositionVS[ i ];",
      "vec3 lightPosition = lightPositionDistance.xyz;",
      "float lightDistance = lightPositionDistance.w;",
      "float d = distance( lightPosition, vertexPosition );",
      "float attenuation = computeAttenuation( d, lightDistance );",
      "#ifdef USE_SHADOWMAP",
      "int shadowIndex = directionalLightPars[ i ];",
      "if ( i == shadowIndex ) {",
      "attenuation  *= occlusion[ DIR_INDEX_OFFSET + i ];",
      "}",
      "#endif",
      "accumulatedColor += attenuation * lightColor;",
      "}",
      "#endif",
      "#if MAX_POINT_LIGHTS > 0",
      "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
      "vec3 lightColor = pointLightColor[ i ];",
      "vec3 lightPosition = pointLightPositionVS[ i ];",
      "float lightDistance = pointLightPars[ i ].x;",
      "float d = distance( lightPosition, vertexPosition );",
      "float attenuation = computeAttenuation( d, lightDistance );",
      "#ifdef USE_SHADOWMAP",
      "int shadowIndex = int( pointLightPars[ i ].y );",
      "if ( i == shadowIndex ) {",
      "attenuation *= occlusion[ POINT_INDEX_OFFSET + i ];",
      "}",
      "#endif",
      "accumulatedColor += attenuation * lightColor;",
      "}",
      "#endif",
      "#if MAX_SPHERE_LIGHTS > 0",
      "for ( int i = 0; i < MAX_SPHERE_LIGHTS; i ++ ) {",
      "vec3 lightColor = sphereLightColor[ i ];",
      "vec3 lightPosition = sphereLightPositionVS[ i ];",
      "float lightDistance = sphereLightPars[ i ].x;",
      "float d = distance( lightPosition, vertexPosition );",
      "float attenuation = computeAttenuation( d, lightDistance );",
      "#ifdef USE_SHADOWMAP",
      "int shadowIndex = int( sphereLightPars[ i ].z );",
      "if ( i == shadowIndex ) {",
      "attenuation *= occlusion[ SPHERE_INDEX_OFFSET + i ];",
      "}",
      "#endif",
      "accumulatedColor += attenuation * lightColor;",
      "}",
      "#endif",
      "#if MAX_SPOT_LIGHTS > 0",
      "for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
      "vec3 lightColor = spotLightColor[ i ];",
      "vec3 lightPosition = spotLightPositionVS[ i ];",
      "vec3 lightVector = lightPosition - vertexPosition;",
      "float lightDistance = length( lightVector );",
      "float spotLightAngleCos = spotLightPars[ i ].x;",
      "float spotLightExponent = spotLightPars[ i ].y;",
      "float spotLightDistance = spotLightPars[ i ].z;",
      "float attenuation = 1.0;",
      "if ( spotLightDistance > 0.0 )",
      "attenuation = 1.0 - min( lightDistance / spotLightDistance, 1.0 );",
      "lightVector = lightVector / lightDistance;",
      "float rho = dot( spotLightDirectionVS[ i ], lightVector );",
      "if ( rho > spotLightAngleCos ) {;",
      "float theta = spotLightAngleCos + 0.0001;",
      "float phi = spotLightAngleCos + 0.05;",
      "const float falloff = 4.0;",
      "float spotEffect = 0.0;",
      "if ( rho >= phi ) {",
      "spotEffect = 1.0;",
      "} else if ( rho <= theta ) {",
      "spotEffect = 0.0;",
      "} else { ",
      "spotEffect = pow( ( rho - theta ) / ( phi - theta ), falloff );",
      "}",
      "attenuation *= spotEffect;",
      "#ifdef USE_SHADOWMAP",
      "int shadowIndex = int( spotLightPars[ i ].w );",
      "if ( i == shadowIndex ) {",
      "attenuation *= occlusion[ SPOT_INDEX_OFFSET + i ];",
      "}",
      "#endif",
      "accumulatedColor += attenuation * lightColor;",
      "}",
      "}",
      "#endif",
      "#if MAX_POLY_LIGHTS > 0",
      "vec3 polyDiffuse = vec3( 0.0 );",
      "vec3 eyeVector = normalize( -vertexPosition );",
      "vec3 normal = normalize( normalMatrix * normalize( normal ) );",
      "float dotNV = dot( normal, eyeVector );",
      "mat3 MinvInitDiffuse = mat3( 1.0 );",
      "mat3 orthoBasis = computeOrthoBasis( dotNV, normal, eyeVector );",
      "MinvInitDiffuse = mul( MinvInitDiffuse, orthoBasis );",
      "vec3 lightPoints[ 4 ];",
      "mat3 MinvDiffuse;",
      "for( int i = 0; i < MAX_POLY_LIGHTS; i ++ ) {",
      "bool lightTwoSided = bool( polyLightPars[ i ].x );",
      "lightPoints[ 0 ] = polyLightPoints[ i * 4 ];",
      "lightPoints[ 1 ] = polyLightPoints[ i * 4 + 1 ];",
      "lightPoints[ 2 ] = polyLightPoints[ i * 4 + 2 ];",
      "lightPoints[ 3 ] = polyLightPoints[ i * 4 + 3 ];",
      "MinvDiffuse = MinvInitDiffuse;",
      "#ifdef POLY_TEXTURE",
      "float texSize = polyLightTexturePars[ i ].x;",
      "float texBias = polyLightTexturePars[ i ].y;",
      "vec3 pDiffuse  = LTC_Evaluate_opt_tex( vertexPosition.xyz, MinvDiffuse, lightPoints, lightTwoSided, polyLightTexture[ i ], texSize, texBias );",
      "#else",
      "vec3 pDiffuse  = LTC_Evaluate_opt( vertexPosition.xyz, MinvDiffuse, lightPoints, lightTwoSided );",
      "#endif",
      "#ifdef USE_SHADOWMAP",
      "int shadowIndex = int( polyLightPars[ i ].y );",
      "if ( i == shadowIndex ) {",
      "pDiffuse *= occlusion[ POLY_INDEX_OFFSET + i ];",
      "}",
      "#endif",
      "polyDiffuse += pDiffuse * polyLightColor[ i ];",
      "}",
      "polyDiffuse /= 2.0 * PI;",
      "accumulatedColor += polyDiffuse;",
      "#endif",
      "#if MAX_TUBE_LIGHTS > 0",
      "vec3 tubeDiffuse  = vec3( 0.0 );",
      "for ( int i = 0; i < MAX_TUBE_LIGHTS; i ++ ) {",
      "vec3 lightPosition0 = tubeLightPosition0VS[ i ];",
      "vec3 lightPosition1 = tubeLightPosition1VS[ i ];",
      "float attenuation = 1.0;",
      "float maxDistance = tubeLightPars[ i ].x;",
      "float lightRadius = tubeLightPars[ i ].y;",
      "vec3 lightVector0 = lightPosition0 - vertexPosition;",
      "vec3 lightVector1 = lightPosition1 - vertexPosition;",
      "float length0 = length( lightVector0 );",
      "float length1 = length( lightVector1 );",
      "float a = saturate( 0.5 * ( dot( normal, lightVector0 ) / length0 + dot( normal, lightVector1 ) / length1 ) );",
      "float b = ( length0 * length1 + dot( lightVector0, lightVector1 ) ) * 0.5 + 1.0;",
      "float dotLN = a;",
      "vec3 tubeDiffuseWeight = vec3( dotLN );",
      "vec3 diffuseTerm = tubeLightColor[ i ] * tubeDiffuseWeight;",
      "if ( maxDistance > 0.0 ) {",
      "attenuation = 1.0 / b;",
      "}",
      "accumulatedColor += diffuseTerm * attenuation;",
      "}",
      "#endif",
      "vLightColor = accumulatedColor;",
      "#endif",
      "vec4 projectedCorner = projectionMatrix * vec4( currentSize, currentSize, mvPosition.z, mvPosition.w );",
      "gl_PointSize = screenWidth * projectedCorner.x / projectedCorner.w;",
      "percentLife *= step( 0.0, percentLife );",
      "percentLife *= step( -1.0, -percentLife );",
      "vSpinLifeTime = vec4( spinStart, spinSpeed, percentLife, localTime );",
      "}",
    ].join("\n"),
    fragmentShader: [
      XG.ShaderChunk.fog_pars_fragment,
      XG.ShaderChunk.tonemappingFragmentPars,
      XG.ShaderChunk.ditheringFragmentPars,
      "uniform sampler2D map;",
      "uniform vec4 diffuse;",
      "uniform float time;",
      "uniform float numFrames;",
      "uniform float frameDuration;",
      "uniform vec4 frameScaleOffset;",
      "uniform vec2 cameraNearFar;",
      "uniform float additiveFactor;",
      "#ifdef OFFSCREEN_PARTICLES",
      "uniform sampler2D tDepth;",
      "uniform vec2 viewSize;",
      "varying vec4 vClipPosition;",
      "#ifdef RGBA_DEPTH",
      "float unpackDepth( vec4 rgba ) {",
      "return dot( rgba, vec4( 1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0 ) );",
      "}",
      "#endif",
      "#if defined( OIT_PARTICLES )",
      "float alphaWeight( float a, float z ) {",
      "return a * max( 1e-2, min( 3.0 * 1e3, 0.03 / ( 1e-5 + pow( abs(z) / 200.0, 4.0 ) ) ) );",
      "}",
      "#endif",
      XG.ShaderChunk.fogAtmoFragmentPars,
      XG.ShaderChunk.linearDepthFragmentPars,
      "#endif",
      "#ifdef USE_LIGHTS",
      "varying vec3 vLightColor;",
      "#endif",
      "varying vec4 vSpinLifeTime;",
      "void main() {",
      "#if defined( OFFSCREEN_PARTICLES )",
      "vec2 screenCoord = gl_FragCoord.xy / viewSize;",
      "#if defined( RGBA_DEPTH )",
      "float sceneDepth = unpackDepth( texture2D( tDepth, screenCoord ) );",
      "#elif defined( FLOAT_DEPTH )",
      "float sceneDepth = texture2D( tDepth, screenCoord ).w;",
      "#elif defined( TEXTURE_DEPTH )",
      "float sceneDepth = texture2D( tDepth, screenCoord ).x * 2.0 - 1.0;",
      "#endif",
      "float myDepth = vClipPosition.z / vClipPosition.w;",
      "float myLinearDepth = linearizeDepth( myDepth, cameraNearFar );",
      "float sceneLinearDepth = linearizeDepth( sceneDepth, cameraNearFar );",
      "const float scale = 0.1;",
      "float zFade = clamp( scale * abs( myLinearDepth - sceneLinearDepth ), 0.0, 1.0 );",
      "if ( myDepth > sceneDepth ) discard;",
      "#endif",
      "float spinStart = vSpinLifeTime.x;",
      "float spinSpeed = vSpinLifeTime.y;",
      "float percentLife = vSpinLifeTime.z;",
      "float localTime = vSpinLifeTime.w;",
      "const float frameStart = 0.0;",
      "vec2 texCoord = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) - 0.5;",
      "texCoord = texCoord * frameScaleOffset.xy + frameScaleOffset.zw;",
      "float s = sin( spinStart + spinSpeed * time );",
      "float c = cos( spinStart + spinSpeed * time );",
      "vec2 rotatedCoord1 = vec2( texCoord.x * c + texCoord.y * s, -texCoord.x * s + texCoord.y * c ) + 0.5;",
      "rotatedCoord1 = clamp( rotatedCoord1, 0.0, 1.0 );",
      "vec2 rotatedCoord2 = rotatedCoord1;",
      "float frame1 = mod( floor( localTime / frameDuration + frameStart ), numFrames );",
      "float uOffset1 = frame1 / numFrames;",
      "rotatedCoord1.x = uOffset1 + ( rotatedCoord1.x ) * ( 1.0 / numFrames );",
      "vec4 pixel1 = texture2D( map, rotatedCoord1 );",
      "pixel1.xyz *= pixel1.xyz;",
      "#ifdef INTERPOLATE_PARTICLE_FRAMES",
      "float frame2 = mod( floor( localTime / frameDuration + frameStart + 1.0 ), numFrames );",
      "float uOffset2 = frame2 / numFrames;",
      "float frameTime = fract( localTime / frameDuration + frameStart );",
      "rotatedCoord2.x = uOffset2 + ( rotatedCoord2.x ) * ( 1.0 / numFrames );",
      "vec4 pixel2 = texture2D( map, rotatedCoord2 );",
      "pixel2.xyz *= pixel2.xyz;",
      "pixel1 = mix( pixel1, pixel2, frameTime );",
      "#endif",
      "if ( pixel1.a < 0.001 ) discard;",
      "vec4 particleColor = pixel1 * diffuse;",
      "#ifdef USE_LIGHTS",
      "particleColor.rgb *= vLightColor;",
      "#endif",
      "#if defined( OFFSCREEN_PARTICLES )",
      "#ifdef FOG_ENABLED",
      "particleColor.rgb = addFog( particleColor.rgb, myLinearDepth );",
      "#endif",
      "particleColor.a *= zFade;",
      "#endif",
      "#if defined( OIT_PARTICLES ) && defined( OFFSCREEN_PARTICLES )",
      "float ai = particleColor.a;",
      "vec3 Ci = particleColor.rgb * particleColor.a;",
      "float wzi = alphaWeight( ai, myLinearDepth );",
      "#endif",
      "#if defined( OIT_MRT_PASS )",
      "mgl_FragData[ 0 ] = vec4( Ci * wzi, ai );",
      "mgl_FragData[ 1 ] = vec4( ai * wzi );",
      "if ( additiveFactor > 0.0 ) mgl_FragData[ 1 ] = vec4( additiveFactor );",
      "#elif defined( OIT_ACCUMULATION_PASS )",
      "mgl_FragColor = vec4( Ci * wzi, ai );",
      "#elif defined( OIT_REVEALAGE_PASS )",
      "mgl_FragColor = vec4( ai * wzi );",
      "if ( additiveFactor > 0.0 ) mgl_FragColor = vec4( additiveFactor );",
      "#elif defined( TRANSLUCENT_PASS )",
      "mgl_FragColor = vec4( particleColor.a );",
      "#else",
      "mgl_FragColor = particleColor;",
      "#endif",
      "}",
    ].join("\n"),
  }),
  (XG.ShaderLib.depthRGBA = {
    uniforms: XG.UniformsUtils.merge([
      {
        slopeScale: { type: "f", value: 2, shared: !0 },
        slopeBias: { type: "f", value: 0, shared: !0 },
        slopeMax: { type: "f", value: 0.001, shared: !0 },
        depthTextureBias: { type: "f", value: 5e-4, shared: !0 },
        epsilon: { type: "f", value: 0.1 },
        alphaTest: { type: "f", value: 0.5 },
        map: { type: "t", value: null },
      },
      { offsetRepeat: { type: "v4", value: new XG.Vector4(0, 0, 1, 1) } },
      XG.UniformsLib.displacement,
    ]),
    vertexShader: [
      XG.ShaderChunk.instances_pars_vertex,
      XG.ShaderChunk.morphtarget_pars_vertex,
      XG.ShaderChunk.skinning_pars_vertex,
      XG.ShaderChunk.displacement_pars_vertex,
      "#if defined( SHADOW_TEXTURE_DEPTH )",
      "uniform float depthTextureBias;",
      "#endif",
      "#ifdef USE_DISPLACEMENTMAP",
      "uniform vec4 offsetRepeat;",
      "#endif",
      "#ifdef SPRITE",
      "attribute vec3 offset;",
      "attribute vec2 scale;",
      "varying vec2 vUv;",
      "#endif",
      "void main() {",
      "#ifdef SPRITE",
      "#ifdef BILLBOARD",
      "vec4 tmpPosition = modelViewMatrix * vec4( offset, 1.0 ) + vec4( position * vec3( scale, 1.0 ), 0.0 );",
      "gl_Position = projectionMatrix * tmpPosition;",
      "#else",
      "vec3 spritePosition = position * vec3( scale, 1.0 ) + offset;",
      "vec4 mvPosition = modelViewMatrix * vec4( spritePosition, 1.0 );",
      "gl_Position = projectionMatrix * mvPosition;",
      "#endif",
      "vUv = uv;",
      "#else",
      "#ifdef USE_DISPLACEMENTMAP",
      "vec2 transformedUV = uv * offsetRepeat.zw + offsetRepeat.xy;",
      "#endif",
      XG.ShaderChunk.skinbase_vertex,
      XG.ShaderChunk.begin_pos_vertex,
      XG.ShaderChunk.displacement_vertex,
      XG.ShaderChunk.morphtarget_vertex,
      XG.ShaderChunk.skinning_vertex,
      XG.ShaderChunk.end_pos_vertex,
      "#endif",
      "#if defined ( SHADOW_TEXTURE_DEPTH )",
      "gl_Position.z += depthTextureBias;",
      "#endif",
      "}",
    ].join("\n"),
    fragmentShader: [
      "#ifdef SPRITE",
      "uniform float epsilon;",
      "uniform float alphaTest;",
      "uniform sampler2D map;",
      "varying vec2 vUv;",
      "#endif",
      "#if defined( SHADOW_RGBA_DEPTH )",
      "#ifdef SLOPE_DEPTH_BIAS",
      "uniform float slopeScale;",
      "uniform float slopeBias;",
      "uniform float slopeMax;",
      "#endif",
      "vec4 pack_depth( const in float depth ) {",
      "const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
      "const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
      "vec4 res = fract( depth * bit_shift );",
      "res -= res.xxyz * bit_mask;",
      "return res;",
      "}",
      "#endif",
      "void main() {",
      "#ifdef SPRITE",
      "vec4 texture = texture2D( map, vUv );",
      "#ifdef SDF",
      "#if defined( GL_OES_standard_derivatives ) || __VERSION__ >= 300",
      "float w = clamp( 200.0 * epsilon * ( abs( dFdx( vUv.x ) ) + abs( dFdy( vUv.y ) ) ), 0.0, 0.5 );",
      "#else",
      "float w = epsilon;",
      "#endif",
      "float alpha = smoothstep( 0.5 - w, 0.5 + w, texture.r );",
      "alpha = pow( alpha, 1.0/2.2 );",
      "#else",
      "float alpha = texture.a;",
      "#endif",
      "if ( alpha < alphaTest ) discard;",
      "#endif",
      "#if defined( SHADOW_RGBA_DEPTH )",
      "float depth = gl_FragCoord.z;",
      "#ifdef SLOPE_DEPTH_BIAS",
      "float dx = dFdx( depth );",
      "float dy = dFdy( depth );",
      "float m = max( abs(dx), abs(dy) );",
      "m = min( m, slopeMax );",
      "depth += m * slopeScale + slopeBias;",
      "#endif",
      "mgl_FragColor = pack_depth( depth );",
      "#endif",
      "}",
    ].join("\n"),
  }),
  (XG.DeferredUniformsLib = {}),
  (XG.DeferredShaderChunk = {}),
  (XG.DeferredShaders = {}),
  (XG.DeferredUniformsLib.gbuffers = {
    samplerColor: { type: "t", value: null, shared: !0 },
    samplerNormalDepth: { type: "t", value: null, shared: !0 },
    samplerDiffuseRGB: { type: "t", value: null, shared: !0 },
    samplerSpecularRGB: { type: "t", value: null, shared: !0 },
    samplerWrapRGB: { type: "t", value: null, shared: !0 },
    samplerNormal: { type: "t", value: null, shared: !0 },
    samplerDepth: { type: "t", value: null, shared: !0 },
    viewSize: { type: "v2", value: new XG.Vector2(800, 600), shared: !0 },
  }),
  (XG.DeferredUniformsLib.multiShadowMaps = {
    samplerShadowMap: { type: "tv", value: [] },
    shadowMapSize: { type: "v2", value: new XG.Vector2(512, 512) },
    shadowDarkness: { type: "f", value: 0.5 },
    shadowBias: { type: "f", value: 0 },
    matShadow: { type: "m4v", value: [] },
  }),
  (XG.DeferredUniformsLib.pointShadowMaps = {
    samplerShadowMap: { type: "t", value: null },
    shadowMapSize: { type: "v2", value: new XG.Vector2(1536, 256) },
    shadowDarkness: { type: "f", value: 0.5 },
    shadowBias: { type: "f", value: 0 },
    shadowCameraPars: { type: "v2", value: new XG.Vector2(5, 5e3) },
    matViewInverse: { type: "m4", value: new XG.Matrix4() },
    lightPositionWS: { type: "v3", value: new XG.Vector3(0, 0, 0) },
  }),
  (XG.DeferredUniformsLib.projectedTexture = {
    samplerTexture: { type: "t", value: null },
    textureBias: { type: "f", value: 0 },
    matTexture: { type: "m4", value: new XG.Matrix4() },
  }),
  (XG.DeferredUniformsLib.wireframe = {
    wireframeDiffuse: { type: "c", value: new XG.Color(0) },
    wireframeSpecular: { type: "c", value: new XG.Color(0) },
    wireframeShininessThickness: { type: "v2", value: new XG.Vector2(0, 1.5) },
  }),
  (XG.DeferredShaderChunk.wireframeParsFragment = [
    "#ifdef WIREFRAME",
    "uniform vec3 wireframeDiffuse;",
    "uniform vec3 wireframeSpecular;",
    "uniform vec2 wireframeShininessThickness;",
    "varying vec3 vCenter;",
    "float edgeFactor() {",
    "vec3 d = fwidth( vCenter );",
    "vec3 a3 = smoothstep( vec3( 0.0 ), d * wireframeShininessThickness.y, vCenter );",
    "return min( min( a3.x, a3.y ), a3.z );",
    "}",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.wireframeFragment = [
    "#ifdef WIREFRAME",
    "diffuseColor.rgb = mix( wireframeDiffuse, diffuseColor.rgb, edgeFactor() );",
    "specularColor.rgb = mix( wireframeSpecular, specularColor.rgb, edgeFactor() );",
    "shininess = mix( wireframeShininessThickness.x, shininess, edgeFactor() );",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.wireframeParsVertex = [
    "#ifdef WIREFRAME",
    "attribute vec3 center;",
    "varying vec3 vCenter;",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.wireframeVertex = [
    "#ifdef WIREFRAME",
    "vCenter = center;",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.gbuffersUniforms = [
    "#ifdef USE_MRT",
    "uniform sampler2D samplerDiffuseRGB;",
    "uniform sampler2D samplerSpecularRGB;",
    "uniform sampler2D samplerWrapRGB;",
    "uniform sampler2D samplerNormal;",
    "uniform sampler2D samplerDepth;",
    "#else",
    "uniform sampler2D samplerColor;",
    "uniform sampler2D samplerNormalDepth;",
    "#endif",
    "uniform vec2 viewSize;",
  ].join("\n")),
  (XG.DeferredShaderChunk.multiShadowMapsUniforms = [
    "#ifdef USE_SHADOWMAP",
    "#ifdef USE_SHADOWSAMPLER",
    "uniform sampler2DShadow samplerShadowMap[ SHADOWMAP_COUNT ];",
    "#else",
    "uniform sampler2D samplerShadowMap[ SHADOWMAP_COUNT ];",
    "#endif",
    "uniform mat4 matShadow[ SHADOWMAP_COUNT ];",
    "uniform float shadowBias;",
    "uniform float shadowDarkness;",
    "uniform vec2 shadowMapSize;",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.pointShadowMapsUniforms = [
    "#ifdef USE_SHADOWMAP",
    "#ifdef USE_SHADOWSAMPLER",
    "uniform sampler2DShadow samplerShadowMap;",
    "#else",
    "uniform sampler2D samplerShadowMap;",
    "#endif",
    "uniform vec2 shadowCameraPars;",
    "uniform float shadowBias;",
    "uniform float shadowDarkness;",
    "uniform vec2 shadowMapSize;",
    "uniform mat4 matViewInverse;",
    "uniform vec3 lightPositionWS;",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.projectedTextureUniforms = [
    "#ifdef PROJECTED_TEXTURE",
    "uniform sampler2D samplerTexture;",
    "uniform float textureBias;",
    "uniform mat4 matTexture;",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.packFloat = [
    "const float unit = 255.0/256.0;",
    "float vec3_to_float( vec3 data ) {",
    "highp float compressed = dot( floor( data * 255.0 + 0.5 ), vec3( 1.0, 256.0, 65536.0 ) );",
    "return compressed;",
    "}",
    "float vec21_to_float( float dataHi, float dataLo ) {",
    "highp float compressed = floor( dataHi ) + unit * dataLo;",
    "return compressed;",
    "}",
    "vec3 packWrapAroundShininess( float wrapAround, float shininess ) {",
    "vec3 tmp;",
    "tmp.r = wrapAround + 0.5;",
    "tmp.b = fract( shininess / 256.0 );",
    "tmp.g = floor( shininess / 256.0 ) / 256.0;",
    "return tmp;",
    "}",
    "vec4 packDepth( const in float depth ) {",
    "vec4 enc = vec4( 1.0, 255.0, 65025.0, 16581375.0 ) * depth;",
    "enc = fract( enc );",
    "enc -= enc.yzww * vec4( 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0 );",
    "return enc;",
    "}",
  ].join("\n")),
  (XG.DeferredShaderChunk.unpackFloat = [
    "const float unitInverse = 256.0/255.0;",
    "vec3 float_to_vec3( float data ) {",
    "vec3 uncompressed;",
    "uncompressed.z = data / 65536.0;",
    "uncompressed.y = 256.0 * fract( uncompressed.z );",
    "uncompressed.x = 256.0 * fract( uncompressed.y );",
    "return floor( uncompressed ) / 255.0;",
    "}",
    "vec2 float_to_vec21( float data ) {",
    "vec2 uncompressed;",
    "uncompressed.x = floor( data );",
    "uncompressed.y = fract( data ) * unitInverse;",
    "return uncompressed;",
    "}",
    "float unpackDepth( const in vec4 rgba ) {",
    "return clamp( dot( rgba, vec4( 1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0 ) ), 0.0, 1.0 );",
    "}",
  ].join("\n")),
  (XG.DeferredShaderChunk.computeVertexPositionVS = [
    "vec2 texCoord = gl_FragCoord.xy / viewSize;",
    "#ifdef USE_MRT",
    "#ifdef TEXTURE_DEPTH",
    "vec4 texDepth = texture2D( samplerDepth, texCoord );",
    "float z = texDepth.x * 2.0 - 1.0;",
    "#else",
    "vec4 packedDepth = texture2D( samplerDepth, texCoord );",
    "float z = unpackDepth( packedDepth );",
    "#endif",
    "#else",
    "vec4 normalDepth = texture2D( samplerNormalDepth, texCoord );",
    "float z = normalDepth.w;",
    "#endif",
    "if ( z <= 0.0 || z >= 1.0 ) discard;",
    "vec2 xy = texCoord * 2.0 - 1.0;",
    "vec4 vertexPositionProjected = vec4( xy, z, 1.0 );",
    "vec4 vertexPositionVS = matProjInverse * vertexPositionProjected;",
    "vertexPositionVS.xyz /= vertexPositionVS.w;",
    "vertexPositionVS.w = 1.0;",
  ].join("\n")),
  (XG.DeferredShaderChunk.computeNormal = [
    "#ifdef USE_MRT",
    "vec4 normalTex = texture2D( samplerNormal, texCoord );",
    "vec3 normal = decodeNormalOct24( normalTex.xyz );",
    "#else",
    "vec3 normal = normalDepth.xyz * 2.0 - 1.0;",
    "#endif",
    "normal = normalize( normal );",
  ].join("\n")),
  (XG.DeferredShaderChunk.unpackColorMap = [
    "#ifdef USE_MRT",
    "vec4 albedoShininessLo = texture2D( samplerDiffuseRGB, texCoord );",
    "vec3 albedo = albedoShininessLo.rgb * albedoShininessLo.rgb;",
    "vec4 specularColorShininessHi = texture2D( samplerSpecularRGB, texCoord );",
    "vec3 specularColor = specularColorShininessHi.rgb * specularColorShininessHi.rgb;",
    "float shininess = specularColorShininessHi.a * 256.0 * 256.0 + albedoShininessLo.a * 256.0;",
    "vec4 wrapRGBWrapAround = texture2D( samplerWrapRGB, texCoord );",
    "vec3 wrapRGB = wrapRGBWrapAround.rgb;",
    "float wrapAround = sign( wrapRGBWrapAround.a - 0.5 );",
    "float lightMapIntensity = normalTex.a;",
    "#else",
    "vec4 colorMap = texture2D( samplerColor, texCoord );",
    "vec3 albedo = float_to_vec3( abs( colorMap.x ) );",
    "albedo *= albedo;",
    "vec3 specularColor = float_to_vec3( abs( colorMap.y ) );",
    "specularColor *= specularColor;",
    "vec3 wrapRGB = float_to_vec3( abs( colorMap.w ) );",
    "vec2 shininessLightmap = float_to_vec21( abs( colorMap.z ) );",
    "float shininess = shininessLightmap.x;",
    "float lightMapIntensity = shininessLightmap.y;",
    "float wrapAround = sign( colorMap.z );",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.computeDiffuse = [
    "float dotLNUnclamped = dot( lightVector, normal );",
    "float dotLN = max( dotLNUnclamped, 0.0 );",
    "vec3 diffuse = vec3( dotLN );",
    "if ( wrapAround < 0.0 ) {",
    "#ifdef SKIN_HQ",
    "float curvature = length( fwidth( normal ) ) / length( fwidth( vertexPositionVS.xyz ) );",
    "diffuse = PSSFitFunction( dotLNUnclamped, curvature );",
    "#else",
    "float dotLNHalf = max( 0.25 * dotLNUnclamped + 0.25, 0.0 );",
    "diffuse = mix( diffuse, vec3( dotLNHalf ), wrapRGB );",
    "#endif",
    "}",
  ].join("\n")),
  (XG.DeferredShaderChunk.geometryFactor = [
    "float SmithGeometryFactor1( vec3 H, vec3 V, vec3 N, float shininess ) {",
    "float dotVN = dot( V, N );",
    "float dotVH = dot( V, H );",
    "if ( ( dotVH / dotVN ) <= 0.0 ) return 0.0;",
    "float f = acos( dotVN );",
    "float a = sqrt( 0.5 * shininess + 1.0 ) / tan( f );",
    "float G = 1.0;",
    "if ( a < 1.6 )",
    "G = ( 3.535 * a + 2.181 * a * a ) / ( 1.0 + 2.276 * a + 2.577 * a * a );",
    "return G;",
    "}",
    "float SmithGeometryFactor2( float dotLN, vec3 V, vec3 N, float shininess ) {",
    "float dotNV = max( dot( N, V ), 0.0 );",
    "float a = 1.0 / ( sqrt( 0.7854 * shininess + 1.571 ) );",
    "return 1.0 / ( ( dotLN * ( 1.0 - a ) + a ) * ( dotNV * ( 1.0 - a ) + a ) );",
    "}",
    "float KelemenGeometryFactor( float dotLH ) {",
    "return 1.0 / ( dotLH * dotLH );",
    "}",
    "float GGX_SchlickGeometryFactor_V1( in float k, in float dotNX ) {",
    "return dotNX / ( dotNX * ( 1.0 - k ) + k );",
    "}",
    "float GGX_SchlickGeometryFactor_V2( in float k, in float dotNX ) {",
    "return 1.0 / ( dotNX + sqrt( k + ( 1.0 - k ) * dotNX * dotNX ) );",
    "}",
  ].join("\n")),
  (XG.DeferredShaderChunk.environmentBRDF = [
    "vec3 EnvironmentBRDF( float gloss, float dotNV, vec3 rf0 ) {",
    "vec4 t = vec4( 1.0 / 0.96, 0.475, ( 0.0275 - 0.25 * 0.04 ) / 0.96, 0.25 );",
    "t *= vec4( gloss );",
    "t += vec4( 0.0, 0.0, ( 0.015 - 0.75 * 0.04 ) / 0.96, 0.75 );",
    "float a0 = t.x * min( t.y, exp2( -9.28 * dotNV ) ) + t.z;",
    "float a1 = t.w;",
    "return clamp( a0 + rf0 * ( a1 - a0 ), 0.0, 1.0 );",
    "}",
  ].join("\n")),
  (XG.DeferredShaderChunk.specularOcclusion = [
    "float computeSpecOcclusion( float NdotV, float AO, float roughness ) {",
    "return saturate( pow( NdotV + AO, exp2( -16.0 * roughness - 1.0 ) ) - 1.0 + AO );",
    "}",
  ].join("\n")),
  (XG.DeferredShaderChunk.specularBRDF = [
    "float GGX_Specular( in float m, in vec3 n, in vec3 h, in vec3 v, in vec3 l ) {",
    "float nDotH = saturate( dot( n, h ) );",
    "float nDotL = saturate( dot( n, l ) );",
    "float nDotV = saturate( dot( n, v ) );",
    "float nDotH2 = nDotH * nDotH;",
    "float m2 = pow( m, 4.0 );",
    "float d = m2 / ( pow( nDotH * nDotH * ( m2 - 1.0 ) + 1.0, 2.0 ) );",
    "float v1i = GGX_SchlickGeometryFactor_V2( m2, nDotL );",
    "float v1o = GGX_SchlickGeometryFactor_V2( m2, nDotV );",
    "float vis = v1i * v1o;",
    "return d * vis;",
    "}",
    "float BlinnPhong_Specular( in float shininess, in float dotLN, in float dotNormalHalf, in vec3 eyeVector, in vec3 normal ) {",
    "float specularNormalization = shininess * 0.125 + 0.25;",
    "float geo = SmithGeometryFactor2( dotLN, eyeVector, normal, shininess );",
    "return ( specularNormalization * geo ) * max( pow( dotNormalHalf, shininess ), 0.0 );",
    "}",
  ].join("\n")),
  (XG.DeferredShaderChunk.computeSpecular = [
    "vec3 eyeVector = normalize( -vertexPositionVS.xyz );",
    "vec3 halfVector = normalize( lightVector + eyeVector );",
    "float dotNormalHalf = max( dot( normal, halfVector ), 0.0 );",
    "float dotLightHalf = max( dot( lightVector, halfVector ), 0.0 );",
    "vec3 fresnel = specularColor + ( 1.0 - specularColor ) * pow( 1.0 - dotLightHalf, 5.0 );",
    "fresnel *= float( dot( specularColor, vec3( 1.0 ) ) > 0.0 );",
    "#if defined( BRDF_BLINN_PHONG )",
    "vec3 specular = BlinnPhong_Specular( shininess, dotLN, dotNormalHalf, eyeVector, normal ) * ( fresnel * dotLN );",
    "#elif defined( BRDF_GGX )",
    "float roughness = saturate( sqrt( 8.0 / ( shininess + 7.0 ) ) );",
    "vec3 specular = GGX_Specular( roughness, normal, halfVector, eyeVector, lightVector ) * ( fresnel * dotLN );",
    "#else",
    "vec3 specular = specularColor * max( pow( dotNormalHalf, shininess ), 0.0 ) * dotLN;",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.combine = [
    "vec3 light = lightIntensity * lightColor;",
    "mgl_FragColor = vec4( light * ( albedo * diffuse + specular ), attenuation );",
  ].join("\n")),
  (XG.DeferredShaderChunk.directionalOcclusion = [
    "#ifdef OCCLUSION_ENABLED",
    "uniform mat4 matProj;",
    "float checkOcclusion( in vec3 pointVS ) {",
    "vec4 pointCS = matProj * vec4( pointVS, 1.0 );",
    "pointCS.xyz /= pointCS.w;",
    "vec2 pointUV = pointCS.xy * 0.5 + 0.5;",
    "#ifdef USE_MRT",
    "#ifdef TEXTURE_DEPTH",
    "vec4 depthSample = texture2D( samplerDepth, pointUV );",
    "float sampleZ = depthSample.x * 2.0 - 1.0;",
    "#else",
    "vec4 depthSample = texture2D( samplerDepth, pointUV );",
    "float sampleZ = unpackDepth( depthSample );",
    "#endif",
    "#else",
    "vec4 normalDepthSample = texture2D( samplerNormalDepth, pointUV );",
    "float sampleZ = normalDepthSample.w;",
    "#endif",
    "float occlusion = 1.0;",
    "if ( pointCS.z > sampleZ ) occlusion = 0.0;",
    "return occlusion;",
    "}",
    "vec2 rand( const in vec2 coord ) {",
    "float nx = dot ( coord, vec2( 12.9898, 78.233 ) );",
    "float ny = dot ( coord, vec2( 25.9796, 156.466 ) );",
    "vec2 noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );",
    "return noise;",
    "}",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.shadowMapPCFSoft = [
    "#ifdef USE_SHADOWSAMPLER",
    "float sampleShadowPCFSoft( sampler2DShadow shadowMap, vec2 shadowMapSize, vec2 shadowCoord, float vertexDepth ) {",
    "vec2 pixelOffset = vec2( 1.0 ) / shadowMapSize;",
    "float dx0 = -pixelOffset.x;",
    "float dy0 = -pixelOffset.y;",
    "float dx1 =  pixelOffset.x;",
    "float dy1 =  pixelOffset.y;",
    "float shadowValue = 0.0;",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( dx0, dy0 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( 0.0, dy0 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( dx1, dy0 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( dx0, 0.0 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord, 				      vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( dx1, 0.0 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( dx0, dy1 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( 0.0, dy1 ), vertexDepth ) );",
    "shadowValue += texture( shadowMap, vec3( shadowCoord + vec2( dx1, dy1 ), vertexDepth ) );",
    "shadowValue /= 9.0;",
    "return 1.0 - shadowValue;",
    "}",
    "#else",
    "float sampleShadowPCFSoft( sampler2D shadowMap, vec2 shadowMapSize, vec2 shadowCoord, float vertexDepth ) {",
    "vec2 pixelOffset = vec2( 1.0 ) / shadowMapSize;",
    "float dx0 = -pixelOffset.x;",
    "float dy0 = -pixelOffset.y;",
    "float dx1 =  pixelOffset.x;",
    "float dy1 =  pixelOffset.y;",
    "float shadowDepth;",
    "mat3 shadowKernel;",
    "shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx0, dy0 ) ).x;",
    "shadowKernel[0][0] = float( vertexDepth > shadowDepth );",
    "shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx0, 0.0 ) ).x;",
    "shadowKernel[0][1] = float( vertexDepth > shadowDepth );",
    "shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx0, dy1 ) ).x;",
    "shadowKernel[0][2] = float( vertexDepth > shadowDepth );",
    "shadowDepth = texture2D( shadowMap, shadowCoord + vec2( 0.0, dy0 ) ).x;",
    "shadowKernel[1][0] = float( vertexDepth > shadowDepth );",
    "shadowDepth = texture2D( shadowMap, shadowCoord ).x;",
    "shadowKernel[1][1] = float( vertexDepth > shadowDepth );",
    "shadowDepth = texture2D( shadowMap, shadowCoord + vec2( 0.0, dy1 ) ).x;",
    "shadowKernel[1][2] = float( vertexDepth > shadowDepth );",
    "shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx1, dy0 ) ).x;",
    "shadowKernel[2][0] = float( vertexDepth > shadowDepth );",
    "shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx1, 0.0 ) ).x;",
    "shadowKernel[2][1] = float( vertexDepth > shadowDepth );",
    "shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx1, dy1 ) ).x;",
    "shadowKernel[2][2] = float( vertexDepth > shadowDepth );",
    "shadowKernel *= 0.25;",
    "vec2 fractionalCoord = 1.0 - fract( shadowCoord * shadowMapSize );",
    "shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
    "shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",
    "vec4 shadowValues;",
    "shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
    "shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
    "shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
    "shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",
    "float shadowValue = dot( shadowValues, vec4( 1.0 ) );",
    "return shadowValue;",
    "}",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.computePointShadowMaps = [
    "#ifdef USE_SHADOWMAP",
    "vec4 vertexPositionWS = matViewInverse * vertexPositionVS;",
    "vec3 lightToPositionWS = vertexPositionWS.xyz - lightPositionWS.xyz;",
    "float shadowCameraNear = shadowCameraPars.x;",
    "float shadowCameraFar  = shadowCameraPars.y;",
    "const vec2 cubeAtlasSize = vec2( 6.0, 1.0 );",
    "const vec2 cubeAtlasSizeInv = vec2( 1.0 / 6.0, 1.0 );",
    "vec3 shadowCoordCube = normalize( lightToPositionWS );",
    "float vertexDepth = vectorToDepth( lightToPositionWS, shadowCameraNear, shadowCameraFar );",
    "vertexDepth += shadowBias;",
    "vec3 shadowCoordStruct = cubeToUV( shadowCoordCube );",
    "vec2 atlasOffset = shadowCoordStruct.z * vec2( 1.0, 0.0 );",
    "#ifdef USE_SHADOWSAMPLER",
    "const float atlasPixelMargin = 0.5;",
    "#else",
    "const float atlasPixelMargin = 0.25;",
    "#endif",
    "vec2 minUV = vec2(   shadowCoordStruct.z         * vec2( 1.0 + atlasPixelMargin/shadowMapSize.x, 0.0 ) ) * cubeAtlasSizeInv;",
    "vec2 maxUV = vec2( ( shadowCoordStruct.z + 1.0 ) * vec2( 1.0 - atlasPixelMargin/shadowMapSize.x, 1.0 ) ) * cubeAtlasSizeInv;",
    "#if defined( SHADOWMAP_TYPE_PCF_SOFT )",
    "float shadowValue = sampleShadowPCFSoftAtlas( samplerShadowMap, shadowMapSize * cubeAtlasSize, ( shadowCoordStruct.xy + atlasOffset ) * cubeAtlasSizeInv, vertexDepth, minUV, maxUV );",
    "#elif defined( SHADOWMAP_TYPE_PCF_SOFT_HQ )",
    "vec2 pixelOffset = vec2( 2.0 ) / shadowMapSize;",
    "float shadowValue0 = sampleShadowPCFSoftAtlas( samplerShadowMap, shadowMapSize * cubeAtlasSize, ( shadowCoordStruct.xy + vec2( -pixelOffset.x, 0.0 ) + atlasOffset ) * cubeAtlasSizeInv, vertexDepth, minUV, maxUV );",
    "float shadowValue1 = sampleShadowPCFSoftAtlas( samplerShadowMap, shadowMapSize * cubeAtlasSize, ( shadowCoordStruct.xy + vec2(  pixelOffset.x, 0.0 ) + atlasOffset ) * cubeAtlasSizeInv, vertexDepth, minUV, maxUV );",
    "float shadowValue2 = sampleShadowPCFSoftAtlas( samplerShadowMap, shadowMapSize * cubeAtlasSize, ( shadowCoordStruct.xy + vec2( 0.0, -pixelOffset.y ) + atlasOffset ) * cubeAtlasSizeInv, vertexDepth, minUV, maxUV );",
    "float shadowValue3 = sampleShadowPCFSoftAtlas( samplerShadowMap, shadowMapSize * cubeAtlasSize, ( shadowCoordStruct.xy + vec2( 0.0,  pixelOffset.y ) + atlasOffset ) * cubeAtlasSizeInv, vertexDepth, minUV, maxUV );",
    "float shadowValue = ( shadowValue0 + shadowValue1 + shadowValue2 + shadowValue3 ) * 0.25;",
    "#else",
    "vec2 shadowCoord = clamp( ( shadowCoordStruct.xy + shadowCoordStruct.z * vec2( 1.0, 0.0 ) ) * cubeAtlasSizeInv, minUV, maxUV );",
    "#ifdef USE_SHADOWSAMPLER",
    "float shadowValue = 1.0 - texture( samplerShadowMap, vec3( shadowCoord, vertexDepth ) );",
    "#else",
    "vec4 rgbaDepth = texture2D( samplerShadowMap, shadowCoord );",
    "float shadowDepth = unpackDepthShadow( rgbaDepth );",
    "float shadowValue = float( vertexDepth > shadowDepth );",
    "#endif",
    "#endif",
    "occlusion = 1.0 - shadowDarkness * shadowValue;",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.normalsParsFragment = [
    "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP ) || defined( USE_DISPLACEMENTMAP )",
    "varying vec3 vViewPosition;",
    "#endif",
    XG.ShaderChunk.bumpmap_pars_fragment,
    XG.ShaderChunk.derivativemap_pars_fragment,
    XG.ShaderChunk.normalmap_pars_fragment,
    "#if defined( USE_BUMPDETAILMAP ) || defined( USE_NORMALDETAILMAP )",
    "uniform vec3 detailRepeatScale;",
    "#endif",
    "varying vec3 normalView;",
  ].join("\n")),
  (XG.DeferredShaderChunk.normalsFragment = [
    "#if defined( USE_DISPLACEMENTMAP )",
    "normal = perturbNormalArb( vViewPosition, normal, dHdxy_fwd( displacementMap, uvCoord, displacementNormalScale ) );",
    "#endif",
    "#if defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP )",
    "#ifdef USE_NORMALDETAILMAP",
    "vec4 normalDetail = texture2D( normalDetailMap, uvCoord *  detailRepeatScale.xy ) * 2.0 - 1.0;",
    "normalDetail.rgb = normalize( normalDetail.rgb * vec3( detailRepeatScale.zz, 1.0 ) ) * 0.5 + 0.5;",
    "vec3 n1 = normalGloss.xyz  * vec3(  2.0,  2.0, 2.0 ) + vec3( -1.0, -1.0,  0.0 );",
    "vec3 n2 = normalDetail.xyz * vec3( -2.0, -2.0, 2.0 ) + vec3(  1.0,  1.0, -1.0 );",
    "normalGloss.xyz  = normalize( n1 * dot( n1, n2 ) / n1.z - n2 ) * 0.5 + 0.5;",
    "#endif",
    "normal = perturbNormal2Arb( vViewPosition, normal, normalGloss.xyz, uvCoord );",
    "#elif defined( USE_BUMPMAP )",
    "normal = perturbNormalArb( vViewPosition, normal, dHdxy_fwd( bumpMap, uvCoord, bumpScale ) );",
    "#endif",
    "#ifdef USE_BUMPDETAILMAP",
    "normal = perturbNormalArb( vViewPosition, normal, dHdxy_fwd( bumpDetailMap, uvCoord * detailRepeatScale.xy, detailRepeatScale.z ) );",
    "#endif",
    "#if defined ( USE_NORMALDETAILMAP ) && ! ( defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP ) )",
    "vec4 normalDetail = texture2D( normalDetailMap, uvCoord * detailRepeatScale.xy ) * 2.0 - 1.0;",
    "normalDetail.rgb = normalize( normalDetail.rgb * vec3( detailRepeatScale.zz, 1.0 ) ) * 0.5 + 0.5;",
    "normal = perturbNormal2Arb( vViewPosition, normal, normalDetail.xyz, uvCoord * detailRepeatScale.xy );",
    "#endif",
    "#ifdef DOUBLE_SIDED",
    "float flipNormal = 2.0 * float( gl_FrontFacing ) - 1.0;",
    "normal = flipNormal * normal;",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.colorsFragment = [
    "float shininess = specular.a;",
    "float wrapAround = diffuse.a;",
    "vec4 diffuseColor  = vec4( diffuse.rgb, 1.0 );",
    "vec4 specularColor = vec4( specular.rgb, 1.0 );",
    "#ifdef USE_MAP",
    "#ifdef PARTICLE",
    "vec2 texCoord = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );",
    "#else",
    "vec2 texCoord = uvCoord;",
    "#endif",
    "vec4 diffuseMapColor = texture2D( map, texCoord );",
    "diffuseColor *= diffuseMapColor;",
    "#endif",
    "#ifdef ALPHATEST",
    "if ( diffuseColor.a < ALPHATEST ) discard;",
    "#endif",
    "#ifdef USE_COLOR",
    "diffuseColor.rgb *= vColor;",
    "#endif",
    XG.ShaderChunk.specularmap_fragment,
    "specularColor.rgb *= specularMapColor;",
    "#ifdef USE_LIGHTMAP",
    "#ifdef LIGHTMAP_SECONDARY_UV",
    "float lightMapIntensity = texture2D( lightMap, uvCoord2 ).r;",
    "#else",
    "float lightMapIntensity = texture2D( lightMap, uvCoord ).r;",
    "#endif",
    "#ifdef LIGHTMAP_GAMMA",
    "lightMapIntensity *= lightMapIntensity;",
    "#endif",
    "#else",
    "float lightMapIntensity = 1.0;",
    "#endif",
    "#if defined( USE_GLOSSMAP )",
    "vec4 glossMapVal = texture2D( glossMap, uvCoord );",
    "float gloss = exp2( 13.0 * glossMapVal.r + 1.0 );",
    "#elif defined( USE_NORMALGLOSSMAP )",
    "float gloss = exp2( 13.0 * normalGloss.a + 1.0 );",
    "#else",
    "float gloss = 1.0;",
    "#endif",
    "shininess = clamp( shininess * gloss, 0.0, 8192.0 );",
  ].join("\n")),
  (XG.DeferredShaderChunk.hemiTerm = [
    "const float maxShininess = 8192.0;",
    "float gloss = min( shininess / maxShininess, 1.0 );",
    "vec3 fresnelHemi = EnvironmentBRDF( gloss, dot( eyeVector, halfVector ), specularColor );",
    "float dotProductHemi = dot( normal, lightVectorHemi );",
    "float hemiDiffuseWeightUnclamped = 0.5 * dotProductHemi + 0.5;",
    "float hemiDiffuseWeight = clamp( hemiDiffuseWeightUnclamped, 0.0, 1.0 );",
    "vec3 diffuseHemi;",
    "if ( wrapAround < 0.0 ) {",
    "float hemiDiffuseWeightUnclamped2 = -0.5 * dotProductHemi + 0.5;",
    "float hemiDiffuseWeight2 = clamp( hemiDiffuseWeightUnclamped2, 0.0, 1.0 );",
    "diffuseHemi = 0.75 * mix( lightColorGround, lightColorSky, hemiDiffuseWeight ) + 0.25 * mix( lightColorGround, lightColorSky, hemiDiffuseWeight2 );",
    "} else {",
    "diffuseHemi = mix( lightColorGround, lightColorSky, hemiDiffuseWeight );",
    "}",
    "diffuseHemi *= ( 1.0 - fresnelHemi );",
    "vec3 R = reflect( -eyeVector, normal );",
    "R = normalize( R );",
    "float hemiSpecularWeight = clamp( dot( R, lightVectorHemi ) * 0.5 + 0.5, 0.0, 1.0 );",
    "vec3 specularHemi = fresnelHemi * mix( lightColorGround, lightColorSky, hemiSpecularWeight );",
    "float diffuseOcclusion = lightMapIntensity;",
    "#ifdef USE_SSAO",
    "float ssaoOcclusion = texture2D( samplerSSAO, texCoord ).x;",
    "ssaoOcclusion *= ssaoOcclusion;",
    "diffuseOcclusion = min( diffuseOcclusion, ssaoOcclusion );",
    "#endif",
    "float NdotV = dot( normal, eyeVector );",
    "float specularOcclusion = computeSpecOcclusion( NdotV, diffuseOcclusion, roughness );",
    "vec3 hemiTerm = lightIntensityHemi * ( albedo * diffuseHemi * diffuseOcclusion + specularHemi * specularOcclusion );",
  ].join("\n")),
  (XG.DeferredShaderChunk.shadowPrep = [
    "float sectorOcclusion = 1.0;",
    "vec4 posLightCS = matShadow[ i ] * vertexPositionVS;",
    "vec2 shadowCoord = ( posLightCS.xy / posLightCS.w ) * 0.5 + 0.5;",
    "bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
    "bool inFrustum = all( inFrustumVec );",
  ].join("\n")),
  (XG.DeferredShaderChunk.shadowCheck = [
    "float vertexDepth = posLightCS.z / posLightCS.w;",
    "#if defined( SHADOW_TEXTURE_DEPTH )",
    "vertexDepth = vertexDepth * 0.5 + 0.5;",
    "#endif",
    "#if !defined( SLOPE_DEPTH_BIAS )",
    "vertexDepth -= shadowBias;",
    "#endif",
    "#if defined( SHADOWMAP_TYPE_PCF_SOFT )",
    "float shadowValue = sampleShadowPCFSoft( samplerShadowMap[ i ], shadowMapSize, shadowCoord, vertexDepth );",
    "#elif defined( SHADOWMAP_TYPE_PCF_SOFT_HQ )",
    "vec2 pixelOffset = vec2( 2.0 ) / shadowMapSize;",
    "float shadowValue0 = sampleShadowPCFSoft( samplerShadowMap[ i ], shadowMapSize, shadowCoord + vec2( -pixelOffset.x, 0.0 ), vertexDepth );",
    "float shadowValue1 = sampleShadowPCFSoft( samplerShadowMap[ i ], shadowMapSize, shadowCoord + vec2(  pixelOffset.x, 0.0 ), vertexDepth );",
    "float shadowValue2 = sampleShadowPCFSoft( samplerShadowMap[ i ], shadowMapSize, shadowCoord + vec2( 0.0, -pixelOffset.y ), vertexDepth );",
    "float shadowValue3 = sampleShadowPCFSoft( samplerShadowMap[ i ], shadowMapSize, shadowCoord + vec2( 0.0,  pixelOffset.y ), vertexDepth );",
    "float shadowValue = ( shadowValue0 + shadowValue1 + shadowValue2 + shadowValue3 ) * 0.25;",
    "#else",
    "#ifdef USE_SHADOWSAMPLER",
    "float shadowValue = 1.0 - texture( samplerShadowMap[ i ], vec3( shadowCoord, vertexDepth ) );",
    "#else",
    "float shadowDepth = texture2D( samplerShadowMap[ i ], shadowCoord ).x;",
    "float shadowValue = float( vertexDepth > shadowDepth );",
    "#endif",
    "#endif",
    "sectorOcclusion = 1.0 - shadowDarkness * shadowValue;",
    "occlusion *= sectorOcclusion;",
  ].join("\n")),
  (XG.DeferredShaderChunk.directionalShadows = [
    "float occlusion = 1.0;",
    "#ifdef USE_SHADOWMAP",
    "#ifdef SHADOWMAP_DEBUG",
    "vec3 frustumColors[5];",
    "frustumColors[0] = vec3( 1.0, 0.0, 0.0 );",
    "frustumColors[1] = vec3( 0.0, 1.0, 0.0 );",
    "frustumColors[2] = vec3( 0.0, 0.0, 1.0 );",
    "frustumColors[3] = vec3( 0.0, 0.5, 1.0 );",
    "frustumColors[4] = vec3( 0.2, 0.5, 1.0 );",
    "vec3 debugColor = vec3( 1.0 );",
    "#endif",
    "#ifdef OSX_HACK",
    "bool found = false;",
    "#endif",
    "for ( int i = 0; i < SHADOWMAP_COUNT; i ++ ) {",
    XG.DeferredShaderChunk.shadowPrep,
    "#ifdef OSX_HACK",
    "if ( inFrustum && !found ) {",
    "#else",
    "if ( inFrustum ) {",
    "#endif",
    XG.DeferredShaderChunk.shadowCheck,
    "#ifdef SHADOWMAP_DEBUG",
    "debugColor *= frustumColors[ i ];",
    "#endif",
    "#if SHADOWMAP_COUNT > 1",
    "#ifdef OSX_HACK",
    "found = true;",
    "#else",
    "break;",
    "#endif",
    "#endif",
    "}",
    "}",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaderChunk.directionalProjectedTexture = [
    "#ifdef PROJECTED_TEXTURE",
    "vec4 posTextureCS = matTexture * vertexPositionVS;",
    "#ifdef PROJECTED_SHADOW",
    "vec2 textureCoord = ( posTextureCS.xy / posTextureCS.w ) * 0.5 + 0.5;",
    "bvec4 inTexFrustumVec = bvec4 ( textureCoord.x >= 0.0, textureCoord.x <= 1.0, textureCoord.y >= 0.0, textureCoord.y <= 1.0 );",
    "bool inTexFrustum = all( inTexFrustumVec );",
    "if ( inTexFrustum ) {",
    "vec4 textureColor = texture2DProj( samplerTexture, posTextureCS, textureBias );",
    "float translucency = 1.0 - textureColor.r * shadowDarkness;",
    "occlusion = min( occlusion, translucency );",
    "}",
    "#else",
    "vec4 textureColor = texture2DProj( samplerTexture, posTextureCS, textureBias );",
    "textureColor.rgb *= textureColor.rgb;",
    "diffuse *= textureColor.rgb;",
    "specular *= textureColor.rgb;",
    "#endif",
    "#endif",
  ].join("\n")),
  (XG.DeferredShaders.combined = {
    uniforms: XG.UniformsUtils.merge([
      XG.UniformsLib.common,
      XG.UniformsLib.particle,
      XG.UniformsLib.bump,
      XG.UniformsLib.normalmap,
      XG.UniformsLib.displacement,
      XG.DeferredUniformsLib.wireframe,
      {
        diffuse: { type: "v4", value: new XG.Vector4(1, 1, 1, 1) },
        specular: { type: "v4", value: new XG.Vector4(0.1, 0.1, 0.1, 30) },
        wrapRGB: { type: "v3", value: new XG.Vector3(1, 1, 1) },
        detailRepeatScale: { type: "v3", value: new XG.Vector3(1, 1, 1) },
        glossMap: { type: "t", value: null },
        specularMap: { type: "t", value: null },
        parallaxScale: { type: "f", value: 1 },
      },
    ]),
    fragmentShader: [
      "uniform vec4 diffuse;",
      "uniform vec4 specular;",
      "uniform vec3 wrapRGB;",
      "#ifndef TEXTURE_DEPTH",
      "varying vec4 clipPos;",
      "#endif",
      XG.DeferredShaderChunk.wireframeParsFragment,
      XG.DeferredShaderChunk.normalsParsFragment,
      XG.DeferredShaderChunk.packFloat,
      XG.ShaderChunk.color_pars_fragment,
      XG.ShaderChunk.map_pars_fragment,
      XG.ShaderChunk.lightmap_pars_fragment,
      XG.ShaderChunk.specularmap_pars_fragment,
      XG.ShaderChunk.glossmap_pars_fragment,
      XG.ShaderChunk.parallax_pars_fragment,
      XG.ShaderChunk.displacementmap_pars_fragment,
      XG.ShaderChunk.encodingUtils,
      "void main() {",
      "#if !defined( PARTICLE ) && ( defined( USE_MAP ) || defined( USE_LIGHTMAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined ( USE_NORMALGLOSSMAP ) || defined ( USE_GLOSSMAP ) || defined( USE_SPECULARMAP ) || defined( USE_DISPLACEMENTMAP ) )",
      "vec2 uvCoord = vUv;",
      "#endif",
      "#if defined( USE_LIGHTMAP ) && defined( LIGHTMAP_SECONDARY_UV )",
      "vec2 uvCoord2 = vUv2;",
      "#endif",
      "vec3 normal = normalize( normalView );",
      "#if defined( USE_BUMPMAP ) && defined( USE_PARALLAX )",
      "vec3 eyeVector = normalize( -vViewPosition );",
      "#endif",
      XG.ShaderChunk.parallax_fragment,
      "#if defined( USE_NORMALGLOSSMAP ) || defined( USE_NORMALMAP )",
      "vec4 normalGloss = texture2D( normalMap, uvCoord );",
      "#endif",
      XG.DeferredShaderChunk.normalsFragment,
      XG.DeferredShaderChunk.colorsFragment,
      XG.DeferredShaderChunk.wireframeFragment,
      "float shininessLo = fract( shininess / 256.0 );",
      "float shininessHi = floor( shininess / 256.0 ) / 256.0;",
      "mgl_FragData[ 0 ] = vec4( diffuseColor.rgb, shininessLo );",
      "mgl_FragData[ 1 ] = vec4( specularColor.rgb, shininessHi );",
      "mgl_FragData[ 2 ] = vec4( wrapRGB.rgb, wrapAround + 0.5 );",
      "mgl_FragData[ 3 ] = vec4( encodeNormalOct24( normal ), lightMapIntensity );",
      "#ifndef TEXTURE_DEPTH",
      "mgl_FragData[ 4 ] = vec4( packDepth( clipPos.z / clipPos.w ) );",
      "#endif",
      "}",
    ].join("\n"),
    vertexShader: [
      XG.DeferredShaderChunk.wireframeParsVertex,
      XG.ShaderChunk.instances_pars_vertex,
      XG.ShaderChunk.map_pars_vertex,
      XG.ShaderChunk.color_pars_vertex,
      XG.ShaderChunk.morphtarget_pars_vertex,
      XG.ShaderChunk.skinning_pars_vertex,
      XG.ShaderChunk.particle_pars_vertex,
      XG.ShaderChunk.displacement_pars_vertex,
      "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP ) || defined( USE_DISPLACEMENTMAP )",
      "varying vec3 vViewPosition;",
      "#endif",
      "varying vec3 normalView;",
      "#ifndef TEXTURE_DEPTH",
      "varying vec4 clipPos;",
      "#endif",
      "void main() {",
      XG.ShaderChunk.map_vertex,
      XG.ShaderChunk.begin_nor_vertex,
      XG.ShaderChunk.morphnormal_vertex,
      XG.ShaderChunk.skinbase_vertex,
      XG.ShaderChunk.skinnormal_vertex,
      XG.ShaderChunk.end_nor_vertex,
      XG.ShaderChunk.begin_pos_vertex,
      XG.ShaderChunk.displacement_vertex,
      XG.ShaderChunk.morphtarget_vertex,
      XG.ShaderChunk.skinning_vertex,
      XG.ShaderChunk.default_vertex,
      XG.ShaderChunk.end_pos_vertex,
      XG.ShaderChunk.particle_vertex,
      "normalView = transformedNormal;",
      "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP ) || defined( USE_DISPLACEMENTMAP )",
      "vViewPosition = mvPosition.xyz;",
      "#endif",
      "#ifdef USE_COLOR",
      "vColor = color;",
      "#endif",
      "#ifndef TEXTURE_DEPTH",
      "clipPos = gl_Position;",
      "#endif",
      XG.DeferredShaderChunk.wireframeVertex,
      "}",
    ].join("\n"),
  }),
  (XG.DeferredShaders.occluder = {
    uniforms: XG.UniformsUtils.merge([
      XG.UniformsLib.common,
      XG.UniformsLib.particle,
      XG.UniformsLib.displacement,
      {
        alphaMap: { type: "t", value: null },
        detailRepeatScale: { type: "v3", value: new XG.Vector3(1, 1, 1) },
      },
    ]),
    fragmentShader: [
      "varying vec4 clipPos;",
      "#ifdef ALPHATEST",
      "uniform sampler2D alphaMap;",
      "varying vec2 vUv;",
      "#endif",
      XG.DeferredShaderChunk.packFloat,
      "void main() {",
      "#ifdef ALPHATEST",
      "vec2 textureCoord;",
      "#ifdef PARTICLE",
      "textureCoord = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );",
      "#else",
      "textureCoord = vUv;",
      "#endif",
      "float alphaValue = texture2D( alphaMap, textureCoord ).a;",
      "if ( alphaValue < ALPHATEST ) discard;",
      "#endif",
      "mgl_FragColor = vec4( packDepth( clipPos.z / clipPos.w ) );",
      "}",
    ].join("\n"),
    vertexShader: [
      XG.ShaderChunk.instances_pars_vertex,
      XG.ShaderChunk.map_pars_vertex,
      XG.ShaderChunk.morphtarget_pars_vertex,
      XG.ShaderChunk.skinning_pars_vertex,
      XG.ShaderChunk.particle_pars_vertex,
      XG.ShaderChunk.displacement_pars_vertex,
      "#ifdef ALPHATEST",
      "varying vec2 vUv;",
      "#endif",
      "varying vec4 clipPos;",
      "void main() {",
      "#if !defined( PARTICLE ) &&( defined( ALPHATEST ) || defined( USE_DISPLACEMENTMAP ) )",
      "vec2 transformedUV = uv * offsetRepeat.zw + offsetRepeat.xy;",
      "#endif",
      XG.ShaderChunk.skinbase_vertex,
      XG.ShaderChunk.begin_pos_vertex,
      XG.ShaderChunk.displacement_vertex,
      XG.ShaderChunk.morphtarget_vertex,
      XG.ShaderChunk.skinning_vertex,
      XG.ShaderChunk.default_vertex,
      XG.ShaderChunk.end_pos_vertex,
      XG.ShaderChunk.particle_vertex,
      "#ifdef ALPHATEST",
      "vUv = transformedUV;",
      "#endif",
      "clipPos = gl_Position;",
      "}",
    ].join("\n"),
  }),
  (XG.DeferredShaders.color = {
    uniforms: XG.UniformsUtils.merge([
      XG.UniformsLib.common,
      XG.UniformsLib.particle,
      XG.UniformsLib.displacement,
      XG.DeferredUniformsLib.wireframe,
      {
        diffuse: { type: "v4", value: new XG.Vector4(1, 1, 1, 1) },
        specular: { type: "v4", value: new XG.Vector4(0.1, 0.1, 0.1, 30) },
        wrapRGB: { type: "v3", value: new XG.Vector3(1, 1, 1) },
        glossMap: { type: "t", value: null },
        specularMap: { type: "t", value: null },
        normalMap: { type: "t", value: null },
        bumpMap: { type: "t", value: null },
        samplerNormalDepth: { type: "t", value: null, shared: !0 },
        viewSize: { type: "v2", value: new XG.Vector2(800, 600), shared: !0 },
        parallaxScale: { type: "f", value: 1 },
      },
    ]),
    fragmentShader: [
      "uniform vec4 diffuse;",
      "uniform vec4 specular;",
      "uniform vec3 wrapRGB;",
      XG.ShaderChunk.color_pars_fragment,
      XG.ShaderChunk.map_pars_fragment,
      XG.ShaderChunk.lightmap_pars_fragment,
      "#ifdef USE_NORMALGLOSSMAP",
      "uniform sampler2D normalMap;",
      "#endif",
      "#if defined( USE_PARALLAX ) && defined( USE_BUMPMAP )",
      "uniform sampler2D bumpMap;",
      "varying vec3 normalView;",
      "varying vec3 vViewPosition;",
      "#endif",
      XG.DeferredShaderChunk.wireframeParsFragment,
      XG.ShaderChunk.glossmap_pars_fragment,
      XG.ShaderChunk.specularmap_pars_fragment,
      XG.ShaderChunk.parallax_pars_fragment,
      XG.DeferredShaderChunk.packFloat,
      "void main() {",
      "#if !defined( PARTICLE ) && ( defined( USE_MAP ) || defined( USE_LIGHTMAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined ( USE_NORMALGLOSSMAP ) || defined ( USE_GLOSSMAP ) || defined( USE_SPECULARMAP ) )",
      "vec2 uvCoord = vUv;",
      "#endif",
      "#if defined( USE_LIGHTMAP ) && defined( LIGHTMAP_SECONDARY_UV )",
      "vec2 uvCoord2 = vUv2;",
      "#endif",
      "#if defined( USE_PARALLAX ) && defined( USE_BUMPMAP )",
      "vec3 normal = normalize( normalView );",
      "vec3 eyeVector = normalize( -vViewPosition );",
      "#endif",
      XG.ShaderChunk.parallax_fragment,
      "#ifdef USE_NORMALGLOSSMAP",
      "vec4 normalGloss = texture2D( normalMap, uvCoord );",
      "#endif",
      XG.DeferredShaderChunk.colorsFragment,
      XG.DeferredShaderChunk.wireframeFragment,
      "float compressedDiffuse = vec3_to_float( diffuseColor.rgb );",
      "float compressedSpecular = vec3_to_float( specularColor.rgb );",
      "float compressedWrapRGB = vec3_to_float( wrapRGB.rgb );",
      "float wrapAroundShininessOcclusion = wrapAround * vec21_to_float( shininess, lightMapIntensity );",
      "mgl_FragColor = vec4( compressedDiffuse, compressedSpecular, wrapAroundShininessOcclusion, compressedWrapRGB );",
      "}",
    ].join("\n"),
    vertexShader: [
      XG.ShaderChunk.instances_pars_vertex,
      XG.ShaderChunk.map_pars_vertex,
      XG.ShaderChunk.color_pars_vertex,
      XG.ShaderChunk.morphtarget_pars_vertex,
      XG.ShaderChunk.skinning_pars_vertex,
      XG.ShaderChunk.particle_pars_vertex,
      XG.ShaderChunk.displacement_pars_vertex,
      XG.DeferredShaderChunk.wireframeParsVertex,
      "#if defined( USE_PARALLAX ) && defined( USE_BUMPMAP )",
      "varying vec3 normalView;",
      "varying vec3 vViewPosition;",
      "#endif",
      "void main() {",
      XG.ShaderChunk.map_vertex,
      XG.ShaderChunk.begin_nor_vertex,
      XG.ShaderChunk.morphnormal_vertex,
      XG.ShaderChunk.skinbase_vertex,
      XG.ShaderChunk.skinnormal_vertex,
      XG.ShaderChunk.end_nor_vertex,
      XG.ShaderChunk.begin_pos_vertex,
      XG.ShaderChunk.displacement_vertex,
      XG.ShaderChunk.morphtarget_vertex,
      XG.ShaderChunk.skinning_vertex,
      XG.ShaderChunk.end_pos_vertex,
      XG.ShaderChunk.particle_vertex,
      "#if defined( USE_PARALLAX ) && defined( USE_BUMPMAP )",
      "normalView = transformedNormal;",
      "vViewPosition = mvPosition.xyz;",
      "#endif",
      "#ifdef USE_COLOR",
      "vColor = color;",
      "#endif",
      XG.DeferredShaderChunk.wireframeVertex,
      "}",
    ].join("\n"),
  }),
  (XG.DeferredShaders.normalDepth = {
    uniforms: XG.UniformsUtils.merge([
      XG.UniformsLib.particle,
      XG.UniformsLib.bump,
      XG.UniformsLib.normalmap,
      XG.UniformsLib.displacement,
      {
        alphaMap: { type: "t", value: null },
        detailRepeatScale: { type: "v3", value: new XG.Vector3(1, 1, 1) },
        offsetRepeat: { type: "v4", value: new XG.Vector4(0, 0, 1, 1) },
        parallaxScale: { type: "f", value: 1 },
      },
    ]),
    fragmentShader: [
      "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP ) || defined( ALPHATEST ) || defined( USE_DISPLACEMENTMAP )",
      "varying vec2 vUv;",
      "#endif",
      "#ifdef ALPHATEST",
      "uniform sampler2D alphaMap;",
      "#endif",
      XG.DeferredShaderChunk.normalsParsFragment,
      XG.ShaderChunk.parallax_pars_fragment,
      XG.ShaderChunk.displacementmap_pars_fragment,
      "varying vec4 clipPos;",
      "void main() {",
      "#if !defined( PARTICLE ) && ( defined( USE_MAP ) || defined( USE_LIGHTMAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined ( USE_NORMALGLOSSMAP ) || defined ( USE_GLOSSMAP ) || defined( USE_SPECULARMAP ) || defined( ALPHATEST ) || defined( USE_DISPLACEMENTMAP ) )",
      "vec2 uvCoord = vUv;",
      "#endif",
      "vec3 normal = normalize( normalView );",
      "#if defined( USE_BUMPMAP ) && defined( USE_PARALLAX )",
      "vec3 eyeVector = normalize( -vViewPosition );",
      "#endif",
      XG.ShaderChunk.parallax_fragment,
      "#ifdef ALPHATEST",
      "vec2 textureCoord;",
      "#ifdef PARTICLE",
      "textureCoord = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );",
      "#else",
      "textureCoord = uvCoord;",
      "#endif",
      "float alphaValue = texture2D( alphaMap, textureCoord ).a;",
      "if ( alphaValue < ALPHATEST ) discard;",
      "#endif",
      "#if defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP )",
      "vec4 normalGloss = texture2D( normalMap, uvCoord );",
      "#endif",
      XG.DeferredShaderChunk.normalsFragment,
      "normal = normal * 0.5 + 0.5;",
      "mgl_FragColor = vec4( normal, clipPos.z / clipPos.w );",
      "}",
    ].join("\n"),
    vertexShader: [
      "varying vec3 normalView;",
      "varying vec4 clipPos;",
      "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP ) || defined( ALPHATEST )",
      "varying vec2 vUv;",
      "uniform vec4 offsetRepeat;",
      "#endif",
      "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP )",
      "varying vec3 vViewPosition;",
      "#endif",
      XG.ShaderChunk.instances_pars_vertex,
      XG.ShaderChunk.morphtarget_pars_vertex,
      XG.ShaderChunk.skinning_pars_vertex,
      XG.ShaderChunk.particle_pars_vertex,
      XG.ShaderChunk.displacement_pars_vertex,
      "void main() {",
      XG.ShaderChunk.map_vertex,
      XG.ShaderChunk.begin_nor_vertex,
      XG.ShaderChunk.morphnormal_vertex,
      XG.ShaderChunk.skinbase_vertex,
      XG.ShaderChunk.skinnormal_vertex,
      XG.ShaderChunk.end_nor_vertex,
      XG.ShaderChunk.begin_pos_vertex,
      XG.ShaderChunk.displacement_vertex,
      XG.ShaderChunk.morphtarget_vertex,
      XG.ShaderChunk.skinning_vertex,
      XG.ShaderChunk.end_pos_vertex,
      XG.ShaderChunk.particle_vertex,
      "normalView = transformedNormal;",
      "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_NORMALGLOSSMAP ) || defined( USE_DISPLACEMENTMAP )",
      "vViewPosition = mvPosition.xyz;",
      "#endif",
      "clipPos = gl_Position;",
      "}",
    ].join("\n"),
  }),
  (XG.DeferredShaders.depth = {
    uniforms: XG.UniformsUtils.merge([
      XG.UniformsLib.particle,
      XG.UniformsLib.displacement,
      {
        slopeScale: { type: "f", value: 2, shared: !0 },
        slopeBias: { type: "f", value: 0, shared: !0 },
        slopeMax: { type: "f", value: 0.001, shared: !0 },
        depthTextureBias: { type: "f", value: 5e-4, shared: !0 },
        alphaMap: { type: "t", value: null },
        offsetRepeat: { type: "v4", value: new XG.Vector4(0, 0, 1, 1) },
      },
    ]),
    fragmentShader: [
      "#ifdef ALPHATEST",
      "uniform sampler2D alphaMap;",
      "varying vec2 vUv;",
      "#endif",
      "#if defined( SHADOW_FLOAT_DEPTH )",
      "#ifdef SLOPE_DEPTH_BIAS",
      "uniform float slopeScale;",
      "uniform float slopeBias;",
      "uniform float slopeMax;",
      "#endif",
      "varying vec4 clipPos;",
      "#endif",
      "void main() {",
      "#ifdef ALPHATEST",
      "float alphaValue = texture2D( alphaMap, vUv ).a;",
      "if ( alphaValue < ALPHATEST ) discard;",
      "#endif",
      "#if defined( SHADOW_FLOAT_DEPTH )",
      "float depth = clipPos.z / clipPos.w;",
      "#ifdef SLOPE_DEPTH_BIAS",
      "float dx = dFdx( depth );",
      "float dy = dFdy( depth );",
      "float m = max( abs(dx), abs(dy) );",
      "m = min( m, slopeMax );",
      "depth += m * slopeScale + slopeBias;",
      "#endif",
      "mgl_FragColor.x = depth;",
      "#endif",
      "}",
    ].join("\n"),
    vertexShader: [
      "#ifdef ALPHATEST",
      "varying vec2 vUv;",
      "#endif",
      "#if defined( ALPHATEST ) || defined( USE_DISPLACEMENTMAP )",
      "uniform vec4 offsetRepeat;",
      "#endif",
      "#if defined( SHADOW_TEXTURE_DEPTH )",
      "uniform float depthTextureBias;",
      "#elif defined( SHADOW_FLOAT_DEPTH )",
      "varying vec4 clipPos;",
      "#endif",
      XG.ShaderChunk.instances_pars_vertex,
      XG.ShaderChunk.morphtarget_pars_vertex,
      XG.ShaderChunk.skinning_pars_vertex,
      XG.ShaderChunk.particle_pars_vertex,
      XG.ShaderChunk.displacement_pars_vertex,
      "void main() {",
      "#if defined( ALPHATEST ) || defined( USE_DISPLACEMENTMAP )",
      "vec2 transformedUV = uv * offsetRepeat.zw + offsetRepeat.xy;",
      "#endif",
      XG.ShaderChunk.skinbase_vertex,
      XG.ShaderChunk.begin_pos_vertex,
      XG.ShaderChunk.displacement_vertex,
      XG.ShaderChunk.morphtarget_vertex,
      XG.ShaderChunk.skinning_vertex,
      XG.ShaderChunk.end_pos_vertex,
      XG.ShaderChunk.particle_vertex,
      "#if defined( SHADOW_FLOAT_DEPTH )",
      "clipPos = gl_Position;",
      "#elif defined ( SHADOW_TEXTURE_DEPTH )",
      "gl_Position.z += depthTextureBias;",
      "#endif",
      "#ifdef ALPHATEST",
      "vUv = transformedUV;",
      "#endif",
      "}",
    ].join("\n"),
  }),
  (XG.DeferredShaders.pointLight = {
    uniforms: XG.UniformsUtils.merge([
      XG.DeferredUniformsLib.gbuffers,
      XG.DeferredUniformsLib.pointShadowMaps,
      {
        matProjInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        lightPositionVS: { type: "v3", value: new XG.Vector3(0, 0, 0) },
        lightColor: { type: "c", value: new XG.Color(0) },
        lightIntensity: { type: "f", value: 1 },
        lightDistance: { type: "f", value: 1 },
      },
    ]),
    fragmentShader: [
      "uniform float lightDistance;",
      "uniform float lightIntensity;",
      "uniform vec3 lightColor;",
      "uniform vec3 lightPositionVS;",
      "uniform mat4 matProjInverse;",
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.skin_pars_fragment,
      XG.ShaderChunk.decodingUtils,
      XG.ShaderChunk.linearDepthFragmentPars,
      XG.ShaderChunk.shadowmap_pars_depth,
      XG.ShaderChunk.shadowmap_pars_point,
      XG.DeferredShaderChunk.pointShadowMapsUniforms,
      XG.DeferredShaderChunk.gbuffersUniforms,
      XG.DeferredShaderChunk.unpackFloat,
      XG.DeferredShaderChunk.geometryFactor,
      XG.DeferredShaderChunk.specularBRDF,
      "void main() {",
      XG.DeferredShaderChunk.computeVertexPositionVS,
      "vec3 lightVector = lightPositionVS - vertexPositionVS.xyz;",
      "float distance = length( lightVector );",
      "if ( distance > lightDistance ) discard;",
      XG.DeferredShaderChunk.computeNormal,
      XG.DeferredShaderChunk.unpackColorMap,
      "lightVector = lightVector / distance;",
      XG.DeferredShaderChunk.computeDiffuse,
      XG.DeferredShaderChunk.computeSpecular,
      "diffuse -= diffuse * fresnel;",
      "const float cutoff = 0.3;",
      "float denom = distance / lightDistance + 1.0;",
      "float attenuation = 1.0 / ( denom * denom );",
      "attenuation = ( attenuation - cutoff ) / ( 1.0 - cutoff );",
      "attenuation = max( attenuation, 0.0 );",
      "attenuation *= attenuation;",
      "float occlusion = 1.0;",
      XG.DeferredShaderChunk.computePointShadowMaps,
      "attenuation *= occlusion;",
      XG.DeferredShaderChunk.combine,
      "}",
    ].join("\n"),
    vertexShader: XG.ShaderChunk.vertexShaderGeometry,
  }),
  (XG.DeferredShaders.sphereLight = {
    uniforms: XG.UniformsUtils.merge([
      XG.DeferredUniformsLib.gbuffers,
      XG.DeferredUniformsLib.pointShadowMaps,
      {
        matProjInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        lightPositionVS: { type: "v3", value: new XG.Vector3(0, 0, 0) },
        lightColor: { type: "c", value: new XG.Color(0) },
        lightIntensity: { type: "f", value: 1 },
        lightDistance: { type: "f", value: 1 },
        lightRadius: { type: "f", value: 1 },
      },
    ]),
    fragmentShader: [
      "uniform float lightRadius;",
      "uniform float lightDistance;",
      "uniform float lightIntensity;",
      "uniform vec3 lightColor;",
      "uniform vec3 lightPositionVS;",
      "uniform mat4 matProjInverse;",
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.skin_pars_fragment,
      XG.ShaderChunk.decodingUtils,
      XG.ShaderChunk.linearDepthFragmentPars,
      XG.ShaderChunk.shadowmap_pars_depth,
      XG.ShaderChunk.shadowmap_pars_point,
      XG.DeferredShaderChunk.pointShadowMapsUniforms,
      XG.DeferredShaderChunk.gbuffersUniforms,
      XG.DeferredShaderChunk.unpackFloat,
      XG.DeferredShaderChunk.geometryFactor,
      XG.DeferredShaderChunk.specularBRDF,
      "void main() {",
      XG.DeferredShaderChunk.computeVertexPositionVS,
      "vec3 lightVectorFull = lightPositionVS - vertexPositionVS.xyz;",
      "float distance = length( lightVectorFull );",
      "if ( distance > lightDistance ) discard;",
      XG.DeferredShaderChunk.computeNormal,
      XG.DeferredShaderChunk.unpackColorMap,
      "vec3 lightVector = lightVectorFull / distance;",
      XG.DeferredShaderChunk.computeDiffuse,
      "vec3 eye = normalize( -vertexPositionVS.xyz );",
      "vec3 reflectVS = reflect( eye, normal );",
      "vec3 centerToRay = lightVectorFull - dot( lightVectorFull, reflectVS ) * reflectVS;",
      "vec3 closestPoint = lightVectorFull - centerToRay * saturate( lightRadius / length( centerToRay ) );",
      "lightVector = normalize( closestPoint );",
      "dotLN = max( dot( lightVector, normal ), 0.0 );",
      XG.DeferredShaderChunk.computeSpecular,
      "float alpha = roughness * roughness;",
      "float alphaPrime = saturate( alpha + 0.5 * saturate( lightRadius / distance ) );",
      "float sphereNormalization = alpha / alphaPrime;",
      "sphereNormalization *= sphereNormalization;",
      "specular *= sphereNormalization;",
      "diffuse -= diffuse * fresnel;",
      "const float cutoff = 0.3;",
      "float denom = distance / lightDistance + 1.0;",
      "float attenuation = 1.0 / ( denom * denom );",
      "attenuation = ( attenuation - cutoff ) / ( 1.0 - cutoff );",
      "attenuation = max( attenuation, 0.0 );",
      "attenuation *= attenuation;",
      "float occlusion = 1.0;",
      XG.DeferredShaderChunk.computePointShadowMaps,
      "attenuation *= occlusion;",
      XG.DeferredShaderChunk.combine,
      "}",
    ].join("\n"),
    vertexShader: XG.ShaderChunk.vertexShaderGeometry,
  }),
  (XG.DeferredShaders.tubeLight = {
    uniforms: XG.UniformsUtils.merge([
      XG.DeferredUniformsLib.gbuffers,
      {
        matProj: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        matProjInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        lightPosition0VS: { type: "v3", value: new XG.Vector3(0, -1, 0) },
        lightPosition1VS: { type: "v3", value: new XG.Vector3(0, 1, 0) },
        lightColor: { type: "c", value: new XG.Color(0) },
        lightIntensity: { type: "f", value: 1 },
        lightDistance: { type: "f", value: 1 },
        lightRadius: { type: "f", value: 1 },
      },
    ]),
    fragmentShader: [
      "uniform float lightRadius;",
      "uniform float lightDistance;",
      "uniform float lightIntensity;",
      "uniform vec3 lightColor;",
      "uniform vec3 lightPosition0VS;",
      "uniform vec3 lightPosition1VS;",
      "uniform mat4 matProjInverse;",
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.decodingUtils,
      XG.DeferredShaderChunk.multiShadowMapsUniforms,
      XG.DeferredShaderChunk.gbuffersUniforms,
      XG.DeferredShaderChunk.unpackFloat,
      XG.DeferredShaderChunk.geometryFactor,
      XG.DeferredShaderChunk.specularBRDF,
      XG.DeferredShaderChunk.directionalOcclusion,
      "void main() {",
      XG.DeferredShaderChunk.computeVertexPositionVS,
      XG.DeferredShaderChunk.computeNormal,
      XG.DeferredShaderChunk.unpackColorMap,
      "vec3 lightVector0 = lightPosition0VS - vertexPositionVS.xyz;",
      "vec3 lightVector1 = lightPosition1VS - vertexPositionVS.xyz;",
      "float length0 = length( lightVector0 );",
      "float length1 = length( lightVector1 );",
      "float a = saturate( 0.5 * ( dot( normal, lightVector0 ) / length0 + dot( normal, lightVector1 ) / length1 ) );",
      "float b = ( length0 * length1 + dot( lightVector0, lightVector1 ) ) * 0.5 + 1.0;",
      "float dotLN = a;",
      "vec3 diffuse = vec3( dotLN );",
      "vec3 eye = normalize( -vertexPositionVS.xyz );",
      "vec3 reflectVS = reflect( eye, normal );",
      "vec3 lightVectorD = lightVector1 - lightVector0;",
      "float lengthD = length( lightVectorD );",
      "float dotRD = dot( reflectVS, lightVectorD );",
      "float ta = dot( reflectVS, lightVector0 ) * dotRD - dot( lightVector0, lightVectorD );",
      "float tb = lengthD * lengthD - dotRD * dotRD;",
      "float t = ta / tb;",
      "vec3 closestPoint = lightVector0 + saturate( t ) * lightVectorD;",
      "vec3 lightVectorClosest = closestPoint;",
      "vec3 centerToRay = lightVectorClosest - dot( lightVectorClosest, reflectVS ) * reflectVS;",
      "closestPoint = lightVectorClosest - centerToRay * saturate( lightRadius / length( centerToRay ) );",
      "vec3 lightVector = normalize( closestPoint );",
      XG.DeferredShaderChunk.computeSpecular,
      "vec3 lightVectorFull = ( lightPosition0VS + lightPosition1VS ) * 0.5 - vertexPositionVS.xyz;",
      "float distance = length( lightVectorFull );",
      "float alpha = roughness * roughness;",
      "float alphaPrime = saturate( alpha + 0.5 * saturate( lightRadius / distance ) );",
      "float sphereNormalization = alpha / alphaPrime;",
      "sphereNormalization *= sphereNormalization;",
      "float alphaPrimeLine = saturate( alpha + 0.5 * saturate( lengthD / distance ) );",
      "float lineNormalization = alpha / alphaPrimeLine;",
      "specular *= sphereNormalization;",
      "specular *= lineNormalization;",
      "diffuse -= diffuse * fresnel;",
      "#ifdef OCCLUSION_ENABLED",
      "const float occlusionScale = 0.9;",
      "vec2 r = rand( texCoord ) + 0.1;",
      "float occlusionDistanceC = occlusionScale * r.x;",
      "float occlusionDistance0 = occlusionScale * r.y;",
      "float occlusionDistance1 = occlusionScale * rand( texCoord + 0.01 ).y + 0.1;",
      "float occlusionC = checkOcclusion( vertexPositionVS.xyz + occlusionDistanceC * lightVector );",
      "float occlusion0 = checkOcclusion( vertexPositionVS.xyz + occlusionDistance0 * lightVector0 / length0 );",
      "float occlusion1 = checkOcclusion( vertexPositionVS.xyz + occlusionDistance1 * lightVector1 / length1 );",
      "float occlusion = ( 0.5 * occlusionC + 0.25 * occlusion0 + 0.25 * occlusion1 );",
      "#else",
      "float occlusion = 1.0;",
      "#endif",
      "float attenuation = 1.0 / b;",
      "attenuation *= occlusion;",
      XG.DeferredShaderChunk.combine,
      "}",
    ].join("\n"),
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangle,
  }),
  (XG.DeferredShaders.spotLight = {
    uniforms: XG.UniformsUtils.merge([
      XG.DeferredUniformsLib.gbuffers,
      XG.DeferredUniformsLib.projectedTexture,
      {
        matProjInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        lightPositionVS: { type: "v3", value: new XG.Vector3(0, 1, 0) },
        lightDirectionVS: { type: "v3", value: new XG.Vector3(0, 1, 0) },
        lightColor: { type: "c", value: new XG.Color(0) },
        lightIntensity: { type: "f", value: 1 },
        lightDistance: { type: "f", value: 1 },
        lightAngleCos: { type: "f", value: 1 },
        matShadow: { type: "m4", value: new XG.Matrix4() },
        samplerShadowMap: { type: "t", value: null },
        shadowMapSize: { type: "v2", value: new XG.Vector2(512, 512) },
        shadowDarkness: { type: "f", value: 0.5 },
        shadowBias: { type: "f", value: 0 },
      },
    ]),
    fragmentShader: [
      "uniform vec3 lightPositionVS;",
      "uniform vec3 lightDirectionVS;",
      "uniform vec3 lightColor;",
      "uniform float lightIntensity;",
      "uniform float lightAngleCos;",
      "uniform mat4 matProjInverse;",
      "#ifdef USE_SHADOWMAP",
      "uniform mat4 matShadow;",
      "#ifdef USE_SHADOWSAMPLER",
      "uniform sampler2DShadow samplerShadowMap;",
      "#else",
      "uniform sampler2D samplerShadowMap;",
      "#endif",
      "uniform float shadowBias;",
      "uniform float shadowDarkness;",
      "uniform vec2 shadowMapSize;",
      "#endif",
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.skin_pars_fragment,
      XG.ShaderChunk.decodingUtils,
      XG.DeferredShaderChunk.gbuffersUniforms,
      XG.DeferredShaderChunk.projectedTextureUniforms,
      XG.DeferredShaderChunk.unpackFloat,
      XG.DeferredShaderChunk.shadowMapPCFSoft,
      XG.DeferredShaderChunk.geometryFactor,
      XG.DeferredShaderChunk.specularBRDF,
      "void main() {",
      XG.DeferredShaderChunk.computeVertexPositionVS,
      XG.DeferredShaderChunk.computeNormal,
      XG.DeferredShaderChunk.unpackColorMap,
      "vec3 lightVector = normalize( lightPositionVS.xyz - vertexPositionVS.xyz );",
      "float rho = dot( lightDirectionVS, lightVector );",
      "if ( rho <= lightAngleCos ) discard;",
      "float theta = lightAngleCos + 0.0001;",
      "float phi = lightAngleCos + 0.05;",
      "const float falloff = 4.0;",
      "float spot = 0.0;",
      "if ( rho >= phi ) {",
      "spot = 1.0;",
      "} else if ( rho <= theta ) {",
      "spot = 0.0;",
      "} else { ",
      "spot = pow( ( rho - theta ) / ( phi - theta ), falloff );",
      "}",
      XG.DeferredShaderChunk.computeDiffuse,
      XG.DeferredShaderChunk.computeSpecular,
      "diffuse *= spot;",
      "specular *= spot;",
      "diffuse -= diffuse * fresnel;",
      "float occlusion = 1.0;",
      "#ifdef USE_SHADOWMAP",
      "vec4 posLightCS = matShadow * vertexPositionVS;",
      "vec2 shadowCoord = ( posLightCS.xy / posLightCS.w ) * 0.5 + 0.5;",
      "float vertexDepth = posLightCS.z / posLightCS.w;",
      "#if defined( SHADOW_TEXTURE_DEPTH )",
      "vertexDepth = vertexDepth * 0.5 + 0.5;",
      "#endif",
      "#if !defined( SLOPE_DEPTH_BIAS )",
      "vertexDepth -= shadowBias;",
      "#endif",
      "#if defined( SHADOWMAP_TYPE_PCF_SOFT )",
      "float shadowValue = sampleShadowPCFSoft( samplerShadowMap, shadowMapSize, shadowCoord, vertexDepth );",
      "#elif defined( SHADOWMAP_TYPE_PCF_SOFT_HQ )",
      "vec2 pixelOffset = vec2( 2.0 ) / shadowMapSize;",
      "float shadowValue0 = sampleShadowPCFSoft( samplerShadowMap, shadowMapSize, shadowCoord + vec2( -pixelOffset.x, 0.0 ), vertexDepth );",
      "float shadowValue1 = sampleShadowPCFSoft( samplerShadowMap, shadowMapSize, shadowCoord + vec2(  pixelOffset.x, 0.0 ), vertexDepth );",
      "float shadowValue2 = sampleShadowPCFSoft( samplerShadowMap, shadowMapSize, shadowCoord + vec2( 0.0, -pixelOffset.y ), vertexDepth );",
      "float shadowValue3 = sampleShadowPCFSoft( samplerShadowMap, shadowMapSize, shadowCoord + vec2( 0.0,  pixelOffset.y ), vertexDepth );",
      "float shadowValue = ( shadowValue0 + shadowValue1 + shadowValue2 + shadowValue3 ) * 0.25;",
      "#else",
      "#ifdef USE_SHADOWSAMPLER",
      "float shadowValue = 1.0 - texture( samplerShadowMap, vec3( shadowCoord, vertexDepth ) );",
      "#else",
      "float shadowDepth = texture2D( samplerShadowMap, shadowCoord ).x;",
      "float shadowValue = float( vertexDepth > shadowDepth );",
      "#endif",
      "#endif",
      "occlusion = 1.0 - shadowDarkness * shadowValue;",
      "#endif",
      "#ifdef PROJECTED_TEXTURE",
      "vec4 posTextureCS = matTexture * vertexPositionVS;",
      "#ifdef PROJECTED_SHADOW",
      "vec2 textureCoord = ( posTextureCS.xy / posTextureCS.w ) * 0.5 + 0.5;",
      "bvec4 inTexFrustumVec = bvec4 ( textureCoord.x >= 0.0, textureCoord.x <= 1.0, textureCoord.y >= 0.0, textureCoord.y <= 1.0 );",
      "bool inTexFrustum = all( inTexFrustumVec );",
      "if ( inTexFrustum ) {",
      "vec4 textureColor = texture2DProj( samplerTexture, posTextureCS, textureBias );",
      "float translucency = 1.0 - textureColor.r * shadowDarkness;",
      "occlusion = min( occlusion, translucency );",
      "}",
      "#else",
      "vec4 textureColor = texture2DProj( samplerTexture, posTextureCS );",
      "textureColor.xyz *= textureColor.xyz;",
      "diffuse *= textureColor.xyz;",
      "specular *= textureColor.xyz;",
      "#endif",
      "#endif",
      "float attenuation = occlusion;",
      XG.DeferredShaderChunk.combine,
      "}",
    ].join("\n"),
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangle,
  }),
  (XG.DeferredShaders.directionalLight = {
    uniforms: XG.UniformsUtils.merge([
      XG.DeferredUniformsLib.gbuffers,
      XG.DeferredUniformsLib.multiShadowMaps,
      XG.DeferredUniformsLib.projectedTexture,
      {
        matProjInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        lightDirectionVS: { type: "v3", value: new XG.Vector3(0, 1, 0) },
        lightColor: { type: "c", value: new XG.Color(0) },
        lightIntensity: { type: "f", value: 1 },
      },
    ]),
    fragmentShader: [
      "uniform float lightIntensity;",
      "uniform vec3 lightColor;",
      "uniform vec3 lightDirectionVS;",
      "uniform mat4 matProjInverse;",
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.skin_pars_fragment,
      XG.ShaderChunk.decodingUtils,
      XG.DeferredShaderChunk.multiShadowMapsUniforms,
      XG.DeferredShaderChunk.gbuffersUniforms,
      XG.DeferredShaderChunk.projectedTextureUniforms,
      XG.DeferredShaderChunk.unpackFloat,
      XG.DeferredShaderChunk.shadowMapPCFSoft,
      XG.DeferredShaderChunk.geometryFactor,
      XG.DeferredShaderChunk.specularBRDF,
      "void main() {",
      XG.DeferredShaderChunk.computeVertexPositionVS,
      XG.DeferredShaderChunk.computeNormal,
      XG.DeferredShaderChunk.unpackColorMap,
      "vec3 lightVector = lightDirectionVS;",
      XG.DeferredShaderChunk.computeDiffuse,
      XG.DeferredShaderChunk.computeSpecular,
      XG.DeferredShaderChunk.directionalShadows,
      XG.DeferredShaderChunk.directionalProjectedTexture,
      "diffuse -= diffuse * fresnel;",
      "float attenuation = occlusion;",
      XG.DeferredShaderChunk.combine,
      "#ifdef SHADOWMAP_DEBUG",
      "mgl_FragColor.xyz *= debugColor;",
      "#endif",
      "}",
    ].join("\n"),
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangle,
  }),
  (XG.DeferredShaders.hemisphereLight = {
    uniforms: XG.UniformsUtils.merge([
      XG.DeferredUniformsLib.gbuffers,
      {
        matProjInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        lightDirectionVS: { type: "v3", value: new XG.Vector3(0, 1, 0) },
        lightColorSky: { type: "c", value: new XG.Color(0) },
        lightColorGround: { type: "c", value: new XG.Color(0) },
        lightIntensity: { type: "f", value: 1 },
        samplerSSAO: { type: "t", value: null },
      },
    ]),
    fragmentShader: [
      "uniform float lightIntensity;",
      "uniform vec3 lightColorSky;",
      "uniform vec3 lightColorGround;",
      "uniform vec3 lightDirectionVS;",
      "uniform mat4 matProjInverse;",
      "#ifdef USE_SSAO",
      "uniform sampler2D samplerSSAO;",
      "#endif",
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.skin_pars_fragment,
      XG.ShaderChunk.decodingUtils,
      XG.DeferredShaderChunk.gbuffersUniforms,
      XG.DeferredShaderChunk.unpackFloat,
      XG.DeferredShaderChunk.environmentBRDF,
      XG.DeferredShaderChunk.specularOcclusion,
      "void main() {",
      XG.DeferredShaderChunk.computeVertexPositionVS,
      XG.DeferredShaderChunk.computeNormal,
      XG.DeferredShaderChunk.unpackColorMap,
      "vec3 lightVectorHemi = lightDirectionVS;",
      "float lightIntensityHemi = lightIntensity;",
      "vec3 eyeVector = normalize( -vertexPositionVS.xyz );",
      "vec3 halfVector = normalize( lightVectorHemi + eyeVector );",
      "float roughness = saturate( sqrt( 8.0 / ( shininess + 7.0 ) ) );",
      XG.DeferredShaderChunk.hemiTerm,
      "mgl_FragColor = vec4( hemiTerm, 1.0 );",
      "}",
    ].join("\n"),
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangle,
  }),
  (XG.DeferredShaders.dayLight = {
    uniforms: XG.UniformsUtils.merge([
      XG.DeferredUniformsLib.gbuffers,
      XG.DeferredUniformsLib.multiShadowMaps,
      XG.DeferredUniformsLib.projectedTexture,
      {
        matProjInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        lightDirectionVSSun: { type: "v3", value: new XG.Vector3(0, 1, 0) },
        lightDirectionVSHemi: { type: "v3", value: new XG.Vector3(0, 1, 0) },
        lightColorSun: { type: "c", value: new XG.Color(0) },
        lightColorSky: { type: "c", value: new XG.Color(0) },
        lightColorGround: { type: "c", value: new XG.Color(0) },
        lightIntensitySun: { type: "f", value: 1 },
        lightIntensityHemi: { type: "f", value: 1 },
        samplerSSAO: { type: "t", value: null },
      },
    ]),
    fragmentShader: [
      "uniform float lightIntensitySun;",
      "uniform float lightIntensityHemi;",
      "uniform vec3 lightColorSun;",
      "uniform vec3 lightColorSky;",
      "uniform vec3 lightColorGround;",
      "uniform vec3 lightDirectionVSSun;",
      "uniform vec3 lightDirectionVSHemi;",
      "uniform mat4 matProjInverse;",
      "#ifdef USE_SSAO",
      "uniform sampler2D samplerSSAO;",
      "#endif",
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.skin_pars_fragment,
      XG.ShaderChunk.decodingUtils,
      XG.DeferredShaderChunk.multiShadowMapsUniforms,
      XG.DeferredShaderChunk.gbuffersUniforms,
      XG.DeferredShaderChunk.projectedTextureUniforms,
      XG.DeferredShaderChunk.unpackFloat,
      XG.DeferredShaderChunk.shadowMapPCFSoft,
      XG.DeferredShaderChunk.geometryFactor,
      XG.DeferredShaderChunk.specularBRDF,
      XG.DeferredShaderChunk.environmentBRDF,
      XG.DeferredShaderChunk.specularOcclusion,
      "void main() {",
      XG.DeferredShaderChunk.computeVertexPositionVS,
      XG.DeferredShaderChunk.computeNormal,
      XG.DeferredShaderChunk.unpackColorMap,
      "vec3 lightVector = lightDirectionVSSun;",
      XG.DeferredShaderChunk.computeDiffuse,
      XG.DeferredShaderChunk.computeSpecular,
      XG.DeferredShaderChunk.directionalShadows,
      XG.DeferredShaderChunk.directionalProjectedTexture,
      "diffuse -= diffuse * fresnel;",
      "vec3 directionalTerm = ( occlusion * lightIntensitySun ) * lightColorSun * ( albedo * diffuse + specular );",
      "vec3 lightVectorHemi = lightDirectionVSHemi;",
      XG.DeferredShaderChunk.hemiTerm,
      "mgl_FragColor = vec4( directionalTerm + hemiTerm, 1.0 );",
      "#ifdef SHADOWMAP_DEBUG",
      "mgl_FragColor.xyz *= debugColor;",
      "#endif",
      "}",
    ].join("\n"),
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangle,
  }),
  (XG.DeferredShaders.dayLightCube = {
    uniforms: XG.UniformsUtils.merge([
      XG.DeferredUniformsLib.gbuffers,
      XG.DeferredUniformsLib.multiShadowMaps,
      XG.DeferredUniformsLib.projectedTexture,
      {
        matProjInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        lightDirectionVSSun: { type: "v3", value: new XG.Vector3(0, 1, 0) },
        lightColorSun: { type: "c", value: new XG.Color(0) },
        lightIntensitySun: { type: "f", value: 1 },
        lightIntensityAmbient: { type: "f", value: 1 },
        matViewInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        samplerSpecular: { type: "t", value: null },
        samplerDiffuse: { type: "t", value: null },
        samplerMip: { type: "t", value: null },
        samplerSSAO: { type: "t", value: null },
        maxMipSpecular: { type: "f", value: 7 },
        samplerSize: { type: "f", value: 0 },
        lightPositionWS: { type: "v3", value: new XG.Vector3(0, 0, 0) },
        lightSize: { type: "v3", value: new XG.Vector3(1, 1, 1) },
      },
    ]),
    fragmentShader: [
      "uniform float lightIntensitySun;",
      "uniform float lightIntensityAmbient;",
      "uniform vec3 lightColorSun;",
      "uniform vec3 lightDirectionVSSun;",
      "uniform mat4 matProjInverse;",
      "uniform mat4 matViewInverse;",
      "uniform samplerCube samplerSpecular;",
      "uniform samplerCube samplerDiffuse;",
      "#if !defined( SUPPORTS_TEXTURE_LOD )",
      "uniform samplerCube samplerMip;",
      "#endif",
      "#ifdef USE_SSAO",
      "uniform sampler2D samplerSSAO;",
      "#endif",
      "uniform float maxMipSpecular;",
      "#ifdef FIX_SEAMS",
      "uniform float samplerSize;",
      "vec3 fix_cube_lookup( vec3 v, float mipLevelClamp, float cubeSize ) {",
      "float M = max( max( abs( v.x ), abs( v.y ) ), abs( v.z ) );",
      "float scale = 1.0 - exp2( mipLevelClamp ) / cubeSize;",
      "if ( abs( v.x ) != M ) v.x *= scale;",
      "if ( abs( v.y ) != M ) v.y *= scale;",
      "if ( abs( v.z ) != M ) v.z *= scale;",
      "return v;",
      "}",
      "#endif",
      "#ifdef LIGHT_LOCAL",
      "uniform vec3 lightPositionWS;",
      "uniform vec3 lightSize;",
      "float maxLength( vec3 v ) {",
      "return max( v.x, max( v.y, v.z ) );",
      "}",
      "#endif",
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.skin_pars_fragment,
      XG.ShaderChunk.decodingUtils,
      XG.DeferredShaderChunk.multiShadowMapsUniforms,
      XG.DeferredShaderChunk.gbuffersUniforms,
      XG.DeferredShaderChunk.projectedTextureUniforms,
      XG.DeferredShaderChunk.unpackFloat,
      XG.DeferredShaderChunk.shadowMapPCFSoft,
      XG.DeferredShaderChunk.geometryFactor,
      XG.DeferredShaderChunk.specularBRDF,
      XG.DeferredShaderChunk.environmentBRDF,
      XG.DeferredShaderChunk.specularOcclusion,
      "void main() {",
      XG.DeferredShaderChunk.computeVertexPositionVS,
      XG.DeferredShaderChunk.computeNormal,
      XG.DeferredShaderChunk.unpackColorMap,
      "float localFade = 1.0;",
      "#ifdef LIGHT_LOCAL",
      "vec4 vertexPositionWS = matViewInverse * vertexPositionVS;",
      "vec3 lightVectorWS = abs( lightPositionWS.xyz - vertexPositionWS.xyz );",
      "if ( lightVectorWS.x > lightSize.x || lightVectorWS.y > lightSize.y || lightVectorWS.z > lightSize.z ) {",
      "localFade = 0.0;",
      "} else {",
      "localFade = max( 1.0 - maxLength( lightVectorWS / lightSize ), 0.0 );",
      "}",
      "#endif",
      "vec3 lightVector = lightDirectionVSSun;",
      XG.DeferredShaderChunk.computeDiffuse,
      XG.DeferredShaderChunk.computeSpecular,
      XG.DeferredShaderChunk.directionalShadows,
      XG.DeferredShaderChunk.directionalProjectedTexture,
      "diffuse -= diffuse * fresnel;",
      "vec3 directionalTerm = ( occlusion * lightIntensitySun ) * lightColorSun * ( albedo * diffuse + specular );",
      "float gloss = shininess / 8192.0;",
      "vec3 reflectVS = reflect( -eyeVector, normal );",
      "vec4 reflectWS = matViewInverse * vec4( reflectVS, 0.0 );",
      "#ifdef LIGHT_LOCAL",
      "vec3 BoxMin = lightPositionWS - lightSize;",
      "vec3 BoxMax = lightPositionWS + lightSize;",
      "vec3 FirstPlaneIntersect  = ( BoxMax - vertexPositionWS.xyz ) / reflectWS.xyz;",
      "vec3 SecondPlaneIntersect = ( BoxMin - vertexPositionWS.xyz ) / reflectWS.xyz;",
      "vec3 FurthestPlane = max( FirstPlaneIntersect, SecondPlaneIntersect );",
      "float Distance = min( min( FurthestPlane.x, FurthestPlane.y ), FurthestPlane.z );",
      "vec3 IntersectPositionWS = vertexPositionWS.xyz + reflectWS.xyz * Distance;",
      "reflectWS.xyz = IntersectPositionWS - lightPositionWS;",
      "#endif",
      "vec3 cubeCoord = reflectWS.xyz;",
      "float maxMipLevel = maxMipSpecular - 2.0;",
      "#ifdef SUPPORTS_TEXTURE_LOD",
      "#if defined( IBL_HDR_RGBM ) || defined( IBL_HDR_RGBA32F ) || defined( IBL_HDR_RGBA16F )",
      "float mipLod = ( maxMipLevel - 1.0 ) * ( 1.0 - gloss );",
      "#else",
      "float mipLod = max( ( maxMipLevel * ( 1.0 - gloss ) ), 1.5 );",
      "#endif",
      "#ifdef FIX_SEAMS",
      "cubeCoord = fix_cube_lookup( cubeCoord, mipLod, samplerSize );",
      "#endif",
      "vec4 cubeColorSpecularSample = textureCubeLodEXT( samplerSpecular, cubeCoord, mipLod );",
      "#else",
      "const float mipUnit = 255.0 / 16.0;",
      "#ifdef SPECULAR_MIP_FIX",
      "float curvature = length( fwidth( cubeCoord ) );",
      "float mipLevelMinification = mipUnit * textureCube( samplerMip, cubeCoord, -curvature ).a;",
      "float mipLevelMagnification = mipUnit * textureCube( samplerMip, cubeCoord, maxMipSpecular - 1.0 - curvature ).a;",
      "#else",
      "const float curvature = 0.0;",
      "float mipLevelMinification = mipUnit * textureCube( samplerMip, cubeCoord ).a;",
      "float mipLevelMagnification = mipUnit * textureCube( samplerMip, cubeCoord, maxMipSpecular - 1.0 ).a;",
      "#endif",
      "float mipLevel;",
      "if ( mipLevelMinification == 0.0 ) {",
      "mipLevel = mipLevelMagnification - ( maxMipSpecular - 1.0 );",
      "} else {",
      "mipLevel = mipLevelMinification;",
      "}",
      "#if defined( IBL_HDR_RGBM ) || defined( IBL_HDR_RGBA32F ) || defined( IBL_HDR_RGBA16F )",
      "float mipBias = max( ( maxMipLevel - 1.0 ) * ( 1.0 - gloss ) - mipLevel, -3.0 );",
      "#else",
      "float mipBias = max( ( maxMipLevel * ( 1.0 - gloss ) ) - mipLevel, 0.0 );",
      "#endif",
      "mipBias -= curvature;",
      "#ifdef FIX_SEAMS",
      "cubeCoord = fix_cube_lookup( cubeCoord, mipLevel, samplerSize );",
      "#endif",
      "vec4 cubeColorSpecularSample = textureCube( samplerSpecular, cubeCoord, mipBias );",
      "#endif",
      "vec4 normalWS = matViewInverse * vec4( normal, 0.0 );",
      "vec4 cubeColorDiffuseSample = textureCube( samplerDiffuse, normalWS.xyz );",
      "vec3 cubeColorSpecular = cubeColorSpecularSample.rgb;",
      "vec3 cubeColorDiffuse = cubeColorDiffuseSample.rgb;",
      "#ifdef IBL_HDR_RGBM",
      "cubeColorSpecular *= cubeColorSpecularSample.a * 5.0;",
      "cubeColorDiffuse *= cubeColorDiffuseSample.a * 5.0;",
      "#endif",
      "#ifdef IBL_GAMMA_TEXTURE",
      "cubeColorSpecular *= cubeColorSpecular;",
      "cubeColorDiffuse *= cubeColorDiffuse;",
      "#endif",
      "vec3 fresnelEnv = EnvironmentBRDF( gloss, dot( eyeVector, normal ), specularColor );",
      "vec3 imageDiffuse = ( 1.0 - fresnelEnv ) * cubeColorDiffuse;",
      "vec3 imageSpecular = fresnelEnv * cubeColorSpecular;",
      "float diffuseOcclusion = lightMapIntensity;",
      "#ifdef USE_SSAO",
      "float ssaoOcclusion = texture2D( samplerSSAO, texCoord ).x;",
      "ssaoOcclusion *= ssaoOcclusion;",
      "diffuseOcclusion = min( diffuseOcclusion, ssaoOcclusion );",
      "#endif",
      "float NdotV = dot( normal, eyeVector );",
      "float specularOcclusion = computeSpecOcclusion( NdotV, diffuseOcclusion, roughness );",
      "vec3 imageTerm = lightIntensityAmbient * ( albedo * imageDiffuse * diffuseOcclusion + imageSpecular * specularOcclusion ) * localFade;",
      "mgl_FragColor = vec4( directionalTerm + imageTerm, 1.0 );",
      "#ifdef SHADOWMAP_DEBUG",
      "mgl_FragColor.xyz *= debugColor;",
      "#endif",
      "}",
    ].join("\n"),
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangle,
  }),
  (XG.DeferredShaders.polyLight = {
    uniforms: XG.UniformsUtils.merge([
      XG.DeferredUniformsLib.gbuffers,
      {
        matProjInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        matViewInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        lightColor: { type: "c", value: new XG.Color(0) },
        lightIntensity: { type: "f", value: 1 },
        lightPoints: {
          type: "v3v",
          value: [
            new XG.Vector3(-10, 10, 0),
            new XG.Vector3(10, 10, 0),
            new XG.Vector3(10, -10, 0),
            new XG.Vector3(-10, -10, 0),
          ],
        },
        lightTwoSided: { type: "i", value: 0 },
        samplerLtcMat: { type: "t", value: null },
        samplerLtcMag: { type: "t", value: null },
        matShadow: { type: "m4", value: new XG.Matrix4() },
        samplerShadowMap: { type: "t", value: null },
        shadowMapSize: { type: "v2", value: new XG.Vector2(512, 512) },
        shadowDarkness: { type: "f", value: 0.5 },
        shadowBias: { type: "f", value: 0 },
        samplerTexture: { type: "t", value: null },
        samplerTextureSize: { type: "f", value: 0 },
        samplerTextureBias: { type: "f", value: 0 },
      },
    ]),
    fragmentShader: [
      "uniform float lightIntensity;",
      "uniform vec3 lightColor;",
      "uniform vec3 lightPoints[ 4 ];",
      "uniform int lightTwoSided;",
      "uniform mat4 matProjInverse;",
      "uniform mat4 matViewInverse;",
      "uniform sampler2D samplerLtcMat;",
      "uniform sampler2D samplerLtcMag;",
      "#ifdef POLY_TEXTURE",
      "uniform sampler2D samplerTexture;",
      "uniform float samplerTextureSize;",
      "uniform float samplerTextureBias;",
      "#endif",
      "#ifdef USE_SHADOWMAP",
      "uniform mat4 matShadow;",
      "#ifdef USE_SHADOWSAMPLER",
      "uniform sampler2DShadow samplerShadowMap;",
      "#else",
      "uniform sampler2D samplerShadowMap;",
      "#endif",
      "uniform float shadowBias;",
      "uniform float shadowDarkness;",
      "uniform vec2 shadowMapSize;",
      "#endif",
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.skin_pars_fragment,
      XG.ShaderChunk.polylights_pars_fragment,
      XG.ShaderChunk.decodingUtils,
      XG.DeferredShaderChunk.gbuffersUniforms,
      XG.DeferredShaderChunk.unpackFloat,
      XG.DeferredShaderChunk.shadowMapPCFSoft,
      "void main() {",
      XG.DeferredShaderChunk.computeVertexPositionVS,
      XG.DeferredShaderChunk.computeNormal,
      XG.DeferredShaderChunk.unpackColorMap,
      "vec3 eyeVector = normalize( -vertexPositionVS.xyz );",
      "float roughness = saturate( sqrt( 8.0 / ( shininess + 7.0 ) ) );",
      "float theta = acos( dot( normal, eyeVector ) );",
      "vec2 uv = vec2( roughness, theta / ( 0.5 * PI ) );",
      "vec2 uv64 = uv * LUT_SCALE64 + LUT_BIAS64;",
      "vec2 uv32 = uv * LUT_SCALE32 + LUT_BIAS32;",
      "vec4 t = texture2D( samplerLtcMat, uv64 );",
      "mat3 Minv = mat3(",
      "vec3(   1,   0, t.y ),",
      "vec3(   0, t.z,   0 ),",
      "vec3( t.w,   0, t.x )",
      ");",
      "#ifdef POLY_TEXTURE",
      "vec3 specular = LTC_Evaluate_tex( normal, eyeVector, vertexPositionVS.xyz, Minv, lightPoints, bool( lightTwoSided ), samplerTexture, samplerTextureSize, samplerTextureBias );",
      "vec3 diffuse  = LTC_Evaluate_tex( normal, eyeVector, vertexPositionVS.xyz, mat3( 1 ), lightPoints, bool( lightTwoSided ), samplerTexture, samplerTextureSize, samplerTextureBias );",
      "#else",
      "vec3 specular = LTC_Evaluate( normal, eyeVector, vertexPositionVS.xyz, Minv, lightPoints, bool( lightTwoSided ) );",
      "vec3 diffuse  = LTC_Evaluate( normal, eyeVector, vertexPositionVS.xyz, mat3( 1 ), lightPoints, bool( lightTwoSided ) );",
      "#endif",
      "vec4 schlick = texture2D( samplerLtcMag, uv32 );",
      "#if __VERSION__ < 300",
      "vec3 specIntensity = specularColor * schlick.x + ( 1.0 - specularColor ) * schlick.w;",
      "#else",
      "vec3 specIntensity = specularColor * schlick.x + ( 1.0 - specularColor ) * schlick.y;",
      "#endif",
      "specular *= specIntensity;",
      "diffuse *= ( 1.0 - specIntensity );",
      "diffuse /= 2.0 * PI;",
      "specular /= 2.0 * PI;",
      "float occlusion = 1.0;",
      "#ifdef USE_SHADOWMAP",
      "vec4 posLightCS = matShadow * vertexPositionVS;",
      "vec2 shadowCoord = ( posLightCS.xy / posLightCS.w ) * 0.5 + 0.5;",
      "float vertexDepth = posLightCS.z / posLightCS.w;",
      "#if defined( SHADOW_TEXTURE_DEPTH )",
      "vertexDepth = vertexDepth * 0.5 + 0.5;",
      "#endif",
      "#if !defined( SLOPE_DEPTH_BIAS )",
      "vertexDepth -= shadowBias;",
      "#endif",
      "#if defined( SHADOWMAP_TYPE_PCF_SOFT )",
      "float shadowValue = sampleShadowPCFSoft( samplerShadowMap, shadowMapSize, shadowCoord, vertexDepth );",
      "#elif defined( SHADOWMAP_TYPE_PCF_SOFT_HQ )",
      "vec2 pixelOffset = vec2( 2.0 ) / shadowMapSize;",
      "float shadowValue0 = sampleShadowPCFSoft( samplerShadowMap, shadowMapSize, shadowCoord + vec2( -pixelOffset.x, 0.0 ), vertexDepth );",
      "float shadowValue1 = sampleShadowPCFSoft( samplerShadowMap, shadowMapSize, shadowCoord + vec2(  pixelOffset.x, 0.0 ), vertexDepth );",
      "float shadowValue2 = sampleShadowPCFSoft( samplerShadowMap, shadowMapSize, shadowCoord + vec2( 0.0, -pixelOffset.y ), vertexDepth );",
      "float shadowValue3 = sampleShadowPCFSoft( samplerShadowMap, shadowMapSize, shadowCoord + vec2( 0.0,  pixelOffset.y ), vertexDepth );",
      "float shadowValue = ( shadowValue0 + shadowValue1 + shadowValue2 + shadowValue3 ) * 0.25;",
      "#else",
      "#ifdef USE_SHADOWSAMPLER",
      "float shadowValue = 1.0 - texture( samplerShadowMap, vec3( shadowCoord, vertexDepth ) );",
      "#else",
      "float shadowDepth = texture2D( samplerShadowMap, shadowCoord ).x;",
      "float shadowValue = float( vertexDepth > shadowDepth );",
      "#endif",
      "#endif",
      "occlusion = 1.0 - shadowDarkness * shadowValue;",
      "#endif",
      "float attenuation = occlusion;",
      XG.DeferredShaderChunk.combine,
      "}",
    ].join("\n"),
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangle,
  }),
  (XG.DeferredShaders.polyLightMulti = {
    uniforms: XG.UniformsUtils.merge([
      XG.DeferredUniformsLib.gbuffers,
      {
        matProjInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        matViewInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        polyLightColor: { type: "fv3", value: [] },
        polyLightPars: { type: "fv1", value: [] },
        polyLightPoints: { type: "v3v", value: [] },
        samplerLtcMat: { type: "t", value: null },
        samplerLtcMag: { type: "t", value: null },
        samplerShadowMap: { type: "tv", value: [] },
        shadowMapPars: { type: "fv4", value: [] },
        shadowMatrix: { type: "m4v", value: [] },
        samplerTexture: { type: "tv", value: [] },
        samplerTexturePars: { type: "fv2", value: [] },
      },
    ]),
    fragmentShader: [
      "uniform vec3 polyLightColor[ MAX_POLY_LIGHTS_MULTI ];",
      "uniform float polyLightPars[ MAX_POLY_LIGHTS_MULTI ];",
      "uniform vec3 polyLightPoints[ MAX_POLY_LIGHTS_MULTI * 4 ];",
      "uniform mat4 matProjInverse;",
      "uniform mat4 matViewInverse;",
      "uniform sampler2D samplerLtcMat;",
      "uniform sampler2D samplerLtcMag;",
      "#ifdef POLY_TEXTURE",
      "uniform sampler2D samplerTexture[ MAX_POLY_LIGHTS_MULTI ];",
      "uniform vec2 samplerTexturePars[ MAX_POLY_LIGHTS_MULTI ];",
      "#endif",
      "#ifdef USE_SHADOWMAP",
      "uniform mat4 shadowMatrix[ MAX_POLY_LIGHTS_MULTI ];",
      "uniform vec4 shadowMapPars[ MAX_POLY_LIGHTS_MULTI ];",
      "#ifdef USE_SHADOWSAMPLER",
      "uniform sampler2DShadow samplerShadowMap[ MAX_POLY_LIGHTS_MULTI ];",
      "#else",
      "uniform sampler2D samplerShadowMap[ MAX_POLY_LIGHTS_MULTI ];",
      "#endif",
      "#endif",
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.skin_pars_fragment,
      XG.ShaderChunk.polylights_pars_fragment,
      XG.ShaderChunk.decodingUtils,
      XG.DeferredShaderChunk.gbuffersUniforms,
      XG.DeferredShaderChunk.unpackFloat,
      XG.DeferredShaderChunk.shadowMapPCFSoft,
      "void main() {",
      XG.DeferredShaderChunk.computeVertexPositionVS,
      XG.DeferredShaderChunk.computeNormal,
      XG.DeferredShaderChunk.unpackColorMap,
      "vec3 eyeVector = normalize( -vertexPositionVS.xyz );",
      "float roughness = saturate( sqrt( 8.0 / ( shininess + 7.0 ) ) );",
      "float dotNV = dot( normal, eyeVector );",
      "float theta = acos( dotNV );",
      "vec2 uv = vec2( roughness, theta / ( 0.5 * PI ) );",
      "vec2 uv64 = uv * LUT_SCALE64 + LUT_BIAS64;",
      "vec2 uv32 = uv * LUT_SCALE32 + LUT_BIAS32;",
      "vec4 tMat = texture2D( samplerLtcMat, uv64 );",
      "mat3 MinvInitSpecular = mat3(",
      "vec3(   1,   0, tMat.y ),",
      "vec3(   0, tMat.z,   0 ),",
      "vec3( tMat.w,   0, tMat.x )",
      ");",
      "mat3 MinvInitDiffuse = mat3( 1.0 );",
      "mat3 orthoBasis = computeOrthoBasis( dotNV, normal, eyeVector );",
      "MinvInitSpecular = mul( MinvInitSpecular, orthoBasis );",
      "MinvInitDiffuse = mul( MinvInitDiffuse, orthoBasis );",
      "mat3 MinvSpecular;",
      "mat3 MinvDiffuse;",
      "vec3 lightPoints[ 4 ];",
      "vec3 specular = vec3( 0.0 );",
      "vec3 diffuse = vec3( 0.0 );",
      "for( int i = 0; i < MAX_POLY_LIGHTS_MULTI; i ++ ) {",
      "bool lightTwoSided = bool( polyLightPars[ i ] );",
      "lightPoints[ 0 ] = polyLightPoints[ i * 4 ];",
      "lightPoints[ 1 ] = polyLightPoints[ i * 4 + 1 ];",
      "lightPoints[ 2 ] = polyLightPoints[ i * 4 + 2 ];",
      "lightPoints[ 3 ] = polyLightPoints[ i * 4 + 3 ];",
      "MinvSpecular = MinvInitSpecular;",
      "MinvDiffuse = MinvInitDiffuse;",
      "#ifdef POLY_TEXTURE",
      "float texSize = samplerTexturePars[ i ].x;",
      "float texBias = samplerTexturePars[ i ].y;",
      "vec3 specularPart = LTC_Evaluate_opt_tex( vertexPositionVS.xyz, MinvSpecular, lightPoints, lightTwoSided, samplerTexture[ i ], texSize, texBias );",
      "vec3 diffusePart  = LTC_Evaluate_opt_tex( vertexPositionVS.xyz, MinvDiffuse, lightPoints, lightTwoSided, samplerTexture[ i ], texSize, texBias );",
      "#else",
      "vec3 specularPart = LTC_Evaluate_opt( vertexPositionVS.xyz, MinvSpecular, lightPoints, lightTwoSided );",
      "vec3 diffusePart  = LTC_Evaluate_opt( vertexPositionVS.xyz, MinvDiffuse, lightPoints, lightTwoSided );",
      "#endif",
      "float occlusion = 1.0;",
      "#ifdef USE_SHADOWMAP",
      "mat4 matShadow = shadowMatrix[ i ];",
      "vec2 shadowMapSize = shadowMapPars[ i ].xy;",
      "float shadowDarkness = shadowMapPars[ i ].z;",
      "float shadowBias = shadowMapPars[ i ].w;",
      "vec4 posLightCS = matShadow * vertexPositionVS;",
      "vec2 shadowCoord = ( posLightCS.xy / posLightCS.w ) * 0.5 + 0.5;",
      "float vertexDepth = posLightCS.z / posLightCS.w;",
      "#if defined( SHADOW_TEXTURE_DEPTH )",
      "vertexDepth = vertexDepth * 0.5 + 0.5;",
      "#endif",
      "#if !defined( SLOPE_DEPTH_BIAS )",
      "vertexDepth -= shadowBias;",
      "#endif",
      "#if defined( SHADOWMAP_TYPE_PCF_SOFT )",
      "float shadowValue = sampleShadowPCFSoft( samplerShadowMap[ i ], shadowMapSize, shadowCoord, vertexDepth );",
      "#elif defined( SHADOWMAP_TYPE_PCF_SOFT_HQ )",
      "vec2 pixelOffset = vec2( 2.0 ) / shadowMapSize;",
      "float shadowValue0 = sampleShadowPCFSoft( samplerShadowMap[ i ], shadowMapSize, shadowCoord + vec2( -pixelOffset.x, 0.0 ), vertexDepth );",
      "float shadowValue1 = sampleShadowPCFSoft( samplerShadowMap[ i ], shadowMapSize, shadowCoord + vec2(  pixelOffset.x, 0.0 ), vertexDepth );",
      "float shadowValue2 = sampleShadowPCFSoft( samplerShadowMap[ i ], shadowMapSize, shadowCoord + vec2( 0.0, -pixelOffset.y ), vertexDepth );",
      "float shadowValue3 = sampleShadowPCFSoft( samplerShadowMap[ i ], shadowMapSize, shadowCoord + vec2( 0.0,  pixelOffset.y ), vertexDepth );",
      "float shadowValue = ( shadowValue0 + shadowValue1 + shadowValue2 + shadowValue3 ) * 0.25;",
      "#else",
      "#ifdef USE_SHADOWSAMPLER",
      "float shadowValue = 1.0 - texture( samplerShadowMap[ i ], vec3( shadowCoord, vertexDepth ) );",
      "#else",
      "float shadowDepth = texture2D( samplerShadowMap[ i ], shadowCoord ).x;",
      "float shadowValue = float( vertexDepth > shadowDepth );",
      "#endif",
      "#endif",
      "occlusion = 1.0 - shadowDarkness * shadowValue;",
      "#endif",
      "specularPart *= occlusion;",
      "diffusePart *= occlusion;",
      "specular += specularPart * polyLightColor[ i ];",
      "diffuse += diffusePart * polyLightColor[ i ];",
      "}",
      "vec4 schlick = texture2D( samplerLtcMag, uv32 );",
      "#if __VERSION__ < 300",
      "vec3 specIntensity = specularColor * schlick.x + ( 1.0 - specularColor ) * schlick.w;",
      "#else",
      "vec3 specIntensity = specularColor * schlick.x + ( 1.0 - specularColor ) * schlick.y;",
      "#endif",
      "specular *= specIntensity;",
      "diffuse *= ( 1.0 - specIntensity );",
      "specular /= 2.0 * PI;",
      "diffuse /= 2.0 * PI;",
      "mgl_FragColor = vec4( albedo * diffuse + specular, 1.0 );",
      "}",
    ].join("\n"),
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangle,
  }),
  (XG.DeferredShaders.areaLight = {
    uniforms: XG.UniformsUtils.merge([
      XG.DeferredUniformsLib.gbuffers,
      {
        matProjInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        lightPositionVS: { type: "v3", value: new XG.Vector3(0, 1, 0) },
        lightNormalVS: { type: "v3", value: new XG.Vector3(0, -1, 0) },
        lightRightVS: { type: "v3", value: new XG.Vector3(1, 0, 0) },
        lightUpVS: { type: "v3", value: new XG.Vector3(1, 0, 0) },
        lightColor: { type: "c", value: new XG.Color(0) },
        lightIntensity: { type: "f", value: 1 },
        lightWidth: { type: "f", value: 1 },
        lightHeight: { type: "f", value: 1 },
        constantAttenuation: { type: "f", value: 1.5 },
        linearAttenuation: { type: "f", value: 0.5 },
        quadraticAttenuation: { type: "f", value: 0.1 },
        samplerTexture: { type: "t", value: null },
        matShadow: { type: "m4", value: new XG.Matrix4() },
        samplerShadowMap: { type: "t", value: null },
        shadowMapSize: { type: "v2", value: new XG.Vector2(512, 512) },
        shadowDarkness: { type: "f", value: 0.5 },
        shadowBias: { type: "f", value: 0 },
      },
    ]),
    fragmentShader: [
      "uniform vec3 lightPositionVS;",
      "uniform vec3 lightNormalVS;",
      "uniform vec3 lightRightVS;",
      "uniform vec3 lightUpVS;",
      "#ifdef AREA_TEXTURE",
      "uniform sampler2D samplerTexture;",
      "#endif",
      "uniform float lightWidth;",
      "uniform float lightHeight;",
      "uniform float constantAttenuation;",
      "uniform float linearAttenuation;",
      "uniform float quadraticAttenuation;",
      "uniform float lightIntensity;",
      "uniform vec3 lightColor;",
      "uniform mat4 matProjInverse;",
      "#ifdef USE_SHADOWMAP",
      "uniform mat4 matShadow;",
      "#ifdef USE_SHADOWSAMPLER",
      "uniform sampler2DShadow samplerShadowMap;",
      "#else",
      "uniform sampler2D samplerShadowMap;",
      "#endif",
      "uniform float shadowBias;",
      "uniform float shadowDarkness;",
      "uniform vec2 shadowMapSize;",
      "#endif",
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.skin_pars_fragment,
      XG.ShaderChunk.decodingUtils,
      XG.DeferredShaderChunk.gbuffersUniforms,
      XG.DeferredShaderChunk.unpackFloat,
      XG.DeferredShaderChunk.shadowMapPCFSoft,
      XG.DeferredShaderChunk.geometryFactor,
      XG.DeferredShaderChunk.specularBRDF,
      "vec3 projectOnPlane( vec3 point, vec3 planeCenter, vec3 planeNorm ) {",
      "return point - dot( point - planeCenter, planeNorm ) * planeNorm;",
      "}",
      "bool sideOfPlane( vec3 point, vec3 planeCenter, vec3 planeNorm ) {",
      "return ( dot( point - planeCenter, planeNorm ) >= 0.0 );",
      "}",
      "vec3 linePlaneIntersect( vec3 lp, vec3 lv, vec3 pc, vec3 pn ) {",
      "return lp + lv * ( dot( pn, pc - lp ) / dot( pn, lv ) );",
      "}",
      "float calculateAttenuation( float dist ) {",
      "return ( 1.0 / ( constantAttenuation + linearAttenuation * dist + quadraticAttenuation * dist * dist ) );",
      "}",
      "void main() {",
      XG.DeferredShaderChunk.computeVertexPositionVS,
      XG.DeferredShaderChunk.computeNormal,
      XG.DeferredShaderChunk.unpackColorMap,
      "float w = lightWidth;",
      "float h = lightHeight;",
      "vec3 proj = projectOnPlane( vertexPositionVS.xyz, lightPositionVS, lightNormalVS );",
      "vec3 dir = proj - lightPositionVS;",
      "vec2 diagonal = vec2( dot( dir, lightRightVS ), dot( dir, lightUpVS ) );",
      "vec2 nearest2D = vec2( clamp( diagonal.x, -w, w ), clamp( diagonal.y, -h, h ) );",
      "vec3 nearestPointInside = lightPositionVS + ( lightRightVS * nearest2D.x + lightUpVS * nearest2D.y );",
      "vec3 lightDir = normalize( nearestPointInside - vertexPositionVS.xyz );",
      "float NdotL = max( dot( lightNormalVS, -lightDir ), 0.0 );",
      "float NdotL2 = max( dot( normal, lightDir ), 0.0 );",
      "float dotLN = sqrt( NdotL * NdotL2 );",
      "vec3 diffuse = vec3( dotLN );",
      "#ifdef SKIN_HQ",
      "if ( wrapAround < 0.0 && NdotL > 0.0 ) {",
      "float curvature = length( fwidth( normal ) ) / length( fwidth( vertexPositionVS.xyz ) );",
      "diffuse = PSSFitFunction( dotLN, curvature );",
      "}",
      "#else",
      "if ( wrapAround < 0.0 && NdotL > 0.0 ) {",
      "float dotLNHalf = max( 0.25 * dotLN + 0.25, 0.0 );",
      "diffuse = mix( diffuse, vec3( dotLNHalf ), wrapRGB );",
      "}",
      "#endif",
      "#ifdef AREA_TEXTURE",
      "float d = distance( vertexPositionVS.xyz, nearestPointInside );",
      "vec2 co = ( diagonal.xy + vec2( w, h ) ) / ( 2.0 * vec2( w, h ) );",
      "co.y = 1.0 - co.y;",
      "vec3 ve = vertexPositionVS.xyz - lightPositionVS;",
      "vec4 diff = vec4( 0.0 );",
      "if ( dot( ve, lightNormalVS ) < 0.0 ) {",
      "diff = vec4( 0.0 );",
      "} else {",
      "float lod = max( pow( d, 0.1 ), 0.0 ) * 5.0;",
      "vec4 t00 = texture2D( samplerTexture, co, lod );",
      "vec4 t01 = texture2D( samplerTexture, co, lod + 1.0 );",
      "diff = mix( t00, t01, 0.5 );",
      "}",
      "diffuse *= diff.xyz;",
      "#endif",
      "vec3 fresnel = vec3( 0.0 );",
      "vec3 specular = vec3( 0.0 );",
      "vec3 eyeVector = normalize( -vertexPositionVS.xyz );",
      "vec3 R = reflect( eyeVector, normal );",
      "vec3 E = linePlaneIntersect( vertexPositionVS.xyz, R, lightPositionVS, lightNormalVS );",
      "float specAngle = dot( R, lightNormalVS );",
      "if ( dot( vertexPositionVS.xyz - lightPositionVS, lightNormalVS )>=0.0 && specAngle > 0.0 ) {",
      "vec3 dirSpec = E - lightPositionVS;",
      "vec2 dirSpec2D = vec2( dot( dirSpec, lightRightVS ), dot( dirSpec, lightUpVS ) );",
      "vec2 nearestSpec2D = vec2( clamp( dirSpec2D.x, -w, w ), clamp( dirSpec2D.y, -h, h ) );",
      "vec3 nearestPointInsideSpec = lightPositionVS + ( lightRightVS * nearestSpec2D.x + lightUpVS * nearestSpec2D.y );",
      "vec3 lightDirSpec = normalize( nearestPointInsideSpec - vertexPositionVS.xyz );",
      "vec3 halfVectorSpec = normalize( lightDirSpec + eyeVector );",
      "float dotNormalHalf = max( dot( normal, halfVectorSpec ), 0.0 );",
      "float dotLH = max( dot( lightDirSpec, halfVectorSpec ), 0.0 );",
      "float dotLN = max( dot( lightDirSpec, normal ), 0.0 );",
      "fresnel = specularColor + ( 1.0 - specularColor ) * pow( 1.0 - dotLH, 5.0 );",
      "#if defined( BRDF_BLINN_PHONG )",
      "specular = BlinnPhong_Specular( shininess, dotLN, dotNormalHalf, eyeVector, normal ) * ( fresnel * diffuse ) * specAngle;",
      "#elif defined( BRDF_GGX )",
      "float roughness = saturate( sqrt( 8.0 / ( shininess + 7.0 ) ) );",
      "specular = GGX_Specular( roughness, normal, halfVectorSpec, eyeVector, lightDirSpec ) * ( fresnel * diffuse ) * specAngle;",
      "#else",
      "specular = specularColor * max( pow( dotNormalHalf, shininess ), 0.0 ) * diffuse * specAngle;",
      "#endif",
      "#ifdef AREA_TEXTURE",
      "const float hard = 16.0;",
      "const float gloss = 16.0;",
      "vec3 specPlane = lightPositionVS + ( lightRightVS * dirSpec2D.x + lightUpVS * dirSpec2D.y );",
      "float dist = max( distance( vertexPositionVS.xyz, specPlane ), 0.0 );",
      "float d = ( ( 1.0 / hard ) / 2.0 ) * ( dist / gloss );",
      "w = max( w, 0.0 );",
      "h = max( h, 0.0 );",
      "vec2 co = dirSpec2D / ( d + 1.0 );",
      "co /= 2.0 * vec2( w, h );",
      "co = co + vec2( 0.5 );",
      "co.y = 1.0 - co.y;",
      "float lod = ( 2.0 / hard * max( dist, 0.0 ) );",
      "vec4 t00 = texture2D( samplerTexture, co, lod );",
      "vec4 t01 = texture2D( samplerTexture, co, lod + 1.0 );",
      "vec4 spec = mix( t00, t01, 0.5 );",
      "specular *= spec.xyz;",
      "#endif",
      "}",
      "diffuse -= diffuse * fresnel * specAngle;",
      "float occlusion = 1.0;",
      "#ifdef USE_SHADOWMAP",
      "vec4 posLightCS = matShadow * vertexPositionVS;",
      "vec2 shadowCoord = ( posLightCS.xy / posLightCS.w ) * 0.5 + 0.5;",
      "float vertexDepth = posLightCS.z / posLightCS.w;",
      "#if defined( SHADOW_TEXTURE_DEPTH )",
      "vertexDepth = vertexDepth * 0.5 + 0.5;",
      "#endif",
      "#if !defined( SLOPE_DEPTH_BIAS )",
      "vertexDepth -= shadowBias;",
      "#endif",
      "#if defined( SHADOWMAP_TYPE_PCF_SOFT )",
      "float shadowValue = sampleShadowPCFSoft( samplerShadowMap, shadowMapSize, shadowCoord, vertexDepth );",
      "#else",
      "#ifdef USE_SHADOWSAMPLER",
      "float shadowValue = 1.0 - texture( samplerShadowMap, vec3( shadowCoord, vertexDepth ) );",
      "#else",
      "float shadowDepth = texture2D( samplerShadowMap, shadowCoord ).x;",
      "float shadowValue = float( vertexDepth > shadowDepth );",
      "#endif",
      "#endif",
      "occlusion = 1.0 - shadowDarkness * shadowValue;",
      "#endif",
      "float dist = distance( vertexPositionVS.xyz, nearestPointInside );",
      "float attenuation = calculateAttenuation( dist ) * occlusion;",
      XG.DeferredShaderChunk.combine,
      "}",
    ].join("\n"),
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangle,
  }),
  (XG.DeferredShaders.imageLight = {
    uniforms: XG.UniformsUtils.merge([
      XG.DeferredUniformsLib.gbuffers,
      {
        matProjInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        matViewInverse: { type: "m4", value: new XG.Matrix4(), shared: !0 },
        samplerSpecular: { type: "t", value: null },
        samplerDiffuse: { type: "t", value: null },
        samplerMip: { type: "t", value: null },
        samplerSSAO: { type: "t", value: null },
        samplerSize: { type: "f", value: 0 },
        maxMipSpecular: { type: "f", value: 7 },
        lightIntensity: { type: "f", value: 1 },
        lightPositionWS: { type: "v3", value: new XG.Vector3(0, 0, 0) },
        lightSize: { type: "v3", value: new XG.Vector3(1, 1, 1) },
      },
    ]),
    fragmentShader: [
      "uniform mat4 matProjInverse;",
      "uniform mat4 matViewInverse;",
      "uniform samplerCube samplerSpecular;",
      "uniform samplerCube samplerDiffuse;",
      "#ifdef USE_SSAO",
      "uniform sampler2D samplerSSAO;",
      "#endif",
      "uniform float maxMipSpecular;",
      "uniform float lightIntensity;",
      "#ifdef LIGHT_LOCAL",
      "uniform vec3 lightPositionWS;",
      "uniform vec3 lightSize;",
      "float maxLength( vec3 v ) {",
      "return max( v.x, max( v.y, v.z ) );",
      "}",
      "#endif",
      "#if !defined( SUPPORTS_TEXTURE_LOD )",
      "uniform samplerCube samplerMip;",
      "#endif",
      XG.ShaderChunk.utils_pars_fragment,
      XG.ShaderChunk.decodingUtils,
      XG.DeferredShaderChunk.gbuffersUniforms,
      XG.DeferredShaderChunk.unpackFloat,
      XG.DeferredShaderChunk.environmentBRDF,
      XG.DeferredShaderChunk.specularOcclusion,
      "#ifdef FIX_SEAMS",
      "uniform float samplerSize;",
      "vec3 fix_cube_lookup( vec3 v, float mipLevelClamp, float cubeSize ) {",
      "float M = max( max( abs( v.x ), abs( v.y ) ), abs( v.z ) );",
      "float scale = 1.0 - exp2( mipLevelClamp ) / cubeSize;",
      "if ( abs( v.x ) != M ) v.x *= scale;",
      "if ( abs( v.y ) != M ) v.y *= scale;",
      "if ( abs( v.z ) != M ) v.z *= scale;",
      "return v;",
      "}",
      "#endif",
      "void main() {",
      XG.DeferredShaderChunk.computeVertexPositionVS,
      "#ifdef LIGHT_LOCAL",
      "vec4 vertexPositionWS = matViewInverse * vertexPositionVS;",
      "vec3 lightVectorWS = abs( lightPositionWS.xyz - vertexPositionWS.xyz );",
      "if ( lightVectorWS.x > lightSize.x || lightVectorWS.y > lightSize.y || lightVectorWS.z > lightSize.z ) discard;",
      "float localFade = max( 1.0 - maxLength( lightVectorWS / lightSize ), 0.0 );",
      "#else",
      "float localFade = 1.0;",
      "#endif",
      XG.DeferredShaderChunk.computeNormal,
      XG.DeferredShaderChunk.unpackColorMap,
      "vec3 eyeVector = normalize( -vertexPositionVS.xyz );",
      "vec3 reflectVS = reflect( -eyeVector, normal );",
      "vec4 reflectWS = matViewInverse * vec4( reflectVS, 0.0 );",
      "#ifdef LIGHT_LOCAL",
      "vec3 BoxMin = lightPositionWS - lightSize;",
      "vec3 BoxMax = lightPositionWS + lightSize;",
      "vec3 FirstPlaneIntersect  = ( BoxMax - vertexPositionWS.xyz ) / reflectWS.xyz;",
      "vec3 SecondPlaneIntersect = ( BoxMin - vertexPositionWS.xyz ) / reflectWS.xyz;",
      "vec3 FurthestPlane = max( FirstPlaneIntersect, SecondPlaneIntersect );",
      "float Distance = min( min( FurthestPlane.x, FurthestPlane.y ), FurthestPlane.z );",
      "vec3 IntersectPositionWS = vertexPositionWS.xyz + reflectWS.xyz * Distance;",
      "reflectWS.xyz = IntersectPositionWS - lightPositionWS;",
      "#endif",
      "vec3 cubeCoord = reflectWS.xyz;",
      "float gloss = shininess / 8192.0;",
      "float maxMipLevel = maxMipSpecular - 2.0;",
      "#ifdef SUPPORTS_TEXTURE_LOD",
      "#if defined( IBL_HDR_RGBM ) || defined( IBL_HDR_RGBA32F ) || defined( IBL_HDR_RGBA16F )",
      "float mipLod = ( maxMipLevel - 1.0 ) * ( 1.0 - gloss );",
      "#else",
      "float mipLod = max( ( maxMipLevel * ( 1.0 - gloss ) ), 1.5 );",
      "#endif",
      "#ifdef FIX_SEAMS",
      "cubeCoord = fix_cube_lookup( cubeCoord, mipLod, samplerSize );",
      "#endif",
      "vec4 cubeColorSpecularSample = textureCubeLodEXT( samplerSpecular, cubeCoord, mipLod );",
      "#else",
      "const float mipUnit = 255.0 / 16.0;",
      "#ifdef SPECULAR_MIP_FIX",
      "float curvature = length( fwidth( cubeCoord ) );",
      "float mipLevelMinification = mipUnit * textureCube( samplerMip, cubeCoord, -curvature ).a;",
      "float mipLevelMagnification = mipUnit * textureCube( samplerMip, cubeCoord, maxMipSpecular - 1.0 - curvature ).a;",
      "#else",
      "const float curvature = 0.0;",
      "float mipLevelMinification = mipUnit * textureCube( samplerMip, cubeCoord ).a;",
      "float mipLevelMagnification = mipUnit * textureCube( samplerMip, cubeCoord, maxMipSpecular - 1.0 ).a;",
      "#endif",
      "float mipLevel;",
      "if ( mipLevelMinification == 0.0 ) {",
      "mipLevel = mipLevelMagnification - ( maxMipSpecular - 1.0 );",
      "} else {",
      "mipLevel = mipLevelMinification;",
      "}",
      "#if defined( IBL_HDR_RGBM ) || defined( IBL_HDR_RGBA32F ) || defined( IBL_HDR_RGBA16F )",
      "float mipBias = max( ( maxMipLevel - 1.0 ) * ( 1.0 - gloss ) - mipLevel, -3.0 );",
      "#else",
      "float mipBias = max( ( maxMipLevel * ( 1.0 - gloss ) ) - mipLevel, 0.0 );",
      "#endif",
      "mipBias -= curvature;",
      "#ifdef FIX_SEAMS",
      "cubeCoord = fix_cube_lookup( cubeCoord, mipLevel, samplerSize );",
      "#endif",
      "vec4 cubeColorSpecularSample = textureCube( samplerSpecular, cubeCoord, mipBias );",
      "#endif",
      "vec4 normalWS = matViewInverse * vec4( normal, 0.0 );",
      "vec4 cubeColorDiffuseSample = textureCube( samplerDiffuse, normalWS.xyz );",
      "vec3 cubeColorSpecular = cubeColorSpecularSample.rgb;",
      "vec3 cubeColorDiffuse = cubeColorDiffuseSample.rgb;",
      "#ifdef IBL_HDR_RGBM",
      "cubeColorSpecular *= cubeColorSpecularSample.a * 5.0;",
      "cubeColorDiffuse *= cubeColorDiffuseSample.a * 5.0;",
      "#endif",
      "#ifdef IBL_GAMMA_TEXTURE",
      "cubeColorSpecular *= cubeColorSpecular;",
      "cubeColorDiffuse *= cubeColorDiffuse;",
      "#endif",
      "vec3 fresnelEnv = EnvironmentBRDF( gloss, dot( eyeVector, normal ), specularColor );",
      "vec3 diffuse = ( 1.0 - fresnelEnv ) * cubeColorDiffuse;",
      "vec3 specular = fresnelEnv * cubeColorSpecular;",
      "float diffuseOcclusion = lightMapIntensity;",
      "#ifdef USE_SSAO",
      "float ssaoOcclusion = texture2D( samplerSSAO, texCoord ).x;",
      "ssaoOcclusion *= ssaoOcclusion;",
      "diffuseOcclusion = min( diffuseOcclusion, ssaoOcclusion );",
      "#endif",
      "float roughness = saturate( sqrt( 8.0 / ( shininess + 7.0 ) ) );",
      "float NdotV = dot( normal, eyeVector );",
      "float specularOcclusion = computeSpecOcclusion( NdotV, diffuseOcclusion, roughness );",
      "mgl_FragColor = vec4( lightIntensity * ( albedo * diffuse * diffuseOcclusion + specular * specularOcclusion ), lightMapIntensity * localFade );",
      "}",
    ].join("\n"),
    vertexShader: [
      "void main() { ",
      "#ifdef LIGHT_LOCAL",
      "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
      "gl_Position = projectionMatrix * mvPosition;",
      "#else",
      "gl_Position = vec4( position.xyz, 1.0 );",
      "#endif",
      "}",
    ].join("\n"),
  }),
  (XG.DeferredShaders.composite = {
    uniforms: XG.UniformsUtils.merge([
      XG.UniformsLib.fogAtmo,
      {
        samplerLight: { type: "t", value: null },
        samplerBloom: { type: "t", value: null },
        samplerDepth: { type: "t", value: null },
        samplerParticles: { type: "t", value: null },
        samplerParticlesRevealage: { type: "t", value: null },
        samplerParticlesDepth: { type: "t", value: null },
        particleSamplerSize: { type: "v2", value: new XG.Vector2(960, 540) },
        particleDepthMult: { type: "f", value: 1e3 },
        particleDepthThreshold: { type: "f", value: 0.1 },
        samplerBlur: { type: "t", value: null },
        samplerBlurAmount: { type: "t", value: null },
        brightness: { type: "f", value: 1 },
        whitePoint: { type: "f", value: 1 },
        bloomStrength: { type: "f", value: 1 },
        cameraNearFar: { type: "v2", value: new XG.Vector2(1, 1e3) },
      },
    ]),
    fragmentShader: [
      "varying vec2 vUv;",
      "uniform sampler2D samplerLight;",
      "#ifdef BLOOM_ENABLED",
      "uniform sampler2D samplerBloom;",
      "uniform float bloomStrength;",
      "#endif",
      "#ifdef OFFSCREEN_PARTICLES",
      "uniform sampler2D samplerParticles;",
      "uniform sampler2D samplerParticlesDepth;",
      "uniform vec2 particleSamplerSize;",
      "uniform float particleDepthMult;",
      "uniform float particleDepthThreshold;",
      "#ifdef PARTICLE_OIT",
      "uniform sampler2D samplerParticlesRevealage;",
      "#endif",
      "#endif",
      "#ifdef FANCY_DOF",
      "uniform sampler2D samplerBlur;",
      "uniform sampler2D samplerBlurAmount;",
      "#endif",
      "#if defined( FOG_ENABLED ) || defined( OFFSCREEN_PARTICLES )",
      "uniform sampler2D samplerDepth;",
      "uniform vec2 cameraNearFar;",
      "#endif",
      XG.ShaderChunk.fogAtmoFragmentPars,
      XG.ShaderChunk.linearDepthFragmentPars,
      XG.ShaderChunk.tonemappingFragmentPars,
      XG.ShaderChunk.ditheringFragmentPars,
      XG.DeferredShaderChunk.unpackFloat,
      "#ifdef OFFSCREEN_PARTICLES",
      "#ifdef PARTICLE_OIT",
      "vec4 fetchLowResParticleColor( vec2 uv ) {",
      "vec4 accum = texture2D( samplerParticles, uv );",
      "float rev = texture2D( samplerParticlesRevealage, uv ).r;",
      "return vec4( accum.rgb / clamp( rev, 1e-4, 5e4 ), accum.a );",
      "}",
      "#else",
      "vec4 fetchLowResParticleColor( vec2 uv ) {",
      "return texture2D( samplerParticles, uv );",
      "}",
      "#endif",
      "float fetchLowResDepth( vec2 uv ) {",
      "vec4 packedDepth = texture2D( samplerParticlesDepth, uv );",
      "float depth = unpackDepth( packedDepth );",
      "float linearDepth = linearizeDepth( depth, cameraNearFar );",
      "return linearDepth;",
      "}",
      "float fetchFullResDepth( vec2 uv ) {",
      "#if defined( RGBA_DEPTH )",
      "vec4 packedDepth = texture2D( samplerDepth, uv );",
      "float depth = unpackDepth( packedDepth );",
      "#elif defined( FLOAT_DEPTH )",
      "float depth = texture2D( samplerDepth, uv ).w;",
      "#elif defined( TEXTURE_DEPTH )",
      "float depth = texture2D( samplerDepth, uv ).x * 2.0 - 1.0;",
      "#endif",
      "float linearDepth = linearizeDepth( depth, cameraNearFar );",
      "return linearDepth;",
      "}",
      "#endif",
      "void main() {",
      "vec3 color = texture2D( samplerLight, vUv ).xyz;",
      "#ifdef FOG_ENABLED",
      "#if defined( RGBA_DEPTH )",
      "vec4 packedDepth = texture2D( samplerDepth, vUv );",
      "float depth = unpackDepth( packedDepth );",
      "#elif defined( FLOAT_DEPTH )",
      "float depth = texture2D( samplerDepth, vUv ).w;",
      "#elif defined( TEXTURE_DEPTH )",
      "float depth = texture2D( samplerDepth, vUv ).x * 2.0 - 1.0;",
      "#endif",
      "float linearDepth = linearizeDepth( depth, cameraNearFar );",
      "color = addFog( color, linearDepth );",
      "#endif",
      "#ifdef FANCY_DOF",
      "float bias = texture2D( samplerBlurAmount, vUv ).a;",
      "vec3 blur = texture2D( samplerBlur, vUv ).rgb;",
      "color = mix( color, blur, smoothstep( 0.0, 0.1, bias ) );",
      "#endif",
      "#ifdef OFFSCREEN_PARTICLES",
      "#ifdef PARTICLES_UPSAMPLING_NEAREST_DEPTH",
      "vec2 lowResTexelSize = vec2( 1.0 / particleSamplerSize );",
      "vec2 uv00 = vUv - 0.5 * lowResTexelSize;",
      "vec2 uv10 = vUv + vec2( lowResTexelSize.x, 0.0 );",
      "vec2 uv01 = vUv + vec2( 0.0, lowResTexelSize.y );",
      "vec2 uv11 = vUv + lowResTexelSize;",
      "vec4 c00 = fetchLowResParticleColor( uv00 );",
      "vec4 c10 = fetchLowResParticleColor( uv10 );",
      "vec4 c01 = fetchLowResParticleColor( uv01 );",
      "vec4 c11 = fetchLowResParticleColor( uv11 );",
      "vec4 centerSample = fetchLowResParticleColor( vUv );",
      "float z00 = fetchLowResDepth( uv00 );",
      "float z10 = fetchLowResDepth( uv10 );",
      "float z01 = fetchLowResDepth( uv01 );",
      "float z11 = fetchLowResDepth( uv11 );",
      "float zfull = fetchFullResDepth( vUv );",
      "const float upsampleDepthThreshold = 0.0001;",
      "float minDepthDiff = 1.0;",
      "vec4 nearestSample = centerSample;",
      "float currentDepthDiff = abs( z00 - zfull );",
      "bool rejectSample = currentDepthDiff < upsampleDepthThreshold;",
      "if ( currentDepthDiff < minDepthDiff ) {",
      "minDepthDiff = currentDepthDiff;",
      "nearestSample = c00;",
      "}",
      "currentDepthDiff = abs( z10 - zfull );",
      "rejectSample = rejectSample && currentDepthDiff < upsampleDepthThreshold;",
      "if ( currentDepthDiff < minDepthDiff ) {",
      "minDepthDiff = currentDepthDiff;",
      "nearestSample = c10;",
      "}",
      "currentDepthDiff = abs( z01 - zfull );",
      "rejectSample = rejectSample && currentDepthDiff < upsampleDepthThreshold;",
      "if ( currentDepthDiff < minDepthDiff ) {",
      "minDepthDiff = currentDepthDiff;",
      "nearestSample = c01;",
      "}",
      "currentDepthDiff = abs( z11 - zfull );",
      "rejectSample = rejectSample && currentDepthDiff < upsampleDepthThreshold;",
      "if ( currentDepthDiff < minDepthDiff ) {",
      "minDepthDiff = currentDepthDiff;",
      "nearestSample = c11;",
      "}",
      "if ( rejectSample ) {",
      "nearestSample = centerSample;",
      "}",
      "vec4 particleColor = nearestSample;",
      "#if defined( PARTICLE_OIT )",
      "color = particleColor.a * color.rgb + ( 1.0 - particleColor.a ) * particleColor.rgb;",
      "#else",
      "color += particleColor.rgb;",
      "#endif",
      "#else",
      "#if defined( PARTICLE_OIT )",
      "vec4 accum = texture2D( samplerParticles, vUv );",
      "float rev = texture2D( samplerParticlesRevealage, vUv ).r;",
      "vec4 transparent = vec4( accum.rgb / clamp( rev, 1e-4, 5e4 ), accum.a );",
      "color = transparent.a * color.rgb + ( 1.0 - transparent.a ) * transparent.rgb;",
      "#else",
      "vec3 particleColor = texture2D( samplerParticles, vUv ).xyz;",
      "color += particleColor;",
      "#endif",
      "#endif",
      "#endif",
      "#ifdef TONEMAPPING",
      "color = applyTonemapping( color, brightness, whitePoint );",
      "#endif",
      "#ifdef DITHERING_ENABLED",
      "color = applyDithering( color, vUv );",
      "#endif",
      "#ifdef BLOOM_ENABLED",
      "vec3 bloomColor = texture2D( samplerBloom, vUv ).xyz;",
      "color += bloomStrength * bloomColor;",
      "#endif",
      "mgl_FragColor = vec4( color, 1.0 );",
      "}",
    ].join("\n"),
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
  }),
  (XG.ConvolutionShader = {
    defines: { KERNEL_SIZE_FLOAT: "25.0", KERNEL_SIZE_INT: "25" },
    uniforms: {
      tDiffuse: { type: "t", value: null },
      uImageIncrement: { type: "v2", value: new XG.Vector2(0.001953125, 0) },
      cKernel: { type: "fv1", value: [] },
    },
    vertexShader: [
      "uniform vec2 uImageIncrement;",
      "varying vec2 vUv;",
      "void main() {",
      "vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;",
      "gl_Position = vec4( position.xyz, 1.0 );",
      "}",
    ].join("\n"),
    fragmentShader: [
      "uniform float cKernel[ KERNEL_SIZE_INT ];",
      "uniform sampler2D tDiffuse;",
      "uniform vec2 uImageIncrement;",
      "varying vec2 vUv;",
      "void main() {",
      "vec2 imageCoord = vUv;",
      "vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );",
      "for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {",
      "sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];",
      "imageCoord += uImageIncrement;",
      "}",
      "mgl_FragColor = sum;",
      "}",
    ].join("\n"),
    buildKernel: function (e) {
      function t(e, t) {
        return Math.exp(-(e * e) / (2 * t * t));
      }
      var a,
        r,
        i,
        o,
        n = 25,
        s = 2 * Math.ceil(3 * e) + 1;
      for (
        s > n && (s = n), o = 0.5 * (s - 1), r = new Array(s), i = 0, a = 0;
        s > a;
        ++a
      )
        (r[a] = t(a - o, e)), (i += r[a]);
      for (a = 0; s > a; ++a) r[a] /= i;
      return r;
    },
  }),
  (XG.CopyShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      opacity: { type: "f", value: 1 },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform float opacity;",
      "uniform sampler2D tDiffuse;",
      "varying vec2 vUv;",
      "void main() {",
      "vec4 texel = texture2D( tDiffuse, vUv );",
      "mgl_FragColor = opacity * texel;",
      "}",
    ].join("\n"),
  }),
  (XG.DepthSampleShader = {
    uniforms: {
      samplerDepth: { type: "t", value: null },
      tDiffuse: { type: "t", value: null },
      opacity: { type: "f", value: 1 },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform sampler2D samplerDepth;",
      "varying vec2 vUv;",
      "vec4 packDepth( const in float depth ) {",
      "vec4 enc = vec4( 1.0, 255.0, 65025.0, 16581375.0 ) * depth;",
      "enc = fract( enc );",
      "enc -= enc.yzww * vec4( 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0 );",
      "return enc;",
      "}",
      "void main() {",
      "#if defined( RGBA_DEPTH )",
      "vec4 packedDepth = texture2D( samplerDepth, vUv );",
      "#elif defined( FLOAT_DEPTH )",
      "float depth = texture2D( samplerDepth, vUv ).w;",
      "vec4 packedDepth = packDepth( depth );",
      "#elif defined( TEXTURE_DEPTH )",
      "float depth = texture2D( samplerDepth, vUv ).x * 2.0 - 1.0;",
      "vec4 packedDepth = packDepth( depth );",
      "#endif",
      "mgl_FragColor = packedDepth;",
      "}",
    ].join("\n"),
  }),
  (XG.FXAAShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      resolution: { type: "v2", value: new XG.Vector2(1 / 1024, 1 / 512) },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      "uniform vec2 resolution;",
      "varying vec2 vUv;",
      "#define FXAA_REDUCE_MIN   (1.0/128.0)",
      "#define FXAA_REDUCE_MUL   (1.0/8.0)",
      "#define FXAA_SPAN_MAX     8.0",
      "void main() {",
      "vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;",
      "vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;",
      "vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;",
      "vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;",
      "vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );",
      "vec3 rgbM  = rgbaM.xyz;",
      "float opacity  = rgbaM.w;",
      "vec3 luma = vec3( 0.299, 0.587, 0.114 );",
      "float lumaNW = dot( rgbNW, luma );",
      "float lumaNE = dot( rgbNE, luma );",
      "float lumaSW = dot( rgbSW, luma );",
      "float lumaSE = dot( rgbSE, luma );",
      "float lumaM  = dot( rgbM,  luma );",
      "float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
      "float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );",
      "vec2 dir;",
      "dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",
      "dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",
      "float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );",
      "float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );",
      "dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),",
      "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),",
      "dir * rcpDirMin)) * resolution;",
      "vec3 rgbA = 0.5 * (",
      "texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz +",
      "texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz );",
      "vec3 rgbB = rgbA * 0.5 + 0.25 * (",
      "texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz +",
      "texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz );",
      "float lumaB = dot( rgbB, luma );",
      "if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {",
      "mgl_FragColor = vec4( rgbA, opacity );",
      "} else {",
      "mgl_FragColor = vec4( rgbB, opacity );",
      "}",
      "}",
    ].join("\n"),
  }),
  (XG.TAAShader = {
    uniforms: {
      tDepth: { type: "t", value: null },
      tDiffuse: { type: "t", value: null },
      tDiffuseLast: { type: "t", value: null },
      feedbackMin: { type: "f", value: 0.88 },
      feedbackMax: { type: "f", value: 0.97 },
      jitterOffset: { type: "v4", value: new XG.Vector4() },
      matProjInverse: { type: "m4", value: new XG.Matrix4() },
      matViewInverse: { type: "m4", value: new XG.Matrix4() },
      matViewProjLast: { type: "m4", value: new XG.Matrix4() },
      viewSize: { type: "v2", value: new XG.Vector2(800, 600) },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "#define USE_OPTIMIZATIONS 1",
      "#define MINMAX_3X3 0",
      "#define MINMAX_3X3_ROUNDED 1",
      "#define USE_CLIPPING 1",
      "#define UNJITTER_COLORSAMPLES 1",
      "#define UNJITTER_NEIGHBORHOOD 0",
      "#define UNJITTER_REPROJECTION 0",
      "#define USE_YCOCG 0",
      "const float FLT_EPS = 0.00000001;",
      "uniform sampler2D tDepth;",
      "uniform sampler2D tDiffuse;",
      "uniform sampler2D tDiffuseLast;",
      "uniform float feedbackMin;",
      "uniform float feedbackMax;",
      "uniform vec4 jitterOffset;",
      "uniform mat4 matProjInverse;",
      "uniform mat4 matViewInverse;",
      "uniform mat4 matViewProjLast;",
      "uniform vec2 viewSize;",
      "varying vec2 vUv;",
      "#if defined( RGBA_DEPTH )",
      "float unpackDepth( vec4 rgba ) {",
      "return clamp( dot( rgba, vec4( 1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0 ) ), 0.0, 1.0 );",
      "}",
      "#endif",
      "float Luminance( vec3 c ) {",
      "return dot( c, vec3( 0.22, 0.707, 0.071 ) );",
      "}",
      "vec3 RGB_YCoCg( vec3 c ) {",
      "return vec3(",
      "c.x/4.0 + c.y/2.0 + c.z/4.0,",
      "c.x/2.0 - c.z/2.0,",
      "-c.x/4.0 + c.y/2.0 - c.z/4.0",
      ");",
      "}",
      "vec4 sample_color( sampler2D tex, vec2 uv ) {",
      "#if USE_YCOCG",
      "vec4 c = texture2D( tex, uv );",
      "return vec4( RGB_YCoCg( c.rgb ), c.a );",
      "#else",
      "return texture2D( tex, uv );",
      "#endif",
      "}",
      "vec4 clip_aabb( vec3 aabb_min, vec3 aabb_max, vec4 p, vec4 q ) {",
      "#if USE_OPTIMIZATIONS",
      "vec3 p_clip = 0.5 * ( aabb_max + aabb_min );",
      "vec3 e_clip = 0.5 * ( aabb_max - aabb_min );",
      "vec4 v_clip = q - vec4( p_clip, p.w );",
      "vec3 v_unit = v_clip.xyz / e_clip;",
      "vec3 a_unit = abs( v_unit );",
      "float ma_unit = max( a_unit.x, max( a_unit.y, a_unit.z ) );",
      "if ( ma_unit > 1.0 )",
      "return vec4( p_clip, p.w ) + v_clip / ma_unit;",
      "else",
      "return q;",
      "#else",
      "vec4 r = q - p;",
      "vec3 rmax = aabb_max - p.xyz;",
      "vec3 rmin = aabb_min - p.xyz;",
      "const float eps = FLT_EPS;",
      "if ( r.x > rmax.x + eps )",
      "r *= ( rmax.x / r.x );",
      "if ( r.y > rmax.y + eps )",
      "r *= ( rmax.y / r.y );",
      "if ( r.z > rmax.z + eps )",
      "r *= ( rmax.z / r.z );",
      "if ( r.x < rmin.x - eps )",
      "r *= ( rmin.x / r.x );",
      "if ( r.y < rmin.y - eps )",
      "r *= ( rmin.y / r.y );",
      "if ( r.z < rmin.z - eps )",
      "r *= ( rmin.z / r.z );",
      "return p + r;",
      "#endif",
      "}",
      "void main() {",
      "vec2 texCoord = vUv;",
      "#if defined( RGBA_DEPTH )",
      "vec4 packedDepth = texture2D( tDepth, texCoord );",
      "float z = unpackDepth( packedDepth );",
      "#elif defined( TEXTURE_DEPTH )",
      "vec4 texDepth = texture2D( tDepth, texCoord );",
      "float z = texDepth.x * 2.0 - 1.0;",
      "#elif defined( FLOAT_DEPTH )",
      "vec4 normalDepth = texture2D( tDepth, texCoord );",
      "float z = normalDepth.w;",
      "#endif",
      "vec2 xy = texCoord * 2.0 - 1.0;",
      "vec4 vertexPositionProjected = vec4( xy, z, 1.0 );",
      "vec4 vertexPositionVS = matProjInverse * vertexPositionProjected;",
      "vertexPositionVS.xyz /= vertexPositionVS.w;",
      "vertexPositionVS.w = 1.0;",
      "vec4 vertexPositionWS = matViewInverse * vertexPositionVS;",
      "vec4 reprojectedPositionVS = matViewProjLast * vertexPositionWS;",
      "reprojectedPositionVS.xyz /= reprojectedPositionVS.w;",
      "vec2 texCoordReprojected = 0.5 * reprojectedPositionVS.xy + 0.5;",
      "vec2 texelSize = 1.0 / viewSize;",
      "#if UNJITTER_COLORSAMPLES || UNJITTER_NEIGHBORHOOD",
      "vec2 jitter0 = jitterOffset.xy * texelSize.xy;",
      "#endif",
      "#if UNJITTER_COLORSAMPLES",
      "vec4 texel0 = sample_color( tDiffuse, texCoord - jitter0 );",
      "#else",
      "vec4 texel0 = sample_color( tDiffuse, texCoord );",
      "#endif",
      "vec4 texel1 = sample_color( tDiffuseLast, texCoordReprojected );",
      "#if UNJITTER_NEIGHBORHOOD",
      "vec2 uv = texCoord - jitter0;",
      "#else",
      "vec2 uv = texCoord;",
      "#endif",
      "#if MINMAX_3X3 || MINMAX_3X3_ROUNDED",
      "vec2 du = vec2( texelSize.x, 0.0 );",
      "vec2 dv = vec2( 0.0, texelSize.y );",
      "vec4 ctl = sample_color( tDiffuse, uv - dv - du );",
      "vec4 ctc = sample_color( tDiffuse, uv - dv );",
      "vec4 ctr = sample_color( tDiffuse, uv - dv + du );",
      "vec4 cml = sample_color( tDiffuse, uv - du );",
      "vec4 cmc = sample_color( tDiffuse, uv );",
      "vec4 cmr = sample_color( tDiffuse, uv + du );",
      "vec4 cbl = sample_color( tDiffuse, uv + dv - du );",
      "vec4 cbc = sample_color( tDiffuse, uv + dv );",
      "vec4 cbr = sample_color( tDiffuse, uv + dv + du );",
      "vec4 cmin = min( ctl, min( ctc, min( ctr, min( cml, min( cmc, min( cmr, min( cbl, min( cbc, cbr ) ) ) ) ) ) ) );",
      "vec4 cmax = max( ctl, max( ctc, max( ctr, max( cml, max( cmc, max( cmr, max( cbl, max( cbc, cbr ) ) ) ) ) ) ) );",
      "#if MINMAX_3X3_ROUNDED || USE_YCOCG || USE_CLIPPING",
      "vec4 cavg = ( ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr ) / 9.0;",
      "#endif",
      "#if MINMAX_3X3_ROUNDED",
      "vec4 cmin5 = min( ctc, min( cml, min( cmc, min( cmr, cbc ) ) ) );",
      "vec4 cmax5 = max( ctc, max( cml, max( cmc, max( cmr, cbc ) ) ) );",
      "vec4 cavg5 = ( ctc + cml + cmc + cmr + cbc ) / 5.0;",
      "cmin = 0.5 * ( cmin + cmin5 );",
      "cmax = 0.5 * ( cmax + cmax5 );",
      "cavg = 0.5 * ( cavg + cavg5 );",
      "#endif",
      "#endif",
      "#if USE_YCOCG",
      "vec2 chroma_extent = 0.25 * 0.5 * ( cmax.r - cmin.r );",
      "vec2 chroma_center = texel0.gb;",
      "cmin.yz = chroma_center - chroma_extent;",
      "cmax.yz = chroma_center + chroma_extent;",
      "cavg.yz = chroma_center;",
      "#endif",
      "#if USE_CLIPPING",
      "texel1 = clip_aabb( cmin.xyz, cmax.xyz, clamp( cavg, cmin, cmax ), texel1 );",
      "#else",
      "texel1 = clamp( texel1, cmin, cmax );",
      "#endif",
      "#if USE_YCOCG",
      "float lum0 = texel0.r;",
      "float lum1 = texel1.r;",
      "#else",
      "float lum0 = Luminance( texel0.rgb );",
      "float lum1 = Luminance( texel1.rgb );",
      "#endif",
      "float unbiased_diff = abs( lum0 - lum1 ) / max( lum0, max( lum1, 0.2 ) );",
      "float unbiased_weight = 1.0 - unbiased_diff;",
      "float unbiased_weight_sqr = unbiased_weight * unbiased_weight;",
      "float k_feedback = mix( feedbackMin, feedbackMax, unbiased_weight_sqr );",
      "mgl_FragColor = mix( texel0, texel1, k_feedback );",
      "}",
    ].join("\n"),
  }),
  (XG.SSAOShader = {
    defines: { PREBAKED_SAMPLES: !0, NUM_PREBAKED_SAMPLES: "9" },
    uniforms: {
      tDepth: { type: "t", value: null },
      size: { type: "v2", value: new XG.Vector2(512, 512) },
      cameraCoef: { type: "v3", value: new XG.Vector3(101, 99, 2) },
      onlyAO: { type: "i", value: 0 },
      aoClamp: { type: "f", value: 0.3 },
      radius: { type: "f", value: 15 },
      samplePoints: {
        type: "fv2",
        value: XG.Math.generatePoissonDiscSamples(9),
      },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform vec3 cameraCoef;",
      "uniform float radius;",
      "uniform vec2 size;",
      "uniform float aoClamp;",
      "uniform sampler2D tDepth;",
      "uniform vec2 samplePoints[ NUM_PREBAKED_SAMPLES ];",
      "varying vec2 vUv;",
      "#define DL 2.399963229728653",
      "#define EULER 2.718281828459045",
      "#define WIDTH size.x",
      "#define HEIGHT size.y",
      "#define CAMERA_FAR_PLUS_NEAR cameraCoef.x",
      "#define CAMERA_FAR_MINUS_NEAR cameraCoef.y",
      "#define CAMERA_NEAR2 cameraCoef.z",
      "#ifndef SAMPLES",
      "#define SAMPLES 8",
      "#endif",
      "const int samples = SAMPLES;",
      "#define USE_NOISE 1",
      "const float noiseAmount = 0.0002;",
      "const float diffAreaSq = 0.16;",
      "const float gDisplace = 0.4;",
      "#ifdef RGBA_DEPTH",
      "float unpackDepth( vec4 rgba ) {",
      "return clamp( dot( rgba, vec4( 1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0 ) ), 0.0, 1.0 );",
      "}",
      "#endif",
      "vec2 rand( const in vec2 coord ) {",
      "#ifdef USE_NOISE",
      "float nx = dot ( coord, vec2( 12.9898, 78.233 ) );",
      "float ny = dot ( coord, vec2( 25.9796, 156.466 ) );",
      "vec2 noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );",
      "#else",
      "float ff = fract( 1.0 - coord.s * ( WIDTH / 2.0 ) );",
      "float gg = fract( coord.t * ( HEIGHT / 2.0 ) );",
      "vec2 noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;",
      "#endif",
      "return ( noise * 2.0  - 1.0 ) * noiseAmount;",
      "}",
      "float readDepth( const in vec2 coord ) {",
      "#if defined( RGBA_DEPTH )",
      "vec4 packedDepth = texture2D( tDepth, coord );",
      "float depth = unpackDepth( packedDepth );",
      "#elif defined( FLOAT_DEPTH )",
      "float depth = texture2D( tDepth, coord ).w;",
      "#elif defined( TEXTURE_DEPTH )",
      "float depth = texture2D( tDepth, coord ).x * 2.0 - 1.0;",
      "#endif",
      "return CAMERA_NEAR2 / ( CAMERA_FAR_PLUS_NEAR - depth * CAMERA_FAR_MINUS_NEAR );",
      "}",
      "float compareDepths( const in float depth1, const in float depth2, inout int far ) {",
      "float gareaSq = 4.0;",
      "float diff = ( depth1 - depth2 ) * 100.0;",
      "if ( diff < gDisplace ) {",
      "gareaSq = diffAreaSq;",
      "} else {",
      "far = 1;",
      "}",
      "float dd = diff - gDisplace;",
      "return pow( EULER, -2.0 * dd * dd / gareaSq );",
      "}",
      "float calcAO( const in float depth, const in float dw, const in float dh ) {",
      "float dd = radius - depth * radius;",
      "vec2 vv = vec2( dw, dh );",
      "vec2 coord1 = vUv + dd * vv;",
      "vec2 coord2 = vUv - dd * vv;",
      "float temp1 = 0.0;",
      "float temp2 = 0.0;",
      "int far = 0;",
      "temp1 = compareDepths( depth, readDepth( coord1 ), far );",
      "if ( far > 0 ) {",
      "temp2 = compareDepths( readDepth( coord2 ), depth, far );",
      "temp1 += ( 1.0 - temp1 ) * temp2;",
      "}",
      "return temp1;",
      "}",
      "void main() {",
      "vec2 noise = rand( vUv );",
      "float depth = readDepth( vUv );",
      "float tt = clamp( depth, aoClamp, 1.0 );",
      "float w = ( 1.0 / WIDTH )  / tt + ( noise.x * ( 1.0 - noise.x ) );",
      "float h = ( 1.0 / HEIGHT ) / tt + ( noise.y * ( 1.0 - noise.y ) );",
      "float pw = 0.0;",
      "float ph = 0.0;",
      "float ao = 0.0;",
      "#if defined( PREBAKED_SAMPLES )",
      "for ( int i = 0; i < NUM_PREBAKED_SAMPLES; i ++ ) {",
      "vec2 samplePoint = samplePoints[ i ];",
      "ao += calcAO( depth, samplePoint.x * w, samplePoint.y * h );",
      "}",
      "ao /= float( NUM_PREBAKED_SAMPLES );",
      "#else",
      "float dz = 1.0 / float( samples );",
      "float z = 1.0 - dz / 2.0;",
      "float l = 0.0;",
      "for ( int i = 0; i <= samples; i ++ ) {",
      "float r = sqrt( 1.0 - z );",
      "pw = cos( l ) * r;",
      "ph = sin( l ) * r;",
      "ao += calcAO( depth, pw * w, ph * h );",
      "z = z - dz;",
      "l = l + DL;",
      "}",
      "ao /= float( samples );",
      "#endif",
      "mgl_FragColor = vec4( vec3( 1.0 - ao ), 1.0 );",
      "}",
    ].join("\n"),
  }),
  (XG.SSAOHorizontalBlurShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      h: { type: "f", value: 1 / 512 },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      "uniform float h;",
      "varying vec2 vUv;",
      "void main() {",
      "vec4 sum = vec4( 0.0 );",
      "vec4 h1 = texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) );",
      "vec4 h2 = texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) );",
      "vec4 h0 = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );",
      "vec4 m = ( h1 - h2 ) * 0.5;",
      "float d = abs( h0.x - m.x );",
      "if ( d > 0.15 ) {",
      "sum = min( h1, h2 );",
      "} else {",
      "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;",
      "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;",
      "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;",
      "sum += h1 * 0.1531;",
      "sum += h0 * 0.1633;",
      "sum += h2 * 0.1531;",
      "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;",
      "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;",
      "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;",
      "}",
      "mgl_FragColor = sum;",
      "}",
    ].join("\n"),
  }),
  (XG.SSAOVerticalBlurShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      v: { type: "f", value: 1 / 512 },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      "uniform float v;",
      "varying vec2 vUv;",
      "void main() {",
      "vec4 sum = vec4( 0.0 );",
      "vec4 v1 = texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) );",
      "vec4 v2 = texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) );",
      "vec4 v0 = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );",
      "vec4 m = ( v1 - v2 ) * 0.5;",
      "float d = abs( v0.x - m.x );",
      "if ( d > 0.15 ) {",
      "sum = min( v1, v2 );",
      "} else {",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;",
      "sum += v1 * 0.1531;",
      "sum += v0 * 0.1633;",
      "sum += v2 * 0.1531;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;",
      "}",
      "mgl_FragColor = sum;",
      "}",
    ].join("\n"),
  }),
  (XG.SSAOBilateralHorizontalBlurShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      tDepth: { type: "t", value: null },
      tNormal: { type: "t", value: null },
      h: { type: "f", value: 1 / 512 },
      cameraCoef: { type: "v3", value: new XG.Vector3(101, 99, 2) },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform vec3 cameraCoef;",
      "#define CAMERA_FAR_PLUS_NEAR cameraCoef.x",
      "#define CAMERA_FAR_MINUS_NEAR cameraCoef.y",
      "#define CAMERA_NEAR2 cameraCoef.z",
      XG.ShaderChunk.decodingUtils,
      "float linearizeDepth( float d ) {",
      "return CAMERA_NEAR2 / ( CAMERA_FAR_PLUS_NEAR - d * CAMERA_FAR_MINUS_NEAR );",
      "}",
      "float computeWeight( vec4 a, vec4 b ) {",
      "#ifndef FLOAT_DEPTH",
      "vec3 na = decodeNormalOct24( a.xyz );",
      "vec3 nb = decodeNormalOct24( b.xyz );",
      "#else",
      "vec3 na = a.xyz * 2.0 - 1.0;",
      "vec3 nb = b.xyz * 2.0 - 1.0;",
      "#endif",
      "float dotab = max( dot( na, nb ), 0.0 );",
      "float wn = pow( dotab, 32.0 );",
      "float za = linearizeDepth( a.w );",
      "float zb = linearizeDepth( b.w );",
      "float zz = 10.0 * abs( za - zb );",
      "float wz = 1.0 / ( 1.0 + zz );",
      "return wn * wz;",
      "}",
      "uniform sampler2D tDiffuse;",
      "uniform sampler2D tDepth;",
      "uniform float h;",
      "#if defined( RGBA_DEPTH )",
      "float unpackDepth( vec4 rgba ) {",
      "return clamp( dot( rgba, vec4( 1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0 ) ), 0.0, 1.0 );",
      "}",
      "uniform sampler2D tNormal;",
      "#elif defined( TEXTURE_DEPTH )",
      "uniform sampler2D tNormal;",
      "#endif",
      "varying vec2 vUv;",
      "void main() {",
      "vec4 sum = vec4( 0.0 );",
      "vec2 c1 = vec2( vUv.x - 1.0 * h, vUv.y );",
      "vec2 c2 = vec2( vUv.x + 1.0 * h, vUv.y );",
      "vec2 c3 = vec2( vUv.x - 2.0 * h, vUv.y );",
      "vec2 c4 = vec2( vUv.x + 2.0 * h, vUv.y );",
      "#if defined( RGBA_DEPTH )",
      "vec4 normalDepth0 = texture2D( tNormal, vUv );",
      "vec4 normalDepth1 = texture2D( tNormal, c1 );",
      "vec4 normalDepth2 = texture2D( tNormal, c2 );",
      "vec4 normalDepth3 = texture2D( tNormal, c3 );",
      "vec4 normalDepth4 = texture2D( tNormal, c4 );",
      "normalDepth0.w = unpackDepth( texture2D( tDepth, vUv ) );",
      "normalDepth1.w = unpackDepth( texture2D( tDepth, c1 ) );",
      "normalDepth2.w = unpackDepth( texture2D( tDepth, c2 ) );",
      "normalDepth3.w = unpackDepth( texture2D( tDepth, c3 ) );",
      "normalDepth4.w = unpackDepth( texture2D( tDepth, c4 ) );",
      "#elif defined( FLOAT_DEPTH )",
      "vec4 normalDepth0 = texture2D( tDepth, vUv );",
      "vec4 normalDepth1 = texture2D( tDepth, c1 );",
      "vec4 normalDepth2 = texture2D( tDepth, c2 );",
      "vec4 normalDepth3 = texture2D( tDepth, c3 );",
      "vec4 normalDepth4 = texture2D( tDepth, c4 );",
      "#elif defined( TEXTURE_DEPTH )",
      "vec4 normalDepth0 = texture2D( tNormal, vUv );",
      "vec4 normalDepth1 = texture2D( tNormal, c1 );",
      "vec4 normalDepth2 = texture2D( tNormal, c2 );",
      "vec4 normalDepth3 = texture2D( tNormal, c3 );",
      "vec4 normalDepth4 = texture2D( tNormal, c4 );",
      "normalDepth0.w = texture2D( tDepth, vUv ).x * 2.0 - 1.0;",
      "normalDepth1.w = texture2D( tDepth, c1 ).x * 2.0 - 1.0;",
      "normalDepth2.w = texture2D( tDepth, c2 ).x * 2.0 - 1.0;",
      "normalDepth3.w = texture2D( tDepth, c3 ).x * 2.0 - 1.0;",
      "normalDepth4.w = texture2D( tDepth, c4 ).x * 2.0 - 1.0;",
      "#endif",
      "float w0 = 0.1633;",
      "float w1 = computeWeight( normalDepth0, normalDepth1 ) * 0.1531;",
      "float w2 = computeWeight( normalDepth0, normalDepth2 ) * 0.1531;",
      "float w3 = computeWeight( normalDepth0, normalDepth3 ) * 0.12245;",
      "float w4 = computeWeight( normalDepth0, normalDepth4 ) * 0.12245;",
      "float ws = w0 + w1 + w2 + w3 + w4;",
      "vec4 h0 = texture2D( tDiffuse, vUv );",
      "vec4 h1 = texture2D( tDiffuse, c1 );",
      "vec4 h2 = texture2D( tDiffuse, c2 );",
      "vec4 h3 = texture2D( tDiffuse, c3 );",
      "vec4 h4 = texture2D( tDiffuse, c4 );",
      "sum += h3 * w3;",
      "sum += h1 * w1;",
      "sum += h0 * w0;",
      "sum += h2 * w2;",
      "sum += h4 * w4;",
      "sum /= ws;",
      "mgl_FragColor = sum;",
      "}",
    ].join("\n"),
  }),
  (XG.SSAOBilateralVerticalBlurShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      tDepth: { type: "t", value: null },
      tNormal: { type: "t", value: null },
      v: { type: "f", value: 1 / 512 },
      cameraCoef: { type: "v3", value: new XG.Vector3(101, 99, 2) },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform vec3 cameraCoef;",
      "#define CAMERA_FAR_PLUS_NEAR cameraCoef.x",
      "#define CAMERA_FAR_MINUS_NEAR cameraCoef.y",
      "#define CAMERA_NEAR2 cameraCoef.z",
      XG.ShaderChunk.decodingUtils,
      "float linearizeDepth( float d ) {",
      "return CAMERA_NEAR2 / ( CAMERA_FAR_PLUS_NEAR - d * CAMERA_FAR_MINUS_NEAR );",
      "}",
      "float computeWeight( vec4 a, vec4 b ) {",
      "#ifndef FLOAT_DEPTH",
      "vec3 na = decodeNormalOct24( a.xyz );",
      "vec3 nb = decodeNormalOct24( b.xyz );",
      "#else",
      "vec3 na = a.xyz * 2.0 - 1.0;",
      "vec3 nb = b.xyz * 2.0 - 1.0;",
      "#endif",
      "float dotab = max( dot( na, nb ), 0.0 );",
      "float wn = pow( dotab, 32.0 );",
      "float za = linearizeDepth( a.w );",
      "float zb = linearizeDepth( b.w );",
      "float zz = 10.0 * abs( za - zb );",
      "float wz = 1.0 / ( 1.0 + zz );",
      "return wn * wz;",
      "}",
      "uniform sampler2D tDiffuse;",
      "uniform sampler2D tDepth;",
      "uniform float v;",
      "#if defined( RGBA_DEPTH )",
      "float unpackDepth( vec4 rgba ) {",
      "return clamp( dot( rgba, vec4( 1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0 ) ), 0.0, 1.0 );",
      "}",
      "uniform sampler2D tNormal;",
      "#elif defined( TEXTURE_DEPTH )",
      "uniform sampler2D tNormal;",
      "#endif",
      "varying vec2 vUv;",
      "void main() {",
      "vec4 sum = vec4( 0.0 );",
      "vec2 c1 = vec2( vUv.x, vUv.y - 1.0 * v );",
      "vec2 c2 = vec2( vUv.x, vUv.y + 1.0 * v );",
      "#if defined( RGBA_DEPTH )",
      "vec4 normalDepth0 = texture2D( tNormal, vUv );",
      "vec4 normalDepth1 = texture2D( tNormal, c1 );",
      "vec4 normalDepth2 = texture2D( tNormal, c2 );",
      "normalDepth0.w = unpackDepth( texture2D( tDepth, vUv ) );",
      "normalDepth1.w = unpackDepth( texture2D( tDepth, c1 ) );",
      "normalDepth2.w = unpackDepth( texture2D( tDepth, c2 ) );",
      "#elif defined( FLOAT_DEPTH )",
      "vec4 normalDepth0 = texture2D( tDepth, vUv );",
      "vec4 normalDepth1 = texture2D( tDepth, c1 );",
      "vec4 normalDepth2 = texture2D( tDepth, c2 );",
      "#elif defined( TEXTURE_DEPTH )",
      "vec4 normalDepth0 = texture2D( tNormal, vUv );",
      "vec4 normalDepth1 = texture2D( tNormal, c1 );",
      "vec4 normalDepth2 = texture2D( tNormal, c2 );",
      "normalDepth0.w = texture2D( tDepth, vUv ).x * 2.0 - 1.0;",
      "normalDepth1.w = texture2D( tDepth, c1 ).x * 2.0 - 1.0;",
      "normalDepth2.w = texture2D( tDepth, c2 ).x * 2.0 - 1.0;",
      "#endif",
      "float w0 = 0.1633;",
      "float w1 = computeWeight( normalDepth0, normalDepth1 ) * 0.1531;",
      "float w2 = computeWeight( normalDepth0, normalDepth2 ) * 0.1531;",
      "float ws = w0 + w1 + w2;",
      "vec4 h0 = texture2D( tDiffuse, vUv );",
      "vec4 h1 = texture2D( tDiffuse, c1 );",
      "vec4 h2 = texture2D( tDiffuse, c2 );",
      "sum += h1 * w1;",
      "sum += h0 * w0;",
      "sum += h2 * w2;",
      "sum /= ws;",
      "mgl_FragColor = sum;",
      "}",
    ].join("\n"),
  }),
  (XG.BloomHorizontalBlurShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      h: { type: "f", value: 1 / 512 },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      "uniform float h;",
      "varying vec2 vUv;",
      "void main() {",
      "vec3 sum = vec3( 0.0 );",
      "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ).xyz * 0.051;",
      "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ).xyz * 0.0918;",
      "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ).xyz * 0.12245;",
      "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ).xyz * 0.1531;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ).xyz * 0.1633;",
      "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ).xyz * 0.1531;",
      "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ).xyz * 0.12245;",
      "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ).xyz * 0.0918;",
      "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ).xyz * 0.051;",
      "mgl_FragColor.rgb = sum;",
      "mgl_FragColor.a = 1.0;",
      "}",
    ].join("\n"),
  }),
  (XG.BloomVerticalBlurShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      v: { type: "f", value: 1 / 512 },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      "uniform float v;",
      "varying vec2 vUv;",
      "void main() {",
      "vec3 sum = vec3( 0.0 );",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ).xyz * 0.051;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ).xyz * 0.0918;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ).xyz * 0.12245;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ).xyz * 0.1531;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ).xyz * 0.1633;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ).xyz * 0.1531;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ).xyz * 0.12245;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ).xyz * 0.0918;",
      "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ).xyz * 0.051;",
      "mgl_FragColor.rgb = sum;",
      "mgl_FragColor.a = 1.0;",
      "}",
    ].join("\n"),
  }),
  (XG.BloomFilterShader = {
    uniforms: {
      tSource: { type: "t", value: null },
      threshold: { type: "f", value: 1 },
      brightness: { type: "f", value: 1 },
      whitePoint: { type: "f", value: 1 },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform sampler2D tSource;",
      "uniform float threshold;",
      XG.ShaderChunk.tonemappingFragmentPars,
      "varying vec2 vUv;",
      "void main() {",
      "vec3 color = texture2D( tSource, vUv ).rgb;",
      "const vec3 luma = vec3( 0.299, 0.587, 0.114 );",
      "float v = dot( color, luma );",
      "vec3 outColor = vec3( 0.0 );",
      "if ( v > threshold ) {",
      "outColor = applyTonemapping( color, brightness, whitePoint );",
      "}",
      "mgl_FragColor = vec4( outColor, 1.0 );",
      "}",
    ].join("\n"),
  }),
  (XG.IBLDiffuseConvolutionShader = {
    uniforms: { tCube: { type: "t", value: null } },
    vertexShader: [
      "varying vec3 vWorldNormal;",
      "void main() {",
      "vec4 worldNormal = modelMatrix * vec4( normal, 0.0 );",
      "vWorldNormal = worldNormal.xyz;",
      "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
      "gl_Position = projectionMatrix * mvPosition;",
      "}",
    ].join("\n"),
    fragmentShader: [
      "uniform samplerCube tCube;",
      "varying vec3 vWorldNormal;",
      "const int zSamples = 30;",
      "const int tSamples = 2 * zSamples;",
      "const float zFract = 1.0 / float( zSamples );",
      "const float tFract = 3.14159265 * zFract;",
      "const float normFract = 4.0 * 3.14159265 / float( ( tSamples + 1 ) * ( tSamples ) );",
      "void main() {",
      "vec3 surfaceNormal = normalize( vWorldNormal );",
      "vec3 total = vec3( 0.0 );",
      "for ( int z = -zSamples; z <= zSamples; z ++ ) {",
      "for ( int t = 0; t < tSamples; t ++ ) {",
      "float fz = float( z ) * zFract;",
      "float ft = float( t ) * tFract;",
      "float r = sqrt( 1.0 - fz * fz );",
      "float x = r * cos( ft );",
      "float y = r * sin( ft );",
      "vec3 sampleNormal = vec3( x, y, fz );",
      "float dotProduct = max( dot( surfaceNormal, sampleNormal ), 0.0 );",
      "vec4 pixel = textureCube( tCube, sampleNormal );",
      "total += pixel.rgb * dotProduct;",
      "}",
      "}",
      "mgl_FragColor.rgb = total * normFract;",
      "mgl_FragColor.a = 1.0;",
      "}",
    ].join("\n"),
  }),
  (XG.IBLDiffuseProbeShader = {
    uniforms: { tCube: { type: "t", value: null } },
    vertexShader: [
      "varying vec3 vWorldNormal;",
      "void main() {",
      "vec4 worldNormal = modelMatrix * vec4( normal, 0.0 );",
      "vWorldNormal = worldNormal.xyz;",
      "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
      "gl_Position = projectionMatrix * mvPosition;",
      "}",
    ].join("\n"),
    fragmentShader: [
      "uniform samplerCube tCube;",
      "varying vec3 vWorldNormal;",
      "void main() {",
      "vec3 surfaceNormal = normalize( vWorldNormal );",
      "mgl_FragColor = textureCube( tCube, surfaceNormal );",
      "mgl_FragColor.rgb *= mgl_FragColor.rgb;",
      "mgl_FragColor.a = 1.0;",
      "}",
    ].join("\n"),
  }),
  (XG.DOFBlurPass1Shader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      tBlurAmount: { type: "t", value: null },
      resolution: { type: "v2", value: new XG.Vector2(1024, 512) },
      samplePoints1: {
        type: "fv2",
        value: XG.Math.generateConcentricCircleSamples(7, 6),
      },
      samplePoints2: {
        type: "fv2",
        value: XG.Math.generateConcentricCircleSamples(3, 6),
      },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "#define PREBAKED_SAMPLES",
      "#define NUM_PREBAKED_SAMPLES1 49",
      "#define NUM_PREBAKED_SAMPLES2 9",
      "#define DL 2.399963229728653",
      "#define PI 3.141592653589793",
      "#define PI4 0.7853981633974483",
      "uniform sampler2D tDiffuse;",
      "uniform sampler2D tBlurAmount;",
      "uniform vec2 resolution;",
      "uniform vec2 samplePoints1[ NUM_PREBAKED_SAMPLES1 ];",
      "uniform vec2 samplePoints2[ NUM_PREBAKED_SAMPLES2 ];",
      "varying vec2 vUv;",
      "#if defined( RGBA_DEPTH )",
      "float unpackDepth( vec4 rgba ) {",
      "return clamp( dot( rgba, vec4( 1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0 ) ), 0.0, 1.0 );",
      "}",
      "#endif",
      "#ifdef CONCENTRIC_CIRCLE_SAMPLE",
      "vec2 mapSquareToDisk( float a, float b ) {",
      "float r;",
      "float fi;",
      "if ( a > -b ) {",
      "if ( a > b ) {",
      "r = a;",
      "fi = PI4 * ( b/a );",
      "} else {",
      "r = b;",
      "fi = PI4 * ( 2.0 - a/b );",
      "}",
      "} else {",
      "if ( a < b ) {",
      "r = -a;",
      "fi = PI4 * ( 4.0 + b/a );",
      "} else {",
      "r = -b;",
      "if ( b != 0.0 ) {",
      "fi = PI4 * ( 6.0 - a/b );",
      "} else {",
      "fi = 0.0;",
      "}",
      "}",
      "}",
      "float u = r * cos( fi );",
      "float v = r * sin( fi );",
      "return vec2( u, v );",
      "}",
      "#endif",
      "void main() {",
      "float centerBias = texture2D( tBlurAmount, vUv ).a;",
      "vec4 mixed = vec4( 0.0 );",
      "vec2 pixelRatio = centerBias * 16.0 / resolution;",
      "#if defined( PREBAKED_SAMPLES )",
      "for ( int i = 0; i < NUM_PREBAKED_SAMPLES1; i ++ ) {",
      "vec4 sampleColor = texture2D( tBlurAmount, vUv + samplePoints1[ i ] * pixelRatio );",
      "mixed += sampleColor;",
      "}",
      "#elif defined( CONCENTRIC_CIRCLE_SAMPLES )",
      "const int samples = 3;",
      "for ( int i = -samples; i <= samples; i ++ ) {",
      "for ( int j = -samples; j <= samples; j ++ ) {",
      "float a = float( j ) / 3.0;",
      "float b = float( i ) / 3.0;",
      "vec2 offset = mapSquareToDisk( a, b );",
      "vec4 sampleColor = texture2D( tBlurAmount, vUv + ( offset * pixelRatio ) );",
      "mixed += sampleColor;",
      "}",
      "}",
      "#else",
      "const int samples = 16;",
      "float dz = 1.0 / float( samples );",
      "float z = 1.0 - dz / 2.0;",
      "float l = 0.0;",
      "for ( int i = 0; i <= samples; i ++ ) {",
      "float r = sqrt( 1.0 - z );",
      "float dx = cos( l );",
      "float dy = sin( l );",
      "vec4 sampleColor = texture2D( tBlurAmount, vUv + ( vec2( dx, dy ) * pixelRatio ) * r );",
      "mixed += sampleColor;",
      "z = z - dz;",
      "l = l + DL;",
      "}",
      "#endif",
      "mixed.rgb /= mixed.a;",
      "mixed.a /= float( NUM_PREBAKED_SAMPLES1 );",
      "mixed.rgb *= mixed.a;",
      "if ( mixed.a == 0.0 ) mixed.rgb = texture2D( tDiffuse, vUv ).rgb;",
      "mgl_FragColor = vec4( mixed.rgb, mixed.a );",
      "}",
    ].join("\n"),
  }),
  (XG.DOFBlurPass2Shader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      tBlurAmount: { type: "t", value: null },
      resolution: { type: "v2", value: new XG.Vector2(1024, 512) },
      samplePoints: {
        type: "fv2",
        value: XG.Math.generateConcentricCircleSamples(3, 6),
      },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "#define PREBAKED_SAMPLES",
      "#define NUM_PREBAKED_SAMPLES 9",
      "#define DL 2.399963229728653",
      "#define PI 3.141592653589793",
      "#define PI4 0.7853981633974483",
      "uniform sampler2D tDiffuse;",
      "uniform sampler2D tBlurAmount;",
      "uniform vec2 resolution;",
      "uniform vec2 samplePoints[ NUM_PREBAKED_SAMPLES ];",
      "varying vec2 vUv;",
      "#if defined( RGBA_DEPTH )",
      "float unpackDepth( vec4 rgba ) {",
      "return clamp( dot( rgba, vec4( 1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0 ) ), 0.0, 1.0 );",
      "}",
      "#endif",
      "#ifdef CONCENTRIC_CIRCLE_SAMPLE",
      "vec2 mapSquareToDisk( float a, float b ) {",
      "float r;",
      "float fi;",
      "if ( a > -b ) {",
      "if ( a > b ) {",
      "r = a;",
      "fi = PI4 * ( b/a );",
      "} else {",
      "r = b;",
      "fi = PI4 * ( 2.0 - a/b );",
      "}",
      "} else {",
      "if ( a < b ) {",
      "r = -a;",
      "fi = PI4 * ( 4.0 + b/a );",
      "} else {",
      "r = -b;",
      "if ( b != 0.0 ) {",
      "fi = PI4 * ( 6.0 - a/b );",
      "} else {",
      "fi = 0.0;",
      "}",
      "}",
      "}",
      "float u = r * cos( fi );",
      "float v = r * sin( fi );",
      "return vec2( u, v );",
      "}",
      "#endif",
      "void main() {",
      "float centerBias = texture2D( tDiffuse, vUv ).a;",
      "vec4 mixed = vec4( 0.0 );",
      "vec2 pixelRatio = centerBias * 3.0 / resolution;",
      "#if defined( PREBAKED_SAMPLES )",
      "for ( int i = 0; i < NUM_PREBAKED_SAMPLES; i ++ ) {",
      "vec4 sampleColor = texture2D( tDiffuse, vUv + samplePoints[ i ] * pixelRatio );",
      "mixed += sampleColor;",
      "}",
      "#elif defined( CONCENTRIC_CIRCLE_SAMPLES )",
      "const int samples = 3;",
      "for ( int i = -samples; i <= samples; i ++ ) {",
      "for ( int j = -samples; j <= samples; j ++ ) {",
      "float a = float( j ) / 3.0;",
      "float b = float( i ) / 3.0;",
      "vec2 offset = mapSquareToDisk( a, b );",
      "vec4 sampleColor = texture2D( tBlurAmount, vUv + ( offset * pixelRatio ) );",
      "mixed += sampleColor;",
      "}",
      "}",
      "#else",
      "const int samples = 16;",
      "float dz = 1.0 / float( samples );",
      "float z = 1.0 - dz / 2.0;",
      "float l = 0.0;",
      "for ( int i = 0; i <= samples; i ++ ) {",
      "float r = sqrt( 1.0 - z );",
      "float dx = cos( l );",
      "float dy = sin( l );",
      "vec4 sampleColor = texture2D( tBlurAmount, vUv + ( vec2( dx, dy ) * pixelRatio ) * r );",
      "mixed += sampleColor;",
      "z = z - dz;",
      "l = l + DL;",
      "}",
      "#endif",
      "mixed.rgb /= mixed.a;",
      "if ( mixed.a == 0.0 ) mixed.rgb = texture2D( tDiffuse, vUv ).rgb;",
      "mgl_FragColor = vec4( mixed.rgb, 1.0 );",
      "}",
    ].join("\n"),
  }),
  (XG.DOFShaderChunk = {
    computeBlurPars: [
      "#ifdef DOF_PHYSICAL",
      "uniform float lensAperture;",
      "uniform float lensFocalLength;",
      "uniform float lensBlurScale;",
      "uniform float lensMaxCoc;",
      "float computeBlurStrength( float pointDepth, float focalDepth ) {",
      "float coc = abs( lensAperture * ( ( lensFocalLength * ( focalDepth - pointDepth ) ) / ( pointDepth * ( focalDepth - lensFocalLength ) ) ) );",
      "return min( coc, lensMaxCoc );",
      "}",
      "#else",
      "uniform float focusRampStart;",
      "uniform float focusRampEnd;",
      "uniform float maxBlur;",
      "const float maxBias = 8.0;",
      "float computeBlurBias( float pointDepth, float focalDepth ) {",
      "float blurFactor = abs( focalDepth - pointDepth );",
      "blurFactor *= smoothstep( focusRampStart, focusRampEnd, blurFactor );",
      "float blurBias = maxBlur * blurFactor;",
      "blurBias = min( blurBias, maxBias );",
      "return blurBias;",
      "}",
      "#endif",
    ].join("\n"),
  }),
  (XG.DOFBlurAmountShader = {
    defines: { DOF_PHYSICAL: !0 },
    uniforms: XG.UniformsUtils.merge([
      XG.UniformsLib.fogAtmo,
      {
        tDepth: { type: "t", value: null },
        tDistance: { type: "t", value: null },
        tDiffuse: { type: "t", value: null },
        resolution: { type: "v2", value: new XG.Vector2(1920, 1080) },
        autoFocus: { type: "i", value: 1 },
        autoFocusPoint: { type: "v2", value: new XG.Vector2(0.5, 0.5) },
        focusDistance: { type: "f", value: 5 },
        focusRampStart: { type: "f", value: 2 },
        focusRampEnd: { type: "f", value: 8 },
        maxBlur: { type: "f", value: 1 },
        lensFocalLength: { type: "f", value: 50 },
        lensAperture: { type: "f", value: 12.5 },
        lensBlurScale: { type: "f", value: 50 },
        lensMaxCoc: { type: "f", value: 1 },
        cameraNearFar: { type: "v2", value: new XG.Vector2(1, 1e3) },
      },
    ]),
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      XG.DOFShaderChunk.computeBlurPars,
      "uniform bool autoFocus;",
      "uniform vec2 autoFocusPoint;",
      "uniform float focusDistance;",
      "uniform vec2 cameraNearFar;",
      "uniform sampler2D tDepth;",
      "uniform sampler2D tDistance;",
      "uniform sampler2D tDiffuse;",
      "uniform vec2 resolution;",
      "varying vec2 vUv;",
      "#if defined( RGBA_DEPTH )",
      "float unpackDepth( vec4 rgba ) {",
      "return clamp( dot( rgba, vec4( 1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0 ) ), 0.0, 1.0 );",
      "}",
      "float texture2D_bicubic_packed( sampler2D texSampler, vec2 uv, vec2 textureDimensions ) {",
      "vec2 invTextureDimensions = 1.0 / textureDimensions;",
      "uv *= textureDimensions;",
      "vec2 texelCenter   = floor( uv - 0.5 ) + 0.5;",
      "vec2 fracOffset    = uv - texelCenter;",
      "vec2 fracOffset_x2 = fracOffset * fracOffset;",
      "vec2 fracOffset_x3 = fracOffset * fracOffset_x2;",
      "vec2 weight0 = fracOffset_x2 - 0.5 * ( fracOffset_x3 + fracOffset );",
      "vec2 weight1 = 1.5 * fracOffset_x3 - 2.5 * fracOffset_x2 + 1.0;",
      "vec2 weight3 = 0.5 * ( fracOffset_x3 - fracOffset_x2 );",
      "vec2 weight2 = 1.0 - weight0 - weight1 - weight3;",
      "vec2 scalingFactor0 = weight0 + weight1;",
      "vec2 scalingFactor1 = weight2 + weight3;",
      "vec2 f0 = weight1 / ( weight0 + weight1 );",
      "vec2 f1 = weight3 / ( weight2 + weight3 );",
      "vec2 texCoord0 = texelCenter - 1.0 + f0;",
      "vec2 texCoord1 = texelCenter + 1.0 + f1;",
      "texCoord0 *= invTextureDimensions;",
      "texCoord1 *= invTextureDimensions;",
      "return unpackDepth(texture2D( texSampler, vec2( texCoord0.x, texCoord0.y ) )) * scalingFactor0.x * scalingFactor0.y +",
      "unpackDepth(texture2D( texSampler, vec2( texCoord1.x, texCoord0.y ) )) * scalingFactor1.x * scalingFactor0.y +",
      "unpackDepth(texture2D( texSampler, vec2( texCoord0.x, texCoord1.y ) )) * scalingFactor0.x * scalingFactor1.y +",
      "unpackDepth(texture2D( texSampler, vec2( texCoord1.x, texCoord1.y ) )) * scalingFactor1.x * scalingFactor1.y;",
      "}",
      "#endif",
      "vec4 texture2D_bicubic( sampler2D texSampler, vec2 uv, vec2 textureDimensions ) {",
      "vec2 invTextureDimensions = 1.0 / textureDimensions;",
      "uv *= textureDimensions;",
      "vec2 texelCenter   = floor( uv - 0.5 ) + 0.5;",
      "vec2 fracOffset    = uv - texelCenter;",
      "vec2 fracOffset_x2 = fracOffset * fracOffset;",
      "vec2 fracOffset_x3 = fracOffset * fracOffset_x2;",
      "vec2 weight0 = fracOffset_x2 - 0.5 * ( fracOffset_x3 + fracOffset );",
      "vec2 weight1 = 1.5 * fracOffset_x3 - 2.5 * fracOffset_x2 + 1.0;",
      "vec2 weight3 = 0.5 * ( fracOffset_x3 - fracOffset_x2 );",
      "vec2 weight2 = 1.0 - weight0 - weight1 - weight3;",
      "vec2 scalingFactor0 = weight0 + weight1;",
      "vec2 scalingFactor1 = weight2 + weight3;",
      "vec2 f0 = weight1 / ( weight0 + weight1 );",
      "vec2 f1 = weight3 / ( weight2 + weight3 );",
      "vec2 texCoord0 = texelCenter - 1.0 + f0;",
      "vec2 texCoord1 = texelCenter + 1.0 + f1;",
      "texCoord0 *= invTextureDimensions;",
      "texCoord1 *= invTextureDimensions;",
      "return texture2D( texSampler, vec2( texCoord0.x, texCoord0.y ) ) * scalingFactor0.x * scalingFactor0.y +",
      "texture2D( texSampler, vec2( texCoord1.x, texCoord0.y ) ) * scalingFactor1.x * scalingFactor0.y +",
      "texture2D( texSampler, vec2( texCoord0.x, texCoord1.y ) ) * scalingFactor0.x * scalingFactor1.y +",
      "texture2D( texSampler, vec2( texCoord1.x, texCoord1.y ) ) * scalingFactor1.x * scalingFactor1.y;",
      "}",
      XG.ShaderChunk.fogAtmoFragmentPars,
      XG.ShaderChunk.linearDepthFragmentPars,
      "void main() {",
      "#if defined( RGBA_DEPTH )",
      "float depth = texture2D_bicubic_packed( tDepth, vUv, resolution );",
      "#elif defined( FLOAT_DEPTH )",
      "float depth = texture2D_bicubic( tDepth, vUv, resolution ).w;",
      "#elif defined( TEXTURE_DEPTH )",
      "float depth = texture2D( tDepth, vUv ).x * 2.0 - 1.0;",
      "#endif",
      "depth = linearizeDepth( depth, cameraNearFar );",
      "float zFocusDistance;",
      "if ( autoFocus ) {",
      "zFocusDistance = texture2D( tDistance, autoFocusPoint ).x;",
      "} else {",
      "zFocusDistance = focusDistance;",
      "}",
      "#ifdef DOF_PHYSICAL",
      "float blurAmount = computeBlurStrength( lensBlurScale * depth, lensBlurScale * zFocusDistance );",
      "#else",
      "float blurAmount = computeBlurBias( depth, zFocusDistance );",
      "#endif",
      "vec3 color = texture2D_bicubic( tDiffuse, vUv, resolution ).rgb;",
      "#ifdef FOG_ENABLED",
      "color = addFog( color, depth );",
      "#endif",
      "mgl_FragColor = vec4( color * blurAmount, blurAmount );",
      "}",
    ].join("\n"),
  }),
  (XG.DepthOfFieldShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      tDepth: { type: "t", value: null },
      tBlur: { type: "t", value: null },
      tDistance: { type: "t", value: null },
      focusDistance: { type: "f", value: 5 },
      focusRampStart: { type: "f", value: 2 },
      focusRampEnd: { type: "f", value: 8 },
      cameraNearFar: { type: "v2", value: new XG.Vector2(1, 1e3) },
      maxBlur: { type: "f", value: 1 },
      blurSize: { type: "v2", value: new XG.Vector2(1024, 512) },
      autoFocus: { type: "i", value: 1 },
      autoFocusPoint: { type: "v2", value: new XG.Vector2(0.5, 0.5) },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform bool autoFocus;",
      "uniform vec2 autoFocusPoint;",
      "uniform float focusDistance;",
      "uniform float focusRampStart;",
      "uniform float focusRampEnd;",
      "uniform vec2 cameraNearFar;",
      "uniform float maxBlur;",
      "uniform vec2 blurSize;",
      "uniform sampler2D tDiffuse;",
      "uniform sampler2D tBlur;",
      "uniform sampler2D tDepth;",
      "uniform sampler2D tDistance;",
      "varying vec2 vUv;",
      "const float maxBias = 3.0;",
      XG.ShaderChunk.linearDepthFragmentPars,
      "#if defined( RGBA_DEPTH )",
      "float unpackDepth( vec4 rgba ) {",
      "return clamp( dot( rgba, vec4( 1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0 ) ), 0.0, 1.0 );",
      "}",
      "#endif",
      "void main() {",
      "#if defined( RGBA_DEPTH )",
      "vec4 packedDepth = texture2D( tDepth, vUv );",
      "float depth = unpackDepth( packedDepth );",
      "#elif defined( FLOAT_DEPTH )",
      "float depth = texture2D( tDepth, vUv ).w;",
      "#elif defined( TEXTURE_DEPTH )",
      "float depth = texture2D( tDepth, vUv ).x * 2.0 - 1.0;",
      "#endif",
      "depth = linearizeDepth( depth, cameraNearFar );",
      "float zFocusDistance;",
      "if ( autoFocus ) {",
      "zFocusDistance = texture2D( tDistance, autoFocusPoint ).x;",
      "} else {",
      "zFocusDistance = focusDistance;",
      "}",
      "float blurFactor = abs( zFocusDistance - depth );",
      "#ifdef DOF_DEBUG",
      "vec4 debugColor = vec4( 1.0 );",
      "if ( blurFactor < 0.1 ) {",
      "debugColor = vec4( 1.0, 0.0, 0.0, 1.0 );",
      "}",
      "if ( autoFocus && any( lessThan( abs( vUv - autoFocusPoint ), 0.001 * vec2( 1.0, 2.0 ) ) ) ) {",
      "debugColor *= vec4( 0.0, 0.0, 0.0, 1.0 );",
      "}",
      "#endif",
      "blurFactor *= smoothstep( focusRampStart, focusRampEnd, blurFactor );",
      "float bias = maxBlur * blurFactor;",
      "bias = min( bias, maxBias );",
      "float blurStep = 10.0 * maxBlur;",
      "float dx = blurStep / blurSize.x;",
      "float dy = blurStep / blurSize.y;",
      "vec4 blur0 = texture2D( tBlur, vUv, bias );",
      "vec4 blur1 = texture2D( tBlur, vUv + vec2( -dx, -dy ), bias );",
      "vec4 blur2 = texture2D( tBlur, vUv + vec2(  dx,  dy ), bias );",
      "vec4 blur3 = texture2D( tBlur, vUv + vec2( -dx,  dy ), bias  );",
      "vec4 blur4 = texture2D( tBlur, vUv + vec2(  dx, -dy ), bias  );",
      "vec4 blur = ( blur0 + blur1 + blur2 + blur3 + blur4 ) * 0.2;",
      "vec4 sharp = texture2D( tDiffuse, vUv );",
      "vec4 mixed = mix( sharp, blur, min( bias, 1.0 ) );",
      "mgl_FragColor = mixed;",
      "mgl_FragColor.a = 1.0;",
      "#ifdef DOF_DEBUG",
      "mgl_FragColor *= debugColor;",
      "#endif",
      "}",
    ].join("\n"),
  }),
  (XG.DistanceShader = {
    uniforms: {
      tDepth: { type: "t", value: null },
      tDistance: { type: "t", value: null },
      cameraNearFar: { type: "v2", value: new XG.Vector2(1, 1e3) },
      persistence: { type: "f", value: 0.75 },
      samplePoint: { type: "v2", value: new XG.Vector2(0.5, 0.5) },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform vec2 cameraNearFar;",
      "uniform float persistence;",
      "uniform vec2 samplePoint;",
      "uniform sampler2D tDepth;",
      "uniform sampler2D tDistance;",
      "varying vec2 vUv;",
      XG.ShaderChunk.linearDepthFragmentPars,
      "#if defined( RGBA_DEPTH )",
      "float unpackDepth( vec4 rgba ) {",
      "return clamp( dot( rgba, vec4( 1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0 ) ), 0.0, 1.0 );",
      "}",
      "#endif",
      "void main() {",
      "#if defined( RGBA_DEPTH )",
      "vec4 packedDepth = texture2D( tDepth, samplePoint );",
      "float depth = unpackDepth( packedDepth );",
      "#elif defined( FLOAT_DEPTH )",
      "float depth = texture2D( tDepth, samplePoint ).w;",
      "#elif defined( TEXTURE_DEPTH )",
      "float depth = texture2D( tDepth, samplePoint ).x * 2.0 - 1.0;",
      "#endif",
      "depth = linearizeDepth( depth, cameraNearFar );",
      "float oldDepth = texture2D( tDistance, samplePoint ).x;",
      "depth = mix( depth, oldDepth, persistence );",
      "mgl_FragColor = vec4( depth );",
      "mgl_FragColor.a = 1.0;",
      "}",
    ].join("\n"),
  }),
  (XG.ChromaticAberrationShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      amount: { type: "f", value: 0.005 },
      angle: { type: "f", value: 0 },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      "uniform float amount;",
      "uniform float angle;",
      "varying vec2 vUv;",
      "void main() {",
      "vec2 offset = amount * ( length( vUv - 0.5 ) + 0.01 ) * vec2( cos( angle ), sin( angle ) );",
      "vec4 cr = texture2D( tDiffuse, vUv + offset );",
      "vec4 cga = texture2D( tDiffuse, vUv );",
      "vec4 cb = texture2D( tDiffuse, vUv - offset );",
      "mgl_FragColor = vec4( cr.r, cga.g, cb.b, cga.a );",
      "}",
    ].join("\n"),
  }),
  (XG.CLUTShader = {
    defines: { LINEAR_FILTER: 1 },
    uniforms: {
      tDiffuse: { type: "t", value: null },
      tCLUT: { type: "t", value: null },
      cubeSize: { type: "f", value: 64 },
      texSize: { type: "f", value: 512 },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      "uniform sampler2D tCLUT;",
      "uniform float cubeSize;",
      "uniform float texSize;",
      "varying vec2 vUv;",
      "#ifdef LINEAR_FILTER",
      "vec4 subsample( sampler2D tex, float pixelR, float pixelG, float pixelB, float size, float nPixels ) {",
      "float linearPixelIndex = pixelB * size * size + pixelG * size + pixelR;",
      "float xPixelIndex = mod( linearPixelIndex, nPixels );",
      "float yPixelIndex = floor( linearPixelIndex / nPixels );",
      "vec4 outColor = texture2D( tex, vec2( xPixelIndex, yPixelIndex ) / nPixels );",
      "return outColor;",
      "}",
      "vec4 sampleAs3DTextureLinear( sampler2D tex, vec3 texCoord, float size, float nPixels ) {",
      "float n = size - 1.0;",
      "vec3 pixel = texCoord.rgb * n;",
      "vec3 pixelMin = floor( pixel );",
      "vec3 pixelMax = ceil( pixel );",
      "vec4 RminGminBmin = subsample( tex, pixelMin.r, pixelMin.g, pixelMin.b, size, nPixels );",
      "vec4 RminGminBmax = subsample( tex, pixelMin.r, pixelMin.g, pixelMax.b, size, nPixels );",
      "vec4 RminGmaxBmin = subsample( tex, pixelMin.r, pixelMax.g, pixelMin.b, size, nPixels );",
      "vec4 RminGmaxBmax = subsample( tex, pixelMin.r, pixelMax.g, pixelMax.b, size, nPixels );",
      "vec4 RmaxGminBmin = subsample( tex, pixelMax.r, pixelMin.g, pixelMin.b, size, nPixels );",
      "vec4 RmaxGminBmax = subsample( tex, pixelMax.r, pixelMin.g, pixelMax.b, size, nPixels );",
      "vec4 RmaxGmaxBmin = subsample( tex, pixelMax.r, pixelMax.g, pixelMin.b, size, nPixels );",
      "vec4 RmaxGmaxBmax = subsample( tex, pixelMax.r, pixelMax.g, pixelMax.b, size, nPixels );",
      "vec3 t = pixel - pixelMin;",
      "RminGminBmin = mix( RminGminBmin, RminGminBmax, t.b );",
      "RminGmaxBmin = mix( RminGmaxBmin, RminGmaxBmax, t.b );",
      "RmaxGminBmin = mix( RmaxGminBmin, RmaxGminBmax, t.b );",
      "RmaxGmaxBmin = mix( RmaxGmaxBmin, RmaxGmaxBmax, t.b );",
      "RminGminBmin = mix( RminGminBmin, RminGmaxBmin, t.g );",
      "RmaxGminBmin = mix( RmaxGminBmin, RmaxGmaxBmin, t.g );",
      "RminGminBmin = mix( RminGminBmin, RmaxGminBmin, t.r );",
      "return RminGminBmin;",
      "}",
      "#else",
      "vec4 sampleAs3DTextureNearest( sampler2D tex, vec3 texCoord, float size, float nPixels ) {",
      "float n = size - 1.0;",
      "vec3 pixel = floor( texCoord.rgb * n );",
      "float linearPixelIndex = pixel.b * size * size + pixel.g * size + pixel.r;",
      "float xPixelIndex = mod( linearPixelIndex, nPixels );",
      "float yPixelIndex = floor( linearPixelIndex / nPixels );",
      "vec4 outColor = texture2D( tex, vec2( xPixelIndex, yPixelIndex ) / nPixels );",
      "return outColor;",
      "}",
      "#endif",
      "void main() {",
      "vec4 srcColor = texture2D( tDiffuse, vUv );",
      "#ifdef LINEAR_FILTER",
      "vec4 dstColor = sampleAs3DTextureLinear( tCLUT, srcColor.rgb, cubeSize, texSize );",
      "#else",
      "vec4 dstColor = sampleAs3DTextureNearest( tCLUT, srcColor.rgb, cubeSize, texSize );",
      "#endif",
      "mgl_FragColor = vec4( dstColor.rgb, srcColor.a );",
      "}",
    ].join("\n"),
  }),
  (XG.CLUT3DShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      tCLUT: { type: "t3", value: null },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      "uniform sampler3D tCLUT;",
      "varying vec2 vUv;",
      "void main() {",
      "vec4 srcColor = texture2D( tDiffuse, vUv );",
      "vec4 dstColor = texture( tCLUT, srcColor.rgb );",
      "mgl_FragColor = vec4( dstColor.rgb, srcColor.a );",
      "}",
    ].join("\n"),
  }),
  (XG.SharpenShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      resolution: { type: "v2", value: new XG.Vector2(1920, 1080) },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform vec2 resolution;",
      "uniform sampler2D tDiffuse;",
      "varying vec2 vUv;",
      "void main() {",
      "vec2 r = 1.5 / resolution.xy;",
      "vec3 sampleA = texture2D( tDiffuse, vUv + r ).rgb;",
      "vec3 sampleB = texture2D( tDiffuse, vUv - r ).rgb;",
      "vec3 sampleC = texture2D( tDiffuse, vUv + vec2(  r.x, -r.y ) ).rgb;",
      "vec3 sampleD = texture2D( tDiffuse, vUv + vec2( -r.x,  r.y ) ).rgb;",
      "vec3 avgNeighbors = 0.25 * ( sampleA + sampleB + sampleC + sampleD );",
      "vec3 sampleCenter = texture2D( tDiffuse, vUv ).rgb;",
      "vec3 colorSharp = 2.0 * sampleCenter - avgNeighbors;",
      "mgl_FragColor = vec4( colorSharp, 1.0 );",
      "}",
    ].join("\n"),
  }),
  (XG.SpriteShader = {
    defines: { BILLBOARD: !1, SDF: !1, FOG: !1, ANTIALIAS: !1, ALPHATEST: 0.5 },
    extensions: { OES_standard_derivatives: !0 },
    uniforms: {
      map: { type: "t", value: null },
      alphaTest: { type: "f", value: 0.5 },
      epsilon: { type: "f", value: 0.1 },
      fogDensity: { type: "f", value: 0.015 },
      fogColor: { type: "c", value: new XG.Color(0) },
      baseColor: { type: "c", value: new XG.Color(16777215) },
    },
    vertexShader: [
      "attribute vec3 color;",
      "attribute vec3 offset;",
      "attribute vec2 scale;",
      "varying vec2 vUv;",
      "varying vec3 vColor;",
      "void main() {",
      "vUv = uv;",
      "vColor = color;",
      "#ifdef BILLBOARD",
      "vec4 tmpPosition = modelViewMatrix * vec4( offset, 1.0 ) + vec4( position * vec3( scale, 1.0 ), 0.0 );",
      "gl_Position = projectionMatrix * tmpPosition;",
      "#else",
      "vec3 spritePosition = position * vec3( scale, 1.0 ) + offset;",
      "vec4 mvPosition = modelViewMatrix * vec4( spritePosition, 1.0 );",
      "gl_Position = projectionMatrix * mvPosition;",
      "#endif",
      "}",
    ].join("\n"),
    fragmentShader: [
      "uniform sampler2D map;",
      "uniform float alphaTest;",
      "uniform float epsilon;",
      "uniform float fogDensity;",
      "uniform vec3 fogColor;",
      "uniform vec3 baseColor;",
      "varying vec2 vUv;",
      "varying vec3 vColor;",
      "void main() {",
      "vec4 texture = texture2D( map, vUv );",
      "#ifdef SDF",
      "#if defined( GL_OES_standard_derivatives ) || __VERSION__ >= 300",
      "float w = clamp( 200.0 * epsilon * ( abs( dFdx( vUv.x ) ) + abs( dFdy( vUv.y ) ) ), 0.0, 0.5 );",
      "#else",
      "float w = epsilon;",
      "#endif",
      "float alpha = smoothstep( 0.5 - w, 0.5 + w, texture.r );",
      "alpha = pow( alpha, 1.0/2.2 );",
      "if ( alpha < alphaTest ) discard;",
      "#ifdef ANTIALIAS",
      "mgl_FragColor = vec4( baseColor * vColor, alpha );",
      "#else",
      "mgl_FragColor = vec4( baseColor * vColor, 1.0 );",
      "#endif",
      "#else",
      "float alpha = texture.a;",
      "#ifdef ALPHATEST",
      "if ( alpha < alphaTest ) discard;",
      "#endif",
      "mgl_FragColor = vec4( baseColor * vColor * texture.rgb, 1.0 );",
      "#endif",
      "#ifdef FOG",
      "float depth = gl_FragCoord.z / gl_FragCoord.w;",
      "const float LOG2 = 1.442695;",
      "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
      "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
      "mgl_FragColor = mix( mgl_FragColor, vec4( fogColor, mgl_FragColor.a ), fogFactor );",
      "#endif",
      "#ifdef TRANSPARENT",
      "mgl_FragColor.rgb *= mgl_FragColor.a;",
      "#endif",
      "}",
    ].join("\n"),
  }),
  (XG.TonemapShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      brightness: { type: "f", value: 1 },
      whitePoint: { type: "f", value: 1 },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      XG.ShaderChunk.tonemappingFragmentPars,
      "varying vec2 vUv;",
      "void main() {",
      "vec4 color = texture2D( tDiffuse, vUv );",
      "#ifdef TONEMAPPING",
      "float m = max( color.r, max( color.g, color.b ) );",
      "color.rgb = applyTonemapping( color.rgb, brightness, whitePoint );",
      "color.a = m;",
      "#endif",
      "mgl_FragColor = color;",
      "}",
    ].join("\n"),
  }),
  (XG.TonemapInverseShader = {
    uniforms: {
      tDiffuse: { type: "t", value: null },
      brightness: { type: "f", value: 1 },
      whitePoint: { type: "f", value: 1 },
    },
    vertexShader: XG.ShaderChunk.vertexShaderFullscreenTriangleUV,
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      XG.ShaderChunk.tonemappingFragmentPars,
      "varying vec2 vUv;",
      "void main() {",
      "vec4 color = texture2D( tDiffuse, vUv );",
      "#ifdef TONEMAPPING",
      "color.rgb = inverseTonemapping( color.rgb, brightness, whitePoint );",
      "if ( color.a > 0.9 ) color.rgb *= color.a;",
      "#endif",
      "mgl_FragColor = color;",
      "}",
    ].join("\n"),
  }),
  (XG.RendererUtils = {}),
  (XG.RendererUtils.getUvScale = function (e) {
    var t;
    return (
      e.map
        ? (t = e.map)
        : e.displacementMap
          ? (t = e.displacementMap)
          : e.lightMap
            ? (t = e.lightMap)
            : e.specularMap
              ? (t = e.specularMap)
              : e.glossMap
                ? (t = e.glossMap)
                : e.normalGlossMap
                  ? (t = e.normalGlossMap)
                  : e.normalMap
                    ? (t = e.normalMap)
                    : e.bumpMap && (t = e.bumpMap),
      t
    );
  }),
  (XG.ForwardRenderer = function (e) {
    function t(e, t, a) {
      var o,
        n,
        s,
        l,
        h = e.attributesList,
        d = e.offsets,
        c = e.numInstances > 0 && ua,
        u = e.attributes.index;
      (d.length > 1 || c) && (a = !0);
      for (var f = 0, p = d.length; p > f; f++) {
        var m = d[f];
        if (a) {
          for (var v = m.index, g = 0, S = h.length; S > g; g++)
            (o = h[g]),
              o.attached &&
              ((s = o.name),
                "index" !== s &&
                ((n = t[s]),
                  0 > n ||
                  void 0 === n ||
                  ((l = o.itemSize),
                    i(n),
                    Ve.bindBuffer(Ve.ARRAY_BUFFER, o.buffer),
                    Ve.vertexAttribPointer(n, l, Ve.FLOAT, !1, 0, v * l * 4),
                    c &&
                    o.divisor > 0 &&
                    (pa
                      ? Ve.vertexAttribDivisor(n, o.divisor)
                      : nt.vertexAttribDivisorANGLE(n, o.divisor)))));
          Ve.bindBuffer(Ve.ELEMENT_ARRAY_BUFFER, u.buffer);
        }
        if ((Ha(t, e, m.index), r(), c)) {
          pa
            ? Ve.drawElementsInstanced(
              Ve.TRIANGLES,
              m.count,
              u.type,
              m.start * u.typeSize,
              e.numVisibleInstances
            )
            : nt.drawElementsInstancedANGLE(
              Ve.TRIANGLES,
              m.count,
              u.type,
              m.start * u.typeSize,
              e.numVisibleInstances
            );
          for (var g = 0, S = h.length; S > g; g++)
            (o = h[g]),
              o.attached &&
              ((s = o.name),
                "index" !== s &&
                ((n = t[s]),
                  0 > n ||
                  void 0 === n ||
                  (o.divisor > 0 &&
                    (Ve.bindBuffer(Ve.ARRAY_BUFFER, o.buffer),
                      pa
                        ? Ve.vertexAttribDivisor(n, 0)
                        : nt.vertexAttribDivisorANGLE(n, 0)))));
        } else
          Ve.drawElements(Ve.TRIANGLES, m.count, u.type, m.start * u.typeSize);
      }
    }
    function a(e, t, a, o) {
      var n,
        s,
        l = e.attributesList,
        h = e.numInstances > 0 && ua;
      if (o || h)
        for (var d = 0, c = l.length; c > d; d++)
          (n = l[d]),
            n.attached &&
            ((s = t[n.name]),
              0 > s ||
              void 0 === s ||
              (i(s),
                Ve.bindBuffer(Ve.ARRAY_BUFFER, n.buffer),
                Ve.vertexAttribPointer(s, n.itemSize, Ve.FLOAT, !1, 0, 0),
                h &&
                n.divisor > 0 &&
                (pa
                  ? Ve.vertexAttribDivisor(s, n.divisor)
                  : nt.vertexAttribDivisorANGLE(s, n.divisor))));
      Ha(t, e, 0), r();
      var u = e.attributes.position;
      if (h) {
        pa
          ? Ve.drawArraysInstanced(a, 0, u.numItems / 3, e.numVisibleInstances)
          : nt.drawArraysInstancedANGLE(
            a,
            0,
            u.numItems / 3,
            e.numVisibleInstances
          );
        for (var d = 0, c = l.length; c > d; d++)
          (n = l[d]),
            n.attached &&
            ((s = t[n.name]),
              0 > s ||
              void 0 === s ||
              (Ve.bindBuffer(Ve.ARRAY_BUFFER, n.buffer),
                n.divisor > 0 &&
                (pa
                  ? Ve.vertexAttribDivisor(s, 0)
                  : nt.vertexAttribDivisorANGLE(s, 0))));
      } else Ve.drawArrays(a, 0, u.numItems / 3);
    }
    function r() {
      for (var e = 0, t = Bt.length; t > e; e++) {
        var a = Bt[e];
        !Ut[a] &&
          Nt[a] &&
          (Ve.enableVertexAttribArray(a),
            void 0 === Ut[a] && It.push(a),
            (Ut[a] = !0));
      }
      for (var e = 0, t = It.length; t > e; e++) {
        var a = It[e];
        Ut[a] && !Nt[a] && (Ve.disableVertexAttribArray(a), (Ut[a] = !1));
      }
    }
    function i(e) {
      Nt[e] || ((Nt[e] = !0), Bt.push(e));
    }
    function o() {
      for (var e = 0, t = Bt.length; t > e; e++) {
        var a = Bt[e];
        Nt[a] = !1;
      }
      Bt.length = 0;
    }
    function n(e, t) {
      return e.z !== t.z ? t.z - e.z : t.id - e.id;
    }
    function s(e, t) {
      return t[0] - e[0];
    }
    function l(e, t, a) {
      if (e.length)
        for (var r = 0, i = e.length; i > r; r++)
          (dt = null),
            (pt = null),
            (xt = -1),
            (Xt = -1),
            (Dt = -1),
            (gt = -1),
            (St = -1),
            (ft = -1),
            (ut = -1),
            (ea = !0),
            e[r].render(t, a, Ft, Rt),
            (dt = null),
            (pt = null),
            (xt = -1),
            (Xt = -1),
            (Dt = -1),
            (gt = -1),
            (St = -1),
            (ft = -1),
            (ut = -1),
            (ea = !0);
    }
    function h(e, t, a, r, i, o, n, s) {
      var l, h, d, c;
      t
        ? ((h = e.length - 1), (d = -1), (c = -1))
        : ((h = 0), (d = e.length), (c = 1));
      for (var u, f = h; f !== d; f += c)
        (l = e[f]),
          l.render &&
          ((u = l[a]),
            u &&
            u.visible !== !1 &&
            u.enabled !== !1 &&
            (s &&
              st.setBlending(
                u.blending,
                u.blendEquation,
                u.blendSrcColor,
                u.blendDstColor,
                u.blendSrcAlpha,
                u.blendDstAlpha
              ),
              st.setDepthTest(u.depthTest),
              st.setDepthWrite(u.depthWrite),
              st.setPolygonOffset(
                u.polygonOffset,
                u.polygonOffsetFactor,
                u.polygonOffsetUnits
              ),
              st.setMaterialFaces(u),
              st.setProgram(r, i, o, n, u, l.object, l.geometry),
              st.renderGeometry(u, l.geometry, l.object)));
    }
    function d(e, t, a, r, i, o, n) {
      for (var s, l, h, d = 0, c = e.length; c > d; d++)
        (s = e[d]),
          (l = s.object),
          s.render &&
          ((h = s[t]),
            h &&
            h.visible !== !1 &&
            h.enabled !== !1 &&
            (n &&
              st.setBlending(
                h.blending,
                h.blendEquation,
                h.blendSrcColor,
                h.blendDstColor,
                h.blendSrcAlpha,
                h.blendDstAlpha
              ),
              st.setDepthTest(h.depthTest),
              st.setDepthWrite(h.depthWrite),
              st.setPolygonOffset(
                h.polygonOffset,
                h.polygonOffsetFactor,
                h.polygonOffsetUnits
              ),
              st.setProgram(a, r, i, o, h, l, null),
              st.renderImmediateObject(h, l)));
    }
    function c(e) {
      var t = e.object,
        a = e.index,
        r = t.materials[a];
      r &&
        (r.transparent
          ? ((e.transparent = r), (e.opaque = null))
          : ((e.opaque = r), (e.transparent = null)));
    }
    function u(e) {
      var t = e.object,
        a = e.index,
        r = t.materials[a];
      r &&
        (r.transparent
          ? ((e.transparent = r), (e.opaque = null))
          : ((e.opaque = r), (e.transparent = null)));
    }
    function f(e, t) {
      var a;
      if (
        !e.__webglInit &&
        ((e.__webglInit = !0),
          (e._modelViewMatrix = new XG.Matrix4()),
          (e._normalMatrix = new XG.Matrix3()),
          e instanceof XG.Mesh || e instanceof XG.Particles)
      )
        for (var r = 0, i = e.geometries.length; i > r; r++)
          (a = e.geometries[r]), za(a);
      if (!e.__webglActive) {
        if (e instanceof XG.Mesh || e instanceof XG.Particles)
          for (var r = 0, i = e.geometries.length; i > r; r++)
            (a = e.geometries[r]), p(t.__webglObjects, a, e, r);
        else
          (e instanceof XG.ImmediateRenderObject ||
            e.immediateRenderCallback) &&
            m(t.__webglObjectsImmediate, e);
        e.__webglActive = !0;
      }
    }
    function p(e, t, a, r) {
      e.push({
        render: !1,
        index: r,
        geometry: t,
        object: a,
        opaque: null,
        transparent: null,
        z: 0,
        id: 0,
      });
    }
    function m(e, t) {
      e.push({
        render: !1,
        index: 0,
        object: t,
        opaque: null,
        transparent: null,
        z: 0,
        id: 0,
      });
    }
    function v(e) {
      var t = e.geometries;
      if (e instanceof XG.Mesh || e instanceof XG.Particles)
        for (var a = 0, r = t.length; r > a; a++) st.setBuffers(t[a]);
    }
    function g(e, t) {
      e instanceof XG.Mesh || e instanceof XG.Particles
        ? S(t.__webglObjects, e)
        : (e instanceof XG.ImmediateRenderObject ||
          e.immediateRenderCallback) &&
        S(t.__webglObjectsImmediate, e),
        (e.__webglActive = !1);
    }
    function S(e, t) {
      for (var a = e.length - 1; a >= 0; a--)
        e[a].object === t && e.splice(a, 1);
    }
    function x(e, t) {
      (e.uniforms = XG.UniformsUtils.clone(t.uniforms)),
        (e.vertexShader = t.vertexShader),
        (e.fragmentShader = t.fragmentShader);
    }
    function G(e, t) {
      var a = t.color;
      if (
        (st.gammaInput
          ? e.diffuse.value.setRGBAGamma(a, t.opacity)
          : e.diffuse.value.setRGBA(a, t.opacity),
          t instanceof XG.EmissiveMaterial ||
          t instanceof XG.DynamicParticleMaterial)
      ) {
        var r = e.diffuse.value.data,
          i = t.intensity;
        (r[0] *= i), (r[1] *= i), (r[2] *= i);
      }
      (e.map.value = t.map), (e.lightMap.value = t.lightMap);
      var o = Va(t);
      if (void 0 !== o) {
        var n = o.offset,
          s = o.repeat;
        e.offsetRepeat.value.set(n.data[0], n.data[1], s.data[0], s.data[1]);
      }
      t.displacementMap &&
        ((e.displacementMap.value = t.displacementMap),
          e.displacementScaleBias.value.set(
            t.displacementScale,
            t.displacementBias
          ),
          (e.displacementNormalScale.value = t.displacementNormalScale)),
        (e.brightness.value = st.brightness),
        (e.whitePoint.value = st.whitePoint);
    }
    function M(e, t, a) {
      (e.particleSize.value = t.particleSize),
        (e.screenWidth.value = Ft),
        t instanceof XG.DynamicParticleMaterial &&
        ((e.time.value = t.time),
          (e.timeRange.value = t.timeRange),
          (e.timeOffset.value = t.timeOffset),
          (e.numFrames.value = t.numFrames),
          (e.frameDuration.value = t.frameDuration),
          e.frameScaleOffset.value.copy(t.frameScaleOffset),
          e.cameraNearFar.value.set(a.near, a.far),
          (e.additiveFactor.value = t.additiveFactor));
    }
    function y(e, t, a) {
      (e.fogColor.value = t.color),
        t instanceof XG.LinearFog
          ? e.fogNearFar.value.set(t.near, t.far)
          : t instanceof XG.ExponentialFog
            ? (e.fogDensity.value = t.density)
            : t instanceof XG.AtmosphericFog &&
            (e.fogStartStrength.value.set(t.start, t.strength),
              e.cameraNearFar.value.set(a.near, a.far));
    }
    function w(e, t) {
      (e.fogHeight.value = t.height),
        (e.fogVisibilityDistance.value = t.visibilityDistance),
        (e.fogFadeSpeed.value = t.fadeSpeed),
        (e.fogShallowDepthColor.value = t.shallowDepthColor),
        (e.fogDeepDepthColor.value = t.deepDepthColor),
        (e.fogRgbExtinctionDistance.value = t.rgbExtinctionDistance);
    }
    function _(e, t) {
      var a = t.specular;
      st.gammaInput
        ? e.specular.value.setRGBAGamma(a, t.shininess)
        : e.specular.value.setRGBA(a, t.shininess),
        t.specularMap && (e.specularMap.value = t.specularMap),
        t.glossMap && (e.glossMap.value = t.glossMap),
        t.bumpMap &&
        ((e.bumpMap.value = t.bumpMap), (e.bumpScale.value = t.bumpScale)),
        (t.normalMap || t.normalGlossMap) &&
        ((e.normalMap.value = t.normalGlossMap
          ? t.normalGlossMap
          : t.normalMap),
          e.normalScale.value.copy(t.normalScale)),
        t.bumpDetailMap && (e.bumpDetailMap.value = t.bumpDetailMap),
        t.normalDetailMap && (e.normalDetailMap.value = t.normalDetailMap),
        (t.bumpDetailMap || t.normalDetailMap) &&
        e.detailRepeatScale.value.set(
          t.detailRepeat.x,
          t.detailRepeat.y,
          t.detailScale
        ),
        t.wrapAround && (e.wrapRGB.value = t.wrapRGB),
        t.parallax && (e.parallaxScale.value = t.parallaxScale);
    }
    function X(e, t) {
      e.directionalLightPositionVS &&
        (e.directionalLightPositionVS.value = t.directional.positionsFull),
        (e.directionalLightColor.value = t.directional.colors),
        (e.directionalLightDirectionVS.value = t.directional.positionsNorm),
        (e.directionalLightPars.value = t.directional.pars),
        (e.pointLightColor.value = t.point.colors),
        (e.pointLightPositionVS.value = t.point.positions),
        (e.pointLightPars.value = t.point.pars),
        (e.sphereLightColor.value = t.sphere.colors),
        (e.sphereLightPositionVS.value = t.sphere.positions),
        (e.sphereLightPars.value = t.sphere.pars),
        (e.tubeLightColor.value = t.tube.colors),
        (e.tubeLightPosition0VS.value = t.tube.positions0),
        (e.tubeLightPosition1VS.value = t.tube.positions1),
        (e.tubeLightPars.value = t.tube.pars),
        (e.spotLightColor.value = t.spot.colors),
        (e.spotLightPositionVS.value = t.spot.positions),
        (e.spotLightDirectionVS.value = t.spot.directions),
        (e.spotLightPars.value = t.spot.pars),
        (e.hemisphereLightSkyColor.value = t.hemi.skyColors),
        (e.hemisphereLightGroundColor.value = t.hemi.groundColors),
        (e.hemisphereLightDirectionVS.value = t.hemi.positions),
        (e.areaLightColor.value = t.area.colors),
        (e.areaLightPosition.value = t.area.positions),
        (e.areaLightNormal.value = t.area.normals),
        (e.areaLightRight.value = t.area.rights),
        (e.areaLightUp.value = t.area.ups),
        (e.areaLightPars.value = t.area.pars),
        (e.areaLightAttenuation.value = t.area.attenuations),
        (e.areaLightTexture.value = t.area.textures),
        (e.imageLightTextureDiffuse.value = t.image.texturesDiffuse),
        (e.imageLightTextureSpecular.value = t.image.texturesSpecular),
        (e.imageLightTextureMip.value = t.image.texturesMip),
        (e.imageLightPars.value = t.image.pars),
        (e.imageLightPositionWS.value = t.image.positions),
        (e.imageLightSize.value = t.image.sizes),
        (e.polyLightColor.value = t.poly.colors),
        (e.polyLightPoints.value = t.poly.points),
        (e.polyLightPars.value = t.poly.pars),
        (e.polyLightTexture.value = t.poly.textures),
        (e.polyLightTexturePars.value = t.poly.texturesPars),
        (e.samplerLtcMat.value = t.poly.samplerLtcMat),
        (e.samplerLtcMag.value = t.poly.samplerLtcMag);
    }
    function D(e, t, a, r, i) {
      e.useDepthTexture &&
        oa &&
        st.shadowMapUseDepthTextures &&
        (e = e.depthTexture);
      var o = Math.sqrt(a.shadowDarkness),
        n = a.properties.shadowMapPars;
      (n[0] = a.shadowMapWidth),
        (n[1] = a.shadowMapHeight),
        (n[2] = o),
        (n[3] = a.shadowBias);
      var s = a.properties.shadowCameraPars;
      (s[0] = a.shadowCameraNear),
        (s[1] = a.shadowCameraFar),
        (r.shadowMap.value[i] = e),
        (r.shadowMatrix.value[i] = t),
        (r.shadowMapPars.value[4 * i] = n[0]),
        (r.shadowMapPars.value[4 * i + 1] = n[1]),
        (r.shadowMapPars.value[4 * i + 2] = n[2]),
        (r.shadowMapPars.value[4 * i + 3] = n[3]),
        (r.shadowCameraPars.value[2 * i] = s[0]),
        (r.shadowCameraPars.value[2 * i + 1] = s[1]);
    }
    function T(e, t) {
      for (var a = 0, r = 0, i = t.length; i > r; r++) {
        var o = t[r];
        if (o.castShadow) {
          if (
            o instanceof XG.SpotLight ||
            o instanceof XG.AreaLight ||
            o instanceof XG.PolyLight ||
            ((o instanceof XG.DirectionalLight ||
              o instanceof XG.DayLight ||
              o instanceof XG.DayLightCube) &&
              !o.shadowCascade)
          ) {
            var n = o.properties,
              s = n.shadowMap,
              l = n.shadowMatrixForward;
            if (s instanceof Array)
              for (var h = 0, d = s.length; d > h; h++)
                D(s[h], l[h], o, e, a), a++;
            else D(s, l, o, e, a), a++;
          }
          if (o instanceof XG.SphereLight || o instanceof XG.PointLight) {
            var n = o.properties,
              s = n.shadowMap,
              c = n.shadowMatrixTranslation;
            D(s, c, o, e, a), a++;
          }
        }
      }
    }
    function C(e, t) {
      e.modelViewMatrix &&
        Ve.uniformMatrix4fv(e.modelViewMatrix, !1, t._modelViewMatrix.elements),
        e.normalMatrix &&
        Ve.uniformMatrix3fv(e.normalMatrix, !1, t._normalMatrix.elements),
        e.modelMatrix &&
        Ve.uniformMatrix4fv(e.modelMatrix, !1, t.matrixWorld.elements);
    }
    function A() {
      var e = mt;
      return (
        e >= ma &&
        console.warn(
          "XG:ForwardRenderer: trying to use " +
          (e + 1) +
          " texture units while this GPU supports only " +
          ma
        ),
        (mt += 1),
        e
      );
    }
    function P(e) {
      for (var t, a, r, i, o, n, s, l, h, d, c, u = 0, f = e.length; f > u; u++)
        if (
          ((t = e[u]),
            (a = t[0]),
            (o = t[1]),
            (i = a.type),
            (r = a.value),
            "i" === i)
        )
          Ve.uniform1i(o, r);
        else if ("ui" === i) Ve.uniform1ui(o, r);
        else if ("f" === i) Ve.uniform1f(o, r);
        else if ("v2" === i) Ve.uniform2fv(o, r.data);
        else if ("v3" === i) Ve.uniform3fv(o, r.data);
        else if ("v4" === i) Ve.uniform4fv(o, r.data);
        else if ("c" === i) Ve.uniform3f(o, r.r, r.g, r.b);
        else if ("iv1" === i) Ve.uniform1iv(o, r);
        else if ("uiv1" === i) Ve.uniform1uiv(o, r);
        else if ("iv2" === i) Ve.uniform2iv(o, r);
        else if ("iv3" === i) Ve.uniform3iv(o, r);
        else if ("fv1" === i) Ve.uniform1fv(o, r);
        else if ("fv2" === i) Ve.uniform2fv(o, r);
        else if ("fv3" === i) Ve.uniform3fv(o, r);
        else if ("fv4" === i) Ve.uniform4fv(o, r);
        else if ("v2v" === i) {
          for (
            void 0 === a._array && (a._array = new Float32Array(2 * r.length)),
            l = 0,
            h = r.length;
            h > l;
            l++
          )
            (d = 2 * l), a._array.set(r[l].data, d);
          Ve.uniform2fv(o, a._array);
        } else if ("v3v" === i) {
          for (
            void 0 === a._array && (a._array = new Float32Array(3 * r.length)),
            l = 0,
            h = r.length;
            h > l;
            l++
          )
            (d = 3 * l), a._array.set(r[l].data, d);
          Ve.uniform3fv(o, a._array);
        } else if ("v4v" === i) {
          for (
            void 0 === a._array && (a._array = new Float32Array(4 * r.length)),
            l = 0,
            h = r.length;
            h > l;
            l++
          )
            (d = 4 * l), a._array.set(r[l].data, d);
          Ve.uniform4fv(o, a._array);
        } else if ("v3c" === i) {
          for (
            void 0 === a._array && (a._array = new Float32Array(3 * r.length)),
            l = 0,
            h = r.length;
            h > l;
            l++
          )
            (c = r[l]),
              (d = 3 * l),
              (a._array[d] = c.r),
              (a._array[d + 1] = c.g),
              (a._array[d + 2] = c.b);
          Ve.uniform3fv(o, a._array);
        } else if ("m4" === i) Ve.uniformMatrix4fv(o, !1, r.elements);
        else if ("m4v" === i) {
          for (
            void 0 === a._array && (a._array = new Float32Array(16 * r.length)),
            l = 0,
            h = r.length;
            h > l;
            l++
          )
            r[l].flattenToArrayOffset(a._array, 16 * l);
          Ve.uniformMatrix4fv(o, !1, a._array);
        } else if ("t" === i) {
          if (((n = r), (s = A()), Ve.uniform1i(o, s), !n)) continue;
          n.image instanceof Array
            ? Q(n, s)
            : n instanceof XG.RenderTargetCube
              ? J(n, s)
              : st.setTexture(n, s);
        } else if ("t3" === i) {
          if (((n = r), (s = A()), Ve.uniform1i(o, s), !n)) continue;
          n instanceof XG.RenderTarget3D ? te(n, s) : ee(n, s);
        } else if ("tv" === i) {
          for (
            void 0 === a._array && (a._array = []), l = 0, h = a.value.length;
            h > l;
            l++
          )
            a._array[l] = A();
          for (
            Ve.uniform1iv(o, a._array), l = 0, h = a.value.length;
            h > l;
            l++
          )
            (n = a.value[l]),
              (s = a._array[l]),
              n &&
              (n.image instanceof Array
                ? Q(n, s)
                : n instanceof XG.RenderTargetCube
                  ? J(n, s)
                  : st.setTexture(n, s));
        }
    }
    function L(e, t) {
      e._modelViewMatrix.multiply(t.matrixWorldInverse, e.matrixWorld),
        e._normalMatrix.getNormalMatrix(e._modelViewMatrix);
    }
    function b(e, t, a, r) {
      var i = a.r * r,
        o = a.g * r,
        n = a.b * r;
      st.gammaInput && ((i *= i), (o *= o), (n *= n)),
        (e[t] = i),
        (e[t + 1] = o),
        (e[t + 2] = n);
    }
    function E(e, t, a) {
      var r = a.data;
      (e[t] = r[0]), (e[t + 1] = r[1]), (e[t + 2] = r[2]);
    }
    function F(e, t, a, r) {
      var i = a.data;
      (e[t] = i[0]), (e[t + 1] = i[1]), (e[t + 2] = i[2]), (e[t + 3] = r);
    }
    function R(e, t, a, r) {
      (e[t] = a), (e[t + 1] = r);
    }
    function U(e, t, a, r, i) {
      (e[t] = a), (e[t + 1] = r), (e[t + 2] = i);
    }
    function I(e, t, a, r, i, o) {
      (e[t] = a), (e[t + 1] = r), (e[t + 2] = i), (e[t + 3] = o);
    }
    function N(e, t) {
      var a,
        r,
        i,
        o,
        n,
        s,
        l,
        h = ta,
        d = h.directional.colors,
        c = h.directional.positionsNorm,
        u = h.directional.positionsFull,
        f = h.directional.pars,
        p = h.point.colors,
        m = h.point.positions,
        v = h.point.pars,
        g = h.sphere.colors,
        S = h.sphere.positions,
        x = h.sphere.pars,
        G = h.tube.colors,
        M = h.tube.positions0,
        y = h.tube.positions1,
        w = h.tube.pars,
        _ = h.spot.colors,
        X = h.spot.positions,
        D = h.spot.directions,
        T = h.spot.pars,
        C = h.hemi.skyColors,
        A = h.hemi.groundColors,
        P = h.hemi.positions,
        L = h.area.colors,
        N = h.area.positions,
        B = h.area.normals,
        O = h.area.rights,
        V = h.area.ups,
        k = h.area.pars,
        z = h.area.attenuations,
        H = h.area.textures,
        W = h.image.pars,
        j = h.image.texturesDiffuse,
        q = h.image.texturesSpecular,
        Y = h.image.texturesMip,
        K = h.image.positions,
        Z = h.image.sizes,
        Q = h.poly.colors,
        J = h.poly.points,
        $ = h.poly.pars,
        ee = h.poly.textures,
        te = h.poly.texturesPars,
        ae = 0,
        re = 0,
        ie = 0,
        oe = 0,
        ne = 0,
        se = 0,
        le = 0,
        he = 0,
        de = 0,
        ce = 0,
        ue = 0,
        fe = 0,
        pe = 0,
        me = 0,
        ve = 0,
        ge = 0,
        Se = 0,
        xe = 0,
        Ge = 999999,
        Me = 0,
        ye = [],
        we = [],
        _e = [],
        Xe = [],
        De = [],
        Te = [],
        Ce = t.matrixWorldInverse;
      for (a = 0, r = e.length; r > a; a++)
        if (((i = e[a]), i.onlyShadow))
          i instanceof XG.DirectionalLight ||
            i instanceof XG.DayLight ||
            i instanceof XG.DayLightCube
            ? i.castShadow && ye.push(i)
            : i instanceof XG.SpotLight
              ? i.castShadow && we.push(i)
              : i instanceof XG.AreaLight
                ? i.castShadow && _e.push(i)
                : i instanceof XG.PolyLight
                  ? i.castShadow && Xe.push(i)
                  : i instanceof XG.SphereLight
                    ? i.castShadow && De.push(i)
                    : i instanceof XG.PointLight && i.castShadow && Te.push(i);
        else if (
          ((o = i.color),
            (n = i.intensity),
            (s = i.distance),
            (l = i.matrixWorld),
            i instanceof XG.DirectionalLight)
        ) {
          if (((ce += 1), !i.visible)) continue;
          if (
            (Wt.copy(l.getPosition()),
              Wt.subSelf(i.target.matrixWorld.getPosition()),
              Wt.normalize(),
              Ce.rotateAxis(Wt),
              0 === Wt.data[0] && 0 === Wt.data[1] && 0 === Wt.data[2])
          )
            continue;
          Ht.copy(l.getPosition()),
            Ce.multiplyVector3(Ht),
            E(c, 3 * ae, Wt),
            F(u, 4 * ae, Ht, s),
            b(d, 3 * ae, o, n),
            (f[ae] = i.castShadow ? ye.length : Ge),
            i.castShadow && ye.push(i),
            (ae += 1);
        } else if (i instanceof XG.PointLight) {
          if (((ue += 1), !i.visible)) continue;
          Ht.copy(l.getPosition()),
            Ce.multiplyVector3(Ht),
            E(m, 3 * re, Ht),
            b(p, 3 * re, o, n),
            R(v, 2 * re, s, i.castShadow ? Te.length : Ge),
            i.castShadow && Te.push(i),
            (re += 1);
        } else if (i instanceof XG.SphereLight) {
          if (((fe += 1), !i.visible)) continue;
          Ht.copy(l.getPosition()),
            Ce.multiplyVector3(Ht),
            E(S, 3 * ie, Ht),
            b(g, 3 * ie, o, n),
            U(x, 3 * ie, s, i.radius, i.castShadow ? De.length : Ge),
            i.castShadow && De.push(i),
            (ie += 1);
        } else if (i instanceof XG.TubeLight) {
          if (((pe += 1), !i.visible)) continue;
          Ht.copy(i.endPoint0.matrixWorld.getPosition()),
            Ce.multiplyVector3(Ht),
            E(M, 3 * oe, Ht),
            Ht.copy(i.endPoint1.matrixWorld.getPosition()),
            Ce.multiplyVector3(Ht),
            E(y, 3 * oe, Ht),
            b(G, 3 * oe, o, n),
            R(w, 2 * oe, s, i.radius),
            (oe += 1);
        } else if (i instanceof XG.SpotLight) {
          if (((me += 1), !i.visible)) continue;
          Ht.copy(l.getPosition()),
            Ce.multiplyVector3(Ht),
            Wt.copy(l.getPosition()),
            Wt.subSelf(i.target.matrixWorld.getPosition()),
            Wt.normalize(),
            Ce.rotateAxis(Wt),
            E(X, 3 * ne, Ht),
            E(D, 3 * ne, Wt),
            b(_, 3 * ne, o, n),
            (Me = Math.cos(0.5 * i.angle)),
            I(T, 4 * ne, Me, i.exponent, s, i.castShadow ? we.length : Ge),
            i.castShadow && we.push(i),
            (ne += 1);
        } else if (i instanceof XG.HemisphereLight) {
          if (((ve += 1), !i.visible)) continue;
          if (
            (Wt.copy(l.getPosition()),
              Wt.normalize(),
              Ce.rotateAxis(Wt),
              0 === Wt.data[0] && 0 === Wt.data[1] && 0 === Wt.data[2])
          )
            continue;
          E(P, 3 * se, Wt),
            b(C, 3 * se, i.color, n),
            b(A, 3 * se, i.groundColor, n),
            (se += 1);
        } else if (i instanceof XG.AreaLight) {
          if (((ge += 1), !i.visible)) continue;
          Ht.copy(l.getPosition()),
            Ce.multiplyVector3(Ht),
            jt.copy(i.normal),
            l.rotateAxis(jt),
            Ce.rotateAxis(jt),
            qt.copy(i.right),
            l.rotateAxis(qt),
            Ce.rotateAxis(qt),
            Yt.cross(qt, jt),
            Yt.normalize(),
            E(N, 3 * le, Ht),
            E(B, 3 * le, jt),
            E(O, 3 * le, qt),
            E(V, 3 * le, Yt),
            b(L, 3 * le, o, n),
            U(
              z,
              3 * le,
              i.constantAttenuation,
              i.linearAttenuation,
              i.quadraticAttenuation
            ),
            I(
              k,
              4 * le,
              i.width,
              i.height,
              i.texture ? 1 : 0,
              i.castShadow ? _e.length : Ge
            ),
            (H[le] = i.texture),
            i.castShadow && _e.push(i),
            (le += 1);
        } else if (i instanceof XG.PolyLight) {
          if (((xe += 1), !i.visible)) continue;
          Ht.copy(l.getPosition()),
            qt.copy(i.right).normalize(),
            jt.copy(i.normal).normalize(),
            l.rotateAxis(qt),
            l.rotateAxis(jt),
            Yt.cross(qt, jt),
            Yt.normalize(),
            qt.multiplyScalar(i.width),
            Yt.multiplyScalar(i.height),
            Zt.copy(Ht),
            Zt.subSelf(qt),
            Zt.addSelf(Yt),
            Qt.copy(Ht),
            Qt.addSelf(qt),
            Qt.addSelf(Yt),
            Jt.copy(Ht),
            Jt.addSelf(qt),
            Jt.subSelf(Yt),
            $t.copy(Ht),
            $t.subSelf(qt),
            $t.subSelf(Yt),
            Ce.multiplyVector3(Zt),
            Ce.multiplyVector3(Qt),
            Ce.multiplyVector3(Jt),
            Ce.multiplyVector3($t),
            E(J, 12 * de, Zt),
            E(J, 12 * de + 3, Qt),
            E(J, 12 * de + 6, Jt),
            E(J, 12 * de + 9, $t),
            b(Q, 3 * de, o, n),
            R($, 2 * de, i.twoSided, i.castShadow ? Xe.length : Ge),
            (ee[de] = i.texture),
            R(te, 2 * de, i.texture ? i.texture.getWidth() : 0, i.textureBias),
            i.castShadow && Xe.push(i),
            (de += 1);
        } else if (i instanceof XG.ImageLight) {
          if (((Se += 1), !i.visible)) continue;
          i.textureDiffuse instanceof XG.RenderTargetCube &&
            (n /= st.brightness),
            st.gammaInput && (n *= n),
            Ht.copy(l.getPosition());
          var Ae = i.textureSpecular,
            Pe = ((i.local ? 1 : 0) + 1) * (Ae.fixSeams ? 1 : -1),
            Le = (i.textureEncoding + 1) * (i.textureGamma ? 1 : -1),
            be = Ae.image ? Ae.image[0] : null,
            Ee = be ? be.width : 0;
          Kt.copy(i.size).multiplyScalar(0.5),
            E(K, 3 * he, Ht),
            F(Z, 4 * he, Kt, Le),
            I(W, 4 * he, Ae.mipmapCount, n, Pe, Ee),
            (j[he] = i.textureDiffuse),
            (q[he] = i.textureSpecular),
            (Y[he] = i.textureMip),
            (he += 1);
        } else if (i instanceof XG.DayLight) {
          if (((ve += 1), (ce += 1), !i.visible)) continue;
          if (
            (Wt.copy(i.hemiPosition),
              Wt.normalize(),
              Ce.rotateAxis(Wt),
              0 === Wt.data[0] && 0 === Wt.data[1] && 0 === Wt.data[2])
          )
            continue;
          if (
            (E(P, 3 * se, Wt),
              b(C, 3 * se, i.skyColor, i.hemiIntensity),
              b(A, 3 * se, i.groundColor, i.hemiIntensity),
              (se += 1),
              Wt.copy(l.getPosition()),
              Wt.subSelf(i.target.matrixWorld.getPosition()),
              Wt.normalize(),
              Ce.rotateAxis(Wt),
              0 === Wt.data[0] && 0 === Wt.data[1] && 0 === Wt.data[2])
          )
            continue;
          Ht.copy(l.getPosition()),
            Ce.multiplyVector3(Ht),
            E(c, 3 * ae, Wt),
            F(u, 4 * ae, Ht, s),
            b(d, 3 * ae, o, i.sunIntensity),
            (f[ae] = i.castShadow ? ye.length : Ge),
            i.castShadow && ye.push(i),
            (ae += 1);
        } else if (i instanceof XG.DayLightCube) {
          if (((Se += 1), (ce += 1), !i.visible)) continue;
          var Fe = i.ambientIntensity;
          st.gammaInput && (Fe *= Fe);
          var Ae = i.textureSpecular,
            Pe = ((i.local ? 1 : 0) + 1) * (Ae.fixSeams ? 1 : -1),
            Le = (i.textureEncoding + 1) * (i.textureGamma ? 1 : -1),
            be = Ae.image ? Ae.image[0] : null,
            Ee = be ? be.width : 0;
          if (
            (Kt.copy(i.size).multiplyScalar(0.5),
              E(K, 3 * he, i.cubePosition),
              F(Z, 4 * he, Kt, Le),
              I(W, 4 * he, Ae.mipmapCount, Fe, Pe, Ee),
              (j[he] = i.textureDiffuse),
              (q[he] = i.textureSpecular),
              (Y[he] = i.textureMip),
              (he += 1),
              Wt.copy(l.getPosition()),
              Wt.subSelf(i.target.matrixWorld.getPosition()),
              Wt.normalize(),
              Ce.rotateAxis(Wt),
              0 === Wt.data[0] && 0 === Wt.data[1] && 0 === Wt.data[2])
          )
            continue;
          Ht.copy(l.getPosition()),
            Ce.multiplyVector3(Ht),
            E(c, 3 * ae, Wt),
            F(u, 4 * ae, Ht, s),
            b(d, 3 * ae, o, n),
            (f[ae] = i.castShadow ? ye.length : Ge),
            i.castShadow && ye.push(i),
            (ae += 1);
        }
      var Re = h.shadowCasters;
      Re.length = 0;
      var Ue, Ie, Ne;
      for (Ue = 0, Ie = ye.length; Ie > Ue; Ue++) (Ne = ye[Ue]), Re.push(Ne);
      for (Ue = 0, Ie = we.length; Ie > Ue; Ue++) (Ne = we[Ue]), Re.push(Ne);
      for (Ue = 0, Ie = _e.length; Ie > Ue; Ue++) (Ne = _e[Ue]), Re.push(Ne);
      for (Ue = 0, Ie = Xe.length; Ie > Ue; Ue++) (Ne = Xe[Ue]), Re.push(Ne);
      for (Ue = 0, Ie = De.length; Ie > Ue; Ue++) (Ne = De[Ue]), Re.push(Ne);
      for (Ue = 0, Ie = Te.length; Ie > Ue; Ue++) (Ne = Te[Ue]), Re.push(Ne);
      if (xe > 0) {
        if (!h.poly.samplerLtcMat) {
          var Be = new Float32Array(XG.PolyLight.ltcMatData),
            Oe = new XG.DataTexture(
              Be,
              64,
              64,
              XG.RGBAFormat,
              XG.FloatType,
              XG.ClampToEdgeWrapping,
              XG.ClampToEdgeWrapping,
              XG.LinearFilter,
              XG.NearestFilter
            );
          (Oe.flipY = !1),
            (Oe.generateMipmaps = !1),
            (Oe.needsUpdate = !0),
            (h.poly.samplerLtcMat = Oe);
        }
        if (!h.poly.samplerLtcMag) {
          var Ve = new Float32Array(XG.PolyLight.ltcMagData),
            ke = new XG.DataTexture(
              Ve,
              32,
              32,
              XG.LuminanceAlphaFormat,
              XG.FloatType,
              XG.ClampToEdgeWrapping,
              XG.ClampToEdgeWrapping,
              XG.LinearFilter,
              XG.NearestFilter
            );
          (ke.flipY = !1),
            (ke.generateMipmaps = !1),
            (ke.needsUpdate = !0),
            (h.poly.samplerLtcMag = ke);
        }
      }
      for (a = 3 * ae, r = Math.max(d.length, 3 * ce); r > a; a++) d[a] = 0;
      for (a = 3 * re, r = Math.max(p.length, 3 * ue); r > a; a++) p[a] = 0;
      for (a = 3 * ie, r = Math.max(g.length, 3 * fe); r > a; a++) g[a] = 0;
      for (a = 3 * oe, r = Math.max(G.length, 3 * pe); r > a; a++) G[a] = 0;
      for (a = 3 * ne, r = Math.max(_.length, 3 * me); r > a; a++) _[a] = 0;
      for (a = 3 * se, r = Math.max(C.length, 3 * ve); r > a; a++) C[a] = 0;
      for (a = 3 * se, r = Math.max(A.length, 3 * ve); r > a; a++) A[a] = 0;
      for (a = 3 * le, r = Math.max(L.length, 3 * ge); r > a; a++) L[a] = 0;
      for (a = 3 * de, r = Math.max(Q.length, 3 * xe); r > a; a++) Q[a] = 0;
      (h.directional.length = ae),
        (h.point.length = re),
        (h.sphere.length = ie),
        (h.tube.length = oe),
        (h.spot.length = ne),
        (h.hemi.length = se),
        (h.area.length = le),
        (h.image.length = he),
        (h.poly.length = de);
    }
    function B(e, t) {
      var a;
      "fragment" === e
        ? (a = Ve.FRAGMENT_SHADER)
        : "vertex" === e && (a = Ve.VERTEX_SHADER);
      var r = Ve.createShader(a);
      Ve.shaderSource(r, t),
        Ve.compileShader(r),
        Ve.getShaderParameter(r, Ve.COMPILE_STATUS) ||
        console.error(e.toUpperCase() + " SHADER COMPILATION FAILED");
      var i = Ve.getShaderInfoLog(r);
      if ("" !== i) {
        var o = XG.DebugUtils.parseGLSLShaderErrorLog(i);
        XG.DebugUtils.prettyPrintShaderErrors(t, o);
      }
      return r;
    }
    function O(e) {
      var t,
        a,
        r = [];
      for (var i in e)
        (t = e[i]),
          t !== !1 &&
          (void 0 !== t
            ? ((a = "#define " + i + " " + t), r.push(a))
            : console.warn(
              "XG.ForwardRenderer generateDefines(): undefined value for label [" +
              i +
              "]"
            ));
      return r.join("\n");
    }
    function V(e) {
      var t,
        a,
        r,
        i = {
          OES_standard_derivatives: "GL_OES_standard_derivatives",
          WEBGL_draw_buffers: "GL_EXT_draw_buffers",
          EXT_shader_texture_lod: "GL_EXT_shader_texture_lod",
          EXT_frag_depth: "GL_EXT_frag_depth",
        },
        o = {
          EXT_shader_texture_lod: !0,
          WEBGL_draw_buffers: !0,
          OES_standard_derivatives: !0,
          EXT_frag_depth: !0,
          OES_element_index_uint: !0,
          ANGLE_instanced_arrays: !0,
          OES_vertex_array_object: !0,
          EXT_blend_minmax: !0,
          EXT_sRGB: !0,
        },
        n = [];
      for (var s in e)
        (a = e[s]),
          (pa && o[s]) ||
          (a !== !1 &&
            (void 0 !== a
              ? ((t = i[s]),
                void 0 !== t
                  ? ((r = "#extension " + t + " : enable"), n.push(r))
                  : console.warn(
                    "XG.ForwardRenderer generateExtensions(): unknown extension [" +
                    s +
                    "]"
                  ))
              : console.warn(
                "XG.ForwardRenderer generateExtensions(): undefined state for extension [" +
                s +
                "]"
              )));
      return n.join("\n");
    }
    function k(e, t, a, r, i) {
      var o = t.fragmentShader,
        n = t.vertexShader,
        s = t.extensions || {},
        l = t.defines || {},
        h = [];
      e ? h.push(e) : (h.push(o), h.push(n));
      var d;
      for (d in l) h.push(d), h.push(l[d]);
      for (d in i) h.push(d), h.push(i[d]);
      for (var c = h.join(), u = 0, f = lt.length; f > u; u++) {
        var p = lt[u];
        if (p.code === c) return p.usedTimes++, p.program;
      }
      var m = "SHADOWMAP_TYPE_BASIC";
      i.shadowMapType === XG.PCFSoftShadowMap
        ? (m = "SHADOWMAP_TYPE_PCF_SOFT")
        : i.shadowMapType === XG.PCFSoftHQShadowMap &&
        (m = "SHADOWMAP_TYPE_PCF_SOFT_HQ");
      var v;
      switch (Oe) {
        case XG.SimpleOperator:
          v = "TONEMAP_SIMPLE";
          break;
        case XG.LinearOperator:
          v = "TONEMAP_LINEAR";
          break;
        case XG.ReinhardOperator:
          v = "TONEMAP_REINHARD";
          break;
        case XG.FilmicOperator:
          v = "TONEMAP_FILMIC";
          break;
        case XG.Filmic2015Operator:
          v = "TONEMAP_FILMIC_2015";
          break;
        case XG.UnchartedOperator:
          v = "TONEMAP_UNCHARTED";
          break;
        case XG.LumaReinhardOperator:
          v = "TONEMAP_REINHARD_LUMA";
          break;
        case XG.WhitePreservingReinhardOperator:
          v = "TONEMAP_REINHARD_WHITE";
          break;
        case XG.PhotographicOperator:
          v = "TONEMAP_PHOTOGRAPHIC";
      }
      var g;
      switch (st.specularBRDF) {
        case XG.SimpleBRDF:
          g = "BRDF_SIMPLE";
          break;
        case XG.BlinnPhongBRDF:
          g = "BRDF_BLINN_PHONG";
          break;
        case XG.GGXBRDF:
          g = "BRDF_GGX";
      }
      var S;
      i.fog instanceof XG.LinearFog
        ? (S = "LINEAR_FOG")
        : i.fog instanceof XG.ExponentialFog
          ? (S = "EXPONENTIAL_FOG")
          : i.fog instanceof XG.AtmosphericFog && (S = "ATMOSPHERIC_FOG");
      var x;
      switch (t.displacementDirection) {
        case XG.DisplaceByNormal:
          x = "DISPLACE_BY_NORMAL";
          break;
        case XG.DisplaceByPosition:
          x = "DISPLACE_BY_POSITION";
      }
      var G = i.maxImageLights > 0 || i.polyTextures,
        M =
          i.bumpMap ||
          i.normalMap ||
          i.bumpDetailMap ||
          i.normalDetailMap ||
          i.normalGlossMap ||
          i.wrapAroundSkin ||
          i.displacementMap ||
          G;
      (s.OES_standard_derivatives = ra && (s.OES_standard_derivatives || !!M)),
        (s.EXT_shader_texture_lod = ha && (s.EXT_shader_texture_lod || !!G));
      var y = V(s),
        w = O(l),
        _ = Ve.createProgram(),
        X = [
          "precision " + Ae + " float;",
          "precision " + Ae + " int;",
          "#if __VERSION__ >= 300",
          "precision highp sampler2DShadow;",
          "precision highp sampler3D;",
          "#endif",
          w,
          st.gammaInput ? "#define GAMMA_INPUT" : "",
          st.gammaOutput ? "#define GAMMA_OUTPUT" : "",
          st.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",
          Oe ? "#define TONEMAPPING" : "",
          v ? "#define " + v : "",
          Ee ? "#define DITHERING_ENABLED" : "",
          i.transparent ? "#define TRANSPARENT" : "",
          i.instances ? "#define USE_INSTANCES" : "",
          "#define " + g,
          "#define MAX_DIR_LIGHTS " + i.maxDirLights,
          "#define MAX_POINT_LIGHTS " + i.maxPointLights,
          "#define MAX_SPHERE_LIGHTS " + i.maxSphereLights,
          "#define MAX_TUBE_LIGHTS " + i.maxTubeLights,
          "#define MAX_SPOT_LIGHTS " + i.maxSpotLights,
          "#define MAX_HEMI_LIGHTS " + i.maxHemiLights,
          "#define MAX_AREA_LIGHTS " + i.maxAreaLights,
          "#define MAX_IMAGE_LIGHTS " + i.maxImageLights,
          "#define MAX_POLY_LIGHTS " + i.maxPolyLights,
          i.areaTextures ? "#define AREA_TEXTURE" : "",
          i.polyTextures ? "#define POLY_TEXTURE" : "",
          oa && st.shadowMapUseDepthTextures
            ? "#define SHADOW_TEXTURE_DEPTH"
            : "#define SHADOW_RGBA_DEPTH",
          "#define MAX_SHADOWS " + i.maxShadows,
          "#define MAX_SHADOWS_2D " + i.maxShadows2d,
          "#define MAX_SHADOWS_CUBE " + i.maxShadowsCube,
          i.alphaTest ? "#define ALPHATEST " + i.alphaTest : "",
          i.map ? "#define USE_MAP" : "",
          i.lightMap ? "#define USE_LIGHTMAP" : "",
          i.lightMapGamma ? "#define LIGHTMAP_GAMMA" : "",
          i.lightMapSecondaryUV ? "#define LIGHTMAP_SECONDARY_UV" : "",
          ra && i.bumpMap ? "#define USE_BUMPMAP" : "",
          ra && i.normalMap ? "#define USE_NORMALMAP" : "",
          ra && i.normalGlossMap ? "#define USE_NORMALGLOSSMAP" : "",
          ra && i.bumpDetailMap ? "#define USE_BUMPDETAILMAP" : "",
          ra && i.normalDetailMap ? "#define USE_NORMALDETAILMAP" : "",
          i.glossMap ? "#define USE_GLOSSMAP" : "",
          i.specularMap ? "#define USE_SPECULARMAP" : "",
          ra && xa && i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
          ra && xa && i.displacementMap ? "#define " + x : "",
          i.vertexColors ? "#define USE_COLOR" : "",
          i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          i.shadowMapEnabled ? "#define " + m : "",
          i.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
          i.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",
          i.shadowSampler ? "#define USE_SHADOWSAMPLER" : "",
          "#define DIR_INDEX_OFFSET " + i.dirIndexOffset,
          "#define SPOT_INDEX_OFFSET " + i.spotIndexOffset,
          "#define AREA_INDEX_OFFSET " + i.areaIndexOffset,
          "#define POLY_INDEX_OFFSET " + i.polyIndexOffset,
          "#define SPHERE_INDEX_OFFSET " + i.sphereIndexOffset,
          "#define POINT_INDEX_OFFSET " + i.pointIndexOffset,
          i.isParticle ? "#define PARTICLE" : "",
          i.sizeAttenuation ? "#define USE_PARTICLE_SIZEATTENUATION" : "",
          i.interpolateParticleFrames
            ? "#define INTERPOLATE_PARTICLE_FRAMES"
            : "",
          i.wrapAround ? "#define WRAP_AROUND" : "",
          ra && i.wrapAroundSkin ? "#define WRAP_AROUND_SKIN" : "",
          i.doubleSided ? "#define DOUBLE_SIDED" : "",
          i.flipSided ? "#define FLIP_SIDED" : "",
          i.osxHack ? "#define OSX_HACK" : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "\n",
        ].join("\n"),
        D = [
          "#if __VERSION__ >= 300",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
          "#define texture2DLod textureLod",
          "#define texture2DProj textureProj",
          "#define texture2DProjLod textureProjLod",
          "#define textureCube texture",
          "#define textureCubeLod textureLod",
          "#define texture2DLodEXT textureLod",
          "#else",
          "#define texture2DLodEXT texture2DLod",
          "#endif",
          xa ? "#define VERTEX_TEXTURES" : "",
          "#define MAX_BONES " + i.maxBones,
          i.skinning ? "#define USE_SKINNING" : "",
          i.useVertexTexture ? "#define BONE_TEXTURE" : "",
          i.boneTextureWidth
            ? "#define N_BONE_PIXEL_X " + i.boneTextureWidth.toFixed(1)
            : "",
          i.boneTextureHeight
            ? "#define N_BONE_PIXEL_Y " + i.boneTextureHeight.toFixed(1)
            : "",
          i.morphTargets ? "#define USE_MORPHTARGETS" : "",
          i.morphNormals ? "#define USE_MORPHNORMALS" : "",
          "#define MAX_MORPHTARGETS " + i.maxMorphTargets,
          "#define MAX_MORPHNORMALS " + i.maxMorphNormals,
          ha ? "#define SUPPORTS_TEXTURE_LOD" : "",
          i.useFog && i.fog ? "#define USE_FOG" : "",
          i.useFog && i.fog ? "#define " + S : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat3 normalMatrix;",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "attribute vec2 uv2;",
          "#ifdef USE_COLOR",
          "attribute vec3 color;",
          "#endif",
          "#ifdef USE_MORPHTARGETS",
          "attribute vec3 morphTarget0;",
          "attribute vec3 morphTarget1;",
          "attribute vec3 morphTarget2;",
          "attribute vec3 morphTarget3;",
          "#ifdef USE_MORPHNORMALS",
          "attribute vec3 morphNormal0;",
          "attribute vec3 morphNormal1;",
          "attribute vec3 morphNormal2;",
          "attribute vec3 morphNormal3;",
          "#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "attribute vec4 skinIndex;",
          "attribute vec4 skinWeight;",
          "#endif",
          "",
        ].join("\n"),
        T = [
          "#if __VERSION__ >= 300",
          "#define varying in",
          "#ifdef MRT_OUTPUT",
          "out vec4 mgl_FragData[ " + fa + " ];",
          "#else",
          "out vec4 mgl_FragColor;",
          "#endif",
          "#define texture2D texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define textureCube texture",
          "#define textureCubeLodEXT textureLod",
          "#define shadow2D texture",
          "#else",
          "#define mgl_FragColor gl_FragColor",
          "#define mgl_FragData  gl_FragData",
          "#endif",
          "",
          ha ? "#define SUPPORTS_TEXTURE_LOD" : "",
          i.useFog && i.fog ? "#define USE_FOG" : "",
          i.useFog && i.fog ? "#define " + S : "",
          i.metal ? "#define METAL" : "",
          i.parallax ? "#define USE_PARALLAX" : "",
          i.parallax && i.parallaxRefineSteps > 0
            ? "#define PARALLAX_REFINE_STEPS " +
            i.parallaxRefineSteps.toFixed(0)
            : "",
          "",
        ].join("\n"),
        C = y + "\n" + X + T + o,
        A = X + D + n;
      pa && ((C = "#version 300 es\n" + C), (A = "#version 300 es\n" + A));
      var P = B("fragment", C),
        L = B("vertex", A);
      Ve.attachShader(_, L),
        Ve.attachShader(_, P),
        Ve.linkProgram(_),
        Ve.getProgramParameter(_, Ve.LINK_STATUS) ||
        console.error(
          "Could not link shader program\nVALIDATE_STATUS: " +
          Ve.getProgramParameter(_, Ve.VALIDATE_STATUS) +
          "\nGL_ERROR: " +
          XG.DebugUtils.translateGLErrorCode(Ve.getError())
        );
      var b = Ve.getProgramInfoLog(_);
      if ("" !== b)
        if (rt) {
          var E =
            (rt.getTranslatedShaderSource(L),
              rt.getTranslatedShaderSource(P)),
            F = XG.DebugUtils.parseTranslatedShaderErrorLog(b);
          XG.DebugUtils.prettyPrintTranslatedShaderErrors(E, F);
        } else console.warn("PROGRAM_INFO_LOG: " + b);
      Ve.deleteShader(P),
        Ve.deleteShader(L),
        (_.uniforms = {}),
        (_.attributes = {});
      var R;
      R = [];
      for (d in a) R.push(d);
      z(_, R), (R = []);
      for (d in r) R.push(d);
      return (
        H(_, R),
        (_.id = ht++),
        lt.push({ program: _, code: c, usedTimes: 1 }),
        (st.info.memory.programs = lt.length),
        _
      );
    }
    function z(e, t) {
      var a, r, i;
      for (a = 0, r = t.length; r > a; a++)
        (i = t[a]), (e.uniforms[i] = Ve.getUniformLocation(e, i));
    }
    function H(e, t) {
      var a, r, i;
      for (a = 0, r = t.length; r > a; a++)
        (i = t[a]), (e.attributes[i] = Ve.getAttribLocation(e, i));
    }
    function W(e) {
      return 0 === (e & (e - 1));
    }
    function j(e, t, a) {
      a
        ? (Ve.texParameteri(e, Ve.TEXTURE_WRAP_S, t.wrapS),
          Ve.texParameteri(e, Ve.TEXTURE_WRAP_T, t.wrapT),
          Ve.texParameteri(e, Ve.TEXTURE_MAG_FILTER, t.magFilter),
          Ve.texParameteri(e, Ve.TEXTURE_MIN_FILTER, t.minFilter))
        : (Ve.texParameteri(e, Ve.TEXTURE_WRAP_S, Ve.CLAMP_TO_EDGE),
          Ve.texParameteri(e, Ve.TEXTURE_WRAP_T, Ve.CLAMP_TO_EDGE),
          Ve.texParameteri(e, Ve.TEXTURE_MAG_FILTER, ve(t.magFilter)),
          Ve.texParameteri(e, Ve.TEXTURE_MIN_FILTER, ve(t.minFilter))),
        qe &&
        t.type !== XG.FloatType &&
        (t.anisotropy > 1 || t.__oldAnisotropy) &&
        (Ve.texParameterf(
          e,
          qe.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(t.anisotropy, Sa)
        ),
          (t.__oldAnisotropy = t.anisotropy));
    }
    function q(e, t, a) {
      a
        ? (Ve.texParameteri(e, Ve.TEXTURE_WRAP_R, t.wrapR),
          Ve.texParameteri(e, Ve.TEXTURE_WRAP_S, t.wrapS),
          Ve.texParameteri(e, Ve.TEXTURE_WRAP_T, t.wrapT),
          Ve.texParameteri(e, Ve.TEXTURE_MAG_FILTER, t.magFilter),
          Ve.texParameteri(e, Ve.TEXTURE_MIN_FILTER, t.minFilter))
        : (Ve.texParameteri(e, Ve.TEXTURE_WRAP_R, Ve.CLAMP_TO_EDGE),
          Ve.texParameteri(e, Ve.TEXTURE_WRAP_S, Ve.CLAMP_TO_EDGE),
          Ve.texParameteri(e, Ve.TEXTURE_WRAP_T, Ve.CLAMP_TO_EDGE),
          Ve.texParameteri(e, Ve.TEXTURE_MAG_FILTER, ve(t.magFilter)),
          Ve.texParameteri(e, Ve.TEXTURE_MIN_FILTER, ve(t.minFilter))),
        qe &&
        t.type !== XG.FloatType &&
        (t.anisotropy > 1 || t.__oldAnisotropy) &&
        (Ve.texParameterf(
          e,
          qe.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(t.anisotropy, Sa)
        ),
          (t.__oldAnisotropy = t.anisotropy));
    }
    function Y(e, t) {
      Ve.activeTexture(Ve.TEXTURE0 + t),
        Ve.bindTexture(Ve.TEXTURE_2D, e.__webglTexture),
        (Ot[t] = e.id),
        Ve.pixelStorei(Ve.UNPACK_FLIP_Y_WEBGL, e.flipY),
        Ve.pixelStorei(Ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha),
        Ve.pixelStorei(Ve.UNPACK_ALIGNMENT, e.unpackAlignment);
      var a = e.image,
        r = W(a.width) && W(a.height),
        i = e.format,
        o = e.type;
      j(Ve.TEXTURE_2D, e, r);
      var n,
        s = e.mipmaps;
      if (e instanceof XG.DataTexture) {
        var l = i,
          h = i;
        if (
          (pa &&
            (i === XG.LuminanceAlphaFormat &&
              (o === XG.FloatType
                ? ((l = XG.RG32F), (h = XG.RG))
                : o === XG.HalfFloatType2 && ((l = XG.RG16F), (h = XG.RG))),
              i === XG.RGBAFormat &&
              (o === XG.FloatType
                ? ((l = XG.RGBA32F), (h = XG.RGBAFormat))
                : o === XG.HalfFloatType2 &&
                ((l = XG.RGBA16F), (h = XG.RGBAFormat)))),
            s.length > 0 && r)
        ) {
          for (var d = 0, c = s.length; c > d; d++)
            (n = s[d]),
              Ve.texImage2D(
                Ve.TEXTURE_2D,
                d,
                l,
                n.width,
                n.height,
                0,
                h,
                o,
                n.data
              );
          e.generateMipmaps = !1;
        } else
          Ve.texImage2D(
            Ve.TEXTURE_2D,
            0,
            l,
            a.width,
            a.height,
            0,
            h,
            o,
            a.data
          );
      } else if (e instanceof XG.CompressedTexture)
        for (var d = 0, c = s.length; c > d; d++)
          if (
            ((n = s[d]),
              Ve.pixelStorei(Ve.UNPACK_ALIGNMENT, n.unpackAlignment),
              i === XG.RGBAFormat ||
              i === XG.RGBFormat ||
              i === XG.LuminanceAlphaFormat ||
              i === XG.LuminanceFormat)
          ) {
            var u = ie(i, o);
            Ve.texImage2D(
              Ve.TEXTURE_2D,
              d,
              u,
              n.width,
              n.height,
              0,
              i,
              o,
              n.data
            );
          } else
            Ve.compressedTexImage2D(
              Ve.TEXTURE_2D,
              d,
              i,
              n.width,
              n.height,
              0,
              n.data
            );
      else if (s.length > 0 && r) {
        for (var d = 0, c = s.length; c > d; d++)
          (n = s[d]), Ve.texImage2D(Ve.TEXTURE_2D, d, i, i, o, n);
        e.generateMipmaps = !1;
      } else Ve.texImage2D(Ve.TEXTURE_2D, 0, i, i, o, e.image);
      e.generateMipmaps && r && Ve.generateMipmap(Ve.TEXTURE_2D),
        (e.needsUpdate = !1),
        e.onUpdate && e.onUpdate();
    }
    function K(e, t) {
      if (e.width <= t && e.height <= t) return e;
      var a = Math.max(e.width, e.height),
        r = Math.floor((e.width * t) / a),
        i = Math.floor((e.height * t) / a),
        o = document.createElement("canvas");
      (o.width = r), (o.height = i);
      var n = o.getContext("2d");
      return n.drawImage(e, 0, 0, e.width, e.height, 0, 0, r, i), o;
    }
    function Z(e, t) {
      Ve.activeTexture(Ve.TEXTURE0 + t),
        Ve.bindTexture(Ve.TEXTURE_CUBE_MAP, e.image.__webglTextureCube),
        (Ot[t] = e.id),
        Ve.pixelStorei(Ve.UNPACK_FLIP_Y_WEBGL, e.flipY),
        Ve.pixelStorei(Ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha),
        Ve.pixelStorei(Ve.UNPACK_ALIGNMENT, e.unpackAlignment);
      for (var a = e instanceof XG.CompressedTexture, r = [], i = 0; 6 > i; i++)
        r[i] = st.autoScaleCubemaps && !a ? K(e.image[i], ga) : e.image[i];
      var o = r[0],
        n = W(o.width) && W(o.height),
        s = e.format,
        l = e.type;
      j(Ve.TEXTURE_CUBE_MAP, e, n);
      for (var i = 0; 6 > i; i++) {
        var h = r[i].mipmaps;
        if (h && h.length > 0)
          for (var d = 0, c = h.length; c > d; d++) {
            var u = h[d];
            if (
              (Ve.pixelStorei(Ve.UNPACK_ALIGNMENT, u.unpackAlignment),
                s === XG.RGBAFormat ||
                s === XG.RGBFormat ||
                s === XG.LuminanceAlphaFormat ||
                s === XG.LuminanceFormat)
            ) {
              var f = ie(s, l);
              Ve.texImage2D(
                Ve.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                d,
                f,
                u.width,
                u.height,
                0,
                s,
                l,
                u.data
              );
            } else
              Ve.compressedTexImage2D(
                Ve.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                d,
                s,
                u.width,
                u.height,
                0,
                u.data
              );
          }
        else
          Ve.texImage2D(Ve.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, s, s, l, r[i]);
      }
      e.generateMipmaps &&
        n &&
        (Ve.generateMipmap(Ve.TEXTURE_CUBE_MAP),
          (e.mipmapCount = Math.log(Math.max(o.width, o.height)) / Math.LN2)),
        (e.needsUpdate = !1),
        e.onUpdate && e.onUpdate();
    }
    function Q(e, t) {
      if (!e.__webglInit) {
        (e.__webglInit = !0),
          (e.image.__webglTextureCube = Ve.createTexture()),
          st.info.memory.textures++,
          Ve.activeTexture(Ve.TEXTURE0 + t),
          Ve.bindTexture(Ve.TEXTURE_CUBE_MAP, e.image.__webglTextureCube),
          (Ot[t] = e.id);
        for (var a = 0; 6 > a; a++)
          Ve.texImage2D(
            Ve.TEXTURE_CUBE_MAP_POSITIVE_X + a,
            0,
            Ve.RGBA,
            1,
            1,
            0,
            Ve.RGBA,
            Ve.UNSIGNED_BYTE,
            aa
          );
      }
      e.needsUpdate && Z(e, t),
        Ot[t] !== e.id &&
        e.image.__webglTextureCube &&
        (Ve.activeTexture(Ve.TEXTURE0 + t),
          Ve.bindTexture(Ve.TEXTURE_CUBE_MAP, e.image.__webglTextureCube),
          (Ot[t] = e.id));
    }
    function J(e, t) {
      e.__webglInit || (pe(e), (e.__webglInit = !0)),
        Ot[t] !== e.id &&
        e.__webglTexture &&
        (Ve.activeTexture(Ve.TEXTURE0 + t),
          Ve.bindTexture(Ve.TEXTURE_CUBE_MAP, e.__webglTexture),
          (Ot[t] = e.id));
    }
    function $(e, t) {
      Ve.activeTexture(Ve.TEXTURE0 + t),
        Ve.bindTexture(Ve.TEXTURE_3D, e.__webglTexture3D),
        (Ot[t] = e.id),
        Ve.pixelStorei(Ve.UNPACK_FLIP_Y_WEBGL, e.flipY),
        Ve.pixelStorei(Ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha),
        Ve.pixelStorei(Ve.UNPACK_ALIGNMENT, e.unpackAlignment),
        Ve.pixelStorei(Ve.UNPACK_IMAGE_HEIGHT, e.unpackImageHeight);
      var a = e.width,
        r = e.height,
        i = e.depth,
        o = e.image,
        n = W(a) && W(r) && W(i),
        s = e.format,
        l = e.type;
      q(Ve.TEXTURE_3D, e, n);
      var h,
        d = e.mipmaps;
      if (e instanceof XG.DataTexture3D) {
        var c = s,
          u = s;
        if (
          (pa &&
            (s === XG.LuminanceAlphaFormat &&
              (l === XG.FloatType
                ? ((c = XG.RG32F), (u = XG.RG))
                : l === XG.HalfFloatType2 && ((c = XG.RG16F), (u = XG.RG))),
              s === XG.RGBAFormat &&
              (l === XG.FloatType
                ? ((c = XG.RGBA32F), (u = XG.RGBAFormat))
                : l === XG.HalfFloatType2 &&
                ((c = XG.RGBA16F), (u = XG.RGBAFormat)))),
            d.length > 0 && n)
        ) {
          for (var f = 0, p = d.length; p > f; f++)
            (h = d[f]),
              Ve.texImage3D(
                Ve.TEXTURE_3D,
                f,
                c,
                h.width,
                h.height,
                h.depth,
                0,
                u,
                l,
                h.data
              );
          e.generateMipmaps = !1;
        } else Ve.texImage3D(Ve.TEXTURE_3D, 0, c, a, r, i, 0, u, l, o.data);
      } else if (e instanceof XG.CompressedTexture3D)
        for (var f = 0, p = d.length; p > f; f++)
          if (
            ((h = d[f]),
              Ve.pixelStorei(Ve.UNPACK_ALIGNMENT, h.unpackAlignment),
              s === XG.RGBAFormat ||
              s === XG.RGBFormat ||
              s === XG.LuminanceAlphaFormat ||
              s === XG.LuminanceFormat)
          ) {
            var m = ie(s, l);
            Ve.texImage3D(
              Ve.TEXTURE_3D,
              f,
              m,
              h.width,
              h.height,
              h.depth,
              0,
              s,
              l,
              h.data
            );
          } else
            Ve.compressedTexImage3D(
              Ve.TEXTURE_3D,
              f,
              s,
              h.width,
              h.height,
              h.depth,
              0,
              h.data
            );
      else if (d.length > 0 && n) {
        for (var f = 0, p = d.length; p > f; f++)
          (h = d[f]),
            Ve.texImage3D(
              Ve.TEXTURE_3D,
              f,
              s,
              h.width,
              h.height,
              h.depth,
              0,
              s,
              l,
              h
            );
        e.generateMipmaps = !1;
      } else Ve.texImage3D(Ve.TEXTURE_3D, 0, s, a, r, i, 0, s, l, e.image);
      e.generateMipmaps && n && Ve.generateMipmap(Ve.TEXTURE_3D),
        (e.needsUpdate = !1),
        e.onUpdate && e.onUpdate();
    }
    function ee(e, t) {
      e.__webglInit ||
        ((e.__webglInit = !0),
          (e.__webglTexture3D = Ve.createTexture()),
          st.info.memory.textures++,
          Ve.activeTexture(Ve.TEXTURE0 + t),
          Ve.bindTexture(Ve.TEXTURE_3D, e.__webglTexture3D),
          (Ot[t] = e.id),
          Ve.texImage3D(
            Ve.TEXTURE_3D,
            0,
            Ve.RGBA,
            1,
            1,
            1,
            0,
            Ve.RGBA,
            Ve.UNSIGNED_BYTE,
            aa
          )),
        e.needsUpdate && $(e, t),
        Ot[t] !== e.id &&
        e.__webglTexture3D &&
        (Ve.activeTexture(Ve.TEXTURE0 + t),
          Ve.bindTexture(Ve.TEXTURE_3D, e.__webglTexture3D),
          (Ot[t] = e.id));
    }
    function te(e, t) {
      e.__webglInit || (pe(e), (e.__webglInit = !0)),
        Ot[t] !== e.id &&
        e.__webglTexture &&
        (Ve.activeTexture(Ve.TEXTURE0 + t),
          Ve.bindTexture(Ve.TEXTURE_3D, e.__webglTexture),
          (Ot[t] = e.id));
    }
    function ae(e, t, a, r, i) {
      Ve.bindFramebuffer(Ve.FRAMEBUFFER, e),
        i &&
        Ve.framebufferTexture2D(
          Ve.FRAMEBUFFER,
          Ve.COLOR_ATTACHMENT0,
          a,
          t.__webglTexture,
          0
        ),
        r &&
        Ve.framebufferTexture2D(
          Ve.FRAMEBUFFER,
          Ve.DEPTH_ATTACHMENT,
          a,
          t.depthTexture.__webglTexture,
          0
        );
    }
    function re(e, t) {
      if (
        (Ve.bindRenderbuffer(Ve.RENDERBUFFER, e),
          t.depthBuffer && !t.stencilBuffer)
      )
        Ve.renderbufferStorage(
          Ve.RENDERBUFFER,
          Ve.DEPTH_COMPONENT16,
          t.width,
          t.height
        ),
          Ve.framebufferRenderbuffer(
            Ve.FRAMEBUFFER,
            Ve.DEPTH_ATTACHMENT,
            Ve.RENDERBUFFER,
            e
          );
      else if (!t.depthBuffer && t.stencilBuffer)
        Ve.renderbufferStorage(
          Ve.RENDERBUFFER,
          Ve.STENCIL_INDEX8,
          t.width,
          t.height
        ),
          Ve.framebufferRenderbuffer(
            Ve.FRAMEBUFFER,
            Ve.STENCIL_ATTACHMENT,
            Ve.RENDERBUFFER,
            e
          );
      else if (t.depthBuffer && t.stencilBuffer) {
        var a = pa ? Ve.DEPTH24_STENCIL8 : Ve.DEPTH_STENCIL;
        Ve.renderbufferStorage(Ve.RENDERBUFFER, a, t.width, t.height),
          Ve.framebufferRenderbuffer(
            Ve.FRAMEBUFFER,
            Ve.DEPTH_STENCIL_ATTACHMENT,
            Ve.RENDERBUFFER,
            e
          );
      }
    }
    function ie(e, t) {
      var a = e;
      if (pa) {
        if (t === XG.HalfFloatType2)
          switch (e) {
            case XG.RGBAFormat:
              a = XG.RGBA16F;
              break;
            case XG.LuminanceAlphaFormat:
              a = XG.RG16F;
              break;
            case XG.LuminanceFormat:
              a = XG.R16F;
          }
        if (t === XG.FloatType)
          switch (e) {
            case XG.RGBAFormat:
              a = XG.RGBA32F;
              break;
            case XG.LuminanceAlphaFormat:
              a = XG.RG32F;
              break;
            case XG.LuminanceFormat:
              a = XG.R32F;
          }
      }
      return a;
    }
    function oe(e) {
      var t;
      if (pa)
        switch (e) {
          case XG.UnsignedShortType:
            t = Ve.DEPTH_COMPONENT16;
            break;
          case XG.UnsignedIntType:
            t = Ve.DEPTH_COMPONENT24;
            break;
          case XG.FloatType:
            t = Ve.DEPTH_COMPONENT32F;
        }
      else t = Ve.DEPTH_COMPONENT;
      return t;
    }
    function ne(e) {
      if (!ia)
        return void console.error(
          "XG.ForwardRenderer: can't create RenderTargetArray"
        );
      var t = e.colorTexture.length;
      (e.__webglFramebuffer = Ve.createFramebuffer()),
        (e.__attachments = []),
        Ve.bindFramebuffer(Ve.FRAMEBUFFER, e.__webglFramebuffer);
      for (var a = 0; t > a; a++)
        e.__attachments.push(Ve.COLOR_ATTACHMENT0 + a);
      pa
        ? Ve.drawBuffers(e.__attachments)
        : at.drawBuffersEXT
          ? at.drawBuffersEXT(e.__attachments)
          : at.drawBuffersWEBGL(e.__attachments),
        (e.__webglTexture = []);
      for (var a = 0; t > a; a++) {
        var r = e.colorTexture[a];
        (r.__webglTexture = Ve.createTexture()), st.info.memory.textures++;
      }
      e.depthTexture
        ? ((e.depthTexture.__webglTexture = Ve.createTexture()),
          st.info.memory.textures++)
        : (e.__webglRenderbuffer = Ve.createRenderbuffer());
    }
    function se(e) {
      var t = W(e.width) && W(e.height),
        a = e.colorTexture.length;
      Ve.bindFramebuffer(Ve.FRAMEBUFFER, e.__webglFramebuffer);
      for (var r = 0; a > r; r++) {
        var i = e.__attachments[r],
          o = e.colorTexture[r];
        o.mrtColorAttachment = i;
        var n = o.internalFormat,
          s = o.format,
          l = o.type;
        Ve.bindTexture(Ve.TEXTURE_2D, o.__webglTexture),
          j(Ve.TEXTURE_2D, o, t),
          Ve.texImage2D(Ve.TEXTURE_2D, 0, n, e.width, e.height, 0, s, l, null),
          Ve.framebufferTexture2D(
            Ve.FRAMEBUFFER,
            i,
            Ve.TEXTURE_2D,
            o.__webglTexture,
            0
          );
      }
      if (e.depthTexture) {
        var h = e.depthTexture.depthTextureType,
          d = oe(h);
        Ve.bindTexture(Ve.TEXTURE_2D, e.depthTexture.__webglTexture),
          j(Ve.TEXTURE_2D, e.depthTexture, t),
          Ve.texImage2D(
            Ve.TEXTURE_2D,
            0,
            d,
            e.width,
            e.height,
            0,
            Ve.DEPTH_COMPONENT,
            h,
            null
          ),
          Ve.framebufferTexture2D(
            Ve.FRAMEBUFFER,
            Ve.DEPTH_ATTACHMENT,
            Ve.TEXTURE_2D,
            e.depthTexture.__webglTexture,
            0
          ),
          (e.depthTexture.needsUpdate = !1);
      } else re(e.__webglRenderbuffer, e);
    }
    function le(e) {
      (e.__webglFramebuffer = []),
        (e.__webglRenderbuffer = []),
        (e.__webglTexture = Ve.createTexture());
      for (var t = 0; 6 > t; t++)
        (e.__webglFramebuffer[t] = Ve.createFramebuffer()),
          (e.__webglRenderbuffer[t] = Ve.createRenderbuffer());
      st.info.memory.textures++;
    }
    function he(e) {
      var t = W(e.width) && W(e.height),
        a = e.internalFormat,
        r = e.format,
        i = e.type;
      Ve.activeTexture(Ve.TEXTURE0),
        Ve.bindTexture(Ve.TEXTURE_CUBE_MAP, e.__webglTexture),
        j(Ve.TEXTURE_CUBE_MAP, e, t);
      for (var o = 0; 6 > o; o++)
        Ve.texImage2D(
          Ve.TEXTURE_CUBE_MAP_POSITIVE_X + o,
          0,
          a,
          e.width,
          e.height,
          0,
          r,
          i,
          null
        ),
          ae(
            e.__webglFramebuffer[o],
            e,
            Ve.TEXTURE_CUBE_MAP_POSITIVE_X + o,
            !1,
            !0
          ),
          re(e.__webglRenderbuffer[o], e);
      t &&
        (e.generateMipmaps ||
          (e.minFilter !== XG.NearestFilter &&
            e.minFilter !== XG.LinearFilter)) &&
        Ve.generateMipmap(Ve.TEXTURE_CUBE_MAP),
        t && (e.mipmapCount = Math.log(Math.max(e.width, e.height)) / Math.LN2);
    }
    function de(e) {
      var t = e.useColorTexture,
        a = e.useDepthTexture && oa;
      if (
        ((e.__webglFramebuffer = Ve.createFramebuffer()),
          t &&
          ((e.__webglTexture = Ve.createTexture()), st.info.memory.textures++),
          e.shareDepthFrom ||
          (a
            ? ((e.depthTexture = {
              __webglTexture: Ve.createTexture(),
              id: XG.TextureIdCount++,
            }),
              st.info.memory.textures++)
            : (e.__webglRenderbuffer = Ve.createRenderbuffer())),
          e.useMRT)
      ) {
        Ve.bindFramebuffer(Ve.FRAMEBUFFER, e.__webglFramebuffer);
        var r = Ve.getParameter(Ve.MAX_COLOR_ATTACHMENTS),
          i = Math.min(r, e.numMRT);
        e.__attachments = [];
        for (var o = 0; i > o; o++)
          e.__attachments.push(Ve.COLOR_ATTACHMENT0 + o);
        Ve.drawBuffers(e.__attachments);
      }
    }
    function ce(e) {
      var t = e.useColorTexture,
        a = e.useDepthTexture && oa,
        r = W(e.width) && W(e.height) && W(e.depth),
        i = e.internalFormat,
        o = e.format,
        n = e.type;
      if (
        (t &&
          (Ve.activeTexture(Ve.TEXTURE0),
            Ve.bindTexture(Ve.TEXTURE_3D, e.__webglTexture),
            q(Ve.TEXTURE_3D, e, r),
            Ve.texImage3D(
              Ve.TEXTURE_3D,
              0,
              i,
              e.width,
              e.height,
              e.depth,
              0,
              o,
              n,
              null
            ),
            r && e.generateMipmaps && Ve.generateMipmap(Ve.TEXTURE_3D)),
          Ve.bindFramebuffer(Ve.FRAMEBUFFER, e.__webglFramebuffer),
          t)
      )
        if (e.useMRT)
          for (
            var s = Ve.getParameter(Ve.MAX_COLOR_ATTACHMENTS),
            l = Math.min(s, e.numMRT),
            h = 0;
            l > h;
            h++
          )
            Ve.framebufferTextureLayer(
              Ve.DRAW_FRAMEBUFFER,
              Ve.COLOR_ATTACHMENT0 + h,
              e.__webglTexture,
              0,
              e.activeLayer + h
            );
        else
          Ve.framebufferTextureLayer(
            Ve.DRAW_FRAMEBUFFER,
            Ve.COLOR_ATTACHMENT0,
            e.__webglTexture,
            0,
            e.activeLayer
          );
      a &&
        Ve.framebufferTextureLayer(
          Ve.DRAW_FRAMEBUFFER,
          Ve.DEPTH_ATTACHMENT,
          e.depthTexture.__webglTexture,
          0,
          e.activeLayer
        );
    }
    function ue(e) {
      var t = e.useColorTexture,
        a = e.useDepthTexture && oa;
      (e.__webglFramebuffer = Ve.createFramebuffer()),
        t &&
        !e.mrtColorAttachment &&
        ((e.__webglTexture = Ve.createTexture()), st.info.memory.textures++),
        e.shareDepthFrom ||
        (a
          ? ((e.depthTexture = {
            __webglTexture: Ve.createTexture(),
            id: XG.TextureIdCount++,
          }),
            st.info.memory.textures++)
          : (e.__webglRenderbuffer = Ve.createRenderbuffer()));
    }
    function fe(e) {
      var t = e.useColorTexture,
        a = e.useDepthTexture && oa,
        r = W(e.width) && W(e.height),
        i = e.internalFormat,
        o = e.format,
        n = e.type;
      if (
        (t &&
          !e.mrtColorAttachment &&
          (Ve.activeTexture(Ve.TEXTURE0),
            Ve.bindTexture(Ve.TEXTURE_2D, e.__webglTexture),
            j(Ve.TEXTURE_2D, e, r),
            Ve.texImage2D(Ve.TEXTURE_2D, 0, i, e.width, e.height, 0, o, n, null),
            r && e.generateMipmaps && Ve.generateMipmap(Ve.TEXTURE_2D)),
          a)
      )
        if (e.shareDepthFrom) e.depthTexture = e.shareDepthFrom.depthTexture;
        else {
          var s = e.depthTextureType,
            l = oe(s);
          Ve.bindTexture(Ve.TEXTURE_2D, e.depthTexture.__webglTexture),
            j(Ve.TEXTURE_2D, e, r),
            pa &&
            (Ve.texParameteri(
              Ve.TEXTURE_2D,
              Ve.TEXTURE_COMPARE_MODE,
              Ve.COMPARE_REF_TO_TEXTURE
            ),
              Ve.texParameteri(
                Ve.TEXTURE_2D,
                Ve.TEXTURE_COMPARE_FUNC,
                Ve.LEQUAL
              )),
            Ve.texImage2D(
              Ve.TEXTURE_2D,
              0,
              l,
              e.width,
              e.height,
              0,
              Ve.DEPTH_COMPONENT,
              s,
              null
            );
        }
      ae(e.__webglFramebuffer, e, Ve.TEXTURE_2D, a, t),
        a ||
        (e.shareDepthFrom && e.shareDepthFrom.depthTexture
          ? ((e.depthTexture = e.shareDepthFrom.depthTexture),
            Ve.framebufferTexture2D(
              Ve.FRAMEBUFFER,
              Ve.DEPTH_ATTACHMENT,
              Ve.TEXTURE_2D,
              e.depthTexture.__webglTexture,
              0
            ))
          : e.shareDepthFrom
            ? ((e.__webglRenderbuffer = e.shareDepthFrom.__webglRenderbuffer),
              e.depthBuffer && !e.stencilBuffer
                ? Ve.framebufferRenderbuffer(
                  Ve.FRAMEBUFFER,
                  Ve.DEPTH_ATTACHMENT,
                  Ve.RENDERBUFFER,
                  e.__webglRenderbuffer
                )
                : e.depthBuffer &&
                e.stencilBuffer &&
                Ve.framebufferRenderbuffer(
                  Ve.FRAMEBUFFER,
                  Ve.DEPTH_STENCIL_ATTACHMENT,
                  Ve.RENDERBUFFER,
                  e.__webglRenderbuffer
                ))
            : re(e.__webglRenderbuffer, e));
    }
    function pe(e) {
      if (e.needsUpdate) {
        var t = e instanceof XG.RenderTargetCube,
          a = e instanceof XG.RenderTargetArray,
          r = e instanceof XG.RenderTarget3D;
        void 0 === e.__webglFramebuffer &&
          (void 0 === e.depthBuffer && (e.depthBuffer = !0),
            void 0 === e.stencilBuffer && (e.stencilBuffer = !0),
            a ? ne(e) : t ? le(e) : r ? de(e) : ue(e)),
          a ? se(e) : t ? he(e) : r ? ce(e) : fe(e),
          t
            ? Ve.bindTexture(Ve.TEXTURE_CUBE_MAP, null)
            : r
              ? Ve.bindTexture(Ve.TEXTURE_3D, null)
              : Ve.bindTexture(Ve.TEXTURE_2D, null),
          (Ot[0] = -1),
          Ve.bindRenderbuffer(Ve.RENDERBUFFER, null),
          Ve.bindFramebuffer(Ve.FRAMEBUFFER, null),
          (e.needsUpdate = !1),
          e.onUpdate && e.onUpdate();
      }
    }
    function me(e) {
      if ((Ve.activeTexture(Ve.TEXTURE0), e instanceof XG.RenderTargetCube))
        Ve.bindTexture(Ve.TEXTURE_CUBE_MAP, e.__webglTexture),
          Ve.generateMipmap(Ve.TEXTURE_CUBE_MAP),
          Ve.bindTexture(Ve.TEXTURE_CUBE_MAP, null);
      else if (e instanceof XG.RenderTarget3D)
        Ve.bindTexture(Ve.TEXTURE_3D, e.__webglTexture),
          Ve.generateMipmap(Ve.TEXTURE_3D),
          Ve.bindTexture(Ve.TEXTURE_3D, null);
      else if (e instanceof XG.RenderTargetArray) {
        for (var t = 0, a = e.colorTexture.length; a > t; t++)
          Ve.bindTexture(Ve.TEXTURE_2D, e.colorTexture[t].__webglTexture),
            Ve.generateMipmap(Ve.TEXTURE_2D);
        Ve.bindTexture(Ve.TEXTURE_2D, null);
      } else
        Ve.bindTexture(Ve.TEXTURE_2D, e.__webglTexture),
          Ve.generateMipmap(Ve.TEXTURE_2D),
          Ve.bindTexture(Ve.TEXTURE_2D, null);
      Ot[0] = -1;
    }
    function ve(e) {
      return e === XG.NearestFilter ||
        e === XG.NearestMipMapNearestFilter ||
        e === XG.NearestMipMapLinearFilter
        ? Ve.NEAREST
        : Ve.LINEAR;
    }
    function ge(e) {
      if (Ga && e && e.useVertexTexture) return 1024;
      var t = Ve.getParameter(Ve.MAX_VERTEX_UNIFORM_VECTORS),
        a = Math.floor((t - 20) / 4),
        r = a;
      return (
        void 0 !== e &&
        e instanceof XG.SkinnedMesh &&
        ((r = Math.min(e.bones.length, r)),
          r < e.bones.length &&
          console.warn(
            "XG.ForwardRenderer: too many bones - " +
            e.bones.length +
            ", this GPU supports just " +
            r +
            " (try OpenGL instead of ANGLE)"
          )),
        r
      );
    }
    function Se(e) {
      var t, a, r, i, o, n, s, l, h, d, c, u, f, p, m, v, g, S;
      (a = r = i = o = n = s = l = h = d = c = u = 0),
        (f = p = m = v = g = S = 0);
      for (var x = 0, G = e.length; G > x; x++)
        (t = e[x]),
          t.onlyShadow ||
          (t instanceof XG.DirectionalLight && (a++, t.castShadow && f++),
            t instanceof XG.SpotLight && (n++, t.castShadow && p++),
            t instanceof XG.AreaLight &&
            (l++, t.texture && h++, t.castShadow && m++),
            t instanceof XG.PolyLight &&
            (c++, t.texture && u++, t.castShadow && v++),
            t instanceof XG.DayLight && (a++, s++, t.castShadow && f++),
            t instanceof XG.DayLightCube && (a++, d++, t.castShadow && f++),
            t instanceof XG.SphereLight && (i++, t.castShadow && g++),
            t instanceof XG.PointLight && (r++, t.castShadow && S++),
            t instanceof XG.TubeLight && o++,
            t instanceof XG.HemisphereLight && s++,
            t instanceof XG.ImageLight && d++);
      var M = 0,
        y = M + f,
        w = y + p,
        _ = w + m,
        X = _ + v,
        D = X + g,
        T = {
          directional: a,
          point: r,
          sphere: i,
          tube: o,
          spot: n,
          hemi: s,
          area: l,
          areaTextures: h,
          image: d,
          poly: c,
          polyTextures: u,
          dirIndexOffset: M,
          spotIndexOffset: y,
          areaIndexOffset: w,
          polyIndexOffset: _,
          sphereIndexOffset: X,
          pointIndexOffset: D,
        };
      return T;
    }
    function xe(e) {
      var t,
        a,
        r,
        i = 0,
        o = 0,
        n = 0;
      for (t = 0, a = e.length; a > t; t++)
        (r = e[t]),
          r.castShadow &&
          ((r instanceof XG.SphereLight || r instanceof XG.PointLight) &&
            (i++, n++),
            (r instanceof XG.SpotLight ||
              r instanceof XG.AreaLight ||
              r instanceof XG.PolyLight) &&
            (i++, o++),
            (r instanceof XG.DirectionalLight ||
              r instanceof XG.DayLight ||
              r instanceof XG.DayLightCube) &&
            !r.shadowCascade &&
            (i++, o++));
      var s = { maxShadows: i, maxShadows2d: o, maxShadowsCube: n };
      return s;
    }
    function Ge(e, t, a) {
      var r = Ve.createFramebuffer(),
        i = Ve.createTexture();
      Ve.activeTexture(Ve.TEXTURE0),
        Ve.bindTexture(Ve.TEXTURE_2D, i),
        Ve.texImage2D(Ve.TEXTURE_2D, 0, e, 2, 2, 0, t, a, null),
        Ve.bindFramebuffer(Ve.FRAMEBUFFER, r),
        Ve.framebufferTexture2D(
          Ve.FRAMEBUFFER,
          Ve.COLOR_ATTACHMENT0,
          Ve.TEXTURE_2D,
          i,
          0
        );
      var o = Ve.checkFramebufferStatus(Ve.FRAMEBUFFER);
      return (
        Ve.bindFramebuffer(Ve.FRAMEBUFFER, null),
        Ve.bindTexture(Ve.TEXTURE_2D, null),
        (Ot[0] = -1),
        o === Ve.FRAMEBUFFER_COMPLETE
      );
    }
    function Me() {
      var e = XG.UnsignedIntType,
        t = oe(e),
        a = Ve.createFramebuffer(),
        r = Ve.createTexture();
      Ve.activeTexture(Ve.TEXTURE0),
        Ve.bindTexture(Ve.TEXTURE_2D, r),
        Ve.texImage2D(
          Ve.TEXTURE_2D,
          0,
          t,
          2,
          2,
          0,
          Ve.DEPTH_COMPONENT,
          e,
          null
        ),
        Ve.bindFramebuffer(Ve.FRAMEBUFFER, a),
        Ve.framebufferTexture2D(
          Ve.FRAMEBUFFER,
          Ve.DEPTH_ATTACHMENT,
          Ve.TEXTURE_2D,
          r,
          0
        );
      var i = Ve.checkFramebufferStatus(Ve.FRAMEBUFFER);
      return (
        Ve.bindFramebuffer(Ve.FRAMEBUFFER, null),
        Ve.bindTexture(Ve.TEXTURE_2D, null),
        (Ot[0] = -1),
        i === Ve.FRAMEBUFFER_COMPLETE
      );
    }
    function ye() {
      (He = Ve.getExtension("OES_texture_float_linear")),
        (qe =
          Ve.getExtension("EXT_texture_filter_anisotropic") ||
          Ve.getExtension("WEBKIT_EXT_texture_filter_anisotropic")),
        (Qe =
          Ve.getExtension("WEBGL_compressed_texture_s3tc") ||
          Ve.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc")),
        (Je =
          Ve.getExtension("WEBGL_compressed_texture_pvrtc") ||
          Ve.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc")),
        ($e =
          Ve.getExtension("WEBGL_compressed_texture_atc") ||
          Ve.getExtension("WEBKIT_WEBGL_compressed_texture_atc")),
        (et =
          Ve.getExtension("WEBGL_compressed_texture_etc1") ||
          Ve.getExtension("WEBKIT_WEBGL_compressed_texture_etc1")),
        (rt = Ve.getExtension("WEBGL_debug_shaders")),
        null === He &&
        console.log("XG: linear filtering for float textures not supported."),
        null === qe &&
        console.log("XG: anisotropic texture filtering not supported."),
        null === Qe &&
        console.log("XG: S3TC compressed textures not supported.");
    }
    function we() {
      try {
        var e = {
          alpha: Pe,
          premultipliedAlpha: Le,
          antialias: be,
          stencil: Fe,
          depth: Re,
          preserveDrawingBuffer: Ue,
        };
        if (
          ((Ve =
            Te.getContext("webgl2", e) ||
            Te.getContext("experimental-webgl2", e)),
            null === Ve)
        )
          throw "Error creating WebGL 2 context.";
      } catch (t) {
        console.error(t);
      }
      console.log("XG: using WebGL 2 backend"),
        ye(),
        (it =
          Ve.getExtension("WEBGL_color_buffer_float") ||
          Ve.getExtension("EXT_color_buffer_float")),
        (ot = Ve.getExtension("EXT_color_buffer_half_float")),
        null === it &&
        console.log("XG: rendering into float textures not supported."),
        null === ot &&
        console.log("XG: rendering into half float textures not supported.");
    }
    function _e() {
      try {
        var e = {
          alpha: Pe,
          premultipliedAlpha: Le,
          antialias: be,
          stencil: Fe,
          depth: Re,
          preserveDrawingBuffer: Ue,
        };
        if (
          ((Ve =
            Te.getContext("webgl", e) ||
            Te.getContext("experimental-webgl", e)),
            null === Ve)
        )
          throw "Error creating WebGL context.";
      } catch (t) {
        console.error(t);
      }
      console.log("XG: using WebGL 1 backend"),
        ye(),
        (ke = Ve.getExtension("OES_texture_float")),
        (ze = Ve.getExtension("OES_texture_half_float")),
        (We = Ve.getExtension("OES_texture_half_float_linear")),
        (je = Ve.getExtension("OES_standard_derivatives")),
        (tt = Ve.getExtension("OES_element_index_uint")),
        (Ke =
          Ve.getExtension("WEBGL_depth_texture") ||
          Ve.getExtension("WEBKIT_WEBGL_depth_texture")),
        (at =
          Ve.getExtension("WEBGL_draw_buffers") ||
          Ve.getExtension("WEBKIT_EXT_draw_buffers")),
        (Ze = Ve.getExtension("EXT_frag_depth")),
        (Ye = Ve.getExtension("EXT_shader_texture_lod")),
        (nt = Ve.getExtension("ANGLE_instanced_arrays")),
        null === ke && console.log("XG: float textures not supported."),
        null === ze && console.log("XG: half float textures not supported."),
        null === We &&
        console.log(
          "XG: linear filtering for half float textures not supported."
        ),
        null === je && console.log("XG: standard derivatives not supported."),
        null === tt &&
        console.log("XG: 32-bit unsigned integer indices not supported."),
        null === Ke && console.log("XG: depth texture not supported."),
        null === at &&
        console.log("XG: multiple render targets not supported."),
        null === Ze && console.log("XG: fragment depth setting not supported."),
        null === Ye &&
        console.log("XG: fragment shader texture LOD not supported."),
        null === nt && console.log("XG: instancing not supported.");
    }
    function Xe() {
      Ve.clearColor(0, 0, 0, 1),
        Ve.clearDepth(1),
        Ve.clearStencil(0),
        Ve.enable(Ve.DEPTH_TEST),
        Ve.depthFunc(Ve.LEQUAL),
        Ve.frontFace(Ve.CCW),
        Ve.cullFace(Ve.BACK),
        Ve.enable(Ve.CULL_FACE),
        Ve.enable(Ve.BLEND),
        Ve.blendEquation(Ve.FUNC_ADD),
        Ve.blendFunc(Ve.SRC_ALPHA, Ve.ONE_MINUS_SRC_ALPHA),
        Ve.disable(Ve.STENCIL_TEST),
        Ve.clearColor(Ie.r, Ie.g, Ie.b, Ne);
    }
    function De() {
      (st.shadowMapPlugin = new XG.ShadowMapPlugin()),
        st.addPrePlugin(st.shadowMapPlugin);
    }
    e = e || {};
    var Te = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"),
      Ce = void 0 !== e.backend ? e.backend : "webgl1",
      Ae = void 0 !== e.precision ? e.precision : "highp",
      Pe = void 0 !== e.alpha ? e.alpha : !1,
      Le = void 0 !== e.premultipliedAlpha ? e.premultipliedAlpha : !0,
      be = void 0 !== e.antialias ? e.antialias : !1,
      Ee = void 0 !== e.dither ? e.dither : !1,
      Fe = void 0 !== e.stencil ? e.stencil : !0,
      Re = void 0 !== e.depth ? e.depth : !0,
      Ue = void 0 !== e.preserveDrawingBuffer ? e.preserveDrawingBuffer : !1,
      Ie = new XG.Color(void 0 !== e.clearColor ? e.clearColor : 0),
      Ne = void 0 !== e.clearAlpha ? e.clearAlpha : 0,
      Be = void 0 !== e.scale ? e.scale : 1,
      Oe = void 0 !== e.tonemapping ? e.tonemapping : XG.SimpleOperator;
    (this.brightness = void 0 !== e.brightness ? e.brightness : 1),
      (this.whitePoint = void 0 !== e.whitePoint ? e.whitePoint : 1),
      (this.domElement = Te),
      (this.context = null),
      (this.devicePixelRatio =
        void 0 !== e.devicePixelRatio
          ? e.devicePixelRatio
          : void 0 !== window.devicePixelRatio
            ? window.devicePixelRatio
            : 1),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.autoUpdateObjects = !0),
      (this.autoUpdateScene = !0),
      (this.autoUpdateView = !0),
      (this.gammaInput = !0),
      (this.gammaOutput = !1),
      (this.physicallyBasedShading = !0),
      (this.specularBRDF = XG.GGXBRDF),
      (this.shadowMapEnabled = !1),
      (this.shadowMapAutoUpdate = !0),
      (this.shadowMapType = XG.PCFSoftShadowMap),
      (this.shadowMapCullFace = XG.CullFaceFront),
      (this.shadowMapDebug = !1),
      (this.shadowMapCascade = !1),
      (this.shadowMapUseDepthTextures = !1),
      (this.shadowMapDepthTextureType = XG.UnsignedIntType),
      (this.shadowMapDepthTextureBias = 0),
      (this.shadowMapSlopeDepthBias = !1),
      (this.shadowMapSlopeScale = 2),
      (this.shadowMapSlopeBias = 0),
      (this.shadowMapSlopeMax = 0.001),
      (this.maxMorphTargets = 4),
      (this.maxMorphNormals = 4),
      (this.autoScaleCubemaps = !0),
      (this.renderPluginsPre = []),
      (this.renderPluginsPost = []),
      (this.info = {
        memory: { programs: 0, geometries: 0, textures: 0 },
        render: { calls: 0, vertices: 0, faces: 0, points: 0 },
      });
    var Ve,
      ke,
      ze,
      He,
      We,
      je,
      qe,
      Ye,
      Ke,
      Ze,
      Qe,
      Je,
      $e,
      et,
      tt,
      at,
      rt,
      it,
      ot,
      nt,
      st = this,
      lt = [],
      ht = 0,
      dt = null,
      ct = null,
      ut = -1,
      ft = null,
      pt = null,
      mt = 0,
      vt = 0,
      gt = -1,
      St = -1,
      xt = -1,
      Gt = -1,
      Mt = -1,
      yt = -1,
      wt = -1,
      _t = -1,
      Xt = -1,
      Dt = -1,
      Tt = null,
      Ct = null,
      At = null,
      Pt = 0,
      Lt = 0,
      bt = 0,
      Et = 0,
      Ft = 0,
      Rt = 0,
      Ut = {},
      It = [],
      Nt = {},
      Bt = [],
      Ot = [],
      Vt = new XG.Frustum(),
      kt = new XG.Matrix4(),
      zt = new XG.Vector3(),
      Ht = new XG.Vector3(),
      Wt = new XG.Vector3(),
      jt = new XG.Vector3(),
      qt = new XG.Vector3(),
      Yt = new XG.Vector3(),
      Kt = new XG.Vector3(),
      Zt = new XG.Vector3(),
      Qt = new XG.Vector3(),
      Jt = new XG.Vector3(),
      $t = new XG.Vector3(),
      ea = !0,
      ta = {
        directional: {
          length: 0,
          colors: [],
          positionsNorm: [],
          positionsFull: [],
          pars: [],
        },
        point: { length: 0, colors: [], positions: [], pars: [] },
        sphere: { length: 0, colors: [], positions: [], pars: [] },
        tube: {
          length: 0,
          colors: [],
          positions0: [],
          positions1: [],
          pars: [],
        },
        spot: {
          length: 0,
          colors: [],
          positions: [],
          directions: [],
          pars: [],
        },
        area: {
          length: 0,
          colors: [],
          positions: [],
          normals: [],
          rights: [],
          ups: [],
          attenuations: [],
          pars: [],
          textures: [],
        },
        hemi: { length: 0, skyColors: [], groundColors: [], positions: [] },
        image: {
          length: 0,
          positions: [],
          sizes: [],
          texturesDiffuse: [],
          texturesSpecular: [],
          texturesMip: [],
          pars: [],
        },
        poly: {
          length: 0,
          colors: [],
          points: [],
          pars: [],
          samplerLtcMat: null,
          samplerLtcMag: null,
          textures: [],
          texturesPars: [],
        },
        shadowCasters: [],
      },
      aa = new Uint8Array([0, 0, 0, 255]);
    if ("webgl2" === Ce) {
      we();
      var ra = !0,
        ia = !0,
        oa = !0,
        na = !0,
        sa = !0,
        la = !0,
        ha = !0,
        da = !0,
        ca = !0,
        ua = !0,
        fa = Ve.getParameter(Ve.MAX_DRAW_BUFFERS);
    } else {
      _e();
      var ra = !!je,
        ia = !!at,
        oa = !!Ke,
        na = !!ke,
        sa = !!ze,
        la = !!We,
        ha = !!Ye,
        da = !!Ze,
        ca = !!tt,
        ua = !!nt,
        fa = ia ? Ve.getParameter(at.MAX_DRAW_BUFFERS_WEBGL) : 0;
    }
    var pa = "webgl2" === Ce;
    Xe(), (this.context = Ve);
    {
      var ma = Ve.getParameter(Ve.MAX_TEXTURE_IMAGE_UNITS),
        va = Ve.getParameter(Ve.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        ga =
          (Ve.getParameter(Ve.MAX_TEXTURE_SIZE),
            Ve.getParameter(Ve.MAX_CUBE_MAP_TEXTURE_SIZE)),
        Sa = qe ? Ve.getParameter(qe.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
        xa = va > 0,
        Ga = xa && ke,
        Ma = !!He;
      Qe || Je || $e || et
        ? Ve.getParameter(Ve.COMPRESSED_TEXTURE_FORMATS)
        : [];
    }
    XG.elementIndexUintAvailable = ca;
    {
      var ya = Ve.getShaderPrecisionFormat(Ve.VERTEX_SHADER, Ve.HIGH_FLOAT),
        wa = Ve.getShaderPrecisionFormat(Ve.VERTEX_SHADER, Ve.MEDIUM_FLOAT),
        _a =
          (Ve.getShaderPrecisionFormat(Ve.VERTEX_SHADER, Ve.LOW_FLOAT),
            Ve.getShaderPrecisionFormat(Ve.FRAGMENT_SHADER, Ve.HIGH_FLOAT)),
        Xa = Ve.getShaderPrecisionFormat(Ve.FRAGMENT_SHADER, Ve.MEDIUM_FLOAT);
      Ve.getShaderPrecisionFormat(Ve.FRAGMENT_SHADER, Ve.LOW_FLOAT),
        Ve.getShaderPrecisionFormat(Ve.VERTEX_SHADER, Ve.HIGH_INT),
        Ve.getShaderPrecisionFormat(Ve.VERTEX_SHADER, Ve.MEDIUM_INT),
        Ve.getShaderPrecisionFormat(Ve.VERTEX_SHADER, Ve.LOW_INT),
        Ve.getShaderPrecisionFormat(Ve.FRAGMENT_SHADER, Ve.HIGH_INT),
        Ve.getShaderPrecisionFormat(Ve.FRAGMENT_SHADER, Ve.MEDIUM_INT),
        Ve.getShaderPrecisionFormat(Ve.FRAGMENT_SHADER, Ve.LOW_INT);
    }
    console.log(
      "XG: render target support autodetection START (please ignore following warnings)"
    );
    var Da = Ge(Ve.RGB, Ve.RGB, Ve.UNSIGNED_BYTE),
      Ta =
        na &&
        (pa ? Ge(Ve.RGB32F, Ve.RGB, Ve.FLOAT) : Ge(Ve.RGB, Ve.RGB, Ve.FLOAT)),
      Ca =
        na &&
        (pa
          ? Ge(Ve.RGBA32F, Ve.RGBA, Ve.FLOAT)
          : Ge(Ve.RGBA, Ve.RGBA, Ve.FLOAT)),
      Aa =
        na &&
        (pa
          ? Ge(Ve.R32F, Ve.RED, Ve.FLOAT)
          : Ge(Ve.LUMINANCE, Ve.LUMINANCE, Ve.FLOAT)),
      Pa =
        na &&
        (pa ? Ge(Ve.R32F, Ve.RED, Ve.FLOAT) : Ge(Ve.ALPHA, Ve.ALPHA, Ve.FLOAT)),
      La =
        na &&
        (pa
          ? Ge(Ve.RG32F, Ve.RG, Ve.FLOAT)
          : Ge(Ve.LUMINANCE_ALPHA, Ve.LUMINANCE_ALPHA, Ve.FLOAT)),
      ba =
        sa &&
        (pa
          ? Ge(Ve.RGB16F, Ve.RGB, Ve.HALF_FLOAT)
          : Ge(Ve.RGB, Ve.RGB, ze.HALF_FLOAT_OES)),
      Ea =
        sa &&
        (pa
          ? Ge(Ve.RGBA16F, Ve.RGBA, Ve.HALF_FLOAT)
          : Ge(Ve.RGBA, Ve.RGBA, ze.HALF_FLOAT_OES)),
      Fa =
        sa &&
        (pa
          ? Ge(Ve.R16F, Ve.RED, Ve.HALF_FLOAT)
          : Ge(Ve.LUMINANCE, Ve.LUMINANCE, ze.HALF_FLOAT_OES)),
      Ra =
        sa &&
        (pa
          ? Ge(Ve.R16F, Ve.RED, Ve.HALF_FLOAT)
          : Ge(Ve.ALPHA, Ve.ALPHA, ze.HALF_FLOAT_OES)),
      Ua =
        sa &&
        (pa
          ? Ge(Ve.RG16F, Ve.RG, Ve.HALF_FLOAT)
          : Ge(Ve.LUMINANCE_ALPHA, Ve.LUMINANCE_ALPHA, ze.HALF_FLOAT_OES)),
      Ia = oa && Me();
    console.log("XG: render target support autodetection END");
    var Na = ya.precision > 0 && _a.precision > 0,
      Ba = wa.precision > 0 && Xa.precision > 0;
    "highp" !== Ae ||
      Na ||
      (Ba
        ? ((Ae = "mediump"),
          console.warn(
            "XG.ForwardRenderer: highp not supported, using mediump"
          ))
        : ((Ae = "lowp"),
          console.warn(
            "XG.ForwardRenderer: highp and mediump not supported, using lowp"
          ))),
      "mediump" !== Ae ||
      Ba ||
      ((Ae = "lowp"),
        console.warn("XG.ForwardRenderer: mediump not supported, using lowp"));
    var Oa = !1,
      Va = XG.RendererUtils.getUvScale;
    (this.getContext = function () {
      return Ve;
    }),
      (this.getRenderingBackend = function () {
        return Ce;
      }),
      (this.supportsStandardDerivatives = function () {
        return ra;
      }),
      (this.supportsElementIndexUint = function () {
        return ca;
      }),
      (this.supportsFloatTextures = function () {
        return na;
      }),
      (this.supportsHalfFloatTextures = function () {
        return sa;
      }),
      (this.supportsFloatTexturesLinear = function () {
        return Ma;
      }),
      (this.supportsHalfFloatTexturesLinear = function () {
        return la;
      }),
      (this.supportsVertexTextures = function () {
        return xa;
      }),
      (this.supportsRGBUnsignedByteRenderTarget = function () {
        return Da;
      }),
      (this.supportsLuminanceFloatRenderTarget = function () {
        return Aa;
      }),
      (this.supportsAlphaFloatRenderTarget = function () {
        return Pa;
      }),
      (this.supportsLuminanceAlphaFloatRenderTarget = function () {
        return La;
      }),
      (this.supportsRGBFloatRenderTarget = function () {
        return Ta;
      }),
      (this.supportsRGBAFloatRenderTarget = function () {
        return Ca;
      }),
      (this.supportsLuminanceHalfFloatRenderTarget = function () {
        return Fa;
      }),
      (this.supportsAlphaHalfFloatRenderTarget = function () {
        return Ra;
      }),
      (this.supportsLuminanceAlphaHalfFloatRenderTarget = function () {
        return Ua;
      }),
      (this.supportsRGBHalfFloatRenderTarget = function () {
        return ba;
      }),
      (this.supportsRGBAHalfFloatRenderTarget = function () {
        return Ea;
      }),
      (this.supportsDepthOnlyRenderTarget = function () {
        return Ia;
      }),
      (this.supportsDepthTextures = function () {
        return oa;
      }),
      (this.supportsDrawBuffers = function () {
        return ia;
      }),
      (this.supportsFragDepth = function () {
        return da;
      }),
      (this.supportsShaderTextureLod = function () {
        return ha;
      }),
      (this.supportsInstancing = function () {
        return ua;
      }),
      (this.getMaxDrawBuffers = function () {
        return fa;
      }),
      (this.getMaxAnisotropy = function () {
        return Sa;
      }),
      (this.getPrecision = function () {
        return Ae;
      }),
      (this.setSize = function (e, t) {
        (Te.width = e * this.devicePixelRatio),
          (Te.height = t * this.devicePixelRatio),
          (Te.style.width = e + "px"),
          (Te.style.height = t + "px"),
          this.setViewport(0, 0, Te.width, Te.height);
      }),
      (this.setScale = function (e) {
        Be = e;
      }),
      (this.setViewport = function (e, t, a, r) {
        (Pt = void 0 !== e ? e : 0),
          (Lt = void 0 !== t ? t : 0),
          (bt = void 0 !== a ? a : Te.width),
          (Et = void 0 !== r ? r : Te.height),
          Ve.viewport(Pt, Lt, bt, Et);
      }),
      (this.getViewport = function (e) {
        return (
          void 0 === e && (e = { x: 0, y: 0, width: 0, height: 0 }),
          (e.x = Pt),
          (e.y = Lt),
          (e.width = bt),
          (e.height = Et),
          e
        );
      }),
      (this.setScissor = function (e, t, a, r) {
        Ve.scissor(e, t, a, r);
      }),
      (this.enableScissorTest = function (e) {
        e ? Ve.enable(Ve.SCISSOR_TEST) : Ve.disable(Ve.SCISSOR_TEST);
      }),
      (this.setClearColorHex = function (e, t) {
        Ie.setHex(e),
          (Ne = t),
          Oe && Ie.copyTonemapped(Ie, Oe, st.brightness, st.whitePoint),
          Ve.clearColor(Ie.r, Ie.g, Ie.b, Ne);
      }),
      (this.setClearColor = function (e, t) {
        Oe
          ? Ie.copyTonemapped(e, Oe, st.brightness, st.whitePoint)
          : Ie.copy(e),
          (Ne = t),
          Ve.clearColor(Ie.r, Ie.g, Ie.b, Ne);
      }),
      (this.getClearColor = function () {
        return Ie;
      }),
      (this.getClearAlpha = function () {
        return Ne;
      }),
      (this.clear = function (e, t, a) {
        var r = 0;
        (void 0 === e || e) && (r |= Ve.COLOR_BUFFER_BIT),
          (void 0 === t || t) && (r |= Ve.DEPTH_BUFFER_BIT),
          (void 0 === a || a) && (r |= Ve.STENCIL_BUFFER_BIT),
          Ve.clear(r);
      }),
      (this.clearTarget = function (e, t, a, r) {
        this.setRenderTarget(e), this.clear(t, a, r);
      }),
      (this.addPostPlugin = function (e) {
        e.init(this), this.renderPluginsPost.push(e);
      }),
      (this.addPrePlugin = function (e) {
        e.init(this), this.renderPluginsPre.push(e);
      }),
      (this.updateShadowMap = function (e, t) {
        (dt = null),
          (xt = -1),
          (Xt = -1),
          (Dt = -1),
          (ft = -1),
          (ut = -1),
          (ea = !0),
          (gt = -1),
          (St = -1),
          this.shadowMapPlugin.update(e, t);
      });
    var ka = function (e) {
      var t = e.program;
      if (void 0 !== t) {
        e.program = void 0;
        var a,
          r,
          i,
          o = !1;
        for (a = 0, r = lt.length; r > a; a++)
          if (((i = lt[a]), i.program === t)) {
            i.usedTimes--, 0 === i.usedTimes && (o = !0);
            break;
          }
        if (o === !0) {
          var n = [];
          for (a = 0, r = lt.length; r > a; a++)
            (i = lt[a]), i.program !== t && n.push(i);
          (lt = n), Ve.deleteProgram(t), st.info.memory.programs--;
        }
      }
    },
      za = function (e) {
        for (var t = 0, a = e.attributesList.length; a > t; t++) {
          var r = e.attributesList[t];
          r.buffer || (r.buffer = Ve.createBuffer());
        }
      };
    this.setBuffers = function (e) {
      for (
        var t,
        a,
        r = e.dynamic ? Ve.DYNAMIC_DRAW : Ve.STATIC_DRAW,
        i = e.attributesList,
        o = 0,
        n = i.length;
        n > o;
        o++
      )
        (a = i[o]),
          a.needsUpdate &&
          ((t =
            "index" === a.name ? Ve.ELEMENT_ARRAY_BUFFER : Ve.ARRAY_BUFFER),
            Ve.bindBuffer(t, a.buffer),
            a.partialUpdate && e.alreadyUploaded
              ? Ve.bufferSubData(
                t,
                a.subOffset,
                a.array.subarray(a.subBegin, a.subEnd)
              )
              : (Ve.bufferData(t, a.array, r), (e.alreadyUploaded = !0)),
            (a.needsUpdate = !1),
            e.dynamic || delete a.array);
    };
    var Ha = function (e, t, a) {
      for (
        var r, o, n, s, l, h = t.virtualAttributesList, d = 0, c = h.length;
        c > d;
        d++
      )
        (r = h[d]),
          (n = r.mapped),
          n &&
          ((o = e[r.name]),
            0 > o ||
            ((s = n.buffer),
              (l = n.itemSize),
              i(o),
              Ve.bindBuffer(Ve.ARRAY_BUFFER, s),
              Ve.vertexAttribPointer(o, l, Ve.FLOAT, !1, 0, a * l * 4)));
    },
      Wa = function (e, t, a, r) {
        for (
          var i,
          o = a.numSupportedMorphTargets,
          n = [],
          l = e.morphTargetInfluences,
          h = 0,
          d = l.length;
          d > h;
          h++
        )
          (i = l[h]), i > 0 && n.push([i, h]);
        n.length > o
          ? (n.sort(s), (n.length = o))
          : 0 === n.length && n.push([0, 0]),
          e.__morphTargetInfluencesArray ||
          (e.__morphTargetInfluencesArray = new Float32Array(
            st.maxMorphTargets
          ));
        for (
          var c,
          u,
          f = e.__morphTargetInfluencesArray,
          p = t.virtualAttributes,
          m = t.attributesList,
          v = t.morphTargets,
          g = 0;
          o > g;

        )
          n[g]
            ? ((c = n[g][1]),
              (u = v[c].index),
              (p["morphTarget" + g].mapped = m[u]),
              (p["morphNormal" + g].mapped = m[u + 1]),
              (f[g] = l[c]))
            : (f[g] = 0),
            g++;
        null !== r.uniforms.morphTargetInfluences &&
          Ve.uniform1fv(r.uniforms.morphTargetInfluences, f);
      };
    (this.renderImmediateGeometry = function (e, t, a) {
      e.hasPositions &&
        !e.__webglVertexBuffer &&
        (e.__webglVertexBuffer = Ve.createBuffer()),
        e.hasNormals &&
        !e.__webglNormalBuffer &&
        (e.__webglNormalBuffer = Ve.createBuffer()),
        e.hasUvs &&
        !e.__webglUvBuffer &&
        (e.__webglUvBuffer = Ve.createBuffer()),
        e.hasColors &&
        !e.__webglColorBuffer &&
        (e.__webglColorBuffer = Ve.createBuffer());
      var r = t.attributes,
        i =
          a.map ||
          a.lightMap ||
          a.bumpMap ||
          a.normalMap ||
          a.bumpDetailMap ||
          a.normalDetailMap ||
          a.normalGlossMap ||
          a.glossMap ||
          a.specularMap ||
          a.displacementMap,
        o = a.uniforms;
      (i =
        i ||
        (o.map && o.map.value) ||
        (o.lightMap && o.lightMap.value) ||
        (o.bumpMap && o.bumpMap.value) ||
        (o.normalMap && o.normalMap.value) ||
        (o.bumpDetailMap && o.bumpDetailMap.value) ||
        (o.normalDetailMap && o.normalDetailMap.value) ||
        (o.normalGlossMap && o.normalGlossMap.value) ||
        (o.glossMap && o.glossMap.value) ||
        (o.specularMap && o.specularMap.value) ||
        (o.displacementMap && o.displacementMap.value)),
        e.hasPositions &&
        r.position >= 0 &&
        (Ve.bindBuffer(Ve.ARRAY_BUFFER, e.__webglVertexBuffer),
          Ve.bufferData(Ve.ARRAY_BUFFER, e.positionArray, Ve.STREAM_DRAW),
          Ve.enableVertexAttribArray(r.position),
          Ve.vertexAttribPointer(r.position, 3, Ve.FLOAT, !1, 0, 0)),
        e.hasNormals &&
        r.normal >= 0 &&
        (Ve.bindBuffer(Ve.ARRAY_BUFFER, e.__webglNormalBuffer),
          Ve.bufferData(Ve.ARRAY_BUFFER, e.normalArray, Ve.STREAM_DRAW),
          Ve.enableVertexAttribArray(r.normal),
          Ve.vertexAttribPointer(r.normal, 3, Ve.FLOAT, !1, 0, 0)),
        e.hasUvs &&
        r.uv >= 0 &&
        i &&
        (Ve.bindBuffer(Ve.ARRAY_BUFFER, e.__webglUvBuffer),
          Ve.bufferData(Ve.ARRAY_BUFFER, e.uvArray, Ve.STREAM_DRAW),
          Ve.enableVertexAttribArray(r.uv),
          Ve.vertexAttribPointer(r.uv, 2, Ve.FLOAT, !1, 0, 0)),
        e.hasColors &&
        r.color >= 0 &&
        a.vertexColors &&
        (Ve.bindBuffer(Ve.ARRAY_BUFFER, e.__webglColorBuffer),
          Ve.bufferData(Ve.ARRAY_BUFFER, e.colorArray, Ve.STREAM_DRAW),
          Ve.enableVertexAttribArray(r.color),
          Ve.vertexAttribPointer(r.color, 3, Ve.FLOAT, !1, 0, 0)),
        Ve.drawArrays(Ve.TRIANGLES, 0, e.count),
        (e.count = 0);
    }),
      (this.renderGeometry = function (e, r, i) {
        var n = e.program,
          s = n.attributes,
          l = !1,
          h = 16777215 * r.id + n.id;
        if (
          (h !== ft && ((ft = h), (l = !0)),
            l && o(),
            i.morphTargetInfluences && e.morphTargets && Wa(i, r, e, n),
            i instanceof XG.Mesh)
        )
          if (r.attributes.index) t(r, s, l);
          else {
            var d =
              i instanceof XG.TriangleStrip ? Ve.TRIANGLE_STRIP : Ve.TRIANGLES;
            a(r, s, d, l);
          }
        else if (i instanceof XG.Particles) {
          var d = Ve.POINTS;
          a(r, s, d, l);
        }
      });
    var ja = function (e, t) {
      for (var a, r, i, o = 0, s = 0, l = e.length; l > s; s++)
        (a = e[s]),
          (r = a.object),
          (i = a.geometry),
          (a.render = !1),
          (a.id = r.id),
          r.visible &&
          r.enabled &&
          (((r instanceof XG.Mesh || r instanceof XG.Particles) &&
            r.frustumCulled &&
            !Vt.contains(r, i)) ||
            (L(r, t),
              u(a),
              (a.render = !0),
              st.sortObjects === !0 &&
              (null !== r.renderDepth
                ? (a.z = r.renderDepth)
                : (zt.copy(r.matrixWorld.getPosition()),
                  kt.multiplyVector3(zt),
                  (a.z = zt.data[2]))),
              (o += 1)));
      st.sortObjects && o > 0 && e.sort(n);
    };
    this.cullInstances = function (e, t, a) {
      var r = t.numInstances;
      t.culledOffsets ||
        ((t.culledOffsets = new Float32Array(3 * r)),
          (t.culledRotations = new Float32Array(4 * r)),
          (t.srcOffsets = t.attributes.offset.array),
          (t.srcRotations = t.attributes.rotation.array));
      for (
        var i = t.attributes.offset,
        o = t.attributes.rotation,
        n = t.srcOffsets,
        s = t.srcRotations,
        l = t.culledOffsets,
        h = t.culledRotations,
        d = 0,
        c = 0;
        r > c;
        c++
      ) {
        var u = a.containsInstance(e, t, c);
        if (u) {
          var f = 3 * c,
            p = n[f],
            m = n[f + 1],
            v = n[f + 2],
            g = 4 * c,
            S = s[g],
            x = s[g + 1],
            G = s[g + 2],
            M = s[g + 3],
            y = 3 * d;
          (l[y] = p), (l[y + 1] = m), (l[y + 2] = v);
          var w = 4 * d;
          (h[w] = S), (h[w + 1] = x), (h[w + 2] = G), (h[w + 3] = M), (d += 1);
        }
      }
      (t.numVisibleInstances = d),
        (o.array = h),
        (i.array = l),
        (o.needsUpdate = !0),
        (i.needsUpdate = !0),
        (o.partialUpdate = !0),
        (i.partialUpdate = !0),
        (o.subOffset = 0),
        (i.subOffset = 0),
        (o.subBegin = 0),
        (i.subBegin = 0),
        (o.subEnd = 4 * d),
        (i.subEnd = 3 * d);
    };
    var qa = function (e, t) {
      for (var a, r, i = 0, o = e.length; o > i; i++)
        (a = e[i]),
          (r = a.object),
          (a.render = !1),
          r.visible &&
          r.enabled &&
          (Vt.contains(r, r) || !r.frustumCulled) &&
          (L(r, t), c(a), (a.render = !0));
    },
      Ya = function (e) {
        for (var t, a = 0, r = e.length; r > a; a++)
          (t = e[a]), t.render && u(t);
      },
      Ka = function (e) {
        for (var t, a = 0, r = e.length; r > a; a++)
          (t = e[a]), t.render && c(t);
      };
    (this.renderCube = function (e, t, a) {
      var r = a.generateMipmaps;
      (a.generateMipmaps = !1),
        (a.activeCubeFace = 0),
        this.render(e, t.px, a),
        (a.activeCubeFace = 1),
        this.render(e, t.nx, a),
        (a.activeCubeFace = 2),
        this.render(e, t.py, a),
        (a.activeCubeFace = 3),
        this.render(e, t.ny, a),
        (a.activeCubeFace = 4),
        this.render(e, t.pz, a),
        (a.generateMipmaps = r),
        (a.activeCubeFace = 5),
        this.render(e, t.nz, a);
    }),
      (this.render = function (e, t, a, r) {
        if (t instanceof XG.Camera == !1)
          return void console.error(
            "XG.ForwardRenderer.render: camera is not an instance of XG.Camera."
          );
        var i = e.__lights,
          o = e.fog,
          n = e.heightFog;
        (ut = -1),
          (ea = !0),
          (Ot.length = 0),
          this.autoUpdateScene && e.updateMatrixWorld(),
          this.autoUpdateView &&
          (void 0 === t.parent && t.updateMatrixWorld(),
            t.matrixWorldInverse.getInverse(t.matrixWorld),
            kt.multiply(t.projectionMatrix, t.matrixWorldInverse),
            Vt.setFromMatrix(kt)),
          this.autoUpdateObjects && this.initWebGLObjects(e),
          Oa || (De(), (Oa = !0)),
          l(this.renderPluginsPre, e, t);
        for (var s = 0, c = e.__webglObjects.length; c > s; s++) {
          var u = e.__webglObjects[s].object,
            f = u.geometries;
          if (u instanceof XG.Mesh || u instanceof XG.Particles)
            for (var p = 0, m = f.length; m > p; p++) {
              var v = f[p],
                g = v.numInstances,
                S = g > 0 && ua;
              S &&
                (v.instanceCulled
                  ? (v.srcOffsets &&
                    ((v.attributes.offset.array = v.srcOffsets),
                      (v.attributes.rotation.array = v.srcRotations)),
                    st.cullInstances(u, v, Vt),
                    st.setBuffers(v))
                  : (v.numVisibleInstances = g));
            }
        }
        this.setRenderTarget(a),
          (this.autoClear || r) &&
          this.clear(
            this.autoClearColor,
            this.autoClearDepth,
            this.autoClearStencil
          ),
          this.autoUpdateView
            ? (ja(e.__webglObjects, t), qa(e.__webglObjectsImmediate, t))
            : (Ya(e.__webglObjects), Ka(e.__webglObjectsImmediate)),
          this.setBlending(XG.NoBlending),
          h(e.__webglObjects, !0, "opaque", t, i, o, n, !1),
          d(e.__webglObjectsImmediate, "opaque", t, i, o, n, !1),
          h(e.__webglObjects, !1, "transparent", t, i, o, n, !0),
          d(e.__webglObjectsImmediate, "transparent", t, i, o, n, !0),
          l(this.renderPluginsPost, e, t),
          a &&
          a.generateMipmaps &&
          a.minFilter !== XG.NearestFilter &&
          a.minFilter !== XG.LinearFilter &&
          me(a),
          this.setDepthTest(!0),
          this.setDepthWrite(!0);
        for (var s = 0, c = e.__webglObjects.length; c > s; s++) {
          var u = e.__webglObjects[s].object,
            f = u.geometries;
          if (u instanceof XG.Mesh || u instanceof XG.Particles)
            for (var p = 0, m = f.length; m > p; p++) {
              var v = f[p];
              v.srcOffsets &&
                ((v.attributes.offset.array = v.srcOffsets),
                  (v.attributes.rotation.array = v.srcRotations));
            }
        }
      }),
      (this.renderImmediateObject = function (e, t) {
        var a = e.program;
        (ft = -1),
          st.setMaterialFaces(e),
          t.immediateRenderCallback
            ? t.immediateRenderCallback(a, Ve, Vt)
            : t.render(function (t) {
              st.renderImmediateGeometry(t, a, e);
            });
      }),
      (this.initWebGLObjects = function (e) {
        for (
          e.__webglObjects ||
          ((e.__webglObjects = []), (e.__webglObjectsImmediate = []));
          e.__objectsAdded.length;

        )
          f(e.__objectsAdded[0], e), e.__objectsAdded.splice(0, 1);
        for (; e.__objectsRemoved.length;)
          g(e.__objectsRemoved[0], e), e.__objectsRemoved.splice(0, 1);
        for (var t = 0, a = e.__webglObjects.length; a > t; t++)
          v(e.__webglObjects[t].object);
      }),
      (this.initMaterial = function (e, t, a, r, i) {
        var o;
        e instanceof XG.EmissiveMaterial
          ? (o = "emissive")
          : e instanceof XG.PhongMaterial
            ? (o = "phong")
            : e instanceof XG.DynamicParticleMaterial && (o = "dynamicParticle"),
          o && x(e, XG.ShaderLib[o]);
        var n,
          s,
          l = Se(t),
          h = ge(r),
          d = xe(t),
          c = {
            map: !!e.map,
            lightMap: !!e.lightMap,
            bumpMap: !!e.bumpMap,
            normalMap: !!e.normalMap,
            normalGlossMap: !!e.normalGlossMap,
            bumpDetailMap: !!e.bumpDetailMap,
            normalDetailMap: !!e.normalDetailMap,
            glossMap: !!e.glossMap,
            specularMap: !!e.specularMap,
            displacementMap: !!e.displacementMap,
            vertexColors: e.vertexColors,
            fog: a,
            useFog: e.fog,
            isParticle: e.particle,
            sizeAttenuation: e.particle && e.particleSizeAttenuation,
            interpolateParticleFrames:
              e.particle && e.interpolateFrames && e.numFrames > 1,
            skinning: e.skinning,
            maxBones: h,
            useVertexTexture: Ga && r && r.useVertexTexture,
            boneTextureWidth: r && r.boneTextureWidth,
            boneTextureHeight: r && r.boneTextureHeight,
            morphTargets: e.morphTargets && this.maxMorphTargets > 0,
            morphNormals: e.morphNormals && this.maxMorphNormals > 0,
            maxMorphTargets: this.maxMorphTargets,
            maxMorphNormals: this.maxMorphNormals,
            maxDirLights: l.directional,
            maxPointLights: l.point,
            maxSphereLights: l.sphere,
            maxTubeLights: l.tube,
            maxSpotLights: l.spot,
            maxHemiLights: l.hemi,
            maxAreaLights: l.area,
            areaTextures: l.areaTextures > 0,
            maxImageLights: l.image,
            maxPolyLights: l.poly,
            polyTextures: l.polyTextures > 0,
            maxShadows: d.maxShadows,
            maxShadows2d: d.maxShadows2d,
            maxShadowsCube: d.maxShadowsCube,
            shadowMapEnabled:
              this.shadowMapEnabled && r.receiveShadow && d.maxShadows > 0,
            shadowMapType: this.shadowMapType,
            shadowMapDebug: this.shadowMapDebug,
            shadowMapCascade: this.shadowMapCascade,
            shadowSampler: pa && oa && this.shadowMapUseDepthTextures,
            areaIndexOffset: l.areaIndexOffset,
            polyIndexOffset: l.polyIndexOffset,
            spotIndexOffset: l.spotIndexOffset,
            dirIndexOffset: l.dirIndexOffset,
            sphereIndexOffset: l.sphereIndexOffset,
            pointIndexOffset: l.pointIndexOffset,
            alphaTest: e.alphaTest,
            metal: e.metal,
            parallax: e.parallax,
            parallaxRefineSteps: e.parallaxRefineSteps,
            wrapAround: e.wrapAround,
            wrapAroundSkin: e.wrapAroundSkin,
            doubleSided: e.side === XG.DoubleSide,
            flipSided: e.side === XG.BackSide,
            instances: e.instances,
            transparent: e.transparent,
            lightMapGamma: !!e.lightMapGamma,
            lightMapSecondaryUV: !!e.lightMapSecondaryUV,
            osxHack: navigator.platform.toLowerCase().indexOf("mac") >= 0,
          },
          u = {
            position: !0,
            normal: !0,
            uv: !0,
            uv2: !0,
            tangent: !0,
            color: !0,
          };
        for (n = 0; n < this.maxMorphTargets; n++) u["morphTarget" + n] = !0;
        for (n = 0; n < this.maxMorphNormals; n++) u["morphNormal" + n] = !0;
        if (i) {
          for (s in i.attributes) u[s] = !0;
          for (s in i.virtualAttributes) u[s] = !0;
        }
        var f = {
          viewMatrix: !0,
          viewInverseMatrix: !0,
          modelViewMatrix: !0,
          projectionMatrix: !0,
          normalMatrix: !0,
          modelMatrix: !0,
          cameraPosition: !0,
          morphTargetInfluences: !0,
        };
        c.useVertexTexture ? (f.boneTexture = !0) : (f.boneGlobalMatrices = !0);
        for (s in e.uniforms) f[s] = !0;
        e.program = k(o, e, f, u, c);
        var p = e.program.uniforms;
        (e.uniformsListUnique = []), (e.uniformsListShared = []);
        for (var m in e.uniforms) {
          var v = p[m];
          if (v) {
            var g = e.uniforms[m],
              S = [g, v];
            g.shared
              ? e.uniformsListShared.push(S)
              : e.uniformsListUnique.push(S);
          }
        }
        if (e.morphTargets) {
          var G = e.program.attributes;
          for (
            e.numSupportedMorphTargets = 0, n = 0;
            n < this.maxMorphTargets;
            n++
          )
            G["morphTarget" + n] >= 0 && e.numSupportedMorphTargets++;
        }
      }),
      (this.setProgram = function (e, t, a, r, i, o, n) {
        (mt = 0),
          i.needsUpdate &&
          (i.program && ka(i),
            st.initMaterial(i, t, a, o, n),
            (i.needsUpdate = !1));
        var s = !1,
          l = !1,
          h = i.program;
        h !== dt && (Ve.useProgram(h), (dt = h), (s = !0), (l = !0)),
          i.id !== ut && ((ut = i.id), (s = !0));
        var d = h.uniforms,
          c = i.uniforms;
        if (i.skinning)
          if (Ga && o.useVertexTexture) {
            if (null !== d.boneTexture) {
              var u = A();
              Ve.uniform1i(d.boneTexture, u), st.setTexture(o.boneTexture, u);
            }
          } else
            null !== d.boneGlobalMatrices &&
              Ve.uniformMatrix4fv(d.boneGlobalMatrices, !1, o.boneMatrices);
        if (
          ((!l && e === pt) ||
            null === d.projectionMatrix ||
            (Ve.uniformMatrix4fv(
              d.projectionMatrix,
              !1,
              e.projectionMatrix.elements
            ),
              e !== pt && (pt = e)),
            l)
        ) {
          if (
            (a && i.fog && y(c, a, e),
              r && i.defines && i.defines.USE_HEIGHT_FOG && w(c, r),
              i.lights && (ea && (N(t, e), (ea = !1)), X(c, ta)),
              o.receiveShadow &&
              !i._shadowPass &&
              c.shadowMatrix &&
              null !== d.shadowMatrix &&
              T(c, ta.shadowCasters),
              null !== d.viewMatrix &&
              Ve.uniformMatrix4fv(
                d.viewMatrix,
                !1,
                e.matrixWorldInverse.elements
              ),
              null !== d.viewInverseMatrix &&
              Ve.uniformMatrix4fv(
                d.viewInverseMatrix,
                !1,
                e.matrixWorld.elements
              ),
              null !== d.cameraPosition)
          ) {
            var f = e.matrixWorld.getPosition();
            Ve.uniform3fv(d.cameraPosition, f.data);
          }
          P(i.uniformsListShared), (vt = mt);
        } else mt = vt;
        return (
          s &&
          (i.particle && M(c, i, e),
            (i instanceof XG.EmissiveMaterial ||
              i instanceof XG.PhongMaterial ||
              i instanceof XG.DynamicParticleMaterial) &&
            G(c, i),
            i instanceof XG.PhongMaterial && _(c, i),
            P(i.uniformsListUnique)),
          C(d, o),
          h
        );
      }),
      (this.setFaceCulling = function (e, t) {
        e === XG.CullFaceNone
          ? Ve.disable(Ve.CULL_FACE)
          : (Ve.frontFace(t === XG.FrontFaceDirectionCW ? Ve.CW : Ve.CCW),
            Ve.cullFace(
              e === XG.CullFaceBack
                ? Ve.BACK
                : e === XG.CullFaceFront
                  ? Ve.FRONT
                  : Ve.FRONT_AND_BACK
            ),
            Ve.enable(Ve.CULL_FACE));
      }),
      (this.setMaterialFaces = function (e) {
        var t = e.side === XG.DoubleSide,
          a = e.side === XG.BackSide;
        gt !== t &&
          (t ? Ve.disable(Ve.CULL_FACE) : Ve.enable(Ve.CULL_FACE), (gt = t)),
          St !== a && (Ve.frontFace(a ? Ve.CW : Ve.CCW), (St = a));
      }),
      (this.setDepthTest = function (e) {
        Xt !== e &&
          (e ? Ve.enable(Ve.DEPTH_TEST) : Ve.disable(Ve.DEPTH_TEST), (Xt = e));
      }),
      (this.setDepthWrite = function (e) {
        Dt !== e && (Ve.depthMask(e), (Dt = e));
      }),
      (this.setPolygonOffset = function (e, t, a) {
        Tt !== e &&
          (e
            ? Ve.enable(Ve.POLYGON_OFFSET_FILL)
            : Ve.disable(Ve.POLYGON_OFFSET_FILL),
            (Tt = e)),
          (Ct !== t || At !== a) &&
          (Ve.polygonOffset(t, a), (Ct = t), (At = a));
      }),
      (this.setBlending = function (e, t, a, r, i, o) {
        e !== xt &&
          (e === XG.NoBlending
            ? Ve.disable(Ve.BLEND)
            : e === XG.AdditiveBlending
              ? (Ve.enable(Ve.BLEND),
                Ve.blendEquation(Ve.FUNC_ADD),
                Ve.blendFunc(Ve.SRC_ALPHA, Ve.ONE))
              : e === XG.SubtractiveBlending
                ? (Ve.enable(Ve.BLEND),
                  Ve.blendEquation(Ve.FUNC_ADD),
                  Ve.blendFunc(Ve.ZERO, Ve.ONE_MINUS_SRC_COLOR))
                : e === XG.MultiplyBlending
                  ? (Ve.enable(Ve.BLEND),
                    Ve.blendEquation(Ve.FUNC_ADD),
                    Ve.blendFunc(Ve.ZERO, Ve.SRC_COLOR))
                  : e === XG.LegacyNormalBlending
                    ? (Ve.enable(Ve.BLEND),
                      Ve.blendEquationSeparate(Ve.FUNC_ADD, Ve.FUNC_ADD),
                      Ve.blendFuncSeparate(
                        Ve.SRC_ALPHA,
                        Ve.ONE_MINUS_SRC_ALPHA,
                        Ve.ONE,
                        Ve.ONE_MINUS_SRC_ALPHA
                      ))
                    : e === XG.CustomBlending
                      ? Ve.enable(Ve.BLEND)
                      : (Ve.enable(Ve.BLEND),
                        Ve.blendEquationSeparate(Ve.FUNC_ADD, Ve.FUNC_ADD),
                        Ve.blendFuncSeparate(
                          Ve.ONE,
                          Ve.ONE_MINUS_SRC_ALPHA,
                          Ve.ONE,
                          Ve.ONE_MINUS_SRC_ALPHA
                        )),
            (xt = e)),
          e === XG.CustomBlending
            ? (t !== Gt && (Ve.blendEquation(t), (Gt = t)),
              (a !== Mt || r !== yt || i !== wt || o !== _t) &&
              (Ve.blendFuncSeparate(a, r, i, o),
                (Mt = a),
                (yt = r),
                (wt = i),
                (_t = o)))
            : ((Gt = null), (Mt = null), (yt = null), (wt = null), (_t = null));
      }),
      (this.setTexture = function (e, t) {
        e instanceof XG.Texture &&
          (e.__webglInit ||
            ((e.__webglInit = !0),
              (e.__webglTexture = Ve.createTexture()),
              st.info.memory.textures++,
              Ve.activeTexture(Ve.TEXTURE0 + t),
              Ve.bindTexture(Ve.TEXTURE_2D, e.__webglTexture),
              (Ot[t] = e.id),
              Ve.texImage2D(
                Ve.TEXTURE_2D,
                0,
                Ve.RGBA,
                1,
                1,
                0,
                Ve.RGBA,
                Ve.UNSIGNED_BYTE,
                aa
              )),
            e.needsUpdate && Y(e, t)),
          Ot[t] !== e.id &&
          e.__webglTexture &&
          (Ve.activeTexture(Ve.TEXTURE0 + t),
            Ve.bindTexture(Ve.TEXTURE_2D, e.__webglTexture),
            (Ot[t] = e.id));
      }),
      (this.setRenderTarget = function (e) {
        var t,
          a,
          r,
          i,
          o,
          n = e instanceof XG.RenderTargetCube,
          s =
            (e instanceof XG.RenderTargetArray, e instanceof XG.RenderTarget3D);
        if (
          (e
            ? (pe(e),
              (t = n
                ? e.__webglFramebuffer[e.activeCubeFace]
                : e.__webglFramebuffer),
              (a = e.width),
              (r = e.height),
              (i = 0),
              (o = 0))
            : ((t = null), (a = bt), (r = Et), (i = Pt), (o = Lt)),
            s)
        )
          if ((Ve.bindFramebuffer(Ve.FRAMEBUFFER, t), e.useMRT))
            for (
              var l = Ve.getParameter(Ve.MAX_COLOR_ATTACHMENTS),
              h = Math.min(l, e.numMRT),
              d = 0;
              h > d;
              d++
            )
              Ve.framebufferTextureLayer(
                Ve.DRAW_FRAMEBUFFER,
                Ve.COLOR_ATTACHMENT0 + d,
                e.__webglTexture,
                0,
                e.activeLayer + d
              );
          else
            Ve.framebufferTextureLayer(
              Ve.DRAW_FRAMEBUFFER,
              Ve.COLOR_ATTACHMENT0,
              e.__webglTexture,
              0,
              e.activeLayer
            );
        t !== ct &&
          (Ve.bindFramebuffer(Ve.FRAMEBUFFER, t),
            Ve.viewport(i, o, a, r),
            (ct = t)),
          (Ft = a),
          (Rt = r);
      }),
      void 0 !== e.width &&
      void 0 !== e.height &&
      this.setSize(e.width, e.height);
  }),
  (XG.DeferredRenderer = function (e) {
    var t = this,
      a = void 0 !== e.width ? e.width : 800,
      r = void 0 !== e.height ? e.height : 600,
      i = void 0 !== e.scale ? e.scale : 1,
      o = Math.max(1, Math.floor(i * a)),
      n = Math.max(1, Math.floor(i * r)),
      s = void 0 !== e.tonemapping ? e.tonemapping : XG.SimpleOperator,
      l = void 0 !== e.antialias ? e.antialias : !1,
      h = void 0 !== e.dither ? e.dither : !1,
      d =
        void 0 !== e.useMultipleRenderTargets ? e.useMultipleRenderTargets : !1,
      c = void 0 !== e.temporalAA ? e.temporalAA : !1,
      u = void 0 !== e.backend ? e.backend : "webgl1",
      f = "webgl2" === u,
      p = void 0 !== e.specularBRDF ? e.specularBRDF : XG.GGXBRDF;
    (t.brightness = void 0 !== e.brightness ? e.brightness : 1),
      (t.whitePoint = void 0 !== e.whitePoint ? e.whitePoint : 1),
      (this.renderer = e.renderer),
      void 0 === this.renderer &&
      ((this.renderer = new XG.ForwardRenderer({
        alpha: !1,
        antialias: !1,
        depth: !1,
        stencil: !1,
        tonemapping: XG.NoOperator,
        scale: i,
        backend: u,
      })),
        this.renderer.setSize(a, r),
        this.renderer.setClearColorHex(0, 0),
        (this.renderer.gammaInput = !0),
        (this.renderer.gammaOutput = !1),
        (this.renderer.specularBRDF = p),
        (this.renderer.autoClear = !1));
    var m = this.renderer.devicePixelRatio;
    (o = Math.max(1, Math.floor(o * m))),
      (n = Math.max(1, Math.floor(n * m))),
      (this.domElement = this.renderer.domElement),
      (this.shadowMapEnabled = !1),
      (this.shadowMapAutoUpdate = !0),
      (this.shadowMapType = XG.PCFSoftShadowMap),
      (this.shadowMapSlopeDepthBias = !1),
      (this.shadowMapSlopeScale = 2),
      (this.shadowMapSlopeBias = 0),
      (this.shadowMapSlopeMax = 0.001),
      (this.shadowMapProjectionBias = 1e-5),
      (this.shadowMapCullFace = XG.CullFaceFront),
      (this.shadowMapUseDepthTextures = !1),
      (this.shadowMapDepthTextureType = XG.UnsignedIntType),
      (this.shadowMapDepthTextureBias = 0),
      (this.shadowMapCascadeUpdateThreshold = 2),
      (this.shadowMapCascadeUpdateModulo = 2),
      (this.shadowMapDebug = !1),
      (this.transparentShadows = !1),
      (this.particlesOffscreen = !1),
      (this.particlesOffscreenScale = 0.5),
      (this.particlesOffscreenUpsampleFancy = !0),
      (this.particlesOit = !1),
      (this.particlesShadows = !1),
      (this.occludersEnabled = !1),
      (this.ssaoEnabled = !1),
      (this.ssaoScale = 0.5),
      (this.ssaoRadius = 1),
      (this.ssaoSamples = 9),
      (this.bloomEnabled = !1),
      (this.bloomScale = 0.25),
      (this.bloomStrength = 1),
      (this.bloomThreshold = 1),
      (this.dofEnabled = !1),
      (this.dofFancy = !1),
      (this.dofPhysical = !0),
      (this.dofLensFstop = 4),
      (this.dofLensFocalLength = 50),
      (this.dofLensBlurScale = 50),
      (this.dofLensMaxCoc = 1),
      (this.dofLensApertureSides = 7),
      (this.dofDebug = !1),
      (this.dofAutofocus = !1),
      (this.dofAutofocusPoint = new XG.Vector2(0.5, 0.5)),
      (this.dofFocusDistance = 1),
      (this.dofFocusWidth = 1),
      (this.dofFocusRampWidth = 2),
      (this.dofMaxBlur = 0.2),
      (this.fogEnabled = !1),
      (this.fogColor = new XG.Color(0)),
      (this.fogStrength = 0.1),
      (this.fogStart = 100),
      (this.specularMipFix = !1),
      (this.useDepthTexture = !1),
      (this.skinHighQuality = !1),
      (this.taaBeforeDOF = !1),
      (this.useMultiProxies = !1),
      d &&
      !this.renderer.supportsDrawBuffers() &&
      (console.warn(
        "XG.DeferredRenderer: can't use multiple render targets, falling back to multipass."
      ),
        (d = !1));
    var v = 5,
      g = this.renderer.getMaxDrawBuffers();
    d &&
      this.renderer.supportsDrawBuffers() &&
      v > g &&
      (console.warn(
        "XG.DeferredRenderer: not enough attachments for multiple render targets (available: " +
        g +
        ", required: " +
        v +
        "), falling back to multipass."
      ),
        (d = !1));
    var S,
      x,
      G,
      M,
      y,
      w,
      _,
      X,
      D,
      T,
      C,
      A,
      P,
      L,
      b,
      E,
      F,
      R,
      U,
      I,
      N,
      B,
      O,
      V,
      k,
      z,
      H,
      W,
      j,
      q,
      Y,
      K,
      Z,
      Q,
      J,
      $,
      ee,
      te,
      ae,
      re,
      ie,
      oe,
      ne,
      se,
      le,
      he,
      de = !1,
      ce = this.renderer.context,
      ue = new XG.Projector(),
      fe = new XG.Vector3(),
      pe = new XG.Vector3(),
      me = new XG.Color(0),
      ve = new XG.Color(16777215),
      ge = new XG.Vector3(1, 1, 1),
      Se = XG.DeferredShaders.combined,
      xe = XG.DeferredShaders.color,
      Ge = XG.DeferredShaders.depth,
      Me = XG.DeferredShaders.normalDepth,
      ye = XG.DeferredShaders.occluder,
      we = XG.DeferredShaders.composite,
      _e = [],
      Xe = new XG.Color(),
      De = 0,
      Te = { offsetX: 0, offsetY: 0, width: 0, height: 0 },
      Ce = [],
      Ae = [],
      Pe = new XG.ShaderMaterial({
        uniforms: XG.UniformsUtils.clone(Me.uniforms),
        vertexShader: Me.vertexShader,
        fragmentShader: Me.fragmentShader,
        blending: XG.NoBlending,
      }),
      Le = new XG.ShaderMaterial({
        uniforms: XG.UniformsUtils.clone(Ge.uniforms),
        vertexShader: Ge.vertexShader,
        fragmentShader: Ge.fragmentShader,
        blending: XG.NoBlending,
      }),
      be = new XG.ShaderMaterial({
        uniforms: XG.UniformsUtils.clone(ye.uniforms),
        vertexShader: ye.vertexShader,
        fragmentShader: ye.fragmentShader,
        blending: XG.NoBlending,
      }),
      Ee = {},
      Fe = {},
      Re = {},
      Ue = {},
      Ie = {},
      Ne = 0,
      Be = 0,
      Oe = XG.Math.generateHalton_2_3(16),
      Ve = new XG.Vector4(0, 0, 0, 0),
      ke = new XG.Matrix4(),
      ze = new XG.Matrix4(),
      He = new XG.Matrix4(),
      We = function (e, a) {
        var r = XG.UniformsUtils.clone(Se.uniforms),
          i = {
            USE_MAP: !!e.map,
            USE_LIGHTMAP: !!e.lightMap,
            USE_BUMPMAP: !!e.bumpMap,
            USE_NORMALMAP: !!e.normalMap,
            USE_NORMALGLOSSMAP: !!e.normalGlossMap,
            USE_GLOSSMAP: !!e.glossMap,
            USE_BUMPDETAILMAP: !!e.bumpDetailMap,
            USE_NORMALDETAILMAP: !!e.normalDetailMap,
            USE_SPECULARMAP: !!e.specularMap,
            USE_DISPLACEMENTMAP: !!e.displacementMap,
            USE_PARALLAX: !!e.parallax,
            LIGHTMAP_GAMMA: !!e.lightMapGamma,
            LIGHTMAP_SECONDARY_UV: !!e.lightMapSecondaryUV,
            PARTICLE: e.particle,
            USE_PARTICLE_SIZEATTENUATION:
              e.particle && e.particleSizeAttenuation,
            TEXTURE_DEPTH: t.useDepthTexture,
            WIREFRAME: e.wireframe,
            MRT_OUTPUT: !0,
          };
        if (
          (e.parallax &&
            e.parallaxRefineSteps > 0 &&
            (i.PARALLAX_REFINE_STEPS = e.parallaxRefineSteps
              .toFixed(0)
              .toString()),
            e.displacementMap)
        )
          switch (e.displacementDirection) {
            case XG.DisplaceByNormal:
              i.DISPLACE_BY_NORMAL = !0;
              break;
            case XG.DisplaceByPosition:
              i.DISPLACE_BY_POSITION = !0;
          }
        var n = { WEBGL_draw_buffers: !0 };
        (i.USE_BUMPMAP ||
          i.USE_NORMALMAP ||
          i.USE_NORMALGLOSSMAP ||
          i.USE_NORMALDETAILMAP ||
          i.USE_BUMPDETAILMAP ||
          i.USE_DISPLACEMENTMAP ||
          i.WIREFRAME) &&
          (n.OES_standard_derivatives = !0);
        var s = new XG.ShaderMaterial({
          fragmentShader: Se.fragmentShader,
          vertexShader: Se.vertexShader,
          uniforms: r,
          defines: i,
          extensions: n,
          blending: XG.NoBlending,
          instances: e.instances,
        }),
          l = void 0 !== e.color ? e.color : ve,
          h = void 0 !== e.specular ? e.specular : me,
          d = void 0 !== e.wrapRGB ? e.wrapRGB : ge,
          c = void 0 !== e.shininess ? e.shininess : 1,
          u = void 0 !== e.wrapAround && e.wrapAround ? -1 : 1;
        if (
          (r.diffuse.value.setRGBA(l, u),
            r.specular.value.setRGBA(h, c),
            r.wrapRGB.value.copy(d),
            (r.map.value = e.map),
            e.lightMap && (r.lightMap.value = e.lightMap),
            e.bumpMap &&
            ((r.bumpMap.value = e.bumpMap), (r.bumpScale.value = e.bumpScale)),
            (e.normalMap || e.normalGlossMap) &&
            ((r.normalMap.value = e.normalGlossMap
              ? e.normalGlossMap
              : e.normalMap),
              r.normalScale.value.copy(e.normalScale)),
            e.bumpDetailMap && (r.bumpDetailMap.value = e.bumpDetailMap),
            e.normalDetailMap && (r.normalDetailMap.value = e.normalDetailMap),
            (e.bumpDetailMap || e.normalDetailMap) &&
            r.detailRepeatScale.value.set(
              e.detailRepeat.x,
              e.detailRepeat.y,
              e.detailScale
            ),
            e.specularMap && (r.specularMap.value = e.specularMap),
            e.glossMap && (r.glossMap.value = e.glossMap),
            e.displacementMap &&
            ((r.displacementMap.value = e.displacementMap),
              r.displacementScaleBias.value.set(
                e.displacementScale,
                e.displacementBias
              ),
              (r.displacementNormalScale.value = e.displacementNormalScale)),
            e.particle &&
            ((r.particleSize.value = e.particleSize),
              (r.screenWidth.value = o)),
            e.particle && e.particleSizeAttenuation && Ce.push({ material: s }),
            e.parallax && (r.parallaxScale.value = e.parallaxScale),
            e.wireframe &&
            (r.wireframeDiffuse.value.copy(e.wireframeDiffuse),
              r.wireframeSpecular.value.copy(e.wireframeSpecular),
              r.wireframeShininessThickness.value.set(
                e.wireframeShininess,
                e.wireframeThickness
              )),
            (s.vertexColors = e.vertexColors),
            (s.morphTargets = e.morphTargets),
            (s.morphNormals = e.morphNormals),
            (s.skinning = e.skinning),
            (s.alphaTest = e.alphaTest),
            (s.side = e.side),
            (s.visible = e.visible),
            (s.polygonOffset = e.polygonOffset),
            (s.polygonOffsetFactor = e.polygonOffsetFactor),
            (s.polygonOffsetUnits = e.polygonOffsetUnits),
            void 0 !== a)
        ) {
          var f = a.offset,
            p = a.repeat;
          r.offsetRepeat.value.set(f.data[0], f.data[1], p.data[0], p.data[1]);
        }
        return s;
      },
      je = function (e, t) {
        var a = {
          PARTICLE: e.particle,
          USE_PARTICLE_SIZEATTENUATION:
            e.particle && e.particleSizeAttenuation,
          USE_DISPLACEMENTMAP: !!e.displacementMap,
        },
          r = {};
        if (e.displacementMap)
          switch (e.displacementDirection) {
            case XG.DisplaceByNormal:
              a.DISPLACE_BY_NORMAL = !0;
              break;
            case XG.DisplaceByPosition:
              a.DISPLACE_BY_POSITION = !0;
          }
        if (
          e.morphTargets ||
          e.skinning ||
          e.alphaTest ||
          e.particle ||
          e.displacementMap ||
          e.instances
        ) {
          var i = XG.UniformsUtils.clone(ye.uniforms),
            n = new XG.ShaderMaterial({
              uniforms: i,
              vertexShader: ye.vertexShader,
              fragmentShader: ye.fragmentShader,
              blending: XG.NoBlending,
              instances: e.instances,
            });
          if (
            ((n.morphTargets = e.morphTargets),
              (n.skinning = e.skinning),
              void 0 !== t)
          ) {
            var s = t.offset,
              l = t.repeat;
            i.offsetRepeat.value.set(
              s.data[0],
              s.data[1],
              l.data[0],
              l.data[1]
            );
          }
          e.alphaTest && e.map && (i.alphaMap.value = e.map),
            e.displacementMap &&
            ((i.displacementMap.value = e.displacementMap),
              i.displacementScaleBias.value.set(
                e.displacementScale,
                e.displacementBias
              )),
            e.particle &&
            ((i.particleSize.value = e.particleSize),
              (i.screenWidth.value = o),
              i.particleSizeAttenuation && Ce.push({ material: n }));
        } else var n = be.clone();
        return (
          (n.defines = a),
          (n.extensions = r),
          (n.alphaTest = e.alphaTest),
          (n.visible = e.visible),
          (n.side = e.side),
          n
        );
      },
      qe = function (e, t) {
        var a = XG.UniformsUtils.clone(xe.uniforms),
          r = {
            USE_MAP: !!e.map,
            USE_LIGHTMAP: !!e.lightMap,
            USE_SPECULARMAP: !!e.specularMap,
            USE_NORMALGLOSSMAP: !!e.normalGlossMap,
            USE_GLOSSMAP: !!e.glossMap,
            USE_BUMPMAP: !!e.bumpMap && e.parallax,
            USE_PARALLAX: !!e.parallax,
            USE_DISPLACEMENTMAP: !!e.displacementMap,
            LIGHTMAP_GAMMA: !!e.lightMapGamma,
            LIGHTMAP_SECONDARY_UV: !!e.lightMapSecondaryUV,
            PARTICLE: e.particle,
            USE_PARTICLE_SIZEATTENUATION:
              e.particle && e.particleSizeAttenuation,
            WIREFRAME: e.wireframe,
          };
        if (
          (e.parallax &&
            e.parallaxRefineSteps > 0 &&
            (r.PARALLAX_REFINE_STEPS = e.parallaxRefineSteps
              .toFixed(0)
              .toString()),
            e.displacementMap)
        )
          switch (e.displacementDirection) {
            case XG.DisplaceByNormal:
              r.DISPLACE_BY_NORMAL = !0;
              break;
            case XG.DisplaceByPosition:
              r.DISPLACE_BY_POSITION = !0;
          }
        var i = {};
        (r.USE_BUMPMAP || r.USE_PARALLAX || r.WIREFRAME) &&
          (i.OES_standard_derivatives = !0);
        var n = new XG.ShaderMaterial({
          fragmentShader: xe.fragmentShader,
          vertexShader: xe.vertexShader,
          uniforms: a,
          defines: r,
          extensions: i,
          instances: e.instances,
        }),
          s = void 0 !== e.color ? e.color : ve,
          l = void 0 !== e.specular ? e.specular : me,
          h = void 0 !== e.wrapRGB ? e.wrapRGB : ge,
          d = void 0 !== e.shininess ? e.shininess : 1,
          c = void 0 !== e.wrapAround && e.wrapAround ? -1 : 1;
        if (
          (a.diffuse.value.setRGBA(s, c),
            a.specular.value.setRGBA(l, d),
            a.wrapRGB.value.copy(h),
            (a.map.value = e.map),
            e.lightMap && (a.lightMap.value = e.lightMap),
            e.specularMap && (a.specularMap.value = e.specularMap),
            e.glossMap && (a.glossMap.value = e.glossMap),
            e.normalGlossMap && (a.normalMap.value = e.normalGlossMap),
            e.displacementMap &&
            ((a.displacementMap.value = e.displacementMap),
              a.displacementScaleBias.value.set(
                e.displacementScale,
                e.displacementBias
              )),
            e.particle &&
            ((a.particleSize.value = e.particleSize),
              (a.screenWidth.value = o)),
            e.particle && e.particleSizeAttenuation && Ce.push({ material: n }),
            e.parallax &&
            ((a.parallaxScale.value = e.parallaxScale),
              (a.bumpMap.value = e.bumpMap)),
            e.wireframe &&
            (a.wireframeDiffuse.value.copy(e.wireframeDiffuse),
              a.wireframeSpecular.value.copy(e.wireframeSpecular),
              a.wireframeShininessThickness.value.set(
                e.wireframeShininess,
                e.wireframeThickness
              )),
            (n.vertexColors = e.vertexColors),
            (n.morphTargets = e.morphTargets),
            (n.morphNormals = e.morphNormals),
            (n.skinning = e.skinning),
            (n.alphaTest = e.alphaTest),
            (n.side = e.side),
            (n.visible = e.visible),
            (n.polygonOffset = e.polygonOffset),
            (n.polygonOffsetFactor = e.polygonOffsetFactor),
            (n.polygonOffsetUnits = e.polygonOffsetUnits),
            void 0 !== t)
        ) {
          var u = t.offset,
            f = t.repeat;
          a.offsetRepeat.value.set(u.data[0], u.data[1], f.data[0], f.data[1]);
        }
        return n;
      },
      Ye = function (e, t) {
        var a = {
          USE_BUMPMAP: !!e.bumpMap,
          USE_NORMALMAP: !!e.normalMap,
          USE_NORMALGLOSSMAP: !!e.normalGlossMap,
          USE_BUMPDETAILMAP: !!e.bumpDetailMap,
          USE_NORMALDETAILMAP: !!e.normalDetailMap,
          USE_DISPLACEMENTMAP: !!e.displacementMap,
          USE_PARALLAX: !!e.parallax,
          PARTICLE: e.particle,
          USE_PARTICLE_SIZEATTENUATION: e.particle && e.particleSizeAttenuation,
        };
        if (
          (e.parallax &&
            e.parallaxRefineSteps > 0 &&
            (a.PARALLAX_REFINE_STEPS = e.parallaxRefineSteps
              .toFixed(0)
              .toString()),
            e.displacementMap)
        )
          switch (e.displacementDirection) {
            case XG.DisplaceByNormal:
              a.DISPLACE_BY_NORMAL = !0;
              break;
            case XG.DisplaceByPosition:
              a.DISPLACE_BY_POSITION = !0;
          }
        var r = {};
        if (
          ((a.USE_BUMPMAP ||
            a.USE_NORMALMAP ||
            a.USE_NORMALGLOSSMAP ||
            a.USE_NORMALDETAILMAP ||
            a.USE_BUMPDETAILMAP ||
            a.USE_PARALLAX ||
            a.USE_DISPLACEMENTMAP) &&
            (r.OES_standard_derivatives = !0),
            e.morphTargets ||
            e.skinning ||
            e.bumpMap ||
            e.normalMap ||
            e.alphaTest ||
            e.particle ||
            e.displacementMap ||
            e.instances ||
            e.polygonOffset)
        ) {
          var i = XG.UniformsUtils.clone(Me.uniforms),
            n = new XG.ShaderMaterial({
              uniforms: i,
              vertexShader: Me.vertexShader,
              fragmentShader: Me.fragmentShader,
              blending: XG.NoBlending,
              instances: e.instances,
            });
          if (
            ((n.morphTargets = e.morphTargets),
              (n.morphNormals = e.morphNormals),
              (n.skinning = e.skinning),
              e.bumpMap &&
              ((i.bumpMap.value = e.bumpMap),
                (i.bumpScale.value = e.bumpScale)),
              (e.normalMap || e.normalGlossMap) &&
              ((i.normalMap.value = e.normalGlossMap
                ? e.normalGlossMap
                : e.normalMap),
                i.normalScale.value.copy(e.normalScale)),
              e.bumpDetailMap && (i.bumpDetailMap.value = e.bumpDetailMap),
              e.normalDetailMap && (i.normalDetailMap.value = e.normalDetailMap),
              (e.bumpDetailMap || e.normalDetailMap) &&
              i.detailRepeatScale.value.set(
                e.detailRepeat.x,
                e.detailRepeat.y,
                e.detailScale
              ),
              e.displacementMap &&
              ((i.displacementMap.value = e.displacementMap),
                i.displacementScaleBias.value.set(
                  e.displacementScale,
                  e.displacementBias
                ),
                (i.displacementNormalScale.value = e.displacementNormalScale)),
              void 0 !== t)
          ) {
            var s = t.offset,
              l = t.repeat;
            i.offsetRepeat.value.set(
              s.data[0],
              s.data[1],
              l.data[0],
              l.data[1]
            );
          }
          e.alphaTest && e.map && (i.alphaMap.value = e.map),
            e.particle &&
            ((i.particleSize.value = e.particleSize),
              (i.screenWidth.value = o),
              e.particleSizeAttenuation && Ce.push({ material: n })),
            e.parallax && (i.parallaxScale.value = e.parallaxScale),
            (n.polygonOffset = e.polygonOffset),
            (n.polygonOffsetFactor = e.polygonOffsetFactor),
            (n.polygonOffsetUnits = e.polygonOffsetUnits);
        } else var n = Pe.clone();
        return (
          (n.defines = a),
          (n.extensions = r),
          (n.vertexColors = e.vertexColors),
          (n.side = e.side),
          (n.alphaTest = e.alphaTest),
          (n.visible = e.visible),
          n
        );
      },
      Ke = function (e, a) {
        var r =
          t.shadowMapUseDepthTextures && t.renderer.supportsDepthTextures(),
          i = {
            PARTICLE: e.particle,
            USE_PARTICLE_SIZEATTENUATION:
              e.particle && e.particleSizeAttenuation,
            USE_DISPLACEMENTMAP: !!e.displacementMap,
            SLOPE_DEPTH_BIAS: t.shadowMapSlopeDepthBias,
          };
        r ? (i.SHADOW_TEXTURE_DEPTH = !0) : (i.SHADOW_FLOAT_DEPTH = !0);
        var n = {};
        if (
          (i.SLOPE_DEPTH_BIAS && !r && (n.OES_standard_derivatives = !0),
            e.displacementMap)
        )
          switch (e.displacementDirection) {
            case XG.DisplaceByNormal:
              i.DISPLACE_BY_NORMAL = !0;
              break;
            case XG.DisplaceByPosition:
              i.DISPLACE_BY_POSITION = !0;
          }
        if (
          e.morphTargets ||
          e.skinning ||
          e.alphaTest ||
          e.particle ||
          e.displacementMap ||
          e.instances
        ) {
          var s = XG.UniformsUtils.clone(Ge.uniforms),
            l = new XG.ShaderMaterial({
              uniforms: s,
              vertexShader: Ge.vertexShader,
              fragmentShader: Ge.fragmentShader,
              blending: XG.NoBlending,
              instances: e.instances,
            });
          if (
            ((l.morphTargets = e.morphTargets),
              (l.skinning = e.skinning),
              void 0 !== a)
          ) {
            var h = a.offset,
              d = a.repeat;
            s.offsetRepeat.value.set(
              h.data[0],
              h.data[1],
              d.data[0],
              d.data[1]
            );
          }
          e.alphaTest && e.map && (s.alphaMap.value = e.map),
            e.displacementMap &&
            ((s.displacementMap.value = e.displacementMap),
              s.displacementScaleBias.value.set(
                e.displacementScale,
                e.displacementBias
              )),
            e.particle &&
            ((s.particleSize.value = e.particleSize),
              (s.screenWidth.value = o),
              e.particleSizeAttenuation && Ce.push({ material: l }));
        } else var l = Le.clone();
        return (
          t.shadowMapSlopeDepthBias &&
          ((l.uniforms.slopeScale.value = t.shadowMapSlopeScale),
            (l.uniforms.slopeBias.value = t.shadowMapSlopeBias),
            (l.uniforms.slopeMax.value = t.shadowMapSlopeMax)),
          (l.defines = i),
          (l.extensions = n),
          (l.vertexColors = e.vertexColors),
          (l.alphaTest = e.alphaTest),
          (l.visible = e.visible),
          (l.side =
            t.shadowMapCullFace === XG.CullFaceFront
              ? XG.BackSide
              : XG.FrontSide),
          l
        );
      },
      Ze = function (e) {
        var t = e.properties,
          a = Je(e.materials);
        (t.combinedMaterials = a.combinedMaterials),
          (t.colorMaterials = a.colorMaterials),
          (t.depthMaterials = a.depthMaterials),
          (t.normalDepthMaterials = a.normalDepthMaterials),
          (t.forwardMaterials = e.materials),
          (t.occluderMaterials = a.occluderMaterials),
          (t.deferredInitialized = !0),
          (t.deferredNeedsUpdate = !1);
      },
      Qe = XG.RendererUtils.getUvScale,
      Je = function (e) {
        for (
          var t = {
            combinedMaterials: [],
            colorMaterials: [],
            depthMaterials: [],
            normalDepthMaterials: [],
            occluderMaterials: [],
          },
          a = 0,
          r = e.length;
          r > a;
          a++
        ) {
          var i = e[a],
            o = Qe(i);
          if (d) {
            void 0 === Ee[i.id] && (Ee[i.id] = We(i, o));
            var n = Ee[i.id];
            t.combinedMaterials.push(n),
              void 0 === Ie[i.id] && (Ie[i.id] = je(i, o));
            var s = Ie[i.id];
            t.occluderMaterials.push(s);
          } else {
            void 0 === Fe[i.id] && (Fe[i.id] = qe(i, o));
            var l = Fe[i.id];
            t.colorMaterials.push(l),
              void 0 === Re[i.id] && (Re[i.id] = Ye(i, o));
            var h = Re[i.id];
            t.normalDepthMaterials.push(h),
              void 0 === Ie[i.id] && (Ie[i.id] = Ye(i, o));
            var s = Ie[i.id];
            t.occluderMaterials.push(s);
          }
          void 0 === Ue[i.id] && (Ue[i.id] = Ke(i, o));
          var c = Ue[i.id];
          t.depthMaterials.push(c);
        }
        return t;
      },
      $e = function (e) {
        for (
          var t,
          a,
          r,
          i,
          o = e.properties,
          n = o.forwardMaterials,
          s = o.combinedMaterials,
          l = o.colorMaterials,
          h = o.depthMaterials,
          c = o.normalDepthMaterials,
          u = o.occluderMaterials,
          f = 0,
          p = n.length;
          p > f;
          f++
        ) {
          var m = n[f],
            v = m.visible,
            g = Qe(m),
            S = h[f];
          (S.visible = v), (r = S.uniforms);
          var x = u[f];
          if (
            ((x.visible = v),
              (i = x.uniforms),
              (S.alphaTest = m.alphaTest),
              (x.alphaTest = m.alphaTest),
              d)
          ) {
            var G = s[f];
            (G.visible = v), (t = G.uniforms), (G.alphaTest = m.alphaTest);
          } else {
            var M = l[f],
              y = c[f];
            (M.visible = v),
              (y.visible = v),
              (t = M.uniforms),
              (a = y.uniforms),
              (M.alphaTest = m.alphaTest),
              (y.alphaTest = m.alphaTest);
          }
          if (((t.map.value = m.map), m instanceof XG.PhongMaterial)) {
            var w = m.wrapAround ? -1 : 1,
              _ = m.shininess,
              X = m.color,
              D = m.specular,
              T = m.wrapRGB;
            t.diffuse.value.setRGBA(X, w),
              t.specular.value.setRGBA(D, _),
              t.wrapRGB.value.copy(T),
              (t.lightMap.value = m.lightMap),
              (t.specularMap.value = m.specularMap),
              (t.glossMap.value = m.glossMap),
              (t.bumpMap.value = m.bumpMap),
              (t.normalMap.value = m.normalGlossMap
                ? m.normalGlossMap
                : m.normalMap),
              (t.displacementMap.value = m.displacementMap),
              (t.parallaxScale.value = m.parallaxScale),
              t.displacementScaleBias.value.set(
                m.displacementScale,
                m.displacementBias
              ),
              d
                ? ((t.bumpDetailMap.value = m.bumpDetailMap),
                  (t.normalDetailMap.value = m.normalDetailMap),
                  t.detailRepeatScale.value.set(
                    m.detailRepeat.x,
                    m.detailRepeat.y,
                    m.detailScale
                  ),
                  t.normalScale.value.copy(m.normalScale),
                  (t.bumpScale.value = m.bumpScale),
                  (t.displacementNormalScale.value = m.displacementNormalScale))
                : ((a.bumpMap.value = m.bumpMap),
                  (a.normalMap.value = m.normalGlossMap
                    ? m.normalGlossMap
                    : m.normalMap),
                  (a.bumpDetailMap.value = m.bumpDetailMap),
                  (a.normalDetailMap.value = m.normalDetailMap),
                  a.detailRepeatScale.value.set(
                    m.detailRepeat.x,
                    m.detailRepeat.y,
                    m.detailScale
                  ),
                  a.normalScale.value.copy(m.normalScale),
                  (a.bumpScale.value = m.bumpScale),
                  (a.parallaxScale.value = m.parallaxScale),
                  (a.displacementMap.value = m.displacementMap),
                  a.displacementScaleBias.value.set(
                    m.displacementScale,
                    m.displacementBias
                  ),
                  (a.displacementNormalScale.value = m.displacementNormalScale),
                  m.alphaTest && m.map && (a.alphaMap.value = m.map)),
              m.alphaTest &&
              m.map &&
              ((r.alphaMap.value = m.map), (i.alphaMap.value = m.map)),
              m.displacementMap &&
              ((r.displacementMap.value = m.displacementMap),
                r.displacementScaleBias.value.set(
                  m.displacementScale,
                  m.displacementBias
                ),
                (i.displacementMap.value = m.displacementMap),
                i.displacementScaleBias.value.set(
                  m.displacementScale,
                  m.displacementBias
                ));
          } else
            m instanceof XG.EmissiveMaterial &&
              (m.alphaTest && m.map && (i.alphaMap.value = m.map),
                m.displacementMap &&
                ((i.displacementMap.value = m.displacementMap),
                  i.displacementScaleBias.value.set(
                    m.displacementScale,
                    m.displacementBias
                  )));
          if (g) {
            var C = g.offset,
              A = g.repeat;
            t.offsetRepeat.value.set(
              C.data[0],
              C.data[1],
              A.data[0],
              A.data[1]
            ),
              r.offsetRepeat.value.set(
                C.data[0],
                C.data[1],
                A.data[0],
                A.data[1]
              ),
              i.offsetRepeat.value.set(
                C.data[0],
                C.data[1],
                A.data[0],
                A.data[1]
              ),
              d ||
              a.offsetRepeat.value.set(
                C.data[0],
                C.data[1],
                A.data[0],
                A.data[1]
              );
          }
        }
        o.deferredNeedsUpdate = !1;
      },
      et = function (e) {
        var a,
          r,
          i,
          o,
          n,
          s,
          l,
          h = e.__objects,
          d = e.__lights;
        for (a = 0, r = h.length; r > a; a++)
          (n = h[a]),
            (l = n.properties),
            n.materials &&
            (l.deferredInitialized ? l.deferredNeedsUpdate && $e(n) : Ze(n));
        if (t.useMultiProxies) var c = { polyLight: null };
        for (a = 0, r = d.length; r > a; a++)
          if (((s = d[a]), !s.properties.deferredInitialized)) {
            if (s instanceof XG.PointLight)
              (i = new XG.PointLightProxy(s, t)),
                (o = s.distance > 0 ? ne : oe);
            else if (s instanceof XG.SphereLight)
              (i = new XG.SphereLightProxy(s, t)),
                (o = s.distance > 0 ? ne : oe);
            else if (s instanceof XG.TubeLight)
              (i = new XG.TubeLightProxy(s, t)), (o = oe);
            else if (s instanceof XG.SpotLight)
              (i = new XG.SpotLightProxy(s, t)), (o = oe);
            else if (s instanceof XG.DirectionalLight)
              (i = new XG.DirectionalLightProxy(s, t)), (o = oe);
            else if (s instanceof XG.HemisphereLight)
              (i = new XG.HemisphereLightProxy(s, t)), (o = oe);
            else if (s instanceof XG.DayLight)
              (i = new XG.DayLightProxy(s, t)), (o = oe);
            else if (s instanceof XG.DayLightCube)
              (i = new XG.DayLightCubeProxy(s, t)), (o = oe);
            else if (s instanceof XG.AreaLight)
              (i = new XG.AreaLightProxy(s, t)), (o = oe);
            else if (s instanceof XG.PolyLight)
              if (t.useMultiProxies) {
                if (!c.polyLight) {
                  var u = new XG.MultiPolyLightProxy(t);
                  (u.needsInit = !0), (c.polyLight = u);
                }
                c.polyLight.addLight(s), (i = null), (o = null);
              } else (i = new XG.PolyLightProxy(s, t)), (o = oe);
            else
              s instanceof XG.ImageLight &&
                ((i = new XG.ImageLightProxy(s, t)), (o = s.local ? ne : oe));
            i && (o.add(i), Ae.push(i)),
              s.castShadow && se.properties.shadowCasters.push(s),
              (s.properties.deferredInitialized = !0);
          }
        if (t.useMultiProxies && c.polyLight && c.polyLight.needsInit) {
          var u = c.polyLight;
          u.init(), oe.add(u), Ae.push(u), (u.needsInit = !1);
        }
      },
      tt = function (e, t, a, r, i, o) {
        for (var n = 0, s = e.length; s > n; n++) {
          var l = e[n];
          (l.blending = t),
            t === XG.CustomBlending &&
            ((l.blendSrcColor = a),
              (l.blendDstColor = r),
              (l.blendSrcAlpha = i),
              (l.blendDstAlpha = o));
        }
      },
      at = function (e) {
        for (var t = [], a = 0, r = e.length; r > a; a++) t[a] = e[a].clone();
        return t;
      },
      rt = function () {
        return d && t.useDepthTexture
          ? { TEXTURE_DEPTH: !0 }
          : d && !t.useDepthTexture
            ? { RGBA_DEPTH: !0 }
            : { FLOAT_DEPTH: !0 };
      },
      it = function (e) {
        switch (
        ((e.TONEMAP_SIMPLE = !1),
          (e.TONEMAP_LINEAR = !1),
          (e.TONEMAP_REINHARD = !1),
          (e.TONEMAP_FILMIC = !1),
          (e.TONEMAP_FILMIC_2015 = !1),
          (e.TONEMAP_UNCHARTED = !1),
          (e.TONEMAP_REINHARD_LUMA = !1),
          (e.TONEMAP_REINHARD_WHITE = !1),
          (e.TONEMAP_PHOTOGRAPHIC = !1),
          s)
        ) {
          case XG.SimpleOperator:
            e.TONEMAP_SIMPLE = !0;
            break;
          case XG.LinearOperator:
            e.TONEMAP_LINEAR = !0;
            break;
          case XG.ReinhardOperator:
            e.TONEMAP_REINHARD = !0;
            break;
          case XG.FilmicOperator:
            e.TONEMAP_FILMIC = !0;
            break;
          case XG.Filmic2015Operator:
            e.TONEMAP_FILMIC_2015 = !0;
            break;
          case XG.UnchartedOperator:
            e.TONEMAP_UNCHARTED = !0;
            break;
          case XG.LumaReinhardOperator:
            e.TONEMAP_REINHARD_LUMA = !0;
            break;
          case XG.WhitePreservingReinhardOperator:
            e.TONEMAP_REINHARD_WHITE = !0;
            break;
          case XG.PhotographicOperator:
            e.TONEMAP_PHOTOGRAPHIC = !0;
        }
        e.TONEMAPPING = !0;
      },
      ot = function (e, t) {
        ht(e, t, !0, !1, !1);
      },
      nt = function (e, t) {
        ht(e, t, !1, !0, !1);
      },
      st = function (e, t) {
        ht(e, t, !1, !1, !0);
      },
      lt = function (e, t) {
        ht(e, t, !0, !0, !0);
      },
      ht = function (e, a, r, i, o) {
        for (
          var n = e.__objects,
          s = "occluderMaterials" === a,
          l = 0,
          h = n.length;
          h > l;
          l++
        ) {
          var d = n[l];
          if (d.materials) {
            var c = d.properties,
              u = c[a];
            if (u) {
              d.materials = u;
              for (
                var f = !0, p = c.forwardMaterials, m = 0, v = u.length;
                v > m;
                m++
              ) {
                var g = u[m],
                  S = p[m],
                  x = S.transparent,
                  G = !x,
                  M = !(x || S instanceof XG.PhongMaterial),
                  y = S.particle && x,
                  w = !!S.occluder;
                (g.enabled =
                  (x && i) || (G && r) || (M && o && !s) || (w && s)),
                  (g.enabled = g.enabled && (!y || !t.particlesOffscreen)),
                  (g.enabled = g.enabled && !(M && !o)),
                  (f = f && !g.enabled);
              }
              d.enabled = !f;
            }
          }
        }
      },
      dt = function (e) {
        ct(e, 4);
      },
      ct = function (e, t) {
        for (var a, r = e.__objects, i = 0, o = r.length; o > i; i++)
          if (((a = r[i]), a.materials))
            if (a instanceof XG.Particles || (4 === t && !a.castShadow))
              for (var n = 0, s = a.materials.length; s > n; n++) {
                var l = a.materials[n];
                l.enabled = !1;
              }
            else {
              var h,
                d = a.properties,
                c = d.forwardMaterials;
              if (0 === t);
              else if (1 === t);
              else if (2 === t);
              else if (3 === t);
              else if (4 === t) {
                if (void 0 === d.forwardMaterialsTranslucency) {
                  var u = at(c);
                  tt(u, XG.AdditiveBlending),
                    (d.forwardMaterialsTranslucency = u);
                }
                (h = d.forwardMaterialsTranslucency), ut(h);
              }
              if (t > 0)
                for (var n = 0, s = c.length; s > n; n++) {
                  var f = c[n],
                    p = h[n];
                  p.additiveFactor = f.additiveFactor;
                }
              (a.enabled = !0), (a.materials = h);
            }
      },
      ut = function (e) {
        for (var t = 0, a = e.length; a > t; t++) {
          var r = e[t];
          if (!r.particle && r.transparent) {
            if (((r.enabled = !0), !r.defines)) {
              var i = rt();
              (i.TRANSLUCENT_PASS = !0), (r.defines = i);
            }
          } else r.enabled = !1;
        }
      },
      ft = function (e) {
        St(e, 0);
      },
      pt = function (e) {
        St(e, 1);
      },
      mt = function (e) {
        St(e, 2);
      },
      vt = function (e) {
        St(e, 3);
      },
      gt = function (e) {
        St(e, 4);
      },
      St = function (e, t) {
        for (var a, r = e.__objects, i = 0, o = r.length; o > i; i++)
          if (((a = r[i]), a.materials))
            if (a instanceof XG.Particles && (4 !== t || a.castShadow)) {
              var n,
                s = a.properties,
                l = s.forwardMaterials;
              if (0 === t) (n = l), xt(n, !1);
              else if (1 === t) {
                if (void 0 === s.forwardMaterialsMRT) {
                  var h = at(l);
                  tt(
                    h,
                    XG.CustomBlending,
                    XG.OneFactor,
                    XG.OneFactor,
                    XG.ZeroFactor,
                    XG.OneMinusSrcAlphaFactor
                  ),
                    (s.forwardMaterialsMRT = h);
                }
                (n = s.forwardMaterialsMRT), xt(n, !1);
              } else if (2 === t) {
                if (void 0 === s.forwardMaterialsAccumulation) {
                  var d = at(l);
                  tt(
                    d,
                    XG.CustomBlending,
                    XG.OneFactor,
                    XG.OneFactor,
                    XG.ZeroFactor,
                    XG.OneMinusSrcAlphaFactor
                  ),
                    (s.forwardMaterialsAccumulation = d);
                }
                (n = s.forwardMaterialsAccumulation), xt(n, !0);
              } else if (3 === t) {
                if (void 0 === s.forwardMaterialsRevealage) {
                  var c = at(l);
                  tt(
                    c,
                    XG.CustomBlending,
                    XG.OneFactor,
                    XG.OneFactor,
                    XG.ZeroFactor,
                    XG.OneMinusSrcAlphaFactor
                  ),
                    (s.forwardMaterialsRevealage = c);
                }
                (n = s.forwardMaterialsRevealage), xt(n, !1);
              } else if (4 === t) {
                if (void 0 === s.forwardMaterialsTranslucency) {
                  var u = at(l);
                  tt(u, XG.AdditiveBlending),
                    (s.forwardMaterialsTranslucency = u);
                }
                (n = s.forwardMaterialsTranslucency), Gt(n);
              }
              if (t > 0)
                for (var f = 0, p = l.length; p > f; f++) {
                  var m = l[f],
                    v = n[f];
                  (v.time = m.time), (v.additiveFactor = m.additiveFactor);
                }
              (a.enabled = !0), (a.materials = n);
            } else
              for (var f = 0, p = a.materials.length; p > f; f++) {
                var g = a.materials[f];
                g.enabled = !1;
              }
      },
      xt = function (e, a) {
        for (
          var r = w.renderTarget2.width,
          i = w.renderTarget2.height,
          o = d ? S.renderTarget2.colorTexture[4] : G.renderTarget2,
          n = 0,
          s = e.length;
          s > n;
          n++
        ) {
          var l = e[n],
            h = l.uniforms;
          if (l.particle && l.transparent) {
            if (((l.enabled = !0), !l.defines)) {
              var c = rt();
              t.particlesOffscreen && (c.OFFSCREEN_PARTICLES = !0),
                t.fogEnabled && (c.FOG_ENABLED = !0),
                l.lights && (d || a) && (c.USE_LIGHTS = !0),
                t.particlesOit &&
                ((c.OIT_PARTICLES = !0),
                  d
                    ? ((c.OIT_MRT_PASS = !0), (c.MRT_OUTPUT = !0))
                    : a
                      ? (c.OIT_ACCUMULATION_PASS = !0)
                      : (c.OIT_REVEALAGE_PASS = !0)),
                (l.defines = c);
            }
            l.extensions || (l.extensions = {}),
              t.particlesOit && d && (l.extensions.WEBGL_draw_buffers = !0),
              h &&
              ((h.tDepth.value = o),
                t.fogEnabled &&
                (h.fogColor.value.copy(t.fogColor),
                  (h.fogStrength.value = t.fogStrength),
                  (h.fogStart.value = t.fogStart)),
                h.viewSize.value.set(r, i));
          } else l.enabled = !1;
        }
      },
      Gt = function (e) {
        for (var t = 0, a = e.length; a > t; t++) {
          var r = e[t];
          if (r.particle && r.transparent) {
            if (((r.enabled = !0), !r.defines)) {
              var i = rt();
              (i.TRANSLUCENT_PASS = !0), (r.defines = i);
            }
          } else r.enabled = !1;
        }
      },
      Mt = function (e, a, r) {
        for (var i = 0, o = e.length; o > i; i++) {
          var n = e[i],
            s = n.uniforms,
            l = a[i].transparent,
            h = !!a[i].forceShadow;
          (n.enabled = !l || h),
            r
              ? ((n.polygonOffset = !0),
                (n.polygonOffsetFactor = 1.5),
                (n.polygonOffsetUnits = 10),
                (s.depthTextureBias.value = t.shadowMapDepthTextureBias))
              : ((s.slopeScale.value = t.shadowMapSlopeScale),
                (s.slopeBias.value = t.shadowMapSlopeBias),
                (s.slopeMax.value = t.shadowMapSlopeMax)),
            (n.side =
              t.shadowMapCullFace === XG.CullFaceFront
                ? XG.BackSide
                : t.shadowMapCullFace === XG.CullFaceBack
                  ? XG.FrontSide
                  : XG.DoubleSide);
        }
      },
      yt = function (e, t) {
        for (var a, r = e.__objects, i = 0, o = r.length; o > i; i++)
          if (((a = r[i]), a.materials))
            if (a.castShadow) {
              var n = a.properties.depthMaterials;
              (a.materials = n),
                (a.enabled = !0),
                Mt(n, a.properties.forwardMaterials, t);
            } else {
              for (var s = 0, l = a.materials.length; l > s; s++) {
                var h = a.materials[s];
                h.enabled = !1;
              }
              a.enabled = !1;
            }
      },
      wt = function (e, t) {
        e.position.copy(t.matrixWorld.getPosition()),
          t.target && e.lookAt(t.target.matrixWorld.getPosition()),
          e.updateMatrixWorld(),
          e.matrixWorldInverse.getInverse(e.matrixWorld);
      },
      _t = function (e, t) {
        (e.near = t.shadowCameraNear),
          (e.far = t.shadowCameraFar),
          t instanceof XG.PointLight || t instanceof XG.SphereLight
            ? (e.fov = 90)
            : t instanceof XG.SpotLight ||
              (t instanceof XG.AreaLight && !t.shadowCameraOrtho) ||
              (t instanceof XG.PolyLight && !t.shadowCameraOrtho)
              ? (e.fov = t.shadowCameraFov)
              : (t instanceof XG.DirectionalLight ||
                t instanceof XG.DayLight ||
                t instanceof XG.DayLightCube ||
                (t instanceof XG.AreaLight && t.shadowCameraOrtho) ||
                (t instanceof XG.PolyLight && t.shadowCameraOrtho)) &&
              ((e.left = t.shadowCameraLeft),
                (e.right = t.shadowCameraRight),
                (e.top = t.shadowCameraTop),
                (e.bottom = t.shadowCameraBottom)),
          e.updateProjectionMatrix();
      },
      Xt = function (e, t, a, r) {
        (e.near = t.shadowCameraNear), (e.far = t.shadowCameraFar);
        var i = t.shadowCascadeNearZ[a],
          o = t.shadowCascadeFarZ[a],
          n = t.properties.pointsFrustum[a];
        n[0].setZ(i),
          n[1].setZ(i),
          n[2].setZ(i),
          n[3].setZ(i),
          n[4].setZ(o),
          n[5].setZ(o),
          n[6].setZ(o),
          n[7].setZ(o);
        var s = t.properties.pointsWorld[a];
        fe.set(1 / 0, 1 / 0, 1 / 0), pe.set(-(1 / 0), -(1 / 0), -(1 / 0));
        for (var l = fe.data, h = pe.data, d = 0; 8 > d; d++) {
          var c = s[d],
            u = c.data;
          c.copy(n[d]),
            ue.unprojectVector(c, r),
            e.matrixWorldInverse.multiplyVector3(c),
            u[0] < l[0] && (l[0] = u[0]),
            u[0] > h[0] && (h[0] = u[0]),
            u[1] < l[1] && (l[1] = u[1]),
            u[1] > h[1] && (h[1] = u[1]),
            u[2] < l[2] && (l[2] = u[2]),
            u[2] > h[2] && (h[2] = u[2]);
        }
        (e.left = l[0]),
          (e.right = h[0]),
          (e.top = h[1]),
          (e.bottom = l[1]),
          e.updateProjectionMatrix();
      },
      Dt = function (e, a, r, i, o, n, s) {
        var l = t.renderer,
          h = a.projectionMatrix.elements,
          d = h[10];
        (h[10] *= 1 + t.shadowMapProjectionBias),
          l.getViewport(Te),
          l.setRenderTarget(r),
          l.setViewport(i, o, n, s),
          l.enableScissorTest(!0),
          l.setScissor(i, o, n, s),
          l.clearTarget(r),
          l.enableScissorTest(!1),
          l.render(e, a, r, !1),
          l.setViewport(Te.x, Te.y, Te.width, Te.height),
          (h[10] = d);
      },
      Tt = function (e, a) {
        var r = t.renderer;
        (r.autoClearDepth = !0),
          (r.autoClearStencil = !1),
          (r.autoUpdateScene = !1);
        var i = t.shadowMapUseDepthTextures && r.supportsDepthTextures();
        i
          ? ((r.autoClearColor = !1), ce.colorMask(!1, !1, !1, !1))
          : (Xe.copy(r.getClearColor()),
            (De = r.getClearAlpha()),
            r.setClearColor(ve, 1)),
          yt(e, i);
        for (
          var o, n, s = e.properties.shadowCasters, l = 0, h = s.length;
          h > l;
          l++
        ) {
          var d = s[l];
          if (
            d instanceof XG.SpotLight ||
            d instanceof XG.AreaLight ||
            d instanceof XG.PolyLight
          ) {
            var c = d.properties.shadowMap,
              u = d.properties.shadowCamera;
            wt(u, d),
              _t(u, d),
              (o = 0),
              (n = 0),
              Dt(e, u, c, o, n, d.shadowMapWidth, d.shadowMapHeight);
          } else if (
            d instanceof XG.DirectionalLight ||
            d instanceof XG.DayLight ||
            d instanceof XG.DayLightCube
          ) {
            for (var f = 0; f < d.properties.cascadeCount; f++)
              if (
                !(
                  f > t.shadowMapCascadeUpdateThreshold &&
                  Ne % t.shadowMapCascadeUpdateModulo !== 0
                )
              ) {
                var c = d.properties.shadowMap[f],
                  u = d.properties.shadowCamera[f];
                wt(u, d),
                  d.shadowCascade ? Xt(u, d, f, a) : _t(u, d),
                  (o = 0),
                  (n = 0),
                  Dt(e, u, c, o, n, d.shadowMapWidth, d.shadowMapHeight);
              }
          } else if (d instanceof XG.PointLight || d instanceof XG.SphereLight)
            for (var c = d.properties.shadowMap, f = 0; 6 > f; f++) {
              var u = d.properties.shadowCamera[f];
              wt(u, d), _t(u, d);
              var o = f * d.shadowMapWidth,
                n = 0;
              Dt(e, u, c, o, n, d.shadowMapWidth, d.shadowMapHeight);
            }
        }
        i
          ? ((r.autoClearColor = !0), ce.colorMask(!0, !0, !0, !0))
          : r.setClearColor(Xe, De);
      },
      Ct = function (e, t) {
        if (t.properties.gyro)
          var a = t.properties.nonGyroLight,
            r = t.properties.nonGyroTarget;
        else
          var a = t,
            r = t.target;
        e.position.copy(a.matrixWorld.getPosition()),
          t.target && e.lookAt(r.matrixWorld.getPosition()),
          e.updateMatrixWorld(),
          e.matrixWorldInverse.getInverse(e.matrixWorld);
      },
      At = function (e, t) {
        (e.near = t.textureCameraNear),
          (e.far = t.textureCameraFar),
          t instanceof XG.PointLight || t instanceof XG.SphereLight
            ? (e.fov = 90)
            : t instanceof XG.SpotLight || t instanceof XG.AreaLight
              ? (e.fov = t.textureCameraFov)
              : (t instanceof XG.DirectionalLight ||
                t instanceof XG.DayLight ||
                t instanceof XG.DayLightCube ||
                t instanceof XG.AreaLight) &&
              ((e.left = t.textureCameraLeft),
                (e.right = t.textureCameraRight),
                (e.top = t.textureCameraTop),
                (e.bottom = t.textureCameraBottom)),
          e.updateProjectionMatrix();
      },
      Pt = function (e) {
        var a = t.renderer;
        (a.autoClearDepth = !1),
          (a.autoClearStencil = !1),
          (a.autoUpdateScene = !1),
          Xe.copy(a.getClearColor()),
          (De = a.getClearAlpha()),
          a.setClearColor(me, 0);
        var r = e.properties.shadowCasters;
        if (t.particlesShadows) {
          gt(e);
          for (var i = 0, o = r.length; o > i; i++) {
            var n = r[i];
            if (
              n.castTransparentShadow &&
              (n instanceof XG.DirectionalLight ||
                n instanceof XG.DayLight ||
                n instanceof XG.DayLightCube ||
                n instanceof XG.SpotLight)
            ) {
              var s = n.texture,
                l = n.properties.textureCamera;
              Ct(l, n), At(l, n), a.render(e, l, s, !0);
            }
          }
        }
        dt(e);
        for (var i = 0, o = r.length; o > i; i++) {
          var n = r[i];
          if (
            n.castTransparentShadow &&
            (n instanceof XG.DirectionalLight ||
              n instanceof XG.DayLight ||
              n instanceof XG.DayLightCube ||
              n instanceof XG.SpotLight)
          ) {
            var s = n.texture,
              l = n.properties.textureCamera;
            t.particlesShadows && (Ct(l, n), At(l, n)),
              a.render(e, l, s, !t.particlesShadows);
          }
        }
        a.setClearColor(Xe, De);
      },
      Lt = function () {
        var e = t.renderer,
          a = e.shadowMapUseDepthTextures;
        (e.shadowMapEnabled = t.shadowMapEnabled),
          (e.shadowMapAutoUpdate = !1),
          (e.shadowMapUseDepthTextures = !0),
          ce.depthFunc(ce.LEQUAL),
          y.render(),
          (e.shadowMapUseDepthTextures = a);
      },
      bt = function () {
        var e = t.renderer;
        (e.shadowMapEnabled = !1),
          (e.autoClearDepth = !1),
          ce.depthFunc(ce.LEQUAL),
          P.render();
      },
      Et = function (e, a) {
        he.enabled = !1;
        var r = e.properties.mirrors;
        if (void 0 !== r) {
          var i = r.length;
          if (0 !== i) {
            var s = t.renderer;
            (s.autoClearDepth = !0),
              ce.depthFunc(ce.LEQUAL),
              lt(e, "forwardMaterials");
            var l = s.shadowMapUseDepthTextures;
            (s.shadowMapEnabled = t.shadowMapEnabled),
              (s.shadowMapAutoUpdate = !1),
              (s.shadowMapUseDepthTextures = !0);
            for (
              var h = d ? S.renderTarget2.colorTexture[4] : G.renderTarget2,
              c = 0;
              i > c;
              c++
            ) {
              var u = r[c],
                f = u.material.uniforms,
                p = u.material.defines;
              (f.refractionSampler.value = le),
                (f.refractionDepthSampler.value = h),
                (f.matProjInverse.value = a.projectionMatrixInverse),
                (f.matViewInverse.value = a.matrixWorld),
                f.viewSize.value.set(o, n),
                (p.USE_MRT = d),
                u.properties.secondaryMirror
                  ? u.renderWithMirror(e, a, u.properties.secondaryMirror)
                  : u.render(e, a);
            }
            (he.enabled = !0),
              (s.autoClearDepth = !1),
              (s.shadowMapUseDepthTextures = l);
          }
        }
      },
      Ft = function (e) {
        t.particlesOffscreenUpsampleFancy && X.render();
        var a = t.renderer,
          r = a.shadowMapUseDepthTextures;
        (a.shadowMapEnabled = t.shadowMapEnabled),
          (a.shadowMapAutoUpdate = !1),
          (a.shadowMapUseDepthTextures = !0),
          t.particlesOit
            ? d
              ? (pt(e), w.render())
              : (mt(e), w.render(), vt(e), _.render())
            : (ft(e), w.render()),
          (a.shadowMapUseDepthTextures = r);
      },
      Rt = function () {
        var e = t.renderer;
        (e.autoClearDepth = !0), ce.depthFunc(ce.LEQUAL), S.render();
      },
      Ut = function () {
        var e = t.renderer;
        (e.autoClearDepth = !0), ce.depthFunc(ce.LEQUAL), G.render();
      },
      It = function () {
        var e = t.renderer;
        (e.autoClearDepth = !0), (e.autoUpdateView = !1), x.render();
      },
      Nt = function (e) {
        e.projectionMatrixInverse.getInverse(e.projectionMatrix);
        for (var t = 0, a = ne.children.length; a > t; t++) {
          var r = ne.children[t];
          r.update(e);
        }
        for (var t = 0, a = oe.children.length; a > t; t++) {
          var r = oe.children[t];
          r.update(e);
        }
      },
      Bt = function (e, o) {
        var n = t.renderer;
        if (
          ((n.autoUpdateView = !0),
            t.shadowMapEnabled && t.shadowMapAutoUpdate && Tt(e, o),
            t.transparentShadows && t.shadowMapAutoUpdate && Pt(e, o),
            t.ssaoEnabled)
        ) {
          var s = o.far + o.near,
            l = o.far - o.near,
            h = 2 * o.near;
          k.uniforms.cameraCoef.value.set(s, l, h),
            W.uniforms.cameraCoef.value.set(s, l, h),
            j.uniforms.cameraCoef.value.set(s, l, h),
            (k.uniforms.radius.value = i * t.ssaoRadius * 15),
            (W.uniforms.h.value = (4 * t.ssaoRadius) / a),
            (j.uniforms.v.value = (2 * t.ssaoRadius) / r),
            T.render(),
            C.render();
        }
        (n.autoClearDepth = !1),
          (n.autoUpdateScene = !0),
          (n.autoUpdateObjects = !0),
          Nt(o),
          ce.depthFunc(ce.GEQUAL),
          M.render();
      },
      Ot = function () {
        (B.enabled = !0),
          (z.enabled = t.dofEnabled),
          (V.enabled = l),
          t.taaBeforeDOF || ((Z.enabled = c), (Q.enabled = c)),
          (H.enabled = !1),
          (B.renderToScreen = !1),
          (z.renderToScreen = !1),
          (V.renderToScreen = !1),
          t.taaBeforeDOF || ((Z.renderToScreen = !1), (Q.renderToScreen = !1)),
          (H.renderToScreen = !1),
          l && t.dofEnabled
            ? t.dofFancy
              ? ((H.enabled = !0), (H.renderToScreen = !0))
              : c
                ? ((H.enabled = !0), (H.renderToScreen = !0))
                : (z.renderToScreen = !0)
            : l && !t.dofEnabled
              ? ((H.enabled = !0), (H.renderToScreen = !0))
              : !l && t.dofEnabled
                ? t.dofFancy
                  ? c
                    ? ((H.enabled = !0), (H.renderToScreen = !0))
                    : (B.renderToScreen = !0)
                  : c
                    ? ((H.enabled = !0), (H.renderToScreen = !0))
                    : (z.renderToScreen = !0)
                : c
                  ? ((H.enabled = !0), (H.renderToScreen = !0))
                  : (B.renderToScreen = !0);
      },
      Vt = function () {
        var e = B.material,
          t = e.defines;
        if ((it(t), (e.needsUpdate = !0), (K.material.needsUpdate = !0), c)) {
          var a = te.defines,
            r = ae.defines;
          it(a), it(r), (te.needsUpdate = !0), (ae.needsUpdate = !0);
        }
      },
      kt = function () {
        var e = B.material,
          t = e.defines;
        (t.DITHERING_ENABLED = h), (e.needsUpdate = !0);
      },
      zt = function (e) {
        var t = {
          isES3: f,
          hasFloatsNearest: e.supportsFloatTextures(),
          hasFloatsLinear: e.supportsFloatTexturesLinear(),
          hasHalfFloatsNearest: e.supportsHalfFloatTextures(),
          hasHalfFloatsLinear: e.supportsHalfFloatTexturesLinear(),
          hasRGBFloatRenderTarget: e.supportsRGBFloatRenderTarget(),
          hasRGBHalfFloatRenderTarget: e.supportsRGBHalfFloatRenderTarget(),
          hasRGBUbyteRenderTarget: e.supportsRGBUnsignedByteRenderTarget(),
        };
        return t;
      },
      Ht = function () {
        if ("webgl2" === u)
          var e = {
            minFilter: XG.NearestFilter,
            magFilter: XG.LinearFilter,
            stencilBuffer: !1,
            format: XG.RGBAFormat,
            internalFormat: XG.RGBA32F,
            type: XG.FloatType,
          },
            i = {
              minFilter: XG.NearestFilter,
              magFilter: XG.NearestFilter,
              stencilBuffer: !1,
              format: XG.RGBAFormat,
              internalFormat: XG.RGBA32F,
              type: XG.FloatType,
            },
            s = {
              minFilter: XG.NearestFilter,
              magFilter: XG.LinearFilter,
              stencilBuffer: !1,
              format: XG.RGBAFormat,
              internalFormat: XG.RGBA16F,
              type: XG.HalfFloatType2,
            },
            l = {
              minFilter: XG.NearestFilter,
              magFilter: XG.NearestFilter,
              stencilBuffer: !1,
              format: XG.RGBAFormat,
              internalFormat: XG.RGBA16F,
              type: XG.HalfFloatType2,
            },
            c = {
              minFilter: XG.LinearFilter,
              magFilter: XG.LinearFilter,
              stencilBuffer: !1,
              format: XG.RGBFormat,
              internalFormat: XG.RGBFormat,
              type: XG.UnsignedByteType,
            };
        else
          var e = {
            minFilter: XG.NearestFilter,
            magFilter: XG.LinearFilter,
            stencilBuffer: !1,
            format: XG.RGBAFormat,
            internalFormat: XG.RGBAFormat,
            type: XG.FloatType,
          },
            i = {
              minFilter: XG.NearestFilter,
              magFilter: XG.NearestFilter,
              stencilBuffer: !1,
              format: XG.RGBAFormat,
              internalFormat: XG.RGBAFormat,
              type: XG.FloatType,
            },
            s = {
              minFilter: XG.NearestFilter,
              magFilter: XG.LinearFilter,
              stencilBuffer: !1,
              format: XG.RGBAFormat,
              internalFormat: XG.RGBAFormat,
              type: XG.HalfFloatType1,
            },
            l = {
              minFilter: XG.NearestFilter,
              magFilter: XG.NearestFilter,
              stencilBuffer: !1,
              format: XG.RGBAFormat,
              internalFormat: XG.RGBAFormat,
              type: XG.HalfFloatType1,
            },
            c = {
              minFilter: XG.LinearFilter,
              magFilter: XG.LinearFilter,
              stencilBuffer: !1,
              format: XG.RGBFormat,
              internalFormat: XG.RGBFormat,
              type: XG.UnsignedByteType,
            };
        var f,
          p = zt(t.renderer);
        if (
          (p.hasHalfFloatsLinear
            ? (f = s)
            : p.hasHalfFloatsNearest
              ? (f = l)
              : p.hasFloatsLinear
                ? (f = e)
                : p.hasFloatsNearest
                  ? (f = i)
                  : console.error(
                    "XG.DeferredRenderer: missing float or half float render targets support"
                  ),
            p.hasRGBUbyteRenderTarget ||
            ((c.format = XG.RGBAFormat), (c.internalFormat = XG.RGBAFormat)),
            d)
        ) {
          var m = t.useDepthTexture ? 4 : 5,
            v = {
              minFilter: XG.NearestFilter,
              magFilter: XG.NearestFilter,
              format: XG.RGBAFormat,
              internalFormat: XG.RGBAFormat,
              type: XG.UnsignedByteType,
              stencilBuffer: !1,
            },
            g = new XG.RenderTargetArray(o, n, m, t.useDepthTexture, v);
          (g.generateMipmaps = !1),
            (L = new XG.RenderPass()),
            (L.clear = !0),
            (L.clearColor = ve),
            (L.clearAlpha = 1),
            (S = new XG.EffectComposer(t.renderer, g)),
            S.addPass(L);
          var oe = S.renderTarget2,
            ne = oe.colorTexture[3],
            se = t.useDepthTexture ? oe.depthTexture : oe.colorTexture[4];
        } else {
          var de = new XG.RenderTarget(o, n, i);
          de.generateMipmaps = !1;
          var ce = new XG.RenderTarget(o, n, i);
          (ce.generateMipmaps = !1),
            (E = new XG.RenderPass()),
            (E.clear = !0),
            (E.clearColor = ve),
            (E.clearAlpha = 1),
            (G = new XG.EffectComposer(t.renderer, ce)),
            G.addPass(E),
            (b = new XG.RenderPass()),
            (b.clear = !0),
            (x = new XG.EffectComposer(t.renderer, de)),
            x.addPass(b),
            (x.renderTarget2.shareDepthFrom = G.renderTarget2);
        }
        var ue = d ? se : G.renderTarget2,
          fe = Math.max(1, Math.floor(o * t.ssaoScale)),
          pe = Math.max(1, Math.floor(n * t.ssaoScale)),
          ge = new XG.RenderTarget(fe, pe, c),
          Se = new XG.RenderTarget(o, n, c);
        (ge.generateMipmaps = !1),
          (Se.generateMipmaps = !1),
          (ge.depthBuffer = !1),
          (ge.stencilBuffer = !1),
          (Se.depthBuffer = !1),
          (Se.stencilBuffer = !1),
          (k = new XG.ShaderPass(XG.SSAOShader)),
          (k.clear = !1),
          k.uniforms.size.value.set(fe, pe),
          (k.uniforms.aoClamp.value = 1.5),
          (W = new XG.ShaderPass(XG.SSAOBilateralHorizontalBlurShader)),
          (j = new XG.ShaderPass(XG.SSAOBilateralVerticalBlurShader)),
          (W.uniforms.h.value = (4 * t.ssaoRadius) / a),
          (j.uniforms.v.value = (2 * t.ssaoRadius) / r),
          (k.material.blending = XG.NoBlending),
          (k.material.depthTest = !1),
          (k.material.depthWrite = !1),
          (W.material.blending = XG.NoBlending),
          (W.material.depthTest = !1),
          (W.material.depthWrite = !1),
          (j.material.blending = XG.NoBlending),
          (j.material.depthTest = !1),
          (j.material.depthWrite = !1),
          (k.uniforms.tDepth.value = ue),
          (W.uniforms.tDepth.value = ue),
          (j.uniforms.tDepth.value = ue),
          d &&
          ((W.uniforms.tNormal.value = ne), (j.uniforms.tNormal.value = ne));
        var xe = rt(),
          Ge = t.ssaoSamples;
        (xe.PREBAKED_SAMPLES = !0),
          (xe.NUM_PREBAKED_SAMPLES = Ge),
          (k.uniforms.samplePoints.value = XG.Math.generatePoissonDiscSamples(
            Ge
          )),
          (k.material.defines = xe),
          (W.material.defines = xe),
          (j.material.defines = xe),
          (T = new XG.EffectComposer(t.renderer, ge)),
          T.addPass(k),
          (W.textureID = "dummy"),
          (W.uniforms.tDiffuse.value = T.renderTarget1),
          (C = new XG.EffectComposer(t.renderer, Se)),
          C.addPass(W),
          C.addPass(j);
        var Me = new XG.RenderTarget(o, n, f),
          ye = new XG.RenderTarget(o, n, c);
        (Me.generateMipmaps = !1),
          (ye.generateMipmaps = !1),
          (ye.depthBuffer = !1),
          (ye.stencilBuffer = !1),
          (F = new XG.RenderPass()),
          (F.clear = !0),
          (R = new XG.RenderPass()),
          (R.clear = !1),
          (le = new XG.RenderTarget(o, n, c)),
          (he = new XG.SavePass(le)),
          (he.material.depthTest = !1),
          (he.enabled = !1),
          (M = new XG.EffectComposer(t.renderer, Me)),
          M.addPass(F),
          M.addPass(R),
          M.addPass(he),
          (M.renderTarget2.shareDepthFrom = d
            ? S.renderTarget2
            : G.renderTarget2),
          (U = new XG.RenderPass()),
          (U.clear = !1),
          (y = new XG.EffectComposer(t.renderer, Me)),
          y.addPass(U),
          (y.renderTarget1 = M.renderTarget1),
          (y.renderTarget2 = M.renderTarget2),
          (y.renderTarget2.shareDepthFrom = d
            ? S.renderTarget2
            : G.renderTarget2),
          (O = new XG.RenderPass()),
          (O.clear = !1),
          (P = new XG.EffectComposer(t.renderer, ue)),
          P.addPass(O),
          (P.renderTarget2 = ue),
          d &&
          ((P.renderTarget2.shareDepthFrom = S.renderTarget2),
            (P.renderTarget2.needsUpdate = !0)),
          (I = new XG.RenderPass()),
          (I.clear = !0),
          (I.clearColor = me),
          (I.clearAlpha = 1);
        var _e = Math.max(1, Math.floor(o * t.particlesOffscreenScale)),
          Xe = Math.max(1, Math.floor(n * t.particlesOffscreenScale));
        if (t.particlesOit)
          if (d) {
            var De = new XG.RenderTargetArray(_e, Xe, 2, !1, f);
            (De.generateMipmaps = !1),
              (w = new XG.EffectComposer(t.renderer, De)),
              w.addPass(I);
          } else {
            var Te = new XG.RenderTarget(_e, Xe, f),
              Ae = new XG.RenderTarget(_e, Xe, f);
            (Te.generateMipmaps = !1),
              (Ae.generateMipmaps = !1),
              (w = new XG.EffectComposer(t.renderer, Te)),
              w.addPass(I),
              (_ = new XG.EffectComposer(t.renderer, Ae)),
              _.addPass(I);
          }
        else {
          var Pe = new XG.RenderTarget(_e, Xe, f);
          (Pe.generateMipmaps = !1),
            (w = new XG.EffectComposer(t.renderer, Pe)),
            w.addPass(I);
        }
        var Le = {
          minFilter: XG.LinearFilter,
          magFilter: XG.LinearFilter,
          format: XG.RGBAFormat,
          internalFormat: XG.RGBAFormat,
          type: XG.UnsignedByteType,
          stencilBuffer: !1,
        },
          be = new XG.RenderTarget(_e, Xe, Le);
        (be.generateMipmaps = !1),
          (N = new XG.ShaderPass(XG.DepthSampleShader)),
          (N.needsSwap = !1),
          (N.uniforms.samplerDepth.value = ue);
        var Ee = rt();
        (N.material.defines = Ee),
          Ce.push({ material: N.material, depth: "samplerDepth" }),
          (X = new XG.EffectComposer(t.renderer, be)),
          X.addPass(N);
        var Fe = Math.max(1, Math.floor(o * t.bloomScale)),
          Re = Math.max(1, Math.floor(n * t.bloomScale)),
          Ue = new XG.RenderTarget(Fe, Re, c);
        (Ue.generateMipmaps = !1),
          (Ue.depthBuffer = !1),
          (Ue.stencilBuffer = !1),
          (q = new XG.ShaderPass(XG.BloomHorizontalBlurShader)),
          (Y = new XG.ShaderPass(XG.BloomVerticalBlurShader)),
          (K = new XG.ShaderPass(XG.BloomFilterShader)),
          (K.uniforms.tSource.value = M.renderTarget2),
          (K.uniforms.threshold.value = t.bloomThreshold),
          (K.uniforms.brightness.value = t.brightness),
          (K.uniforms.whitePoint.value = t.whitePoint),
          (q.uniforms.h.value = 1 / Fe),
          (Y.uniforms.v.value = 1 / Re),
          (q.material.blending = XG.NoBlending),
          (q.material.depthTest = !1),
          (q.material.depthWrite = !1),
          (Y.material.blending = XG.NoBlending),
          (Y.material.depthTest = !1),
          (Y.material.depthWrite = !1),
          (K.material.blending = XG.NoBlending),
          (K.material.depthTest = !1),
          (K.material.depthWrite = !1),
          (A = new XG.EffectComposer(t.renderer, Ue)),
          A.addPass(K),
          A.addPass(q),
          A.addPass(Y),
          (B = new XG.ShaderPass(we)),
          (B.uniforms.brightness.value = t.brightness),
          (B.uniforms.whitePoint.value = t.whitePoint),
          (B.uniforms.samplerLight.value = M.renderTarget2),
          (B.uniforms.samplerBloom.value = A.renderTarget1),
          (B.uniforms.bloomStrength.value = t.bloomStrength),
          t.particlesOit
            ? d
              ? ((B.uniforms.samplerParticles.value =
                w.renderTarget2.colorTexture[0]),
                (B.uniforms.samplerParticlesRevealage.value =
                  w.renderTarget2.colorTexture[1]))
              : ((B.uniforms.samplerParticles.value = w.renderTarget2),
                (B.uniforms.samplerParticlesRevealage.value = _.renderTarget2))
            : (B.uniforms.samplerParticles.value = w.renderTarget2),
          (B.uniforms.samplerParticlesDepth.value = X.renderTarget1),
          B.uniforms.particleSamplerSize.value.set(_e, Xe);
        var Ie = rt();
        if (
          (t.fogEnabled && (Ie.FOG_ENABLED = !0),
            (B.uniforms.samplerDepth.value = ue),
            Ce.push({ material: B.material, depth: "samplerDepth" }),
            h && (Ie.DITHERING_ENABLED = !0),
            (B.material.blending = XG.NoBlending),
            (B.material.depthTest = !1),
            (B.material.depthWrite = !1),
            (B.clear = !0),
            it(Ie),
            (Ie.BLOOM_ENABLED = t.bloomEnabled),
            (Ie.OFFSCREEN_PARTICLES = t.particlesOffscreen),
            (Ie.PARTICLES_UPSAMPLING_NEAREST_DEPTH =
              t.particlesOffscreenUpsampleFancy),
            (Ie.PARTICLE_OIT = t.particlesOit),
            (Ie.USE_MRT = d),
            (Ie.FANCY_DOF = t.dofFancy && t.dofEnabled),
            (B.material.defines = Ie),
            (K.material.defines = Ie),
            (V = new XG.ShaderPass(XG.FXAAShader)),
            (V.material.blending = XG.NoBlending),
            (V.material.depthTest = !1),
            (V.material.depthWrite = !1),
            V.uniforms.resolution.value.set(1 / o, 1 / n),
            t.taaBeforeDOF)
        ) {
          (ee = Me.clone()),
            ($ = Me.clone()),
            (J = Me.clone()),
            (re = new XG.ShaderMaterial({
              vertexShader: XG.TAAShader.vertexShader,
              fragmentShader: XG.TAAShader.fragmentShader,
              uniforms: XG.UniformsUtils.clone(XG.TAAShader.uniforms),
              blending: XG.NoBlending,
            })),
            (te = new XG.ShaderMaterial({
              vertexShader: XG.TonemapShader.vertexShader,
              fragmentShader: XG.TonemapShader.fragmentShader,
              uniforms: XG.UniformsUtils.clone(XG.TonemapShader.uniforms),
              blending: XG.NoBlending,
            })),
            (ae = new XG.ShaderMaterial({
              vertexShader: XG.TonemapInverseShader.vertexShader,
              fragmentShader: XG.TonemapInverseShader.fragmentShader,
              uniforms: XG.UniformsUtils.clone(
                XG.TonemapInverseShader.uniforms
              ),
              blending: XG.NoBlending,
            })),
            (ie = new XG.ShaderMaterial({
              vertexShader: XG.CopyShader.vertexShader,
              fragmentShader: XG.CopyShader.fragmentShader,
              uniforms: XG.UniformsUtils.clone(XG.CopyShader.uniforms),
              blending: XG.NoBlending,
            }));
          var Ne = rt();
          (Ne.USE_MRT = d), (re.defines = Ne);
          var Be = {};
          it(Be), (te.defines = Be), (ae.defines = Be);
        } else {
          var Oe = ye.clone();
          (Q = new XG.SavePass(Oe)),
            (Z = new XG.ShaderPass(XG.TAAShader)),
            (Z.uniforms.tDiffuseLast.value = Oe),
            (Z.uniforms.tDepth.value = ue),
            (Z.uniforms.feedbackMin.value = 0.88),
            (Z.uniforms.feedbackMax.value = 0.97);
          var Ne = rt();
          (Ne.USE_MRT = d), (Z.material.defines = Ne);
        }
        if (t.dofFancy) {
          var Ve = 0.75;
          z = new XG.FancyDepthOfFieldPass(o, n, Ve, p);
        } else z = new XG.DepthOfFieldPass(1024, 512, p);
        (z.defines = rt()),
          t.dofDebug && (z.defines.DOF_DEBUG = 1),
          t.dofPhysical && (z.defines.DOF_PHYSICAL = 1),
          (z.depthInput = ue),
          (z.colorInput = M.renderTarget2),
          (z.autoFocus = t.dofAutofocus),
          (z.autoFocusPoint = t.dofAutofocusPoint),
          (z.focusDistance = t.dofFocusDistance),
          (z.focusRampStart = t.dofFocusWidth),
          (z.focusRampEnd = t.dofFocusWidth + t.dofFocusRampWidth),
          (z.maxBlur = t.dofMaxBlur),
          t.dofFancy &&
          t.dofPhysical &&
          ((z.lensFstop = t.dofLensFstop),
            (z.lensFocalLength = t.dofLensFocalLength),
            (z.lensBlurScale = t.dofLensBlurScale),
            t.fogEnabled && (z.defines.FOG_ENABLED = !0)),
          (H = new XG.ShaderPass(XG.CopyShader)),
          (H.renderToScreen = !0),
          t.dofFancy
            ? ((B.uniforms.samplerBlur.value = z.renderTargetBlurPass2),
              (B.uniforms.samplerBlurAmount.value = z.renderTargetBlurAmount),
              (D = new XG.EffectComposer(t.renderer, ye)),
              D.addPass(z),
              D.addPass(B),
              D.addPass(V),
              t.taaBeforeDOF || (D.addPass(Z), D.addPass(Q)),
              D.addPass(H))
            : ((D = new XG.EffectComposer(t.renderer, ye)),
              D.addPass(B),
              D.addPass(V),
              D.addPass(z),
              t.taaBeforeDOF || (D.addPass(Z), D.addPass(Q)),
              D.addPass(H)),
          Ot();
      };
    (this.getRenderingBackend = function () {
      return u;
    }),
      (this.setAntialias = function (e) {
        (l = e), Ot();
      }),
      (this.getAntialias = function () {
        return l;
      }),
      (this.setDOF = function (e) {
        (this.dofEnabled = e), Ot();
        var a = B.material,
          r = a.defines;
        (r.FANCY_DOF = t.dofFancy && t.dofEnabled), (a.needsUpdate = !0);
      }),
      (this.setTonemapping = function (e) {
        (s = e), de && Vt();
      }),
      (this.setDither = function (e) {
        (h = e), de && kt();
      }),
      (this.setSSAOSamples = function (e) {
        this.ssaoSamples = e;
        var t = rt();
        (t.PREBAKED_SAMPLES = !0),
          (t.NUM_PREBAKED_SAMPLES = e),
          (k.uniforms.samplePoints.value = XG.Math.generatePoissonDiscSamples(
            e
          )),
          (k.material.defines = t),
          (k.material.needsUpdate = !0);
      }),
      (this.addEffect = function (e, a) {
        if (
          e.material &&
          e.uniforms &&
          ((e.properties = {}),
            a && (a.normalDepthUniform || a.colorUniform || a.depthUniform))
        ) {
          var r = {
            material: e.material,
            normalDepth: a.normalDepthUniform,
            color: a.colorUniform,
            depth: a.depthUniform,
          };
          Ce.push(r),
            (e.properties.normalDepthUniform = a.normalDepthUniform),
            (e.properties.colorUniform = a.colorUniform),
            (e.properties.depthUniform = a.depthUniform),
            (a.normalDepthUniform || a.depthUniform) &&
            (e.material.defines = rt());
        }
        if (D) {
          var i = t.dofFancy ? -2 : -3;
          D.insertPass(e, i);
        } else _e.push(e);
      }),
      (this.setScale = function (e) {
        if (
          ((i = e),
            this.renderer.setScale(i),
            (o = Math.max(1, Math.floor(i * a))),
            (n = Math.max(1, Math.floor(i * r))),
            (o = Math.max(1, Math.floor(o * m))),
            (n = Math.max(1, Math.floor(n * m))),
            de)
        ) {
          var s = Math.max(1, Math.floor(o * t.ssaoScale)),
            l = Math.max(1, Math.floor(n * t.ssaoScale)),
            h = Math.max(1, Math.floor(o * t.bloomScale)),
            c = Math.max(1, Math.floor(n * t.bloomScale)),
            u = Math.max(1, Math.floor(o * t.particlesOffscreenScale)),
            f = Math.max(1, Math.floor(n * t.particlesOffscreenScale));
          M.setSize(o, n),
            D.setSize(o, n),
            w.setSize(u, f),
            X.setSize(u, f),
            _ && _.setSize(u, f),
            T.setSize(s, l),
            C.setSize(o, n),
            A.setSize(h, c),
            d ? S.setSize(o, n) : (G.setSize(o, n), x.setSize(o, n));
          for (var p = 0, v = Ce.length; v > p; p++) {
            var g = Ce[p],
              y = g.material,
              P = y.uniforms;
            P.viewSize && P.viewSize.value.set(o, n),
              P.screenWidth && (P.screenWidth.value = o);
          }
          for (var p = 0, v = Ae.length; v > p; p++) {
            var L = Ae[p];
            L.resize(o, n);
          }
          V.uniforms.resolution.value.set(1 / o, 1 / n),
            z.resize(o, n),
            k.uniforms.size.value.set(s, l),
            (q.uniforms.h.value = 1 / h),
            (Y.uniforms.v.value = 1 / c),
            t.taaBeforeDOF
              ? (ee.setSize(o, n), $.setSize(o, n), J.setSize(o, n))
              : Q.renderTarget.setSize(o, n);
        }
      }),
      (this.setSize = function (e, t) {
        (a = e), (r = t), this.renderer.setSize(a, r), this.setScale(i);
      }),
      (this.getCombinedTarget = function () {
        return S.renderTarget2;
      }),
      (this.getColorTarget = function () {
        return x.renderTarget2;
      }),
      (this.getNormalDepthTarget = function () {
        return G.renderTarget2;
      }),
      (this.getSSAOTarget = function () {
        return C.renderTarget2;
      }),
      (this.getUseMultipleRenderTargets = function () {
        return d;
      }),
      (this.prepareForwardPass = function (e) {
        e.properties.deferredInitialized && lt(e, "forwardMaterials");
      }),
      (this.renderCube = function (e, t, a) {
        e.properties.deferredInitialized && ot(e, "forwardMaterials"),
          (this.renderer.autoClear = !0),
          this.renderer.renderCube(e, t, a),
          (this.renderer.autoClear = !1);
      }),
      (this.render = function (e, a) {
        if (!de) {
          Ht();
          for (var r = t.dofFancy ? -2 : -3, i = 0, s = _e.length; s > i; i++) {
            var l = _e[i],
              h = l.properties;
            if (h) {
              var u,
                f,
                p,
                m = h.normalDepthUniform,
                v = h.colorUniform,
                g = h.depthUniform;
              if (d) {
                var y = S.renderTarget2;
                (p = t.useDepthTexture ? y.depthTexture : y.colorTexture[4]),
                  (f = y.colorTexture[0]);
              } else
                (u = G.renderTarget2),
                  (f = x.renderTarget2),
                  (p = G.renderTarget2);
              m && (l.uniforms[m].value = u),
                v && (l.uniforms[v].value = f),
                g && (l.uniforms[g].value = p);
            }
            D.insertPass(l, r);
          }
          de = !0;
        }
        var _ = t.renderer,
          T = e.properties;
        if (
          (T.deferredInitialized ||
            ((T.lightSceneGeometry = new XG.Scene()),
              (T.lightSceneFullscreen = new XG.Scene()),
              (T.shadowCasters = []),
              (T.deferredInitialized = !0)),
            (ne = T.lightSceneGeometry),
            (oe = T.lightSceneFullscreen),
            (se = e),
            c)
        ) {
          var C = Oe,
            P = C[2 * Be],
            N = C[2 * Be + 1],
            V = o,
            k = n;
          a.jitter(P, N, V, k),
            (Ve.z = Ve.x),
            (Ve.w = Ve.y),
            (Ve.x = P),
            (Ve.y = N),
            (Be = (Be + 1) % (0.5 * C.length));
        }
        d
          ? ((L.camera = a), (L.scene = e))
          : ((b.camera = a), (b.scene = e), (E.camera = a), (E.scene = e)),
          (R.camera = a),
          (R.scene = ne),
          (F.camera = XG.EffectComposer.camera),
          (F.scene = oe),
          (U.camera = a),
          (U.scene = e),
          (O.camera = a),
          (O.scene = e),
          (I.camera = a),
          (I.scene = e),
          (_.autoUpdateObjects = !1),
          _.initWebGLObjects(e),
          _.initWebGLObjects(XG.EffectComposer.scene),
          et(e),
          (_.autoUpdateScene = !1),
          e.updateMatrixWorld(),
          (F.clear = !0),
          d
            ? ((L.clear = !0),
              ot(e, "combinedMaterials"),
              Rt(e, a),
              Bt(e, a),
              (L.clear = !1))
            : ((b.clear = !0),
              (E.clear = !0),
              ot(e, "normalDepthMaterials"),
              Ut(e, a),
              ot(e, "colorMaterials"),
              It(e, a),
              Bt(e, a),
              (b.clear = !1),
              (E.clear = !1)),
          (F.clear = !1),
          Et(e, a),
          (_.autoUpdateScene = !1),
          (_.autoUpdateObjects = !1),
          st(e, "forwardMaterials"),
          Lt(e, a),
          nt(e, "forwardMaterials"),
          Lt(e, a),
          t.occludersEnabled &&
          (st(e, "occluderMaterials"), bt(e, a), st(e, "forwardMaterials")),
          t.particlesOffscreen && Ft(e, a),
          t.bloomEnabled &&
          ((K.uniforms.threshold.value = t.bloomThreshold),
            (K.uniforms.brightness.value = t.brightness),
            (K.uniforms.whitePoint.value = t.whitePoint),
            A.render()),
          (_.autoUpdateObjects = !0),
          (_.autoUpdateScene = !0),
          (_.autoClearDepth = !0),
          ce.depthFunc(ce.LEQUAL);
        var H = B.uniforms;
        if (
          (t.bloomEnabled &&
            ((H.bloomStrength.value = t.bloomStrength),
              (H.brightness.value = t.brightness),
              (H.whitePoint.value = t.whitePoint)),
            t.dofEnabled &&
            ((z.cameraNear = a.near),
              (z.cameraFar = a.far),
              (z.autoFocus = t.dofAutofocus),
              (z.autoFocusPoint = t.dofAutofocusPoint),
              (z.focusDistance = t.dofFocusDistance),
              (z.focusRampStart = t.dofFocusWidth),
              (z.focusRampEnd = t.dofFocusWidth + t.dofFocusRampWidth),
              (z.maxBlur = t.dofMaxBlur),
              t.dofFancy &&
              t.dofPhysical &&
              ((z.lensFstop = t.dofLensFstop),
                (z.lensFocalLength = t.dofLensFocalLength),
                (z.lensBlurScale = t.dofLensBlurScale),
                (z.lensMaxCoc = t.dofLensMaxCoc),
                (z.lensApertureSides = t.dofLensApertureSides))),
            c)
        ) {
          if (t.taaBeforeDOF) var W = re.uniforms;
          else {
            var W = Z.uniforms;
            W.tDiffuseLast.value = Q.renderTarget;
          }
          if (
            (W.jitterOffset.value.copy(Ve),
              (W.matViewProjLast.value = ke),
              (W.matProjInverse.value = a.projectionMatrixInverse),
              (W.matViewInverse.value = a.matrixWorld),
              W.viewSize.value.set(o, n),
              ze.copy(a.projectionMatrix),
              He.copy(a.matrixWorldInverse),
              ke.multiply(ze, He),
              t.taaBeforeDOF)
          ) {
            var j = XG.EffectComposer.camera,
              q = XG.EffectComposer.scene,
              Y = XG.EffectComposer.quad.materials,
              le = te.uniforms;
            (le.tDiffuse.value = M.renderTarget2),
              (le.brightness.value = t.brightness),
              (le.whitePoint.value = t.whitePoint),
              (Y[0] = te),
              _.render(q, j, ee),
              (W.tDiffuse.value = ee),
              (W.tDiffuseLast.value = J),
              (Y[0] = re),
              _.render(q, j, $),
              (ie.uniforms.tDiffuse.value = $),
              (Y[0] = ie),
              _.render(q, j, J);
            var he = ae.uniforms;
            (he.tDiffuse.value = $),
              (he.brightness.value = t.brightness),
              (he.whitePoint.value = t.whitePoint),
              (Y[0] = ae),
              _.render(q, j, M.renderTarget2),
              (z.colorInput = M.renderTarget2);
          }
        }
        if (
          t.fogEnabled &&
          (H.fogColor.value.copy(t.fogColor),
            (H.fogStrength.value = t.fogStrength),
            (H.fogStart.value = t.fogStart),
            t.dofFancy && t.dofPhysical)
        ) {
          var ue = z.blurAmountUniforms;
          ue.fogColor.value.copy(t.fogColor),
            (ue.fogStrength.value = t.fogStrength),
            (ue.fogStart.value = t.fogStart);
        }
        if (t.particlesOffscreenUpsampleFancy) {
          var fe = w.renderTarget2.width,
            pe = w.renderTarget2.height;
          (H.samplerParticlesDepth.value = X.renderTarget1),
            H.particleSamplerSize.value.set(fe, pe);
        }
        H.cameraNearFar.value.set(a.near, a.far),
          (B.uniforms.brightness.value = t.brightness),
          (B.uniforms.whitePoint.value = t.whitePoint),
          D.render(0.1),
          (Ne += 1);
      });
  }),
  (XG.ShadowMapPlugin = function () {
    function e(e, t, a, i, f, v, g, S, G) {
      i.updateMatrixWorld(),
        i.matrixWorldInverse.getInverse(i.matrixWorld),
        t.isVirtual && t.originalCamera === a && r(a, t),
        i.updateProjectionMatrix(),
        f.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
        f.multiplySelf(i.projectionMatrix),
        f.multiplySelf(i.matrixWorldInverse),
        m.multiply(i.projectionMatrix, i.matrixWorldInverse),
        p.setFromMatrix(m),
        o.getViewport(x),
        o.setRenderTarget(v),
        o.setViewport(S, G, t.shadowMapWidth, t.shadowMapHeight),
        o.enableScissorTest(!0),
        o.setScissor(S, G, t.shadowMapWidth, t.shadowMapHeight),
        o.clear(),
        o.enableScissorTest(!1);
      var M,
        _,
        X,
        D,
        T,
        C = e.__webglObjects;
      for (M = 0, _ = C.length; _ > M; M++)
        (X = C[M]),
          (D = X.object),
          (T = X.geometry),
          (X.render = !1),
          D.visible &&
          D.castShadow &&
          (((D instanceof XG.Mesh || D instanceof XG.Particles) &&
            D.frustumCulled &&
            !p.contains(D, T)) ||
            (D._modelViewMatrix.multiply(i.matrixWorldInverse, D.matrixWorld),
              (X.render = !0)));
      var A,
        P,
        L,
        b,
        E,
        F,
        R,
        U = null,
        I = null;
      for (M = 0, _ = C.length; _ > M; M++)
        if (
          ((X = C[M]),
            X.render &&
            ((D = X.object),
              (T = X.geometry),
              (E = T instanceof XG.SpriteGeometry),
              (P =
                E || (X.transparent && X.transparent.forceShadow)
                  ? X.transparent
                  : X.opaque),
              P && P.visible))
        ) {
          if (
            ((L = T.morphTargets.length > 0 && P.morphTargets),
              (b = D instanceof XG.SkinnedMesh && P.skinning),
              (F = P.displacementMap),
              (R = P.instances),
              D.customDepthMaterial)
          )
            A = D.customDepthMaterial;
          else if (F) {
            A = P.displacementDirection === XG.DisplaceByNormal ? c : u;
            var N = A.uniforms,
              B = P.uniforms;
            (N.displacementMap.value = P.displacementMap),
              N.displacementScaleBias.value.set(
                P.displacementScale,
                P.displacementBias
              ),
              (N.displacementNormalScale.value = P.displacementNormalScale),
              N.offsetRepeat.value.copy(B.offsetRepeat.value);
          } else if (b)
            void 0 === y[P.id] &&
              ((A = L ? h : l),
                (y[P.id] = A.clone()),
                (y[P.id]._shadowPass = !0)),
              (A = y[P.id]);
          else if (L) A = s;
          else if (E) {
            A = d;
            var N = A.uniforms,
              B = P.uniforms;
            (N.map.value = B.map.value),
              (N.alphaTest.value = B.alphaTest.value),
              (N.epsilon.value = B.epsilon.value);
          } else A = n;
          R &&
            (void 0 === w[P.id] &&
              ((w[P.id] = A.clone()),
                (w[P.id]._shadowPass = !0),
                (w[P.id].instances = !0)),
              (A = w[P.id]),
              T.instanceCulled && (o.cullInstances(D, T, p), o.setBuffers(T))),
            (A.side = E ? XG.DoubleSide : g),
            o.setMaterialFaces(A),
            o.setProgram(i, e.__lights, U, I, A, D, T),
            o.renderGeometry(A, T, D);
        }
      for (C = e.__webglObjectsImmediate, M = 0, _ = C.length; _ > M; M++)
        (X = C[M]),
          (D = X.object),
          D.visible &&
          D.castShadow &&
          (p.contains(D, D) || !D.frustumCulled) &&
          (D._modelViewMatrix.multiply(i.matrixWorldInverse, D.matrixWorld),
            o.setProgram(i, e.__lights, U, I, n, D, null),
            o.renderImmediateObject(n, D));
      o.setViewport(x.x, x.y, x.width, x.height);
    }
    function t(e, t) {
      var a = new XG.DirectionalLight();
      (a.isVirtual = !0),
        (a.onlyShadow = !0),
        (a.castShadow = !0),
        (a.shadowCameraNear = e.shadowCameraNear),
        (a.shadowCameraFar = e.shadowCameraFar),
        (a.shadowCameraLeft = e.shadowCameraLeft),
        (a.shadowCameraRight = e.shadowCameraRight),
        (a.shadowCameraBottom = e.shadowCameraBottom),
        (a.shadowCameraTop = e.shadowCameraTop),
        (a.shadowCameraVisible = e.shadowCameraVisible),
        (a.shadowDarkness = e.shadowDarkness),
        (a.shadowBias = e.shadowCascadeBias[t]),
        (a.shadowMapWidth = e.shadowCascadeWidth[t]),
        (a.shadowMapHeight = e.shadowCascadeHeight[t]),
        (a.properties.pointsWorld = []),
        (a.properties.pointsFrustum = []);
      for (
        var r = a.properties.pointsWorld, i = a.properties.pointsFrustum, o = 0;
        8 > o;
        o++
      )
        (r[o] = new XG.Vector3()), (i[o] = new XG.Vector3());
      var n = e.shadowCascadeNearZ[t],
        s = e.shadowCascadeFarZ[t];
      return (
        i[0].set(-1, -1, n),
        i[1].set(1, -1, n),
        i[2].set(-1, 1, n),
        i[3].set(1, 1, n),
        i[4].set(-1, -1, s),
        i[5].set(1, -1, s),
        i[6].set(-1, 1, s),
        i[7].set(1, 1, s),
        a
      );
    }
    function a(e, t) {
      var a = e.shadowCascadeArray[t];
      a.position.copy(e.position),
        a.target.position.copy(e.target.position),
        a.lookAt(a.target.position),
        (a.shadowCameraVisible = e.shadowCameraVisible),
        (a.shadowDarkness = e.shadowDarkness),
        (a.shadowBias = e.shadowCascadeBias[t]);
      var r = e.shadowCascadeNearZ[t],
        i = e.shadowCascadeFarZ[t],
        o = a.properties.pointsFrustum;
      o[0].setZ(r),
        o[1].setZ(r),
        o[2].setZ(r),
        o[3].setZ(r),
        o[4].setZ(i),
        o[5].setZ(i),
        o[6].setZ(i),
        o[7].setZ(i);
    }
    function r(e, t) {
      var a = t.properties,
        r = a.shadowCamera,
        i = a.pointsFrustum,
        o = a.pointsWorld;
      v.set(1 / 0, 1 / 0, 1 / 0), g.set(-(1 / 0), -(1 / 0), -(1 / 0));
      for (
        var n = v.data, s = g.data, l = XG.ShadowMapPlugin.__projector, h = 0;
        8 > h;
        h++
      ) {
        var d = o[h],
          c = d.data;
        d.copy(i[h]),
          l.unprojectVector(d, e),
          r.matrixWorldInverse.multiplyVector3(d),
          c[0] < n[0] && (n[0] = c[0]),
          c[0] > s[0] && (s[0] = c[0]),
          c[1] < n[1] && (n[1] = c[1]),
          c[1] > s[1] && (s[1] = c[1]),
          c[2] < n[2] && (n[2] = c[2]),
          c[2] > s[2] && (s[2] = c[2]);
      }
      (r.left = n[0]), (r.right = s[0]), (r.top = s[1]), (r.bottom = n[1]);
    }
    var i,
      o,
      n,
      s,
      l,
      h,
      d,
      c,
      u,
      f,
      p = new XG.Frustum(),
      m = new XG.Matrix4(),
      v = new XG.Vector3(),
      g = new XG.Vector3(),
      S = new XG.Vector3(),
      x = { offsetX: 0, offsetY: 0, width: 0, height: 0 },
      G = [
        new XG.Vector3(0, -1, 0),
        new XG.Vector3(0, -1, 0),
        new XG.Vector3(0, 0, 1),
        new XG.Vector3(0, 0, -1),
        new XG.Vector3(0, -1, 0),
        new XG.Vector3(0, -1, 0),
      ],
      M = [
        new XG.Vector3(1, 0, 0),
        new XG.Vector3(-1, 0, 0),
        new XG.Vector3(0, 1, 0),
        new XG.Vector3(0, -1, 0),
        new XG.Vector3(0, 0, 1),
        new XG.Vector3(0, 0, -1),
      ],
      y = {},
      w = {};
    (this.init = function (e) {
      (i = e.context), (o = e);
      var t = XG.ShaderLib.depthRGBA;
      (f = XG.UniformsUtils.clone(t.uniforms)),
        (f.slopeScale.value = o.shadowMapSlopeScale),
        (f.slopeBias.value = o.shadowMapSlopeBias),
        (f.slopeMax.value = o.shadowMapSlopeMax);
      var a = o.shadowMapSlopeDepthBias && o.supportsStandardDerivatives(),
        r = { SLOPE_DEPTH_BIAS: a },
        p = { SLOPE_DEPTH_BIAS: a, SPRITE: !0, SDF: !0 },
        m = o.supportsVertexTextures(),
        v = {
          SLOPE_DEPTH_BIAS: a,
          USE_DISPLACEMENTMAP: m,
          DISPLACE_BY_NORMAL: !0,
        },
        g = {
          SLOPE_DEPTH_BIAS: a,
          USE_DISPLACEMENTMAP: m,
          DISPLACE_BY_POSITION: !0,
        },
        S = { OES_standard_derivatives: a },
        x = { OES_standard_derivatives: !0 },
        G = t.fragmentShader,
        M = t.vertexShader;
      (n = new XG.ShaderMaterial({
        fragmentShader: G,
        vertexShader: M,
        uniforms: f,
        defines: r,
        extensions: S,
      })),
        (s = new XG.ShaderMaterial({
          fragmentShader: G,
          vertexShader: M,
          uniforms: f,
          defines: r,
          extensions: S,
          morphTargets: !0,
        })),
        (l = new XG.ShaderMaterial({
          fragmentShader: G,
          vertexShader: M,
          uniforms: f,
          defines: r,
          extensions: S,
          skinning: !0,
        })),
        (h = new XG.ShaderMaterial({
          fragmentShader: G,
          vertexShader: M,
          uniforms: f,
          defines: r,
          extensions: S,
          morphTargets: !0,
          skinning: !0,
        })),
        (d = new XG.ShaderMaterial({
          fragmentShader: G,
          vertexShader: M,
          uniforms: f,
          defines: p,
          extensions: x,
        })),
        (c = new XG.ShaderMaterial({
          fragmentShader: G,
          vertexShader: M,
          uniforms: f,
          defines: v,
          extensions: S,
        })),
        (u = new XG.ShaderMaterial({
          fragmentShader: G,
          vertexShader: M,
          uniforms: f,
          defines: g,
          extensions: S,
        })),
        (n._shadowPass = !0),
        (s._shadowPass = !0),
        (l._shadowPass = !0),
        (h._shadowPass = !0),
        (d._shadowPass = !0),
        (c._shadowPass = !0),
        (u._shadowPass = !0);
    }),
      (this.render = function (e, t) {
        o.shadowMapEnabled && o.shadowMapAutoUpdate && this.update(e, t);
      }),
      (this.update = function (r, n) {
        var s,
          l,
          h,
          d,
          c,
          u,
          p,
          m,
          v = [],
          g = 0,
          x = o.supportsDepthTextures() && o.shadowMapUseDepthTextures;
        i.clearColor(1, 1, 1, 1), i.disable(i.BLEND);
        var y;
        for (
          y =
          o.shadowMapCullFace === XG.CullFaceFront
            ? XG.BackSide
            : o.shadowMapCullFace === XG.CullFaceBack
              ? XG.FrontSide
              : XG.DoubleSide,
          o.setDepthTest(!0),
          x && i.colorMask(!1, !1, !1, !1),
          s = 0,
          l = r.__lights.length;
          l > s;
          s++
        )
          if (((p = r.__lights[s]), p.castShadow))
            if (
              (p instanceof XG.DirectionalLight ||
                p instanceof XG.DayLight ||
                p instanceof XG.DayLightCube) &&
              p.shadowCascade
            )
              for (h = 0; h < p.shadowCascadeCount; h++) {
                var w;
                if (p.shadowCascadeArray[h]) w = p.shadowCascadeArray[h];
                else {
                  (w = t(p, h)), (w.originalCamera = n);
                  var _ = new XG.Gyroscope();
                  (_.position = p.shadowCascadeOffset),
                    _.add(w),
                    _.add(w.target),
                    n.add(_),
                    (p.shadowCascadeArray[h] = w),
                    console.log("Created virtualLight", w);
                }
                a(p, h), (v[g] = w), g++;
              }
            else (v[g] = p), g++;
        for (
          o.shadowMapSlopeDepthBias &&
          (x
            ? (o.setPolygonOffset(!0, 1.5, 10),
              (f.depthTextureBias.value = o.shadowMapDepthTextureBias))
            : ((f.slopeScale.value = o.shadowMapSlopeScale),
              (f.slopeBias.value = o.shadowMapSlopeBias),
              (f.slopeMax.value = o.shadowMapSlopeMax))),
          s = 0,
          l = v.length;
          l > s;
          s++
        ) {
          if (((p = v[s]), (m = p.properties), !m.shadowMap)) {
            var X = !o.supportsDepthOnlyRenderTarget(),
              D = o.supportsLuminanceFloatRenderTarget()
                ? XG.LuminanceFormat
                : o.supportsRGBFloatRenderTarget()
                  ? XG.RGBFormat
                  : XG.RGBAFormat,
              T = "webgl2" === o.getRenderingBackend(),
              C = {
                minFilter: XG.NearestFilter,
                magFilter: XG.NearestFilter,
                stencilBuffer: !1,
                format: XG.RGBAFormat,
                type: XG.UnsignedByteType,
              };
            if (T)
              var A = {
                minFilter: XG.LinearFilter,
                magFilter: XG.LinearFilter,
                useColorTexture: X,
                stencilBuffer: !1,
                format: D,
                useDepthTexture: !0,
                depthTextureType: o.shadowMapDepthTextureType,
              };
            else
              var A = {
                minFilter: XG.NearestFilter,
                magFilter: XG.NearestFilter,
                useColorTexture: X,
                stencilBuffer: !1,
                format: D,
                useDepthTexture: !0,
                depthTextureType: o.shadowMapDepthTextureType,
              };
            var P = x ? A : C;
            if (p instanceof XG.SphereLight || p instanceof XG.PointLight) {
              var d = new XG.RenderTarget(
                6 * p.shadowMapWidth,
                p.shadowMapHeight,
                P
              );
              d.generateMipmaps = !1;
              for (var L = [], b = 0; 6 > b; b++) L[b] = new XG.Matrix4();
              m.shadowMatrixTranslation = new XG.Matrix4();
            } else {
              var d = new XG.RenderTarget(
                p.shadowMapWidth,
                p.shadowMapHeight,
                P
              );
              d.generateMipmaps = !1;
              var L = new XG.Matrix4();
            }
            (m.shadowMap = d),
              (m.shadowMapPars = [
                p.shadowMapWidth,
                p.shadowMapHeight,
                p.shadowDarkness,
                p.shadowBias,
              ]),
              (m.shadowCameraPars = [p.shadowCameraNear, p.shadowCameraFar]),
              (m.shadowMatrixForward = L);
          }
          if (!m.shadowCamera) {
            var E = p.shadowMapWidth / p.shadowMapHeight;
            if (p instanceof XG.SpotLight)
              u = new XG.PerspectiveCamera(
                p.shadowCameraFov,
                E,
                p.shadowCameraNear,
                p.shadowCameraFar
              );
            else if (
              p instanceof XG.DirectionalLight ||
              p instanceof XG.DayLight ||
              p instanceof XG.DayLightCube
            )
              u = new XG.OrthographicCamera(
                p.shadowCameraLeft,
                p.shadowCameraRight,
                p.shadowCameraTop,
                p.shadowCameraBottom,
                p.shadowCameraNear,
                p.shadowCameraFar
              );
            else if (p instanceof XG.AreaLight || p instanceof XG.PolyLight)
              u = p.shadowCameraOrtho
                ? new XG.OrthographicCamera(
                  p.shadowCameraLeft,
                  p.shadowCameraRight,
                  p.shadowCameraTop,
                  p.shadowCameraBottom,
                  p.shadowCameraNear,
                  p.shadowCameraFar
                )
                : new XG.PerspectiveCamera(
                  p.shadowCameraFov,
                  E,
                  p.shadowCameraNear,
                  p.shadowCameraFar
                );
            else {
              if (
                !(p instanceof XG.SphereLight || p instanceof XG.PointLight)
              ) {
                console.error(
                  "XG:ShadowMapPlugin: Unsupported light type for shadow"
                );
                continue;
              }
              u = [];
              for (var b = 0; 6 > b; b++) {
                var F = new XG.PerspectiveCamera(
                  90,
                  E,
                  p.shadowCameraNear,
                  p.shadowCameraFar
                );
                F.up.copy(G[b]), F.lookAt(M[b]), (u[b] = F);
              }
            }
            (m.shadowCamera = u),
              p instanceof XG.SphereLight ||
              (r.add(u), o.autoUpdateScene && r.updateMatrixWorld());
          }
          if (
            ((d = m.shadowMap),
              (u = m.shadowCamera),
              (c = m.shadowMatrixForward),
              m.shadowCamera instanceof Array)
          ) {
            S.copy(p.matrixWorld.getPosition()), S.negate();
            var R = m.shadowMatrixTranslation;
            R.identity(), R.setPosition(S);
            for (var b = 0, U = m.shadowCamera.length; U > b; b++) {
              (u = m.shadowCamera[b]),
                (c = m.shadowMatrixForward[b]),
                (d = m.shadowMap),
                u.position.copy(p.matrixWorld.getPosition());
              var I = b * p.shadowMapWidth,
                N = 0;
              e(r, p, n, u, c, d, y, I, N);
            }
          } else {
            u.position.copy(p.matrixWorld.getPosition()),
              u.lookAt(p.target.matrixWorld.getPosition());
            var I = 0,
              N = 0;
            e(r, p, n, u, c, d, y, I, N);
          }
        }
        var B = o.getClearColor(),
          O = o.getClearAlpha();
        i.clearColor(B.r, B.g, B.b, O),
          i.enable(i.BLEND),
          x && i.colorMask(!0, !0, !0, !0);
      });
  }),
  (XG.ShadowMapPlugin.__projector = new XG.Projector()),
  (XG.EffectComposer = function (e, t) {
    if (
      (e
        ? e instanceof XG.DeferredRenderer &&
        console.warn(
          "XG.EffectComposer: passed deferred renderer parameter, probably not what you intended"
        )
        : console.warn("XG.EffectComposer: undefined renderer"),
        (this.renderer = e),
        void 0 === t)
    ) {
      var a = window.innerWidth || 1,
        r = window.innerHeight || 1,
        i = {
          minFilter: XG.LinearFilter,
          magFilter: XG.LinearFilter,
          format: XG.RGBAFormat,
          internalFormat: XG.RGBAFormat,
          type: XG.UnsignedByteType,
          stencilBuffer: !1,
        };
      t = new XG.RenderTarget(a, r, i);
    }
    (this.renderTarget1 = t),
      (this.renderTarget2 = t.clone()),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2),
      (this.passes = []),
      (this.copyPass = new XG.ShaderPass(XG.CopyShader));
  }),
  (XG.EffectComposer.prototype = {
    swapBuffers: function () {
      var e = this.readBuffer;
      (this.readBuffer = this.writeBuffer), (this.writeBuffer = e);
    },
    addPass: function (e) {
      this.passes.push(e);
    },
    insertPass: function (e, t) {
      this.passes.splice(t, 0, e);
    },
    render: function (e) {
      (this.writeBuffer = this.renderTarget1),
        (this.readBuffer = this.renderTarget2);
      var t,
        a,
        r = !1,
        i = this.passes.length;
      for (a = 0; i > a; a++)
        if (((t = this.passes[a]), t.enabled)) {
          if (
            (t.render(this.renderer, this.writeBuffer, this.readBuffer, e, r),
              t.needsSwap)
          ) {
            if (r) {
              var o = this.renderer.context;
              o.stencilFunc(o.NOTEQUAL, 1, 4294967295),
                this.copyPass.render(
                  this.renderer,
                  this.writeBuffer,
                  this.readBuffer,
                  e
                ),
                o.stencilFunc(o.EQUAL, 1, 4294967295);
            }
            this.swapBuffers();
          }
          t instanceof XG.MaskPass
            ? (r = !0)
            : t instanceof XG.ClearMaskPass && (r = !1);
        }
    },
    setSize: function (e, t) {
      this.renderTarget1.setSize(e, t), this.renderTarget2.setSize(e, t);
    },
  }),
  (XG.EffectComposer.camera = new XG.OrthographicCamera(-1, 1, 1, -1, 0, 1)),
  (XG.EffectComposer.quad = new XG.Mesh(
    new XG.TriangleGeometry(
      [
        [-1, -3, 0],
        [3, 1, 0],
        [-1, 1, 0],
      ],
      [
        [0, -1],
        [2, 1],
        [0, 1],
      ]
    ),
    null
  )),
  (XG.EffectComposer.scene = new XG.Scene()),
  XG.EffectComposer.scene.add(XG.EffectComposer.quad),
  (XG.TexturePass = function (e, t) {
    var a = XG.CopyShader;
    (this.uniforms = XG.UniformsUtils.clone(a.uniforms)),
      (this.uniforms.opacity.value = void 0 !== t ? t : 1),
      (this.uniforms.tDiffuse.value = e),
      (this.material = new XG.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: a.vertexShader,
        fragmentShader: a.fragmentShader,
      })),
      (this.enabled = !0),
      (this.needsSwap = !1);
  }),
  (XG.TexturePass.prototype = {
    render: function (e, t, a) {
      (XG.EffectComposer.quad.materials[0] = this.material),
        e.render(XG.EffectComposer.scene, XG.EffectComposer.camera, a);
    },
  }),
  (XG.ShaderPass = function (e, t) {
    (this.textureID = void 0 !== t ? t : "tDiffuse"),
      (this.uniforms = XG.UniformsUtils.clone(e.uniforms)),
      (this.material = new XG.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: e.vertexShader,
        fragmentShader: e.fragmentShader,
        defines: XG.UniformsUtils.cloneDefines(e.defines),
      })),
      (this.renderToScreen = !1),
      (this.enabled = !0),
      (this.needsSwap = !0),
      (this.clear = !1);
  }),
  (XG.ShaderPass.prototype = {
    render: function (e, t, a) {
      this.uniforms[this.textureID] &&
        (this.uniforms[this.textureID].value = a),
        (XG.EffectComposer.quad.materials[0] = this.material),
        this.renderToScreen
          ? e.render(XG.EffectComposer.scene, XG.EffectComposer.camera)
          : e.render(
            XG.EffectComposer.scene,
            XG.EffectComposer.camera,
            t,
            this.clear
          );
    },
  }),
  (XG.SavePass = function (e) {
    var t = XG.CopyShader;
    (this.textureID = "tDiffuse"),
      (this.uniforms = XG.UniformsUtils.clone(t.uniforms)),
      (this.material = new XG.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: t.vertexShader,
        fragmentShader: t.fragmentShader,
      })),
      (this.renderTarget = e),
      void 0 === this.renderTarget &&
      ((this.renderTargetParameters = {
        minFilter: XG.LinearFilter,
        magFilter: XG.LinearFilter,
        format: XG.RGBAFormat,
        stencilBuffer: !1,
      }),
        (this.renderTarget = new XG.RenderTarget(
          window.innerWidth,
          window.innerHeight,
          this.renderTargetParameters
        ))),
      (this.enabled = !0),
      (this.needsSwap = !1),
      (this.clear = !1);
  }),
  (XG.SavePass.prototype = {
    render: function (e, t, a) {
      this.uniforms[this.textureID] &&
        (this.uniforms[this.textureID].value = a),
        (XG.EffectComposer.quad.materials[0] = this.material),
        e.render(
          XG.EffectComposer.scene,
          XG.EffectComposer.camera,
          this.renderTarget,
          this.clear
        );
    },
  }),
  (XG.RenderPass = function (e, t, a, r) {
    (this.scene = e),
      (this.camera = t),
      (this.clearColor = a),
      (this.clearAlpha = void 0 !== r ? r : 1),
      (this.oldClearColor = new XG.Color()),
      (this.oldClearAlpha = 1),
      (this.enabled = !0),
      (this.clear = !0),
      (this.needsSwap = !1);
  }),
  (XG.RenderPass.prototype = {
    render: function (e, t, a) {
      this.clearColor &&
        (this.oldClearColor.copy(e.getClearColor()),
          (this.oldClearAlpha = e.getClearAlpha()),
          e.setClearColor(this.clearColor, this.clearAlpha)),
        e.render(this.scene, this.camera, a, this.clear),
        this.clearColor &&
        e.setClearColor(this.oldClearColor, this.oldClearAlpha);
    },
  }),
  (XG.MaskPass = function (e, t) {
    (this.scene = e),
      (this.camera = t),
      (this.enabled = !0),
      (this.clear = !0),
      (this.needsSwap = !1),
      (this.inverse = !1);
  }),
  (XG.MaskPass.prototype = {
    render: function (e, t, a) {
      var r = e.context;
      r.colorMask(!1, !1, !1, !1), r.depthMask(!1);
      var i, o;
      this.inverse ? ((i = 0), (o = 1)) : ((i = 1), (o = 0)),
        r.enable(r.STENCIL_TEST),
        r.stencilOp(r.REPLACE, r.REPLACE, r.REPLACE),
        r.stencilFunc(r.ALWAYS, i, 4294967295),
        r.clearStencil(o),
        e.render(this.scene, this.camera, a, this.clear),
        e.render(this.scene, this.camera, t, this.clear),
        r.colorMask(!0, !0, !0, !0),
        r.depthMask(!0),
        r.stencilFunc(r.EQUAL, 1, 4294967295),
        r.stencilOp(r.KEEP, r.KEEP, r.KEEP);
    },
  }),
  (XG.ClearMaskPass = function () {
    this.enabled = !0;
  }),
  (XG.ClearMaskPass.prototype = {
    render: function (e) {
      var t = e.context;
      t.disable(t.STENCIL_TEST);
    },
  }),
  (XG.BloomPass = function (e, t, a, r) {
    (e = void 0 !== e ? e : 1),
      (t = void 0 !== t ? t : 25),
      (a = void 0 !== a ? a : 4),
      (r = void 0 !== r ? r : 256);
    var i = {
      minFilter: XG.LinearFilter,
      magFilter: XG.LinearFilter,
      format: XG.RGBAFormat,
    };
    (this.renderTargetX = new XG.RenderTarget(r, r, i)),
      (this.renderTargetY = new XG.RenderTarget(r, r, i));
    var o = XG.CopyShader;
    (this.copyUniforms = XG.UniformsUtils.clone(o.uniforms)),
      (this.copyUniforms.opacity.value = e),
      (this.materialCopy = new XG.ShaderMaterial({
        uniforms: this.copyUniforms,
        vertexShader: o.vertexShader,
        fragmentShader: o.fragmentShader,
        blending: XG.AdditiveBlending,
        transparent: !0,
      }));
    var n = XG.ConvolutionShader;
    (this.convolutionUniforms = XG.UniformsUtils.clone(n.uniforms)),
      (this.convolutionUniforms.uImageIncrement.value = XG.BloomPass.blurx),
      (this.convolutionUniforms.cKernel.value = XG.ConvolutionShader.buildKernel(
        a
      )),
      (this.materialConvolution = new XG.ShaderMaterial({
        uniforms: this.convolutionUniforms,
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        defines: {
          KERNEL_SIZE_FLOAT: t.toFixed(1),
          KERNEL_SIZE_INT: t.toFixed(0),
        },
      })),
      (this.enabled = !0),
      (this.needsSwap = !1),
      (this.clear = !1);
  }),
  (XG.BloomPass.prototype = {
    render: function (e, t, a, r, i) {
      i && e.context.disable(e.context.STENCIL_TEST),
        (XG.EffectComposer.quad.materials[0] = this.materialConvolution),
        (this.convolutionUniforms.tDiffuse.value = a),
        (this.convolutionUniforms.uImageIncrement.value = XG.BloomPass.blurX),
        e.render(
          XG.EffectComposer.scene,
          XG.EffectComposer.camera,
          this.renderTargetX,
          !0
        ),
        (this.convolutionUniforms.tDiffuse.value = this.renderTargetX),
        (this.convolutionUniforms.uImageIncrement.value = XG.BloomPass.blurY),
        e.render(
          XG.EffectComposer.scene,
          XG.EffectComposer.camera,
          this.renderTargetY,
          !0
        ),
        (XG.EffectComposer.quad.materials[0] = this.materialCopy),
        (this.copyUniforms.tDiffuse.value = this.renderTargetY),
        i && e.context.enable(e.context.STENCIL_TEST),
        e.render(
          XG.EffectComposer.scene,
          XG.EffectComposer.camera,
          a,
          this.clear
        );
    },
  }),
  (XG.BloomPass.blurX = new XG.Vector2(0.001953125, 0)),
  (XG.BloomPass.blurY = new XG.Vector2(0, 0.001953125)),
  (XG.DepthOfFieldPass = function (e, t, a) {
    (e = void 0 !== e ? e : 1024), (t = void 0 !== t ? t : 512);
    var r = a.isES3 ? XG.RGBA32F : XG.RGBAFormat,
      i = {
        minFilter: XG.NearestFilter,
        magFilter: XG.NearestFilter,
        format: XG.RGBAFormat,
        internalFormat: r,
        type: XG.FloatType,
      },
      o = {
        minFilter: XG.LinearMipMapLinearFilter,
        magFilter: XG.LinearFilter,
        format: XG.RGBAFormat,
      };
    (this.renderTargetBlur = new XG.RenderTarget(e, t, o)),
      (this.renderTargetBlur.generateMipmaps = !0),
      (this.renderTargetDistance1 = new XG.RenderTarget(2, 2, i)),
      (this.renderTargetDistance1.generateMipmaps = !1),
      (this.renderTargetDistance2 = this.renderTargetDistance1.clone()),
      (this.renderTargetDistanceRead = this.renderTargetDistance1),
      (this.renderTargetDistanceWrite = this.renderTargetDistance2);
    var n = XG.CopyShader;
    (this.copyUniforms = XG.UniformsUtils.clone(n.uniforms)),
      (this.materialCopy = new XG.ShaderMaterial({
        uniforms: this.copyUniforms,
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        blending: XG.NoBlending,
        depthTest: !1,
        depthWrite: !1,
      }));
    var s = XG.DistanceShader;
    (this.distanceUniforms = XG.UniformsUtils.clone(s.uniforms)),
      (this.materialDistance = new XG.ShaderMaterial({
        uniforms: this.distanceUniforms,
        vertexShader: s.vertexShader,
        fragmentShader: s.fragmentShader,
        blending: XG.NoBlending,
        depthTest: !1,
        depthWrite: !1,
      }));
    var l = XG.DepthOfFieldShader;
    (this.dofUniforms = XG.UniformsUtils.clone(l.uniforms)),
      (this.materialDOF = new XG.ShaderMaterial({
        uniforms: this.dofUniforms,
        vertexShader: l.vertexShader,
        fragmentShader: l.fragmentShader,
        blending: XG.NoBlending,
        depthTest: !1,
        depthWrite: !1,
      })),
      (this.dofUniforms.tBlur.value = this.renderTargetBlur),
      this.dofUniforms.blurSize.value.set(e, t),
      (this.depthInput = null),
      (this.colorInput = null),
      (this.cameraNear = null),
      (this.cameraFar = null),
      (this.autoFocus = null),
      (this.autoFocusPoint = null),
      (this.focusDistance = null),
      (this.focusRampStart = null),
      (this.focusRampEnd = null),
      (this.maxBlur = null),
      (this.defines = null),
      (this.enabled = !0),
      (this.needsSwap = !0),
      (this.clear = !1);
  }),
  (XG.DepthOfFieldPass.prototype = {
    resize: function () { },
    render: function (e, t, a) {
      var r = this.dofUniforms,
        i = this.copyUniforms,
        o = this.distanceUniforms,
        n = this.renderTargetDistanceRead;
      (this.renderTargetDistanceRead = this.renderTargetDistanceWrite),
        (this.renderTargetDistanceWrite = n),
        (r.tDepth.value = this.depthInput),
        (o.tDepth.value = this.depthInput),
        (r.autoFocus.value = this.autoFocus),
        r.autoFocusPoint.value.copy(this.autoFocusPoint),
        (r.focusDistance.value = this.focusDistance),
        (r.focusRampStart.value = this.focusRampStart),
        (r.focusRampEnd.value = this.focusRampEnd),
        (r.maxBlur.value = this.maxBlur),
        r.cameraNearFar.value.set(this.cameraNear, this.cameraFar),
        o.cameraNearFar.value.set(this.cameraNear, this.cameraFar),
        o.samplePoint.value.copy(this.autoFocusPoint),
        (i.tDiffuse.value = a),
        (r.tDiffuse.value = a),
        (r.tDistance.value = this.renderTargetDistanceRead),
        (o.tDistance.value = this.renderTargetDistanceRead),
        (this.materialDistance.defines = this.defines),
        (this.materialDOF.defines = this.defines),
        (XG.EffectComposer.quad.materials[0] = this.materialCopy),
        e.render(
          XG.EffectComposer.scene,
          XG.EffectComposer.camera,
          this.renderTargetBlur,
          !0
        ),
        (XG.EffectComposer.quad.materials[0] = this.materialDOF),
        this.renderToScreen
          ? e.render(XG.EffectComposer.scene, XG.EffectComposer.camera)
          : e.render(
            XG.EffectComposer.scene,
            XG.EffectComposer.camera,
            t,
            this.clear
          ),
        (XG.EffectComposer.quad.materials[0] = this.materialDistance),
        e.render(
          XG.EffectComposer.scene,
          XG.EffectComposer.camera,
          this.renderTargetDistanceWrite,
          !1
        );
    },
  }),
  (XG.FancyDepthOfFieldPass = function (e, t, a, r) {
    this.blurScale = void 0 !== a ? a : 0.75;
    var i,
      o,
      n,
      s = Math.max(1, Math.floor(this.blurScale * e)),
      l = Math.max(1, Math.floor(this.blurScale * t));
    r.isES3
      ? ((i = XG.RGBA32F), (o = XG.RGBA16F), (n = XG.HalfFloatType2))
      : ((i = XG.RGBAFormat), (o = XG.RGBAFormat), (n = XG.HalfFloatType1));
    var h,
      d,
      c,
      u = {
        minFilter: XG.NearestFilter,
        magFilter: XG.NearestFilter,
        stencilBuffer: !1,
        format: XG.RGBAFormat,
        internalFormat: i,
        type: XG.FloatType,
      },
      f = {
        minFilter: XG.NearestFilter,
        magFilter: XG.NearestFilter,
        stencilBuffer: !1,
        format: XG.RGBAFormat,
        internalFormat: o,
        type: n,
      },
      p = {
        minFilter: XG.NearestFilter,
        magFilter: XG.LinearFilter,
        stencilBuffer: !1,
        format: XG.RGBAFormat,
        internalFormat: i,
        type: XG.FloatType,
      },
      m = {
        minFilter: XG.NearestFilter,
        magFilter: XG.NearestFilter,
        stencilBuffer: !1,
        format: XG.RGBAFormat,
        internalFormat: i,
        type: XG.FloatType,
      },
      v = {
        minFilter: XG.NearestFilter,
        magFilter: XG.LinearFilter,
        stencilBuffer: !1,
        format: XG.RGBAFormat,
        internalFormat: o,
        type: n,
      },
      g = {
        minFilter: XG.NearestFilter,
        magFilter: XG.NearestFilter,
        stencilBuffer: !1,
        format: XG.RGBAFormat,
        internalFormat: o,
        type: n,
      },
      S = {
        minFilter: XG.NearestFilter,
        magFilter: XG.LinearFilter,
        stencilBuffer: !1,
        format: XG.RGBAFormat,
        type: XG.UnsignedByteType,
      };
    r.hasHalfFloatsLinear
      ? ((h = v), (c = f), (d = v))
      : r.hasHalfFloatsNearest
        ? ((h = g), (c = f), (d = g))
        : r.hasFloatsLinear
          ? ((h = p), (c = u), (d = p))
          : r.hasFloatsNearest
            ? ((h = m), (c = u), (d = m))
            : ((h = S), (c = S), (d = S)),
      (this.renderTargetBlurAmount = new XG.RenderTarget(s, l, d)),
      (this.renderTargetBlurAmount.generateMipmaps = !1),
      (this.renderTargetBlurPass1 = new XG.RenderTarget(s, l, h)),
      (this.renderTargetBlurPass1.generateMipmaps = !1),
      (this.renderTargetBlurPass2 = new XG.RenderTarget(s, l, h)),
      (this.renderTargetBlurPass2.generateMipmaps = !1),
      (this.renderTargetDistance1 = new XG.RenderTarget(2, 2, c)),
      (this.renderTargetDistance1.generateMipmaps = !1),
      (this.renderTargetDistance2 = this.renderTargetDistance1.clone()),
      (this.renderTargetDistanceRead = this.renderTargetDistance1),
      (this.renderTargetDistanceWrite = this.renderTargetDistance2);
    var x = XG.DOFBlurAmountShader;
    (this.blurAmountUniforms = XG.UniformsUtils.clone(x.uniforms)),
      (this.materialBlurAmount = new XG.ShaderMaterial({
        uniforms: this.blurAmountUniforms,
        vertexShader: x.vertexShader,
        fragmentShader: x.fragmentShader,
        blending: XG.NoBlending,
        depthTest: !1,
        depthWrite: !1,
      }));
    var G = XG.DistanceShader;
    (this.distanceUniforms = XG.UniformsUtils.clone(G.uniforms)),
      (this.materialDistance = new XG.ShaderMaterial({
        uniforms: this.distanceUniforms,
        vertexShader: G.vertexShader,
        fragmentShader: G.fragmentShader,
        blending: XG.NoBlending,
        depthTest: !1,
        depthWrite: !1,
      }));
    var M = XG.DOFBlurPass1Shader;
    (this.dofPass1Uniforms = XG.UniformsUtils.clone(M.uniforms)),
      (this.materialDOFPass1 = new XG.ShaderMaterial({
        uniforms: this.dofPass1Uniforms,
        vertexShader: M.vertexShader,
        fragmentShader: M.fragmentShader,
        blending: XG.NoBlending,
        depthTest: !1,
        depthWrite: !1,
      }));
    var y = XG.DOFBlurPass2Shader;
    (this.dofPass2Uniforms = XG.UniformsUtils.clone(y.uniforms)),
      (this.materialDOFPass2 = new XG.ShaderMaterial({
        uniforms: this.dofPass2Uniforms,
        vertexShader: y.vertexShader,
        fragmentShader: y.fragmentShader,
        blending: XG.NoBlending,
        depthTest: !1,
        depthWrite: !1,
      })),
      (this.depthInput = null),
      (this.colorInput = null),
      (this.cameraNear = null),
      (this.cameraFar = null),
      (this.autoFocus = null),
      (this.autoFocusPoint = null),
      (this.focusDistance = null),
      (this.focusRampStart = null),
      (this.focusRampEnd = null),
      (this.maxBlur = null),
      (this.lensFstop = null),
      (this.lensFocalLength = null),
      (this.lensBlurScale = null),
      (this.lensMaxCoc = null),
      (this.lensApertureSides = null),
      (this.defines = null),
      (this.oldLensApertureSides = null),
      (this.enabled = !0),
      (this.needsSwap = !0),
      (this.clear = !1);
  }),
  (XG.FancyDepthOfFieldPass.prototype = {
    setLensApertureSides: function (e) {
      (void 0 === e || 3 > e) && (e = 3),
        (this.dofPass1Uniforms.samplePoints1.value = XG.Math.generateConcentricCircleSamples(
          7,
          e
        )),
        (this.dofPass1Uniforms.samplePoints2.value = XG.Math.generateConcentricCircleSamples(
          3,
          e
        )),
        (this.dofPass2Uniforms.samplePoints.value = XG.Math.generateConcentricCircleSamples(
          3,
          e
        ));
    },
    resize: function (e, t) {
      var a = Math.max(1, Math.floor(this.blurScale * e)),
        r = Math.max(1, Math.floor(this.blurScale * t));
      this.renderTargetBlurAmount.setSize(a, r),
        this.renderTargetBlurPass1.setSize(a, r),
        this.renderTargetBlurPass2.setSize(a, r);
    },
    render: function (e) {
      var t = this.dofPass1Uniforms,
        a = this.dofPass2Uniforms,
        r = this.blurAmountUniforms,
        i = (this.blurCompositeUniforms, this.distanceUniforms),
        o = this.renderTargetDistanceRead;
      if (
        ((this.renderTargetDistanceRead = this.renderTargetDistanceWrite),
          (this.renderTargetDistanceWrite = o),
          this.lensApertureSides !== this.oldLensApertureSides)
      ) {
        var n = XG.Math.generateConcentricCircleSamples(
          7,
          this.lensApertureSides
        ),
          s = XG.Math.generateConcentricCircleSamples(
            3,
            this.lensApertureSides
          );
        (t.samplePoints1.value = n),
          (t.samplePoints2.value = s),
          (a.samplePoints.value = s),
          (this.oldLensApertureSides = this.lensApertureSides);
      }
      (r.tDepth.value = this.depthInput),
        (i.tDepth.value = this.depthInput),
        (t.tDiffuse.value = this.colorInput),
        t.resolution.value.set(this.colorInput.width, this.colorInput.height),
        (r.tDiffuse.value = this.colorInput),
        r.resolution.value.set(this.colorInput.width, this.colorInput.height),
        r.cameraNearFar.value.set(this.cameraNear, this.cameraFar),
        (r.autoFocus.value = this.autoFocus),
        r.autoFocusPoint.value.copy(this.autoFocusPoint),
        (r.focusDistance.value = this.focusDistance),
        (r.focusRampStart.value = this.focusRampStart),
        (r.focusRampEnd.value = this.focusRampEnd),
        (r.maxBlur.value = this.maxBlur),
        (r.lensAperture.value = this.lensFocalLength / this.lensFstop),
        (r.lensFocalLength.value = this.lensFocalLength),
        (r.lensBlurScale.value = this.lensBlurScale),
        (r.lensMaxCoc.value = this.lensMaxCoc),
        i.cameraNearFar.value.set(this.cameraNear, this.cameraFar),
        i.samplePoint.value.copy(this.autoFocusPoint),
        (t.tBlurAmount.value = this.renderTargetBlurAmount),
        (a.tBlurAmount.value = this.renderTargetBlurAmount),
        (r.tDistance.value = this.renderTargetDistanceRead),
        (i.tDistance.value = this.renderTargetDistanceRead),
        (a.tDiffuse.value = this.renderTargetBlurPass1),
        a.resolution.value.set(this.colorInput.width, this.colorInput.height),
        (this.materialBlurAmount.defines = this.defines),
        (this.materialDistance.defines = this.defines),
        (this.materialDOFPass1.defines = this.defines),
        (this.materialDOFPass2.defines = this.defines),
        (XG.EffectComposer.quad.materials[0] = this.materialBlurAmount),
        e.render(
          XG.EffectComposer.scene,
          XG.EffectComposer.camera,
          this.renderTargetBlurAmount,
          !0
        ),
        (XG.EffectComposer.quad.materials[0] = this.materialDOFPass1),
        e.render(
          XG.EffectComposer.scene,
          XG.EffectComposer.camera,
          this.renderTargetBlurPass1,
          !0
        ),
        (XG.EffectComposer.quad.materials[0] = this.materialDOFPass2),
        e.render(
          XG.EffectComposer.scene,
          XG.EffectComposer.camera,
          this.renderTargetBlurPass2,
          !0
        ),
        (XG.EffectComposer.quad.materials[0] = this.materialDistance),
        e.render(
          XG.EffectComposer.scene,
          XG.EffectComposer.camera,
          this.renderTargetDistanceWrite,
          !1
        );
    },
  }),
  (XG.PhysicsSimulation = function (e) {
    var t = this,
      a = void 0 !== e.useTransferables ? e.useTransferables : !1,
      r = void 0 !== e.workerUrl ? e.workerUrl : "js/ammo/ammo.worker.js";
    (this.currentFrame = 0),
      (this.currentFPS = 0),
      (this.allFPS = 0),
      (this.callbackIdle = null),
      (this.callbackInitialized = null);
    var i,
      o = 6,
      n = 7,
      s = new Float32Array(0),
      l = [],
      h = [],
      d = [],
      c = [],
      u = [],
      f = function (e) {
        for (var t = 0, a = e.length; a > t; t++)
          for (var r = e[t].wheels, i = 0, o = r.length; o > i; i++) {
            var n = r[i],
              s = h.length;
            h.push(n.mesh), (n.mesh = s);
          }
      },
      p = function (e, t) {
        for (
          var a = (e.length - t) / n, r = l.length, i = Math.min(a, r), o = 0;
          i > o;
          o++
        ) {
          var s = l[o],
            h = s.position.data,
            d = s.quaternion.data;
          (e[t] = h[0]),
            (e[t + 1] = h[1]),
            (e[t + 2] = h[2]),
            (e[t + 3] = d[0]),
            (e[t + 4] = d[1]),
            (e[t + 5] = d[2]),
            (e[t + 6] = d[3]),
            (t += n);
        }
      },
      m = function (e, t, a) {
        var r = l.length,
          i = Math.min(a, r);
        a !== r &&
          console.warn(
            "Number of physics bodies = ",
            a,
            " while number of rendering bodies = ",
            r
          );
        for (var o = 0; i > o; o++) {
          var s = l[o],
            h = s.position.data,
            d = s.quaternion.data;
          (h[0] = e[t]),
            (h[1] = e[t + 1]),
            (h[2] = e[t + 2]),
            (d[0] = e[t + 3]),
            (d[1] = e[t + 4]),
            (d[2] = e[t + 5]),
            (d[3] = e[t + 6]),
            (t += n);
        }
        return t;
      },
      v = function (e, t, a) {
        var r = h.length,
          i = Math.min(a, r);
        a !== r &&
          console.warn(
            "Number of physics wheels = ",
            a,
            " while number of rendering wheels = ",
            r
          );
        for (var o = 0; i > o; o++) {
          var s = h[o],
            l = s.position.data,
            d = s.quaternion.data;
          (l[0] = e[t]),
            (l[1] = e[t + 1]),
            (l[2] = e[t + 2]),
            (d[0] = e[t + 3]),
            (d[1] = e[t + 4]),
            (d[2] = e[t + 5]),
            (d[3] = e[t + 6]),
            (t += n);
        }
        return t;
      },
      g = function (e, t, a) {
        var r = u.length,
          i = Math.min(a, r);
        a !== r &&
          console.warn(
            "Number of physics vehicles = ",
            a,
            " while number of local vehicles = ",
            r
          );
        for (var o = 0; i > o; o++) {
          var n = u[o],
            s = e[t];
          (n.speed = s), (t += 1);
        }
        return t;
      },
      S = function (e) {
        var r,
          n = !1;
        a &&
          (e instanceof Float32Array
            ? ((r = e.buffer),
              0 === e.length && r.byteLength > 0 && (e = new Float32Array(r)))
            : e instanceof ArrayBuffer &&
            ((r = e), (e = new Float32Array(r)), (n = !0)));
        var s = 0,
          l = e[0];
        if (l >= t.currentFrame) {
          (t.currentFrame = l), (t.currentFPS = e[1]), (t.allFPS = e[2]);
          var h = e[3],
            d = e[4],
            c = e[5];
          (s += o), (s = m(e, s, h)), (s = v(e, s, c)), (s = g(e, s, d));
        } else console.warn("Physics simulation frames received out of order");
        a &&
          (n
            ? i.postMessage(e, [e.buffer])
            : i.postMessage(e.buffer, [e.buffer]));
      },
      x = function (e) {
        var a = e.data;
        if (
          a instanceof Float32Array ||
          (a instanceof ArrayBuffer && a.byteLength > 1)
        )
          S(a);
        else {
          var r = a;
          "simulationIdle" === r.type
            ? t.callbackIdle && t.callbackIdle()
            : "simulationInitialized" === r.type
              ? t.callbackInitialized && t.callbackInitialized()
              : "debug" === r.type && console.log(r.content);
        }
      };
    (this.loadPhysicsVehicle = function (e) {
      var t,
        a,
        r,
        i,
        o,
        n = e.chassisUrl,
        s = e.wheelUrl,
        l = e.scale,
        h = e.position,
        d = e.chassisOffset,
        c = e.chassisShape,
        u = e.chassisPhysicsProperties,
        f = e.vehiclePhysicsProperties,
        p = e.wheels,
        m = e.callback,
        v = e.debugPhysicsShapes,
        g = [],
        S = 0,
        x = function () {
          if (((S += 1), 2 === S)) {
            var e = [t];
            (e = e.concat(g)), (f.wheels = []);
            for (var n = 0, s = p.length; s > n; n++) {
              var h = p[n],
                d = {
                  mesh: g[n],
                  isFrontWheel: h.isFrontWheel,
                  wheelRadius: h.wheelRadius,
                  suspensionRestLength: h.suspensionRestLength,
                  connectionPoint: h.connectionPoint,
                  wheelDirection: h.wheelDirection,
                  wheelAxle: h.wheelAxle,
                  tuning: h.tuning,
                };
              f.wheels.push(d);
            }
            t.properties.physics = u;
            var v = {
              chassisGeometries: a,
              wheelGeometries: r,
              chassisMaterials: i,
              wheelMaterials: o,
              parts: e,
              chassisShape: c,
              vehiclePhysicsProperties: f,
              scale: l,
            };
            m(v);
          }
        },
        G = new XG.UTF8Loader();
      G.load(n, function (e, r) {
        if (((a = e), (i = r), XG.GeometryUtils.center(e), d)) {
          var o = new XG.Matrix4(),
            n = new XG.Vector3(d[0], d[1], d[2]);
          o.makeTranslation(n);
          for (var s = 0; s < e.length; s++) {
            var u = e[s];
            u.applyMatrix(o);
          }
        }
        if (
          ((t = new XG.Mesh(e, r)),
            t.scale.multiplyScalar(l),
            t.position.set(h[0], h[1], h[2]),
            (t.useQuaternion = !0),
            (t.castShadow = !0),
            (t.receiveShadow = !0),
            (t.visible = !1),
            v)
        )
          for (
            var f = [16711680, 16755200, 16711935, 65280, 16776960],
            p = new XG.Vector3(1, 1, 1).multiplyScalar(1 / l),
            m = new XG.Vector3(),
            g = new XG.Matrix4(),
            S = new XG.Matrix4(),
            s = 0,
            G = c.children.length;
            G > s;
            s++
          ) {
            var M = new XG.EmissiveMaterial({
              color: f[s % f.length],
              transparent: !0,
              opacity: 0.8,
            }),
              y = c.children[s],
              w = y.position;
            m.set(w[0], w[1], w[2]), S.makeScale(p), g.makeTranslation(m);
            var _ = new XG.BoxGeometry(2 * y.sx, 2 * y.sy, 2 * y.sz);
            _.applyMatrix(g),
              _.applyMatrix(S),
              _.computeBoundingSphere(),
              e.push(_),
              r.push(M);
          }
        x();
      }),
        G.load(s, function (e, t) {
          (r = e), (o = t), XG.GeometryUtils.center(e);
          for (var a = 0, i = p.length; i > a; a++) {
            var n = p[a],
              s = new XG.Mesh(e, t);
            (s.castShadow = !0), (s.receiveShadow = !0), (s.visible = !1);
            var d;
            n.mirrored
              ? ((s.rotation.y = Math.PI), (d = new XG.Node()), d.add(s))
              : (d = s),
              (d.useQuaternion = !0),
              d.scale.multiplyScalar(l),
              d.position.set(h[0], h[1], h[2]),
              g.push(d);
          }
          x();
        });
    }),
      (this.applyEngineForce = function (e, t, a) {
        if (i) {
          var r = {
            type: "applyEngineForce",
            force: e,
            vehicleId: t,
            wheelId: a,
          };
          i.postMessage(r);
        }
      }),
      (this.setSteering = function (e, t, a) {
        if (i) {
          var r = {
            type: "setSteering",
            steering: e,
            vehicleId: t,
            wheelId: a,
          };
          i.postMessage(r);
        }
      }),
      (this.setBrake = function (e, t, a) {
        if (i) {
          var r = { type: "setBrake", brake: e, vehicleId: t, wheelId: a };
          i.postMessage(r);
        }
      }),
      (this.setGravity = function (e, t, a) {
        if (i) {
          var r = { type: "setGravity", value: [e, t, a] };
          i.postMessage(r);
        }
      }),
      (this.resetTransforms = function () {
        if (i) {
          var e = l.length,
            t = e * n;
          s.length < t && (s = new Float32Array(t)), p(s, 0);
          var a = { type: "resetTransforms", nObjects: e, transforms: s };
          i.postMessage(a);
        }
      }),
      (this.startPhysics = function (e) {
        (l = e.objects),
          (d = e.shapes),
          void 0 !== e.constraints && (c = e.constraints),
          void 0 !== e.vehicles && ((u = e.vehicles), f(e.vehicles));
        for (var t = [], a = 0, o = l.length; o > a; a++) {
          var h = l[a],
            m = h.properties.physics,
            v = a,
            g = m.shapeId,
            S = void 0 !== m.mass ? m.mass : 1,
            G =
              void 0 !== m.linearSleepThreshold ? m.linearSleepThreshold : 0.8,
            M =
              void 0 !== m.angularSleepThreshold ? m.angularSleepThreshold : 1,
            y = {
              bodyId: v,
              shapeId: g,
              mass: S,
              linearSleepThreshold: G,
              angularSleepThreshold: M,
            };
          t.push(y);
        }
        var w = l.length,
          _ = w * n;
        s.length < _ && (s = new Float32Array(_)),
          p(s, 0),
          (i = new Worker(r)),
          (i.onmessage = x);
        var X = void 0 !== e.gravity ? e.gravity : [0, -9.81, 0],
          D = void 0 !== e.floorEnabled ? e.floorEnabled : !0,
          T = {
            type: "init",
            nObjects: w,
            transforms: s,
            objectsData: t,
            shapesData: d,
            constraintsData: c,
            vehiclesData: u,
            floorEnabled: D,
            floorSize: 0.5 * e.floorSize,
            floorHeight: e.floorHeight,
            gravity: X,
          };
        i.postMessage(T);
      });
  });
export var Detector = {
  gl1: null,
  gl2: null,
  glExtensionTextureFloat: null,
  glExtensionTextureHalfFloat: null,
  glExtensionShaderTextureLod: null,
};
(Detector.initGL1 = function () {
  try {
    var e = document.createElement("canvas"),
      t = e.getContext("webgl") || e.getContext("experimental-webgl");
    (Detector.gl1 = t),
      (Detector.glExtensionTextureFloat = t.getExtension("OES_texture_float")),
      (Detector.glExtensionTextureHalfFloat = t.getExtension(
        "OES_texture_half_float"
      )),
      (Detector.glExtensionShaderTextureLod = t.getExtension(
        "EXT_shader_texture_lod"
      ));
  } catch (a) { }
}),
  (Detector.initGL2 = function () {
    try {
      var e = document.createElement("canvas"),
        t = e.getContext("webgl2") || e.getContext("experimental-webgl2");
      Detector.gl2 = t;
    } catch (a) { }
  }),
  (Detector.canvas = !!window.CanvasRenderingContext2D),
  (Detector.webgl = (function () {
    try {
      var e = document.createElement("canvas");
      return !(
        !window.WebGLRenderingContext ||
        (!e.getContext("webgl") && !e.getContext("experimental-webgl"))
      );
    } catch (t) {
      return !1;
    }
  })()),
  (Detector.webgl2 = (function () {
    try {
      var e = document.createElement("canvas");
      return !(
        !window.WebGL2RenderingContext ||
        (!e.getContext("webgl2") && !e.getContext("experimental-webgl2"))
      );
    } catch (t) {
      return !1;
    }
  })()),
  (Detector.workers = !!window.Worker),
  (Detector.fileapi =
    window.File && window.FileReader && window.FileList && window.Blob),
  (Detector.isMobile = !!(
    navigator.userAgent.match(/Android/i) ||
    navigator.userAgent.match(/webOS/i) ||
    navigator.userAgent.match(/iPhone/i) ||
    navigator.userAgent.match(/iPad/i) ||
    navigator.userAgent.match(/iPod/i) ||
    navigator.userAgent.match(/BlackBerry/i) ||
    navigator.userAgent.match(/Windows Phone/i)
  )),
  (Detector.isOpenGL = (function () {
    try {
      var e = document.createElement("canvas"),
        t = e.getContext("webgl") || e.getContext("experimental-webgl"),
        a = t.getExtension("WEBGL_debug_renderer_info"),
        r = "";
      a &&
        ((r = t.getParameter(a.UNMASKED_RENDERER_WEBGL)),
          (r = r.toLowerCase()));
      var i = r.indexOf("angle") >= 0 && r.indexOf("opengl") < 0,
        o = navigator.userAgent.toLowerCase().indexOf("trident") >= 0,
        n = !(o || i);
      return n;
    } catch (s) {
      return !0;
    }
  })()),
  (Detector.supportsTransferables = function () {
    var e = !1;
    try {
      var t = new ArrayBuffer(1),
        a = window.URL || window.webkitURL,
        r = new Blob([""], { type: "application/x-javascript" }),
        i = a.createObjectURL(r),
        o = new Worker(i);
      o.postMessage(t, [t]), (e = 0 === t.byteLength);
    } catch (n) {
      console.error(n);
    }
    return e;
  }),
  (Detector.supportsFloatTextures = function (e) {
    return "webgl2" === e
      ? !0
      : (null === Detector.gl1 && Detector.initGL1(),
        !!Detector.glExtensionTextureFloat);
  }),
  (Detector.supportsHalfFloatTextures = function (e) {
    return "webgl2" === e
      ? !0
      : (null === Detector.gl1 && Detector.initGL1(),
        !!Detector.glExtensionTextureHalfFloat);
  }),
  (Detector.supportsShaderTextureLod = function (e) {
    return "webgl2" === e
      ? !0
      : (null === Detector.gl1 && Detector.initGL1(),
        !!Detector.glExtensionShaderTextureLod);
  }),
  (Detector.deferredCapable = (function () {
    function e(e, t, a) {
      var r = e.createFramebuffer(),
        i = e.createTexture();
      e.bindTexture(e.TEXTURE_2D, i),
        e.texImage2D(e.TEXTURE_2D, 0, t, 2, 2, 0, t, a, null),
        e.bindFramebuffer(e.FRAMEBUFFER, r),
        e.framebufferTexture2D(
          e.FRAMEBUFFER,
          e.COLOR_ATTACHMENT0,
          e.TEXTURE_2D,
          i,
          0
        );
      var o = e.checkFramebufferStatus(e.FRAMEBUFFER);
      return (
        e.bindFramebuffer(e.FRAMEBUFFER, null),
        e.bindTexture(e.TEXTURE_2D, null),
        o === e.FRAMEBUFFER_COMPLETE
      );
    }
    try {
      var t = document.createElement("canvas"),
        a = t.getContext("webgl") || t.getContext("experimental-webgl"),
        r = a.getExtension("OES_texture_float"),
        i = a.getExtension("WEBGL_draw_buffers"),
        o = r && e(a, a.RGBA, a.FLOAT);
      return o || !!i;
    } catch (n) {
      return !1;
    }
  })()),
  (Detector.getWebGLErrorMessage = function (e) {
    var t = window.innerHeight,
      a = (window.screen.availHeight, 50),
      r = 4,
      i = 0;
    451 > t && ((r = 1), (a = 75));
    var o = document.createElement("div");
    (o.style.border = "solid 0px #f00"),
      (o.style.color = "#eee"),
      (o.style.width = "100%"),
      (o.style.height = t - i + "px"),
      (o.style.position = "absolute"),
      (o.style.top = "0px"),
      (o.style.left = "0px"),
      (o.style.margin = "0"),
      (o.style.padding = "0"),
      (o.style.paddingBottom = i + "px"),
      (o.style.display = "block"),
      (o.style.backgroundSize = "auto 100%"),
      e && (o.style.background = "url('" + e + "') no-repeat center");
    var n = document.createElement("div");
    (n.style.fontFamily = "Avenir, Helvetica, Arial, sans-serif"),
      (n.style.fontWeight = "bold"),
      (n.style.textAlign = "center"),
      (n.style.lineHeight = "1.5em"),
      (n.style.background = "#000"),
      (n.style.opacity = "0.75"),
      (n.style.padding = "1em"),
      (n.style.margin = "0 auto 0"),
      (n.style.marginTop = r + "em"),
      (n.style.width = a + "%"),
      (n.style.border = "solid 0px #fff");
    var s = "",
      l = [
        "<b>THIS DEMO REQUIRES WEBGL</b><br/><br/>",
        'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" target="_top">WebGL</a>.<br/>',
        'Find out how to get WebGL working <a href="http://get.webgl.org/" target="_top">here</a> or try visiting with a different browser or computer.',
      ].join("\n"),
      h = [
        "<b>THIS DEMO REQUIRES WEBGL</b><br/><br/>",
        'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" target="_top">WebGL</a>.<br/>',
        'Find out how to get browser with WebGL support <a href="http://get.webgl.org/" target="_top">here</a>.',
      ].join("\n"),
      d = [
        "<b>THIS DEMO REQUIRES ADVANCED WEBGL FEATURES</b><br/><br/>",
        'Your graphics card or browser does not seem to support rendering into <a href="https://www.khronos.org/registry/webgl/extensions/WEBGL_draw_buffers/" target="_top">Multiple-Render-Targets</a>',
        ' or <a href="https://www.khronos.org/registry/webgl/extensions/OES_texture_float/" target="_top">Floating Point Render-Targets</a>.<br/><br/>',
        "Try visiting on a different browser or different computer (try desktop PC or notebook, only very few phones or tablets support required features).",
      ].join("\n");
    return (
      this.webgl
        ? this.deferredCapable || (s = d)
        : (s = window.WebGLRenderingContext ? l : h),
      (n.innerHTML = s),
      o.appendChild(n),
      o
    );
  }),
  (Detector.addGetWebGLMessage = function (e) {
    e = e || {};
    var t = void 0 !== e.parent ? e.parent : document.body,
      a = void 0 !== e.id ? e.id : "oldie",
      r = void 0 !== e.fallbackImg ? e.fallbackImg : null,
      i = Detector.getWebGLErrorMessage(r);
    i.id = a;
    var o = 0,
      n = function () {
        var e = (document.body, document.documentElement, window.innerHeight);
        i.style.height = e - o + "px";
      };
    window.addEventListener("resize", n, !1), t.appendChild(i);
  });
var GPUDetector = function () {
  var e = void 0,
    t = {},
    a = [
      ["AMD", "Radeon", "Pro Duo", 28808, !0, !0],
      ["Nvidia", "GeForce", "GTX Titan X SLI", 28274, !0, !0],
      ["Nvidia", "GeForce", "GTX 980 Ti SLI", 26966, !0, !0],
      ["Nvidia", "GeForce", "Titan X", 26660, !0, !1],
      ["Nvidia", "GeForce", "GTX 980 notebook SLI", 23351, !1, !0],
      ["AMD", "Radeon", "R9 295X2", 22073, !0, !0],
      ["Nvidia", "GeForce", "GTX 1080", 21828, !0, !1],
      ["Nvidia", "GeForce", "GTX 980M SLI", 18632, !1, !0],
      ["Nvidia", "GeForce", "GTX 1070", 18255, !0, !1],
      ["Nvidia", "GeForce", "GTX Titan Z", 17851, !0, !0],
      ["Nvidia", "GeForce", "GTX Titan X", 17470, !0, !1],
      ["Nvidia", "Quadro", "M6000", 16993, !0, !1],
      ["Nvidia", "GeForce", "GTX 980 Ti", 16978, !0, !1],
      ["AMD", "Radeon", "R9 Fury X", 16096, !0, !1],
      ["Nvidia", "GeForce", "GTX 970M SLI", 14873, !1, !0],
      ["AMD", "Radeon", "R9 Fury", 14580, !0, !1],
      ["AMD", "Radeon", "R9 Nano", 13888, !0, !1],
      ["Nvidia", "GeForce", "GTX 980", 13386, !0, !1],
      ["Nvidia", "GeForce", "GTX 980 notebook", 13340, !1, !1],
      ["Nvidia", "GeForce", "GTX 1060", 13215, !0, !1],
      ["AMD", "Radeon", "R9 390X", 12855, !0, !1],
      ["AMD", "Radeon", "RX 480", 12186, !0, !1],
      ["AMD", "Radeon", "R9 390", 12044, !0, !1],
      ["AMD", "Radeon", "RX 470", 11869, !0, !1],
      ["AMD", "Radeon", "R9 290X", 11862, !0, !1],
      ["Nvidia", "GeForce", "GTX 880M SLI", 11817, !1, !0],
      ["Nvidia", "GeForce", "GTX 690", 11713, !0, !0],
      ["Nvidia", "GeForce", "GTX Titan Black", 11494, !0, !1],
      ["Nvidia", "GeForce", "GTX 780 Ti", 11275, !0, !1],
      ["Nvidia", "Quadro", "M5000", 10467, !0, !1],
      ["Nvidia", "GeForce", "GTX 780M SLI", 10091, !1, !0],
      ["Nvidia", "GeForce", "GTX 970", 10282, !0, !1],
      ["AMD", "Radeon", "R9 290", 10019, !0, !1],
      ["Nvidia", "GeForce", "GTX Titan", 9913, !0, !1],
      ["Nvidia", "GeForce", "GTX 980M", 9741, !1, !1],
      ["Nvidia", "Quadro", "K6000", 9717, !0, !1],
      ["Nvidia", "GeForce", "GTX 780", 9471, !0, !1],
      ["AMD", "Radeon", "R9 380X", 9250, !0, !1],
      ["Nvidia", "Quadro", "M5000M", 9103, !1, !1],
      ["AMD", "Radeon", "R9 280X", 8402, !0, !1],
      ["AMD", "Radeon", "R9 380", 8334, !0, !1],
      ["AMD", "FirePro", "W8100", 8159, !0, !1],
      ["AMD", "Radeon", "R9 285", 7951, !0, !1],
      ["AMD", "Radeon", "HD 7970", 7852, !0, !1],
      ["Nvidia", "Quadro", "M4000M", 7723, !1, !1],
      ["Nvidia", "Quadro", "M4000", 7710, !0, !1],
      ["Nvidia", "GeForce", "GTX 770", 7707, !0, !1],
      ["Nvidia", "GeForce", "GTX 970M", 7615, !1, !1],
      ["Nvidia", "GeForce", "GTX 960", 7542, !0, !1],
      ["Nvidia", "GeForce", "GTX 1050 Ti", 7367, !0, !1],
      ["AMD", "Radeon", "R9 280", 7223, !0, !1],
      ["Nvidia", "GeForce", "GTX 680", 7001, !0, !1],
      ["AMD", "FirePro", "W7170M", 6935, !1, !1],
      ["AMD", "Radeon", "R9 M395X", 6859, !1, !1],
      ["AMD", "Radeon", "R9 M395", 6819, !1, !1],
      ["Nvidia", "GeForce", "GTX 1050", 6773, !0, !1],
      ["Nvidia", "GeForce", "GTX 950", 6764, !0, !1],
      ["AMD", "FirePro", "D700", 6764, !0, !1],
      ["AMD", "Radeon", "R9 M295X", 6590, !1, !1],
      ["Nvidia", "Quadro", "M3000M", 6415, !1, !1],
      ["AMD", "Radeon", "HD 7950", 6410, !0, !1],
      ["Nvidia", "GeForce", "GTX 670", 6286, !0, !1],
      ["Nvidia", "GeForce", "GTX 965M Ti", 6160, !1, !1],
      ["Nvidia", "GeForce", "GTX 880M", 6101, !1, !1],
      ["Nvidia", "GeForce", "GTX 860M SLI", 5941, !1, !0],
      ["AMD", "Radeon", "R9 270X", 5954, !0, !1],
      ["Nvidia", "GeForce", "GTX 760", 5906, !0, !1],
      ["AMD", "Radeon", "RX 460", 5766, !0, !1],
      ["Nvidia", "GeForce", "GTX 660 Ti", 5720, !0, !1],
      ["AMD", "Radeon", "R9 270", 5716, !0, !1],
      ["Nvidia", "GeForce", "GTX 965M", 5394, !1, !1],
      ["AMD", "Radeon", "HD 7870", 5295, !0, !1],
      ["AMD", "Radeon", "R9 M290X", 5294, !1, !1],
      ["Nvidia", "GeForce", "GTX 780M", 5244, !1, !1],
      ["Nvidia", "GeForce", "GTX 580", 5045, !0, !0],
      ["AMD", "Radeon", "R9 370", 5041, !0, !1],
      ["AMD", "Radeon", "HD 8970M", 5038, !1, !1],
      ["Nvidia", "Quadro", "K5000", 5007, !0, !1],
      ["AMD", "Radeon", "R7 265", 4948, !0, !1],
      ["AMD", "FirePro", "D300", 4899, !0, !1],
      ["Nvidia", "Quadro", "K5100M", 4776, !1, !1],
      ["Nvidia", "GeForce", "GTX 680MX", 4758, !1, !1],
      ["Nvidia", "GeForce", "GTX 870M", 4694, !1, !1],
      ["AMD", "Radeon", "HD 7970M", 4694, !1, !1],
      ["AMD", "Radeon Pro", "460", 4600, !1, !1],
      ["AMD", "FirePro", "D500", 4556, !0, !1],
      ["Nvidia", "GeForce", "GTX 660", 4524, !0, !1],
      ["Nvidia", "GeForce", "GTX 960M", 4365, !1, !1],
      ["Nvidia", "GeForce", "GTX 570", 4336, !0, !1],
      ["Nvidia", "Quadro", "M2000M", 4224, !1, !1],
      ["AMD", "Radeon", "HD 7850", 4224, !0, !1],
      ["Nvidia", "GeForce", "GTX 750 Ti", 4211, !0, !1],
      ["Nvidia", "GeForce", "GT 755M SLI", 4106, !1, !0],
      ["Nvidia", "GeForce", "GTX 680M", 4049, !1, !1],
      ["AMD", "Radeon", "R9 260X", 4016, !0, !1],
      ["AMD", "Radeon", "HD 6970", 3995, !0, !1],
      ["Nvidia", "GeForce", "GTX 860M", 3919, !1, !1],
      ["AMD", "Radeon", "R7 260", 3885, !0, !1],
      ["AMD", "Radeon", "R9 360", 3839, !0, !1],
      ["AMD", "FirePro", "M6100", 3837, !1, !1],
      ["Nvidia", "GeForce", "GTX 750", 3810, !0, !1],
      ["AMD", "Radeon", "HD 7790", 3759, !0, !1],
      ["Nvidia", "GeForce", "GT 750M SLI", 3703, !1, !0],
      ["Nvidia", "Quadro", "K4100M", 3654, !1, !1],
      ["AMD", "Radeon", "HD 5870", 3613, !0, !1],
      ["Nvidia", "GeForce", "GTX 950M", 3568, !1, !1],
      ["AMD", "Radeon", "HD 6950", 3553, !0, !1],
      ["Nvidia", "Quadro", "M1000M", 3517, !1, !1],
      ["Nvidia", "GeForce", "GTX 480", 3480, !0, !1],
      ["AMD", "Radeon", "R9 M385X", 3352, !1, !1],
      ["AMD", "Radeon", "R9 M280X", 3349, !1, !1],
      ["Nvidia", "GeForce", "GTX 770M", 3347, !1, !1],
      ["Nvidia", "GeForce", "GTX 560 Ti", 3256, !0, !1],
      ["Nvidia", "GeForce", "GTX 650 Ti", 3329, !0, !1],
      ["AMD", "Radeon Pro", "450", 3252, !1, !1],
      ["Nvidia", "Quadro", "K4000", 3229, !0, !1],
      ["AMD", "Radeon", "HD 6870", 3204, !0, !1],
      ["Nvidia", "GeForce", "GTX 850M", 3118, !1, !1],
      ["AMD", "Radeon", "HD 5850", 3037, !0, !1],
      ["AMD", "Radeon", "HD 7770", 3016, !0, !1],
      ["Nvidia", "GeForce", "GTX 560", 2886, !0, !1],
      ["Nvidia", "GeForce", "945M", 2884, !1, !1],
      ["Nvidia", "GeForce", "GTX 675MX", 2831, !0, !1],
      ["Nvidia", "GeForce", "GTX 470", 2802, !0, !1],
      ["Nvidia", "Quadro", "K5000M", 2797, !1, !1],
      ["AMD", "Radeon", "HD 5830", 2778, !0, !1],
      ["Nvidia", "GeForce", "GTX 460", 2762, !0, !1],
      ["AMD", "Radeon", "HD 6850", 2707, !0, !1],
      ["Nvidia", "Quadro", "6000", 2563, !0, !1],
      ["AMD", "Radeon", "HD 6990M", 2560, !1, !1],
      ["Nvidia", "GeForce", "GTX 580M", 2509, !1, !1],
      ["Nvidia", "GeForce", "GTX 765M", 2479, !1, !1],
      ["AMD", "Radeon", "HD 7870M", 2478, !1, !1],
      ["AMD", "Radeon", "R9 M370X", 2419, !1, !1],
      ["Nvidia", "Quadro", "M600M", 2404, !1, !1],
      ["Nvidia", "Quadro", "K620", 2381, !0, !1],
      ["Nvidia", "Quadro", "K3100M", 2381, !1, !1],
      ["Nvidia", "GeForce", "845M", 2362, !1, !1],
      ["Nvidia", "GeForce", "GTX 745", 2349, !0, !1],
      ["Nvidia", "GeForce", "GTX 675M", 2331, !1, !1],
      ["Nvidia", "GeForce", "GTX 485M", 2330, !1, !1],
      ["AMD", "FirePro", "M6000", 2398, !1, !1],
      ["AMD", "FirePro", "M5100", 2327, !1, !1],
      ["Nvidia", "GeForce", "GTX 760M", 2271, !1, !1],
      ["Nvidia", "GeForce", "GTX 465", 2253, !0, !1],
      ["AMD", "Radeon", "R8 M445DX", 2235, !1, !0],
      ["AMD", "Radeon", "HD 7750", 2215, !0, !1],
      ["Nvidia", "Quadro", "K4000M", 2199, !1, !1],
      ["AMD", "Radeon", "HD 6970M", 2186, !1, !1],
      ["AMD", "Radeon", "HD 8870M", 2168, !1, !1],
      ["AMD", "Radeon", "R7 250", 2147, !0, !1],
      ["AMD", "FirePro", "W5130M", 2121, !1, !1],
      ["Nvidia", "GeForce", "GT 755M", 2105, !1, !1],
      ["AMD", "Radeon", "HD 5770", 2072, !0, !1],
      ["Nvidia", "GeForce", "GT 740", 2042, !0, !1],
      ["Nvidia", "GeForce", "Surface Book", 2031, !1, !1],
      ["Nvidia", "GeForce", "GTX 570M", 2020, !1, !0],
      ["Nvidia", "GeForce", "GTX 650", 2002, !0, !1],
      ["AMD", "Radeon", "R9 M265X", 1997, !1, !1],
      ["AMD", "Radeon", "HD 6770", 1951, !0, !1],
      ["Nvidia", "GeForce", "GTX 670M", 1950, !1, !1],
      ["AMD", "Radeon", "R7 M275DX", 1931, !1, !0],
      ["Intel", "Iris Pro", "580", 1903, !0, !1],
      ["AMD", "Radeon", "R9 M275", 1885, !1, !1],
      ["Nvidia", "GeForce", "GTX 550 Ti", 1881, !0, !1],
      ["Nvidia", "Quadro", "5000", 1873, !0, !1],
      ["AMD", "Radeon", "HD 8850M", 1845, !1, !1],
      ["Intel", "Iris Pro", "6200", 1773, !1, !1],
      ["AMD", "FirePro", "W4170M", 1766, !1, !1],
      ["AMD", "Radeon", "R7 M370", 1760, !1, !1],
      ["Nvidia", "GeForce", "GTX 660M", 1751, !1, !1],
      ["Nvidia", "GeForce", "GT 640", 1735, !0, !1],
      ["Nvidia", "GeForce", "940MX", 1730, !1, !1],
      ["AMD", "Radeon", "HD 8790M", 1727, !1, !1],
      ["Nvidia", "GeForce", "GTS 450", 1724, !0, !1],
      ["AMD", "Radeon", "R8 M365DX", 1716, !1, !0],
      ["AMD", "FirePro", "M4000", 1713, !1, !1],
      ["AMD", "Radeon", "HD 7730", 1689, !0, !1],
      ["AMD", "Radeon", "R9 M375", 1679, !1, !1],
      ["AMD", "FirePro", "W4100", 1665, !0, !1],
      ["Nvidia", "GeForce", "GTX 470M", 1664, !1, !1],
      ["Nvidia", "Quadro", "4000M", 1663, !1, !1],
      ["Intel", "Iris Graphics", "550", 1638, !1, !1],
      ["Nvidia", "Quadro", "K620M", 1621, !1, !1],
      ["Nvidia", "Quadro", "M500M", 1610, !1, !1],
      ["Nvidia", "Quadro", "K2100M", 1609, !1, !1],
      ["Nvidia", "Quadro", "M500M", 1595, !1, !1],
      ["AMD", "Radeon", "HD 6750", 1594, !0, !1],
      ["AMD", "FirePro", "W4190M", 1588, !1, !1],
      ["Nvidia", "GeForce", "940M", 1582, !1, !1],
      ["Nvidia", "GeForce", "GT 730", 1582, !0, !1],
      ["Nvidia", "GeForce", "GT 750M", 1574, !1, !1],
      ["Nvidia", "GeForce", "840M", 1563, !1, !1],
      ["Nvidia", "GeForce", "GT 745M", 1549, !1, !1],
      ["Nvidia", "GeForce", "GTX 480M", 1541, !1, !1],
      ["Intel", "Iris Pro", "5200", 1536, !1, !1],
      ["AMD", "Radeon", "R6 M340DX", 1472, !1, !0],
      ["Nvidia", "GeForce", "930M", 1442, !1, !1],
      ["Intel", "Iris Graphics", "540", 1440, !1, !1],
      ["Nvidia", "GeForce", "GTX 560M", 1435, !1, !1],
      ["Nvidia", "GeForce", "GT 650M", 1420, !1, !1],
      ["Nvidia", "GeForce", "830M", 1403, !1, !1],
      ["AMD", "Radeon", "R7 M260X", 1396, !1, !1],
      ["Nvidia", "Quadro", "4000", 1366, !0, !1],
      ["Nvidia", "Quadro", "K2000M", 1344, !1, !1],
      ["AMD", "Radeon", "R5 Bristol Ridge", 1337, !1, !1],
      ["AMD", "Radeon", "R7 M265", 1329, !1, !1],
      ["Nvidia", "Quadro", "K1100M", 1326, !1, !1],
      ["Nvidia", "GeForce", "920MX", 1282, !1, !1],
      ["AMD", "Radeon", "HD 8750M", 1276, !1, !1],
      ["Nvidia", "Quadro", "2000", 1272, !0, !1],
      ["Nvidia", "Quadro", "3000M", 1269, !1, !1],
      ["AMD", "Radeon", "HD 6670", 1240, !0, !1],
      ["Nvidia", "GeForce", "GT 640M ", 1225, !1, !1],
      ["AMD", "Radeon", "R7 M340", 1212, !1, !1],
      ["AMD", "Radeon", "HD 8690M", 1210, !1, !1],
      ["AMD", "Radeon", "R7 M440", 1205, !1, !1],
      ["Intel", "HD Graphics", "530", 1202, !1, !1],
      ["AMD", "Radeon", "R7 M270", 1184, !1, !1],
      ["AMD", "Radeon", "R7 M460", 1177, !1, !1],
      ["Nvidia", "GeForce", "GTX 460M", 1162, !1, !1],
      ["Nvidia", "GeForce", "920M", 1161, !1, !1],
      ["AMD", "Radeon", "R7 240", 1153, !0, !1],
      ["Nvidia", "GeForce", "GT 645M", 1151, !1, !1],
      ["Nvidia", "GeForce", "GT 740M", 1151, !1, !1],
      ["AMD", "Radeon", "HD 8730M", 1150, !1, !1],
      ["Nvidia", "GeForce", "825M", 1150, !1, !1],
      ["AMD", "Radeon", "R7 Carrizo", 1137, !1, !1],
      ["Intel", "HD Graphics", "620", 1128, !1, !1],
      ["AMD", "Radeon", "R7 M360", 1122, !1, !1],
      ["AMD", "Radeon", "R6 M255DX", 1115, !1, !0],
      ["AMD", "FirePro", "W2100", 1085, !0, !1],
      ["Nvidia", "Quadro", "2000M", 1076, !1, !1],
      ["AMD", "Radeon", "R5 M255", 1064, !1, !1],
      ["Nvidia", "GeForce", "GT 730M", 1061, !1, !1],
      ["AMD", "Radeon", "R7 M260", 1057, !1, !1],
      ["AMD", "Radeon", "HD 8650M", 1050, !1, !1],
      ["Intel", "HD Graphics", "6000", 1033, !1, !1],
      ["Nvidia", "GeForce", "GT 735M", 1023, !1, !1],
      ["Nvidia", "GeForce", "910M", 1022, !1, !1],
      ["Intel", "Iris Graphics", "6100", 1020, !1, !1],
      ["AMD", "Radeon", "R5 M430", 1004, !1, !1],
      ["Intel", "HD Graphics", "5600", 991, !1, !1],
      ["Nvidia", "GeForce", "GT 555M", 922, !1, !1],
      ["AMD", "Radeon", "R5 M240", 921, !1, !1],
      ["AMD", "Radeon", "R5 M315", 919, !1, !1],
      ["AMD", "Radeon", "R5 M335", 911, !1, !1],
      ["AMD", "Radeon", "HD 8650G", 905, !1, !1],
      ["Nvidia", "Quadro", "K600", 900, !0, !1],
      ["Intel", "Iris Graphics", "5100", 878, !1, !1],
      ["AMD", "Radeon", "HD 6570", 864, !0, !1],
      ["AMD", "FirePro", "M4100", 857, !1, !1],
      ["Nvidia", "Quadro", "K1000M", 857, !1, !1],
      ["Nvidia", "GeForce", "GT 635M", 851, !1, !1],
      ["AMD", "Radeon", "R7 Kaveri", 851, !1, !1],
      ["AMD", "Radeon", "R5 M330", 848, !1, !1],
      ["Intel", "HD Graphics", "520", 844, !1, !1],
      ["Nvidia", "GeForce", "820M", 829, !1, !1],
      ["AMD", "Radeon", "HD 8670M", 829, !1, !1],
      ["Nvidia", "GeForce", "GT 625M", 827, !1, !1],
      ["AMD", "Radeon", "HD 7670M", 824, !1, !1],
      ["Nvidia", "GeForce", "GT 720M", 822, !1, !1],
      ["Nvidia", "GeForce", "GT 720", 811, !0, !1],
      ["Nvidia", "GeForce", "GT 550M", 796, !1, !1],
      ["AMD", "Radeon", "HD 8550G", 792, !1, !1],
      ["AMD", "Radeon", "HD 7560D", 791, !0, !1],
      ["AMD", "Radeon", "HD 8570M", 790, !1, !1],
      ["Nvidia", "GeForce", "GT 620", 772, !0, !1],
      ["AMD", "Radeon", "R5 M230", 771, !1, !1],
      ["AMD", "Radeon", "R6 Kaveri", 770, !1, !1],
      ["Nvidia", "GeForce", "710M", 768, !1, !1],
      ["Nvidia", "Quadro", "K610M", 755, !1, !1],
      ["Nvidia", "Quadro", "1000M", 751, !1, !1],
      ["Intel", "HD Graphics", "515", 748, !1, !1],
      ["Nvidia", "GeForce", "GT 620M", 737, !1, !1],
      ["Nvidia", "GeForce", "GT 430", 735, !0, !1],
      ["Intel", "HD Graphics", "5000", 734, !1, !1],
      ["Nvidia", "GeForce", "GT 540M", 728, !1, !1],
      ["Nvidia", "GeForce", "GT 630M", 719, !1, !1],
      ["AMD", "Radeon", "HD 7620G", 716, !1, !1],
      ["Nvidia", "Quadro", "600", 710, !0, !1],
      ["Nvidia", "NVS", "5200M", 704, !1, !1],
      ["AMD", "Radeon", "HD 8470D", 670, !0, !1],
      ["Nvidia", "GeForce", "GT 630", 665, !0, !1],
      ["Intel", "HD Graphics", "5500", 663, !1, !1],
      ["Intel", "HD Graphics", "4600", 635, !1, !1],
      ["AMD", "Radeon", "HD 7610M", 605, !1, !1],
      ["AMD", "Radeon", "R5 Kaveri", 572, !1, !1],
      ["Intel", "HD Graphics", "4400", 571, !1, !1],
      ["AMD", "Radeon", "HD 7570M", 569, !1, !1],
      ["AMD", "Radeon", "HD 7550M", 569, !1, !1],
      ["Nvidia", "GeForce", "GT 525M", 545, !1, !1],
      ["AMD", "Radeon", "R5 Beema", 524, !1, !1],
      ["AMD", "Radeon", "HD 7500G", 512, !1, !1],
      ["AMD", "Radeon", "R4 Beema", 494, !1, !1],
      ["Intel", "HD Graphics", "4000", 480, !1, !1],
      ["Intel", "HD Graphics", "5300", 478, !1, !1],
      ["AMD", "Radeon", "HD 8610G", 475, !1, !1],
      ["AMD", "Radeon", "HD 8450G", 464, !1, !1],
      ["AMD", "Radeon", "HD 6530D", 452, !0, !1],
      ["AMD", "Radeon", "HD 6450", 450, !0, !1],
      ["AMD", "Radeon", "HD 7480D", 445, !0, !1],
      ["AMD", "Radeon", "R3 Beema", 432, !1, !1],
      ["AMD", "Radeon", "HD 6480G", 416, !1, !1],
      ["Nvidia", "GeForce", "GT 520M", 413, !1, !1],
      ["Nvidia", "GeForce", "GT 610", 406, !0, !1],
      ["AMD", "Radeon", "HD 8400", 401, !0, !1],
      ["Intel", "HD Graphics", "4200", 395, !1, !1],
      ["Nvidia", "GeForce", "GT 520", 389, !0, !1],
      ["AMD", "Radeon", "HD 8350G", 388, !1, !1],
      ["AMD", "Radeon", "HD 7470M", 384, !1, !1],
      ["Intel", "HD Graphics", "Haswell", 355, !1, !1],
      ["AMD", "Radeon", "HD 8330", 352, !0, !1],
      ["AMD", "Radeon", "HD 7420G", 343, !0, !1],
      ["AMD", "Radeon", "HD 8280", 328, !0, !1],
      ["AMD", "Radeon", "HD 7400G", 328, !0, !1],
      ["Intel", "HD Graphics", "2500", 318, !1, !1],
      ["AMD", "Radeon", "HD 8240", 290, !0, !1],
      ["Intel", "HD Graphics", "Ivy Bridge", 285, !1, !1],
      ["AMD", "Radeon", "HD 8250", 253, !0, !1],
      ["Intel", "HD Graphics", "Braswell", 233, !1, !1],
      ["AMD", "Radeon", "HD 8210", 227, !0, !1],
      ["AMD", "Radeon", "HD 7340", 224, !1, !1],
      ["AMD", "Radeon", "HD 7310", 192, !1, !1],
      ["Intel", "HD Graphics", "Bay Trail", 150, !1, !1],
      ["AMD", "Radeon", "HD 8180", 145, !0, !1],
    ],
    r = function () {
      for (var e = 0, r = a.length; r > e; e++) {
        var i = a[e],
          s = i[0],
          l = i[1],
          h = i[2],
          d = i[3],
          c = i[4],
          u = s + " " + l + " " + h,
          f = h,
          p = " (notebook)";
        c && (p = " (desktop)"),
          ("Intel" === s || "NVS" === l || "FirePro" === l || "Quadro" === l) &&
          (f = l + " " + h);
        var m = o(u);
        t[m] = {
          rawScore: d,
          formattedScore: n(d),
          fullName: u,
          shortName: f,
          type: p,
          vendor: s.toLowerCase(),
        };
      }
    },
    i = function (e) {
      var t = e.replace(/\((R|TM)\)/, "");
      return (
        (t = t
          .replace("ANGLE", "")
          .replace("Corporation ", "")
          .replace(/Direct3D\w*/, "")
          .replace(/vs_\w*/, "")
          .replace(/ps_\w*/, "")
          .replace(/[\(\)]/g, "")),
        (t = t.replace("/PCIe/SSE2", "")),
        (t = t.replace(/OpenGL \d*\.\d* compatibility/, "")),
        t.trim()
      );
    },
    o = function (e) {
      return e.toUpperCase();
    },
    n = function (e) {
      for (
        var t = e.toString(), a = [], r = 0, i = 0, o = t.length;
        o > r;
        r++, i++
      ) {
        var n = t[o - 1 - r];
        (a[i] = n), r % 3 === 2 && o - 1 > r && ((i += 1), (a[i] = ","));
      }
      return a.reverse().join("");
    };
  (this.detectGPU = function () {
    var a = null;
    if (void 0 === e) {
      e = "";
      try {
        if (void 0 !== window.WebGLRenderingContext) {
          var r = document.createElement("canvas"),
            n = r.getContext("webgl") || r.getContext("experimental-webgl");
          if (void 0 !== n) {
            var s = n.getExtension("WEBGL_debug_renderer_info");
            if (void 0 !== s) {
              var l = n.getParameter(s.UNMASKED_RENDERER_WEBGL),
                h = i(l);
              !(
                h.toLowerCase().indexOf("geforce") >= 0 ||
                h.toLowerCase().indexOf("quadro") >= 0
              ) ||
                h.toLowerCase().indexOf("nvidia") >= 0 ||
                (h = "NVIDIA " + h),
                (e = h);
            }
          }
        }
      } catch (d) { }
    }
    if ("" !== e) {
      var c = o(e);
      void 0 !== t[c] && (a = t[c]);
    }
    return a;
  }),
    r();
};
!(function () {
  for (
    var e = 0, t = ["ms", "moz", "webkit", "o"], a = 0;
    a < t.length && !window.requestAnimationFrame;
    ++a
  )
    (window.requestAnimationFrame = window[t[a] + "RequestAnimationFrame"]),
      (window.cancelAnimationFrame =
        window[t[a] + "CancelAnimationFrame"] ||
        window[t[a] + "CancelRequestAnimationFrame"]);
  void 0 === window.requestAnimationFrame &&
    (window.requestAnimationFrame = function (t) {
      var a = Date.now(),
        r = Math.max(0, 16 - (a - e)),
        i = window.setTimeout(function () {
          t(a + r);
        }, r);
      return (e = a + r), i;
    }),
    (window.cancelAnimationFrame =
      window.cancelAnimationFrame ||
      function (e) {
        window.clearTimeout(e);
      });
})(),
  (self.console = self.console || {
    info: function () { },
    log: function () { },
    debug: function () { },
    warn: function () { },
    error: function () { },
  }),
  (self.Int32Array = self.Int32Array || Array),
  (self.Float32Array = self.Float32Array || Array),
  (String.prototype.startsWith =
    String.prototype.startsWith ||
    function (e) {
      return this.slice(0, e.length) === e;
    }),
  (String.prototype.endsWith =
    String.prototype.endsWith ||
    function (e) {
      var t = String(e),
        a = this.lastIndexOf(t);
      return (a > -1 && a) === this.length - t.length;
    }),
  (String.prototype.trim =
    String.prototype.trim ||
    function () {
      return this.replace(/^\s+|\s+$/g, "");
    }),
  (function (e, t, a, r, i, o) {
    function n(e) {
      var t,
        a = e.length,
        i = this,
        o = 0,
        n = (i.i = i.j = 0),
        s = (i.S = []);
      for (a || (e = [a++]); r > o;) s[o] = o++;
      for (o = 0; r > o; o++)
        (s[o] = s[(n = p & (n + e[o % a] + (t = s[o])))]), (s[n] = t);
      (i.g = function (e) {
        for (var t, a = 0, o = i.i, n = i.j, s = i.S; e--;)
          (t = s[(o = p & (o + 1))]),
            (a = a * r + s[p & ((s[o] = s[(n = p & (n + t))]) + (s[n] = t))]);
        return (i.i = o), (i.j = n), a;
      })(r);
    }
    function s(e, t) {
      var a,
        r = [],
        i = (typeof e)[0];
      if (t && "o" == i)
        for (a in e)
          try {
            r.push(s(e[a], t - 1));
          } catch (o) { }
      return r.length ? r : "s" == i ? e : e + "\x00";
    }
    function l(e, t) {
      for (var a, r = e + "", i = 0; i < r.length;)
        t[p & i] = p & ((a ^= 19 * t[p & i]) + r.charCodeAt(i++));
      return d(t);
    }
    function h(a) {
      try {
        return e.crypto.getRandomValues((a = new Uint8Array(r))), d(a);
      } catch (i) {
        return [+new Date(), e, e.navigator.plugins, e.screen, d(t)];
      }
    }
    function d(e) {
      return String.fromCharCode.apply(0, e);
    }
    var c = a.pow(r, i),
      u = a.pow(2, o),
      f = 2 * u,
      p = r - 1;
    (a.seedrandom = function (e, o) {
      var p = [],
        m = l(s(o ? [e, d(t)] : 0 in arguments ? e : h(), 3), p),
        v = new n(p);
      return (
        l(d(v.S), t),
        (a.srandom = function () {
          for (var e = v.g(i), t = c, a = 0; u > e;)
            (e = (e + a) * r), (t *= r), (a = v.g(1));
          for (; e >= f;) (e /= 2), (t /= 2), (a >>>= 1);
          return (e + a) / t;
        }),
        m
      );
    }),
      l(a.random(), t);
  })(this, [], Math, 256, 6, 52);
// footer

XG.BUILD_NUMBER = 625;
XG.BUILD_DATE = "2017-03-04";

console.log(
  "XG version " +
  XG.VERSION +
  " | build " +
  XG.BUILD_NUMBER +
  " | " +
  XG.BUILD_DATE +
  "]"
);
