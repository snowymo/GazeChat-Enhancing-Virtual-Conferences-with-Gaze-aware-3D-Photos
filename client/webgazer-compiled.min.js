/** WebGazer.js: Scalable Webcam EyeTracking Using User Interactions 
 * 
 * Copyright (c) 2016-2020, Brown HCI Group 

* Licensed under GPLv3. Companies with a valuation of less than $10M can use WebGazer.js under LGPLv3. 
*/


!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;(b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).localforage=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c;return e(b[g][1][a]||a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){(function(a){"use strict";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode("");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||void 0===a.MessageChannel)e="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var b=a.document.createElement("script");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],2:[function(a,b,c){"use strict";function d(){}function e(a){if("function"!=typeof a)throw new TypeError("resolver must be a function");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,"function"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),"function"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(b){return p.reject(a,b)}d===a?p.reject(a,new TypeError("Cannot resolve promise with itself")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&("object"==typeof a||"function"==typeof a)&&"function"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);"error"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status="success"}catch(a){c.status="error",c.value=a}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a(1),p={},q=["REJECTED"],r=["FULFILLED"],s=["PENDING"];b.exports=e,e.prototype.catch=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if("function"!=typeof a&&this.state===r||"function"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);return this.state!==s?g(c,this.state===r?a:b,this.outcome):this.queue.push(new f(c,a,b)),c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if("error"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},e.resolve=k,e.reject=l,e.all=m,e.race=n},{1:1}],3:[function(a,b,c){(function(b){"use strict";"function"!=typeof b.Promise&&(b.Promise=a(2))}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{2:2}],4:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(){try{if("undefined"!=typeof indexedDB)return indexedDB;if("undefined"!=typeof webkitIndexedDB)return webkitIndexedDB;if("undefined"!=typeof mozIndexedDB)return mozIndexedDB;if("undefined"!=typeof OIndexedDB)return OIndexedDB;if("undefined"!=typeof msIndexedDB)return msIndexedDB}catch(a){return}}function f(){try{if(!ua)return!1;var a="undefined"!=typeof openDatabase&&/(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)&&!/BlackBerry/.test(navigator.platform),b="function"==typeof fetch&&-1!==fetch.toString().indexOf("[native code");return(!a||b)&&"undefined"!=typeof indexedDB&&"undefined"!=typeof IDBKeyRange}catch(a){return!1}}function g(a,b){a=a||[],b=b||{};try{return new Blob(a,b)}catch(f){if("TypeError"!==f.name)throw f;for(var c,d=new("undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:WebKitBlobBuilder),e=0;e<a.length;e+=1)d.append(a[e]);return d.getBlob(b.type)}}function h(a,b){b&&a.then(function(a){b(null,a)},function(a){b(a)})}function i(a,b,c){"function"==typeof b&&a.then(b),"function"==typeof c&&a.catch(c)}function j(a){return"string"!=typeof a&&(console.warn(a+" used as a key, but it is not a string."),a=String(a)),a}function k(){if(arguments.length&&"function"==typeof arguments[arguments.length-1])return arguments[arguments.length-1]}function l(a){for(var b=a.length,c=new ArrayBuffer(b),d=new Uint8Array(c),e=0;e<b;e++)d[e]=a.charCodeAt(e);return c}function m(a){return new va(function(b){var c=a.transaction(wa,Ba),d=g([""]);c.objectStore(wa).put(d,"key"),c.onabort=function(a){a.preventDefault(),a.stopPropagation(),b(!1)},c.oncomplete=function(){var a=navigator.userAgent.match(/Chrome\/(\d+)/),c=navigator.userAgent.match(/Edge\//);b(c||!a||parseInt(a[1],10)>=43)}}).catch(function(){return!1})}function n(a){return"boolean"==typeof xa?va.resolve(xa):m(a).then(function(a){return xa=a})}function o(a){var b=ya[a.name],c={};c.promise=new va(function(a,b){c.resolve=a,c.reject=b}),b.deferredOperations.push(c),b.dbReady?b.dbReady=b.dbReady.then(function(){return c.promise}):b.dbReady=c.promise}function p(a){var b,c=ya[a.name].deferredOperations.pop();if(c)return c.resolve(),c.promise}function q(a,b){var c,d=ya[a.name].deferredOperations.pop();if(d)return d.reject(b),d.promise}function r(a,b){return new va(function(c,d){if(ya[a.name]=ya[a.name]||{forages:[],db:null,dbReady:null,deferredOperations:[]},a.db){if(!b)return c(a.db);o(a),a.db.close()}var e=[a.name];b&&e.push(a.version);var f=ua.open.apply(ua,e);b&&(f.onupgradeneeded=function(b){var c=f.result;try{c.createObjectStore(a.storeName),b.oldVersion<=1&&c.createObjectStore(wa)}catch(c){if("ConstraintError"!==c.name)throw c;console.warn('The database "'+a.name+'" has been upgraded from version '+b.oldVersion+" to version "+b.newVersion+', but the storage "'+a.storeName+'" already exists.')}}),f.onerror=function(a){a.preventDefault(),d(f.error)},f.onsuccess=function(){c(f.result),p(a)}})}function s(a){return r(a,!1)}function t(a){return r(a,!0)}function u(a,b){if(!a.db)return!0;var c=!a.db.objectStoreNames.contains(a.storeName),d=a.version<a.db.version,e=a.version>a.db.version;if(d&&(a.version!==b&&console.warn('The database "'+a.name+"\" can't be downgraded from version "+a.db.version+" to version "+a.version+"."),a.version=a.db.version),e||c){if(c){var f=a.db.version+1;f>a.version&&(a.version=f)}return!0}return!1}function v(a){return new va(function(b,c){var d=new FileReader;d.onerror=c,d.onloadend=function(c){var d=btoa(c.target.result||"");b({__local_forage_encoded_blob:!0,data:d,type:a.type})},d.readAsBinaryString(a)})}function w(a){return g([l(atob(a.data))],{type:a.type})}function x(a){return a&&a.__local_forage_encoded_blob}function y(a){var b=this,c=b._initReady().then(function(){var a=ya[b._dbInfo.name];if(a&&a.dbReady)return a.dbReady});return i(c,a,a),c}function z(a){o(a);for(var b=ya[a.name],c=b.forages,d=0;d<c.length;d++){var e=c[d];e._dbInfo.db&&(e._dbInfo.db.close(),e._dbInfo.db=null)}return a.db=null,s(a).then(function(b){return a.db=b,u(a)?t(a):b}).then(function(d){a.db=b.db=d;for(var e=0;e<c.length;e++)c[e]._dbInfo.db=d}).catch(function(b){throw q(a,b),b})}function A(a,b,c,d){void 0===d&&(d=1);try{var e=a.db.transaction(a.storeName,b);c(null,e)}catch(e){if(d>0&&(!a.db||"InvalidStateError"===e.name||"NotFoundError"===e.name))return va.resolve().then(function(){if(!a.db||"NotFoundError"===e.name&&!a.db.objectStoreNames.contains(a.storeName)&&a.version<=a.db.version)return a.db&&(a.version=a.db.version+1),t(a)}).then(function(){return z(a).then(function(){A(a,b,c,d-1)})}).catch(c);c(e)}}function B(){return{forages:[],db:null,dbReady:null,deferredOperations:[]}}function C(a){function b(){return va.resolve()}var c=this,d={db:null};if(a)for(var e in a)d[e]=a[e];var f=ya[d.name];f||(f={forages:[],db:null,dbReady:null,deferredOperations:[]},ya[d.name]=f),f.forages.push(c),c._initReady||(c._initReady=c.ready,c.ready=y);for(var g=[],h=0;h<f.forages.length;h++){var i=f.forages[h];i!==c&&g.push(i._initReady().catch(b))}var j=f.forages.slice(0);return va.all(g).then(function(){return d.db=f.db,s(d)}).then(function(a){return d.db=a,u(d,c._defaultConfig.version)?t(d):a}).then(function(a){d.db=f.db=a,c._dbInfo=d;for(var b=0;b<j.length;b++){var e=j[b];e!==c&&(e._dbInfo.db=d.db,e._dbInfo.version=d.version)}})}function D(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g,h=f.objectStore(c._dbInfo.storeName).get(a);h.onsuccess=function(){var a=h.result;void 0===a&&(a=null),x(a)&&(a=w(a)),b(a)},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function E(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g,h=f.objectStore(c._dbInfo.storeName).openCursor(),i=1;h.onsuccess=function(){var c=h.result;if(c){var d=c.value;x(d)&&(d=w(d));var e=a(d,c.key,i++);void 0!==e?b(e):c.continue()}else b()},h.onerror=function(){d(h.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function F(a,b,c){var d=this;a=j(a);var e=new va(function(c,e){var f;d.ready().then(function(){return f=d._dbInfo,"[object Blob]"===za.call(b)?n(f.db).then(function(a){return a?b:v(b)}):b}).then(function(b){A(d._dbInfo,Ba,function(f,g){if(f)return e(f);try{var h=g.objectStore(d._dbInfo.storeName);null===b&&(b=void 0);var i=h.put(b,a);g.oncomplete=function(){void 0===b&&(b=null),c(b)},g.onabort=g.onerror=function(){var a=i.error?i.error:i.transaction.error;e(a)}}catch(a){e(a)}})}).catch(e)});return h(e,c),e}function G(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){A(c._dbInfo,Ba,function(e,f){if(e)return d(e);try{var g,h=f.objectStore(c._dbInfo.storeName).delete(a);f.oncomplete=function(){b()},f.onerror=function(){d(h.error)},f.onabort=function(){var a=h.error?h.error:h.transaction.error;d(a)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function H(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Ba,function(d,e){if(d)return c(d);try{var f,g=e.objectStore(b._dbInfo.storeName).clear();e.oncomplete=function(){a()},e.onabort=e.onerror=function(){var a=g.error?g.error:g.transaction.error;c(a)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function I(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Aa,function(d,e){if(d)return c(d);try{var f,g=e.objectStore(b._dbInfo.storeName).count();g.onsuccess=function(){a(g.result)},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function J(a,b){var c=this,d=new va(function(b,d){a<0?b(null):c.ready().then(function(){A(c._dbInfo,Aa,function(e,f){if(e)return d(e);try{var g=f.objectStore(c._dbInfo.storeName),h=!1,i=g.openCursor();i.onsuccess=function(){var c=i.result;c?0===a?b(c.key):h?b(c.key):(h=!0,c.advance(a)):b(null)},i.onerror=function(){d(i.error)}}catch(a){d(a)}})}).catch(d)});return h(d,b),d}function K(a){var b=this,c=new va(function(a,c){b.ready().then(function(){A(b._dbInfo,Aa,function(d,e){if(d)return c(d);try{var f,g=e.objectStore(b._dbInfo.storeName).openCursor(),h=[];g.onsuccess=function(){var b=g.result;b?(h.push(b.key),b.continue()):a(h)},g.onerror=function(){c(g.error)}}catch(a){c(a)}})}).catch(c)});return h(c,a),c}function L(a,b){b=k.apply(this,arguments);var c=this.config();(a="function"!=typeof a&&a||{}).name||(a.name=a.name||c.name,a.storeName=a.storeName||c.storeName);var d,e=this;if(a.name){var f,g=a.name===c.name&&e._dbInfo.db?va.resolve(e._dbInfo.db):s(a).then(function(b){var c=ya[a.name],d=c.forages;c.db=b;for(var e=0;e<d.length;e++)d[e]._dbInfo.db=b;return b});d=a.storeName?g.then(function(b){if(b.objectStoreNames.contains(a.storeName)){var c=b.version+1;o(a);var d=ya[a.name],e=d.forages;b.close();for(var f=0;f<e.length;f++){var g=e[f];g._dbInfo.db=null,g._dbInfo.version=c}return new va(function(b,d){var e=ua.open(a.name,c);e.onerror=function(a){e.result.close(),d(a)},e.onupgradeneeded=function(){e.result.deleteObjectStore(a.storeName)},e.onsuccess=function(){var a=e.result;a.close(),b(a)}}).then(function(a){d.db=a;for(var b=0;b<e.length;b++){var c=e[b];c._dbInfo.db=a,p(c._dbInfo)}}).catch(function(b){throw(q(a,b)||va.resolve()).catch(function(){}),b})}}):g.then(function(b){o(a);var c=ya[a.name],d=c.forages;b.close();for(var e=0;e<d.length;e++)d[e]._dbInfo.db=null;return new va(function(b,c){var d=ua.deleteDatabase(a.name);d.onerror=d.onblocked=function(a){var b=d.result;b&&b.close(),c(a)},d.onsuccess=function(){var a=d.result;a&&a.close(),b(a)}}).then(function(a){c.db=a;for(var b=0;b<d.length;b++)p(d[b]._dbInfo)}).catch(function(b){throw(q(a,b)||va.resolve()).catch(function(){}),b})})}else d=va.reject("Invalid arguments");return h(d,b),d}function M(){return"function"==typeof openDatabase}function N(a){var b,c,d,e,f,g=.75*a.length,h=a.length,i=0;"="===a[a.length-1]&&(g--,"="===a[a.length-2]&&g--);var j=new ArrayBuffer(g),k=new Uint8Array(j);for(b=0;b<h;b+=4)c=Da.indexOf(a[b]),d=Da.indexOf(a[b+1]),e=Da.indexOf(a[b+2]),f=Da.indexOf(a[b+3]),k[i++]=c<<2|d>>4,k[i++]=(15&d)<<4|e>>2,k[i++]=(3&e)<<6|63&f;return j}function O(a){var b,c=new Uint8Array(a),d="";for(b=0;b<c.length;b+=3)d+=Da[c[b]>>2],d+=Da[(3&c[b])<<4|c[b+1]>>4],d+=Da[(15&c[b+1])<<2|c[b+2]>>6],d+=Da[63&c[b+2]];return c.length%3==2?d=d.substring(0,d.length-1)+"=":c.length%3==1&&(d=d.substring(0,d.length-2)+"=="),d}function P(a,b){var c="";if(a&&(c=Ua.call(a)),a&&("[object ArrayBuffer]"===c||a.buffer&&"[object ArrayBuffer]"===Ua.call(a.buffer))){var d,e=Ga;a instanceof ArrayBuffer?(d=a,e+=Ia):(d=a.buffer,"[object Int8Array]"===c?e+=Ka:"[object Uint8Array]"===c?e+=La:"[object Uint8ClampedArray]"===c?e+=Ma:"[object Int16Array]"===c?e+=Na:"[object Uint16Array]"===c?e+=Pa:"[object Int32Array]"===c?e+=Oa:"[object Uint32Array]"===c?e+=Qa:"[object Float32Array]"===c?e+=Ra:"[object Float64Array]"===c?e+=Sa:b(new Error("Failed to get type for BinaryArray"))),b(e+O(d))}else if("[object Blob]"===c){var f=new FileReader;f.onload=function(){var c=Ea+a.type+"~"+O(this.result);b(Ga+Ja+c)},f.readAsArrayBuffer(a)}else try{b(JSON.stringify(a))}catch(c){console.error("Couldn't convert value into a JSON string: ",a),b(null,c)}}function Q(a){if(a.substring(0,Ha)!==Ga)return JSON.parse(a);var b,c=a.substring(Ta),d=a.substring(Ha,Ta);if(d===Ja&&Fa.test(c)){var e=c.match(Fa);b=e[1],c=c.substring(e[0].length)}var f=N(c);switch(d){case Ia:return f;case Ja:return g([f],{type:b});case Ka:return new Int8Array(f);case La:return new Uint8Array(f);case Ma:return new Uint8ClampedArray(f);case Na:return new Int16Array(f);case Pa:return new Uint16Array(f);case Oa:return new Int32Array(f);case Qa:return new Uint32Array(f);case Ra:return new Float32Array(f);case Sa:return new Float64Array(f);default:throw new Error("Unkown type: "+d)}}function R(a,b,c,d){a.executeSql("CREATE TABLE IF NOT EXISTS "+b.storeName+" (id INTEGER PRIMARY KEY, key unique, value)",[],c,d)}function S(a){var b=this,c={db:null};if(a)for(var d in a)c[d]="string"!=typeof a[d]?a[d].toString():a[d];var e=new va(function(a,d){try{c.db=openDatabase(c.name,String(c.version),c.description,c.size)}catch(a){return d(a)}c.db.transaction(function(e){R(e,c,function(){b._dbInfo=c,a()},function(a,b){d(b)})},d)});return c.serializer=Va,e}function T(a,b,c,d,e,f){a.executeSql(c,d,e,function(a,g){g.code===g.SYNTAX_ERR?a.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?",[b.storeName],function(a,h){h.rows.length?f(a,g):R(a,b,function(){a.executeSql(c,d,e,f)},f)},f):f(a,g)},f)}function U(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT * FROM "+e.storeName+" WHERE key = ? LIMIT 1",[a],function(a,c){var d=c.rows.length?c.rows.item(0).value:null;d&&(d=e.serializer.deserialize(d)),b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function V(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT * FROM "+e.storeName,[],function(c,d){for(var f=d.rows,g=f.length,h=0;h<g;h++){var i=f.item(h),j=i.value;if(j&&(j=e.serializer.deserialize(j)),void 0!==(j=a(j,i.key,h+1)))return void b(j)}b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function W(a,b,c,d){var e=this;a=j(a);var f=new va(function(f,g){e.ready().then(function(){void 0===b&&(b=null);var h=b,i=e._dbInfo;i.serializer.serialize(b,function(b,j){j?g(j):i.db.transaction(function(c){T(c,i,"INSERT OR REPLACE INTO "+i.storeName+" (key, value) VALUES (?, ?)",[a,b],function(){f(h)},function(a,b){g(b)})},function(b){if(b.code===b.QUOTA_ERR){if(d>0)return void f(W.apply(e,[a,h,c,d-1]));g(b)}})})}).catch(g)});return h(f,c),f}function X(a,b,c){return W.apply(this,[a,b,c,1])}function Y(a,b){var c=this;a=j(a);var d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"DELETE FROM "+e.storeName+" WHERE key = ?",[a],function(){b()},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function Z(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"DELETE FROM "+d.storeName,[],function(){a()},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function $(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"SELECT COUNT(key) as c FROM "+d.storeName,[],function(b,c){var d=c.rows.item(0).c;a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function _(a,b){var c=this,d=new va(function(b,d){c.ready().then(function(){var e=c._dbInfo;e.db.transaction(function(c){T(c,e,"SELECT key FROM "+e.storeName+" WHERE id = ? LIMIT 1",[a+1],function(a,c){var d=c.rows.length?c.rows.item(0).key:null;b(d)},function(a,b){d(b)})})}).catch(d)});return h(d,b),d}function aa(a){var b=this,c=new va(function(a,c){b.ready().then(function(){var d=b._dbInfo;d.db.transaction(function(b){T(b,d,"SELECT key FROM "+d.storeName,[],function(b,c){for(var d=[],e=0;e<c.rows.length;e++)d.push(c.rows.item(e).key);a(d)},function(a,b){c(b)})})}).catch(c)});return h(c,a),c}function ba(a){return new va(function(b,c){a.transaction(function(d){d.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'",[],function(c,d){for(var e=[],f=0;f<d.rows.length;f++)e.push(d.rows.item(f).name);b({db:a,storeNames:e})},function(a,b){c(b)})},function(a){c(a)})})}function ca(a,b){b=k.apply(this,arguments);var c=this.config();(a="function"!=typeof a&&a||{}).name||(a.name=a.name||c.name,a.storeName=a.storeName||c.storeName);var d,e=this;return h(d=a.name?new va(function(b){var d;d=a.name===c.name?e._dbInfo.db:openDatabase(a.name,"","",0),b(a.storeName?{db:d,storeNames:[a.storeName]}:ba(d))}).then(function(a){return new va(function(b,c){a.db.transaction(function(d){function e(a){return new va(function(b,c){d.executeSql("DROP TABLE IF EXISTS "+a,[],function(){b()},function(a,b){c(b)})})}for(var f=[],g=0,h=a.storeNames.length;g<h;g++)f.push(e(a.storeNames[g]));va.all(f).then(function(){b()}).catch(function(a){c(a)})},function(a){c(a)})})}):va.reject("Invalid arguments"),b),d}function da(){try{return"undefined"!=typeof localStorage&&"setItem"in localStorage&&!!localStorage.setItem}catch(a){return!1}}function ea(a,b){var c=a.name+"/";return a.storeName!==b.storeName&&(c+=a.storeName+"/"),c}function fa(){var a="_localforage_support_test";try{return localStorage.setItem(a,!0),localStorage.removeItem(a),!1}catch(a){return!0}}function ga(){return!fa()||localStorage.length>0}function ha(a){var b=this,c={};if(a)for(var d in a)c[d]=a[d];return c.keyPrefix=ea(a,b._defaultConfig),ga()?(b._dbInfo=c,c.serializer=Va,va.resolve()):va.reject()}function ia(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo.keyPrefix,c=localStorage.length-1;c>=0;c--){var d=localStorage.key(c);0===d.indexOf(a)&&localStorage.removeItem(d)}});return h(c,a),c}function ja(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo,d=localStorage.getItem(b.keyPrefix+a);return d&&(d=b.serializer.deserialize(d)),d});return h(d,b),d}function ka(a,b){var c=this,d=c.ready().then(function(){for(var b=c._dbInfo,d=b.keyPrefix,e=d.length,f=localStorage.length,g=1,h=0;h<f;h++){var i=localStorage.key(h);if(0===i.indexOf(d)){var j=localStorage.getItem(i);if(j&&(j=b.serializer.deserialize(j)),void 0!==(j=a(j,i.substring(e),g++)))return j}}});return h(d,b),d}function la(a,b){var c=this,d=c.ready().then(function(){var b,d=c._dbInfo;try{b=localStorage.key(a)}catch(a){b=null}return b&&(b=b.substring(d.keyPrefix.length)),b});return h(d,b),d}function ma(a){var b=this,c=b.ready().then(function(){for(var a=b._dbInfo,c=localStorage.length,d=[],e=0;e<c;e++){var f=localStorage.key(e);0===f.indexOf(a.keyPrefix)&&d.push(f.substring(a.keyPrefix.length))}return d});return h(c,a),c}function na(a){var b,c=this.keys().then(function(a){return a.length});return h(c,a),c}function oa(a,b){var c=this;a=j(a);var d=c.ready().then(function(){var b=c._dbInfo;localStorage.removeItem(b.keyPrefix+a)});return h(d,b),d}function pa(a,b,c){var d=this;a=j(a);var e=d.ready().then(function(){void 0===b&&(b=null);var c=b;return new va(function(e,f){var g=d._dbInfo;g.serializer.serialize(b,function(b,d){if(d)f(d);else try{localStorage.setItem(g.keyPrefix+a,b),e(c)}catch(a){"QuotaExceededError"!==a.name&&"NS_ERROR_DOM_QUOTA_REACHED"!==a.name||f(a),f(a)}})})});return h(e,c),e}function qa(a,b){if(b=k.apply(this,arguments),!(a="function"!=typeof a&&a||{}).name){var c=this.config();a.name=a.name||c.name,a.storeName=a.storeName||c.storeName}var d,e=this;return h(d=a.name?new va(function(b){b(a.storeName?ea(a,e._defaultConfig):a.name+"/")}).then(function(a){for(var b=localStorage.length-1;b>=0;b--){var c=localStorage.key(b);0===c.indexOf(a)&&localStorage.removeItem(c)}}):va.reject("Invalid arguments"),b),d}function ra(a,b){a[b]=function(){var c=arguments;return a.ready().then(function(){return a[b].apply(a,c)})}}function sa(){for(var a=1;a<arguments.length;a++){var b=arguments[a];if(b)for(var c in b)b.hasOwnProperty(c)&&($a(b[c])?arguments[0][c]=b[c].slice():arguments[0][c]=b[c])}return arguments[0]}var ta="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},ua=e();"undefined"==typeof Promise&&a(3);var va=Promise,wa="local-forage-detect-blob-support",xa=void 0,ya={},za=Object.prototype.toString,Aa="readonly",Ba="readwrite",Ca={_driver:"asyncStorage",_initStorage:C,_support:f(),iterate:E,getItem:D,setItem:F,removeItem:G,clear:H,length:I,key:J,keys:K,dropInstance:L},Da="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",Ea="~~local_forage_type~",Fa=/^~~local_forage_type~([^~]+)~/,Ga="__lfsc__:",Ha=Ga.length,Ia="arbf",Ja="blob",Ka="si08",La="ui08",Ma="uic8",Na="si16",Oa="si32",Pa="ur16",Qa="ui32",Ra="fl32",Sa="fl64",Ta=Ha+Ia.length,Ua=Object.prototype.toString,Va={serialize:P,deserialize:Q,stringToBuffer:N,bufferToString:O},Wa={_driver:"webSQLStorage",_initStorage:S,_support:M(),iterate:V,getItem:U,setItem:X,removeItem:Y,clear:Z,length:$,key:_,keys:aa,dropInstance:ca},Xa={_driver:"localStorageWrapper",_initStorage:ha,_support:da(),iterate:ka,getItem:ja,setItem:pa,removeItem:oa,clear:ia,length:na,key:la,keys:ma,dropInstance:qa},Ya=function(a,b){return a===b||"number"==typeof a&&"number"==typeof b&&isNaN(a)&&isNaN(b)},Za=function(a,b){for(var c=a.length,d=0;d<c;){if(Ya(a[d],b))return!0;d++}return!1},$a=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},_a={},ab={},bb={INDEXEDDB:Ca,WEBSQL:Wa,LOCALSTORAGE:Xa},cb=[bb.INDEXEDDB._driver,bb.WEBSQL._driver,bb.LOCALSTORAGE._driver],db=["dropInstance"],eb=["clear","getItem","iterate","key","keys","length","removeItem","setItem"].concat(db),fb={description:"",driver:cb.slice(),name:"localforage",size:4980736,storeName:"keyvaluepairs",version:1},gb,hb=new(function(){function a(b){for(var c in d(this,a),bb)if(bb.hasOwnProperty(c)){var e=bb[c],f=e._driver;this[c]=f,_a[f]||this.defineDriver(e)}this._defaultConfig=sa({},fb),this._config=sa({},this._defaultConfig,b),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver).catch(function(){})}return a.prototype.config=function(a){if("object"===(void 0===a?"undefined":ta(a))){if(this._ready)return new Error("Can't call config() after localforage has been used.");for(var b in a){if("storeName"===b&&(a[b]=a[b].replace(/\W/g,"_")),"version"===b&&"number"!=typeof a[b])return new Error("Database version must be a number.");this._config[b]=a[b]}return!("driver"in a&&a.driver)||this.setDriver(this._config.driver)}return"string"==typeof a?this._config[a]:this._config},a.prototype.defineDriver=function(a,b,c){var d=new va(function(b,c){try{var d=a._driver,e=new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");if(!a._driver)return void c(e);for(var f=eb.concat("_initStorage"),g=0,i=f.length;g<i;g++){var j=f[g];if((!Za(db,j)||a[j])&&"function"!=typeof a[j])return void c(e)}!function(){for(var b=function(a){return function(){var b=new Error("Method "+a+" is not implemented by the current driver"),c=va.reject(b);return h(c,arguments[arguments.length-1]),c}},c=0,d=db.length;c<d;c++){var e=db[c];a[e]||(a[e]=b(e))}}();var k=function(c){_a[d]&&console.info("Redefining LocalForage driver: "+d),_a[d]=a,ab[d]=c,b()};"_support"in a?a._support&&"function"==typeof a._support?a._support().then(k,c):k(!!a._support):k(!0)}catch(a){c(a)}});return i(d,b,c),d},a.prototype.driver=function(){return this._driver||null},a.prototype.getDriver=function(a,b,c){var d=_a[a]?va.resolve(_a[a]):va.reject(new Error("Driver not found."));return i(d,b,c),d},a.prototype.getSerializer=function(a){var b=va.resolve(Va);return i(b,a),b},a.prototype.ready=function(a){var b=this,c=b._driverSet.then(function(){return null===b._ready&&(b._ready=b._initDriver()),b._ready});return i(c,a,a),c},a.prototype.setDriver=function(a,b,c){function d(){g._config.driver=g.driver()}function e(a){return g._extend(a),d(),g._ready=g._initStorage(g._config),g._ready}function f(a){return function(){function b(){for(;c<a.length;){var f=a[c];return c++,g._dbInfo=null,g._ready=null,g.getDriver(f).then(e).catch(b)}d();var h=new Error("No available storage method found.");return g._driverSet=va.reject(h),g._driverSet}var c=0;return b()}}var g=this;$a(a)||(a=[a]);var h=this._getSupportedDrivers(a),j=null!==this._driverSet?this._driverSet.catch(function(){return va.resolve()}):va.resolve();return this._driverSet=j.then(function(){var a=h[0];return g._dbInfo=null,g._ready=null,g.getDriver(a).then(function(a){g._driver=a._driver,d(),g._wrapLibraryMethodsWithReady(),g._initDriver=f(h)})}).catch(function(){d();var a=new Error("No available storage method found.");return g._driverSet=va.reject(a),g._driverSet}),i(this._driverSet,b,c),this._driverSet},a.prototype.supports=function(a){return!!ab[a]},a.prototype._extend=function(a){sa(this,a)},a.prototype._getSupportedDrivers=function(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c];this.supports(e)&&b.push(e)}return b},a.prototype._wrapLibraryMethodsWithReady=function(){for(var a=0,b=eb.length;a<b;a++)ra(this,eb[a])},a.prototype.createInstance=function(b){return new a(b)},a}());b.exports=hb},{3:3}]},{},[4])(4)});var numeric="undefined"==typeof exports?function(){}:exports;function supports_video(){return!!document.createElement("video").canPlayType}function supports_h264_baseline_video(){return!!supports_video()&&document.createElement("video").canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');var v}function supports_ogg_theora_video(){return!!supports_video()&&document.createElement("video").canPlayType('video/ogg; codecs="theora, vorbis"');var v}"undefined"!=typeof global&&(global.numeric=numeric),numeric.version="1.2.6",numeric.bench=function(t,n){var r,i,s,o;for(void 0===n&&(n=15),s=.5,r=new Date;;){for(o=s*=2;o>3;o-=4)t(),t(),t(),t();for(;o>0;)t(),o--;if((i=new Date)-r>n)break}for(o=s;o>3;o-=4)t(),t(),t(),t();for(;o>0;)t(),o--;return 1e3*(3*s-1)/((i=new Date)-r)},numeric._myIndexOf=function(t){var n=this.length,r;for(r=0;r<n;++r)if(this[r]===t)return r;return-1},numeric.myIndexOf=Array.prototype.indexOf?Array.prototype.indexOf:numeric._myIndexOf,numeric.Function=Function,numeric.precision=4,numeric.largeArray=50,numeric.prettyPrint=function(t){function n(e){if(0===e)return"0";if(isNaN(e))return"NaN";if(e<0)return"-"+n(-e);if(isFinite(e)){var t=Math.floor(Math.log(e)/Math.log(10)),r=e/Math.pow(10,t),i=r.toPrecision(numeric.precision);return 10===parseFloat(i)&&(t++,i=(r=1).toPrecision(numeric.precision)),parseFloat(i).toString()+"e"+t.toString()}return"Infinity"}function i(e){var t;if(void 0===e)return r.push(Array(numeric.precision+8).join(" ")),!1;if("string"==typeof e)return r.push('"'+e+'"'),!1;if("boolean"==typeof e)return r.push(e.toString()),!1;if("number"==typeof e){var s=n(e),o=e.toPrecision(numeric.precision),u=parseFloat(e.toString()).toString(),a=[s,o,u,parseFloat(o).toString(),parseFloat(u).toString()];for(t=1;t<a.length;t++)a[t].length<s.length&&(s=a[t]);return r.push(Array(numeric.precision+8-s.length).join(" ")+s),!1}if(null===e)return r.push("null"),!1;if("function"==typeof e){r.push(e.toString());var f=!1;for(t in e)e.hasOwnProperty(t)&&(f?r.push(",\n"):r.push("\n{"),f=!0,r.push(t),r.push(": \n"),i(e[t]));return f&&r.push("}\n"),!0}if(e instanceof Array){if(e.length>numeric.largeArray)return r.push("...Large Array..."),!0;var f=!1;for(r.push("["),t=0;t<e.length;t++)t>0&&(r.push(","),f&&r.push("\n ")),f=i(e[t]);return r.push("]"),!0}r.push("{");var f=!1;for(t in e)e.hasOwnProperty(t)&&(f&&r.push(",\n"),f=!0,r.push(t),r.push(": \n"),i(e[t]));return r.push("}"),!0}var r=[];return i(t),r.join("")},numeric.parseDate=function(t){function n(e){if("string"==typeof e)return Date.parse(e.replace(/-/g,"/"));if(e instanceof Array){var t=[],r;for(r=0;r<e.length;r++)t[r]=n(e[r]);return t}throw new Error("parseDate: parameter must be arrays of strings")}return n(t)},numeric.parseFloat=function(t){function n(e){if("string"==typeof e)return parseFloat(e);if(e instanceof Array){var t=[],r;for(r=0;r<e.length;r++)t[r]=n(e[r]);return t}throw new Error("parseFloat: parameter must be arrays of strings")}return n(t)},numeric.parseCSV=function(t){var n=t.split("\n"),r,i,s=[],o=/(([^'",]*)|('[^']*')|("[^"]*")),/g,u=/^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/,a=function(e){return e.substr(0,e.length-1)},f=0;for(i=0;i<n.length;i++){var l=(n[i]+",").match(o),c;if(l.length>0){for(s[f]=[],r=0;r<l.length;r++)c=a(l[r]),u.test(c)?s[f][r]=parseFloat(c):s[f][r]=c;f++}}return s},numeric.toCSV=function(t){var n=numeric.dim(t),r,i,s,o,u,a;for(s=n[0],o=n[1],a=[],r=0;r<s;r++){for(u=[],i=0;i<s;i++)u[i]=t[r][i].toString();a[r]=u.join(", ")}return a.join("\n")+"\n"},numeric.getURL=function(t){var n=new XMLHttpRequest;return n.open("GET",t,!1),n.send(),n},numeric.imageURL=function(t){function n(e){var t=e.length,n,r,i,s,o,u,a,f,l="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",c="";for(n=0;n<t;n+=3)u=((3&(r=e[n]))<<4)+((i=e[n+1])>>4),a=((15&i)<<2)+((s=e[n+2])>>6),f=63&s,n+1>=t?a=f=64:n+2>=t&&(f=64),c+=l.charAt(o=r>>2)+l.charAt(u)+l.charAt(a)+l.charAt(f);return c}function r(e,t,n){void 0===t&&(t=0),void 0===n&&(n=e.length);var r=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],i=-1,s=0,o=e.length,u;for(u=t;u<n;u++)i=i>>>8^r[s=255&(i^e[u])];return-1^i}var i=t[0].length,s=t[0][0].length,o,u,a,f,l,c,h,p,d,v,m,g=[137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,s>>24&255,s>>16&255,s>>8&255,255&s,i>>24&255,i>>16&255,i>>8&255,255&i,8,2,0,0,0,-1,-2,-3,-4,-5,-6,-7,-8,73,68,65,84,8,29];for(m=r(g,12,29),g[29]=m>>24&255,g[30]=m>>16&255,g[31]=m>>8&255,g[32]=255&m,o=1,u=0,p=0;p<i;p++){for(p<i-1?g.push(0):g.push(1),c=3*s+1+(0===p)&255,h=3*s+1+(0===p)>>8&255,g.push(c),g.push(h),g.push(255&~c),g.push(255&~h),0===p&&g.push(0),d=0;d<s;d++)for(f=0;f<3;f++)u=(u+(o=(o+(c=(c=t[f][p][d])>255?255:c<0?0:Math.round(c)))%65521))%65521,g.push(c);g.push(0)}return v=(u<<16)+o,g.push(v>>24&255),g.push(v>>16&255),g.push(v>>8&255),g.push(255&v),l=g.length-41,g[33]=l>>24&255,g[34]=l>>16&255,g[35]=l>>8&255,g[36]=255&l,m=r(g,37),g.push(m>>24&255),g.push(m>>16&255),g.push(m>>8&255),g.push(255&m),g.push(0),g.push(0),g.push(0),g.push(0),g.push(73),g.push(69),g.push(78),g.push(68),g.push(174),g.push(66),g.push(96),g.push(130),"data:image/png;base64,"+n(g)},numeric._dim=function(t){for(var n=[];"object"==typeof t;)n.push(t.length),t=t[0];return n},numeric.dim=function(t){var n,r;return"object"==typeof t?"object"==typeof(n=t[0])?"object"==typeof(r=n[0])?numeric._dim(t):[t.length,n.length]:[t.length]:[]},numeric.mapreduce=function(t,n){return Function("x","accum","_s","_k",'if(typeof accum === "undefined") accum = '+n+';\nif(typeof x === "number") { var xi = x; '+t+'; return accum; }\nif(typeof _s === "undefined") _s = numeric.dim(x);\nif(typeof _k === "undefined") _k = 0;\nvar _n = _s[_k];\nvar i,xi;\nif(_k < _s.length-1) {\n    for(i=_n-1;i>=0;i--) {\n        accum = arguments.callee(x[i],accum,_s,_k+1);\n    }    return accum;\n}\nfor(i=_n-1;i>=1;i-=2) { \n    xi = x[i];\n    '+t+";\n    xi = x[i-1];\n    "+t+";\n}\nif(i === 0) {\n    xi = x[i];\n    "+t+"\n}\nreturn accum;")},numeric.mapreduce2=function(t,n){return Function("x","var n = x.length;\nvar i,xi;\n"+n+";\nfor(i=n-1;i!==-1;--i) { \n    xi = x[i];\n    "+t+";\n}\nreturn accum;")},numeric.same=function same(e,t){var n,r;if(e instanceof Array&&t instanceof Array){if((r=e.length)!==t.length)return!1;for(n=0;n<r;n++)if(e[n]!==t[n]){if("object"!=typeof e[n])return!1;if(!same(e[n],t[n]))return!1}return!0}return!1},numeric.rep=function(t,n,r){void 0===r&&(r=0);var i=t[r],s=Array(i),o;if(r===t.length-1){for(o=i-2;o>=0;o-=2)s[o+1]=n,s[o]=n;return-1===o&&(s[0]=n),s}for(o=i-1;o>=0;o--)s[o]=numeric.rep(t,n,r+1);return s},numeric.dotMMsmall=function(t,n){var r,i,s,o,u,a,f,l,c,h,p,d,v,m;for(o=t.length,u=n.length,a=n[0].length,f=Array(o),r=o-1;r>=0;r--){for(l=Array(a),c=t[r],s=a-1;s>=0;s--){for(h=c[u-1]*n[u-1][s],i=u-2;i>=1;i-=2)p=i-1,h+=c[i]*n[i][s]+c[p]*n[p][s];0===i&&(h+=c[0]*n[0][s]),l[s]=h}f[r]=l}return f},numeric._getCol=function(t,n,r){var i,s;for(s=t.length-1;s>0;--s)r[s]=t[s][n],r[--s]=t[s][n];0===s&&(r[0]=t[0][n])},numeric.dotMMbig=function(t,n){var r=numeric._getCol,i=n.length,s=Array(i),o=t.length,u=n[0].length,a=new Array(o),f,l=numeric.dotVV,c,h,p,d;for(--i,c=--o;-1!==c;--c)a[c]=Array(u);for(c=--u;-1!==c;--c)for(r(n,c,s),h=o;-1!==h;--h)d=0,f=t[h],a[h][c]=l(f,s);return a},numeric.dotMV=function(t,n){var r=t.length,i=n.length,s,o=Array(r),u=numeric.dotVV;for(s=r-1;s>=0;s--)o[s]=u(t[s],n);return o},numeric.dotVM=function(t,n){var r,i,s,o,u,a,f,l,c,h,p,d,v,m,g,y,b,w,E;for(o=t.length,u=n[0].length,f=Array(u),s=u-1;s>=0;s--){for(h=t[o-1]*n[o-1][s],i=o-2;i>=1;i-=2)p=i-1,h+=t[i]*n[i][s]+t[p]*n[p][s];0===i&&(h+=t[0]*n[0][s]),f[s]=h}return f},numeric.dotVV=function(t,n){var r,i=t.length,s,o=t[i-1]*n[i-1];for(r=i-2;r>=1;r-=2)s=r-1,o+=t[r]*n[r]+t[s]*n[s];return 0===r&&(o+=t[0]*n[0]),o},numeric.dot=function(t,n){var r=numeric.dim;switch(1e3*r(t).length+r(n).length){case 2002:return n.length<10?numeric.dotMMsmall(t,n):numeric.dotMMbig(t,n);case 2001:return numeric.dotMV(t,n);case 1002:return numeric.dotVM(t,n);case 1001:return numeric.dotVV(t,n);case 1e3:return numeric.mulVS(t,n);case 1:return numeric.mulSV(t,n);case 0:return t*n;default:throw new Error("numeric.dot only works on vectors and matrices")}},numeric.diag=function(t){var n,r,i,s=t.length,o=Array(s),u;for(n=s-1;n>=0;n--){for(u=Array(s),r=n+2,i=s-1;i>=r;i-=2)u[i]=0,u[i-1]=0;for(i>n&&(u[i]=0),u[n]=t[n],i=n-1;i>=1;i-=2)u[i]=0,u[i-1]=0;0===i&&(u[0]=0),o[n]=u}return o},numeric.getDiag=function(e){var t=Math.min(e.length,e[0].length),n,r=Array(t);for(n=t-1;n>=1;--n)r[n]=e[n][n],r[--n]=e[n][n];return 0===n&&(r[0]=e[0][0]),r},numeric.identity=function(t){return numeric.diag(numeric.rep([t],1))},numeric.pointwise=function(t,n,r){void 0===r&&(r="");var i=[],s,o=/\[i\]$/,u,a="",f=!1;for(s=0;s<t.length;s++)o.test(t[s])?a=u=t[s].substring(0,t[s].length-3):u=t[s],"ret"===u&&(f=!0),i.push(u);return i[t.length]="_s",i[t.length+1]="_k",i[t.length+2]='if(typeof _s === "undefined") _s = numeric.dim('+a+');\nif(typeof _k === "undefined") _k = 0;\nvar _n = _s[_k];\nvar i'+(f?"":", ret = Array(_n)")+";\nif(_k < _s.length-1) {\n    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee("+t.join(",")+",_s,_k+1);\n    return ret;\n}\n"+r+"\nfor(i=_n-1;i!==-1;--i) {\n    "+n+"\n}\nreturn ret;",Function.apply(null,i)},numeric.pointwise2=function(t,n,r){void 0===r&&(r="");var i=[],s,o=/\[i\]$/,u,a="",f=!1;for(s=0;s<t.length;s++)o.test(t[s])?a=u=t[s].substring(0,t[s].length-3):u=t[s],"ret"===u&&(f=!0),i.push(u);return i[t.length]="var _n = "+a+".length;\nvar i"+(f?"":", ret = Array(_n)")+";\n"+r+"\nfor(i=_n-1;i!==-1;--i) {\n"+n+"\n}\nreturn ret;",Function.apply(null,i)},numeric._biforeach=function _biforeach(e,t,n,r,i){var s,o;if(r!==n.length-1)for(s=n[r]-1;s>=0;s--)_biforeach("object"==typeof e?e[s]:e,"object"==typeof t?t[s]:t,n,r+1,i);else i(e,t)},numeric._biforeach2=function _biforeach2(e,t,n,r,i){if(r===n.length-1)return i(e,t);var s,o=n[r],u=Array(o);for(s=o-1;s>=0;--s)u[s]=_biforeach2("object"==typeof e?e[s]:e,"object"==typeof t?t[s]:t,n,r+1,i);return u},numeric._foreach=function _foreach(e,t,n,r){var i,s;if(n!==t.length-1)for(i=t[n]-1;i>=0;i--)_foreach(e[i],t,n+1,r);else r(e)},numeric._foreach2=function _foreach2(e,t,n,r){if(n===t.length-1)return r(e);var i,s=t[n],o=Array(s);for(i=s-1;i>=0;i--)o[i]=_foreach2(e[i],t,n+1,r);return o},numeric.ops2={add:"+",sub:"-",mul:"*",div:"/",mod:"%",and:"&&",or:"||",eq:"===",neq:"!==",lt:"<",gt:">",leq:"<=",geq:">=",band:"&",bor:"|",bxor:"^",lshift:"<<",rshift:">>",rrshift:">>>"},numeric.opseq={addeq:"+=",subeq:"-=",muleq:"*=",diveq:"/=",modeq:"%=",lshifteq:"<<=",rshifteq:">>=",rrshifteq:">>>=",bandeq:"&=",boreq:"|=",bxoreq:"^="},numeric.mathfuns=["abs","acos","asin","atan","ceil","cos","exp","floor","log","round","sin","sqrt","tan","isNaN","isFinite"],numeric.mathfuns2=["atan2","pow","max","min"],numeric.ops1={neg:"-",not:"!",bnot:"~",clone:""},numeric.mapreducers={any:["if(xi) return true;","var accum = false;"],all:["if(!xi) return false;","var accum = true;"],sum:["accum += xi;","var accum = 0;"],prod:["accum *= xi;","var accum = 1;"],norm2Squared:["accum += xi*xi;","var accum = 0;"],norminf:["accum = max(accum,abs(xi));","var accum = 0, max = Math.max, abs = Math.abs;"],norm1:["accum += abs(xi)","var accum = 0, abs = Math.abs;"],sup:["accum = max(accum,xi);","var accum = -Infinity, max = Math.max;"],inf:["accum = min(accum,xi);","var accum = Infinity, min = Math.min;"]},function(){var e,t;for(e=0;e<numeric.mathfuns2.length;++e)t=numeric.mathfuns2[e],numeric.ops2[t]=t;for(e in numeric.ops2)if(numeric.ops2.hasOwnProperty(e)){t=numeric.ops2[e];var n,r,i="";-1!==numeric.myIndexOf.call(numeric.mathfuns2,e)?(i="var "+t+" = Math."+t+";\n",n=function(e,n,r){return e+" = "+t+"("+n+","+r+")"},r=function(e,n){return e+" = "+t+"("+e+","+n+")"}):(n=function(e,n,r){return e+" = "+n+" "+t+" "+r},r=numeric.opseq.hasOwnProperty(e+"eq")?function(e,n){return e+" "+t+"= "+n}:function(e,n){return e+" = "+e+" "+t+" "+n}),numeric[e+"VV"]=numeric.pointwise2(["x[i]","y[i]"],n("ret[i]","x[i]","y[i]"),i),numeric[e+"SV"]=numeric.pointwise2(["x","y[i]"],n("ret[i]","x","y[i]"),i),numeric[e+"VS"]=numeric.pointwise2(["x[i]","y"],n("ret[i]","x[i]","y"),i),numeric[e]=Function("var n = arguments.length, i, x = arguments[0], y;\nvar VV = numeric."+e+"VV, VS = numeric."+e+"VS, SV = numeric."+e+'SV;\nvar dim = numeric.dim;\nfor(i=1;i!==n;++i) { \n  y = arguments[i];\n  if(typeof x === "object") {\n      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n  else '+r("x","y")+"\n}\nreturn x;\n"),numeric[t]=numeric[e],numeric[e+"eqV"]=numeric.pointwise2(["ret[i]","x[i]"],r("ret[i]","x[i]"),i),numeric[e+"eqS"]=numeric.pointwise2(["ret[i]","x"],r("ret[i]","x"),i),numeric[e+"eq"]=Function("var n = arguments.length, i, x = arguments[0], y;\nvar V = numeric."+e+"eqV, S = numeric."+e+'eqS\nvar s = numeric.dim(x);\nfor(i=1;i!==n;++i) { \n  y = arguments[i];\n  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n  else numeric._biforeach(x,y,s,0,S);\n}\nreturn x;\n')}for(e=0;e<numeric.mathfuns2.length;++e)t=numeric.mathfuns2[e],delete numeric.ops2[t];for(e=0;e<numeric.mathfuns.length;++e)t=numeric.mathfuns[e],numeric.ops1[t]=t;for(e in numeric.ops1)numeric.ops1.hasOwnProperty(e)&&(i="",t=numeric.ops1[e],-1!==numeric.myIndexOf.call(numeric.mathfuns,e)&&Math.hasOwnProperty(t)&&(i="var "+t+" = Math."+t+";\n"),numeric[e+"eqV"]=numeric.pointwise2(["ret[i]"],"ret[i] = "+t+"(ret[i]);",i),numeric[e+"eq"]=Function("x",'if(typeof x !== "object") return '+t+"x\nvar i;\nvar V = numeric."+e+"eqV;\nvar s = numeric.dim(x);\nnumeric._foreach(x,s,0,V);\nreturn x;\n"),numeric[e+"V"]=numeric.pointwise2(["x[i]"],"ret[i] = "+t+"(x[i]);",i),numeric[e]=Function("x",'if(typeof x !== "object") return '+t+"(x)\nvar i;\nvar V = numeric."+e+"V;\nvar s = numeric.dim(x);\nreturn numeric._foreach2(x,s,0,V);\n"));for(e=0;e<numeric.mathfuns.length;++e)t=numeric.mathfuns[e],delete numeric.ops1[t];for(e in numeric.mapreducers)numeric.mapreducers.hasOwnProperty(e)&&(t=numeric.mapreducers[e],numeric[e+"V"]=numeric.mapreduce2(t[0],t[1]),numeric[e]=Function("x","s","k",t[1]+'if(typeof x !== "object") {    xi = x;\n'+t[0]+';\n    return accum;\n}if(typeof s === "undefined") s = numeric.dim(x);\nif(typeof k === "undefined") k = 0;\nif(k === s.length-1) return numeric.'+e+"V(x);\nvar xi;\nvar n = x.length, i;\nfor(i=n-1;i!==-1;--i) {\n   xi = arguments.callee(x[i]);\n"+t[0]+";\n}\nreturn accum;\n"))}(),numeric.truncVV=numeric.pointwise(["x[i]","y[i]"],"ret[i] = round(x[i]/y[i])*y[i];","var round = Math.round;"),numeric.truncVS=numeric.pointwise(["x[i]","y"],"ret[i] = round(x[i]/y)*y;","var round = Math.round;"),numeric.truncSV=numeric.pointwise(["x","y[i]"],"ret[i] = round(x/y[i])*y[i];","var round = Math.round;"),numeric.trunc=function(t,n){return"object"==typeof t?"object"==typeof n?numeric.truncVV(t,n):numeric.truncVS(t,n):"object"==typeof n?numeric.truncSV(t,n):Math.round(t/n)*n},numeric.inv=function(t){var n=numeric.dim(t),r=Math.abs,i=n[0],s=n[1],o=numeric.clone(t),u,a,f=numeric.identity(i),l,c,h,p,d,t;for(p=0;p<s;++p){var v=-1,m=-1;for(h=p;h!==i;++h)(d=r(o[h][p]))>m&&(v=h,m=d);for(a=o[v],o[v]=o[p],o[p]=a,c=f[v],f[v]=f[p],f[p]=c,t=a[p],d=p;d!==s;++d)a[d]/=t;for(d=s-1;-1!==d;--d)c[d]/=t;for(h=i-1;-1!==h;--h)if(h!==p){for(u=o[h],l=f[h],t=u[p],d=p+1;d!==s;++d)u[d]-=a[d]*t;for(d=s-1;d>0;--d)l[d]-=c[d]*t,l[--d]-=c[d]*t;0===d&&(l[0]-=c[0]*t)}}return f},numeric.det=function(t){var n=numeric.dim(t);if(2!==n.length||n[0]!==n[1])throw new Error("numeric: det() only works on square matrices");var r=n[0],i=1,s,o,u,a=numeric.clone(t),f,l,c,h,p,d,v;for(o=0;o<r-1;o++){for(u=o,s=o+1;s<r;s++)Math.abs(a[s][o])>Math.abs(a[u][o])&&(u=s);for(u!==o&&(h=a[u],a[u]=a[o],a[o]=h,i*=-1),f=a[o],s=o+1;s<r;s++){for(c=(l=a[s])[o]/f[o],u=o+1;u<r-1;u+=2)p=u+1,l[u]-=f[u]*c,l[p]-=f[p]*c;u!==r&&(l[u]-=f[u]*c)}if(0===f[o])return 0;i*=f[o]}return i*a[o][o]},numeric.transpose=function(t){var n,r,i=t.length,s=t[0].length,o=Array(s),u,a,f;for(r=0;r<s;r++)o[r]=Array(i);for(n=i-1;n>=1;n-=2){for(a=t[n],u=t[n-1],r=s-1;r>=1;--r)(f=o[r])[n]=a[r],f[n-1]=u[r],(f=o[--r])[n]=a[r],f[n-1]=u[r];0===r&&((f=o[0])[n]=a[0],f[n-1]=u[0])}if(0===n){for(u=t[0],r=s-1;r>=1;--r)o[r][0]=u[r],o[--r][0]=u[r];0===r&&(o[0][0]=u[0])}return o},numeric.negtranspose=function(t){var n,r,i=t.length,s=t[0].length,o=Array(s),u,a,f;for(r=0;r<s;r++)o[r]=Array(i);for(n=i-1;n>=1;n-=2){for(a=t[n],u=t[n-1],r=s-1;r>=1;--r)(f=o[r])[n]=-a[r],f[n-1]=-u[r],(f=o[--r])[n]=-a[r],f[n-1]=-u[r];0===r&&((f=o[0])[n]=-a[0],f[n-1]=-u[0])}if(0===n){for(u=t[0],r=s-1;r>=1;--r)o[r][0]=-u[r],o[--r][0]=-u[r];0===r&&(o[0][0]=-u[0])}return o},numeric._random=function _random(e,t){var n,r=e[t],i=Array(r),s;if(t===e.length-1){for(s=Math.random,n=r-1;n>=1;n-=2)i[n]=s(),i[n-1]=s();return 0===n&&(i[0]=s()),i}for(n=r-1;n>=0;n--)i[n]=_random(e,t+1);return i},numeric.random=function(t){return numeric._random(t,0)},numeric.norm2=function(t){return Math.sqrt(numeric.norm2Squared(t))},numeric.linspace=function(t,n,r){if(void 0===r&&(r=Math.max(Math.round(n-t)+1,1)),r<2)return 1===r?[t]:[];var i,s=Array(r);for(i=--r;i>=0;i--)s[i]=(i*n+(r-i)*t)/r;return s},numeric.getBlock=function(t,n,r){function s(e,t){var o,u=n[t],a=r[t]-u,f=Array(a);if(t===i.length-1){for(o=a;o>=0;o--)f[o]=e[o+u];return f}for(o=a;o>=0;o--)f[o]=s(e[o+u],t+1);return f}var i=numeric.dim(t);return s(t,0)},numeric.setBlock=function(t,n,r,i){function o(e,t,i){var u,a=n[i],f=r[i]-a;if(i===s.length-1)for(u=f;u>=0;u--)e[u+a]=t[u];for(u=f;u>=0;u--)o(e[u+a],t[u],i+1)}var s=numeric.dim(t);return o(t,i,0),t},numeric.getRange=function(t,n,r){var i=n.length,s=r.length,o,u,a=Array(i),f,l;for(o=i-1;-1!==o;--o)for(a[o]=Array(s),f=a[o],l=t[n[o]],u=s-1;-1!==u;--u)f[u]=l[r[u]];return a},numeric.blockMatrix=function(t){var n=numeric.dim(t);if(n.length<4)return numeric.blockMatrix([t]);var r=n[0],i=n[1],s,o,u,a,f;for(s=0,o=0,u=0;u<r;++u)s+=t[u][0].length;for(a=0;a<i;++a)o+=t[0][a][0].length;var l=Array(s);for(u=0;u<s;++u)l[u]=Array(o);var c=0,h,p,d,v,m;for(u=0;u<r;++u){for(h=o,a=i-1;-1!==a;--a)for(h-=(f=t[u][a])[0].length,d=f.length-1;-1!==d;--d)for(m=f[d],p=l[c+d],v=m.length-1;-1!==v;--v)p[h+v]=m[v];c+=t[u][0].length}return l},numeric.tensor=function(t,n){if("number"==typeof t||"number"==typeof n)return numeric.mul(t,n);var r=numeric.dim(t),i=numeric.dim(n);if(1!==r.length||1!==i.length)throw new Error("numeric: tensor product is only defined for vectors");var s=r[0],o=i[0],u=Array(s),a,f,l,c;for(f=s-1;f>=0;f--){for(a=Array(o),c=t[f],l=o-1;l>=3;--l)a[l]=c*n[l],a[--l]=c*n[l],a[--l]=c*n[l],a[--l]=c*n[l];for(;l>=0;)a[l]=c*n[l],--l;u[f]=a}return u},numeric.T=function(t,n){this.x=t,this.y=n},numeric.t=function(t,n){return new numeric.T(t,n)},numeric.Tbinop=function(t,n,r,i,s){var o=numeric.indexOf,u;if("string"!=typeof s)for(u in s="",numeric)numeric.hasOwnProperty(u)&&(t.indexOf(u)>=0||n.indexOf(u)>=0||r.indexOf(u)>=0||i.indexOf(u)>=0)&&u.length>1&&(s+="var "+u+" = numeric."+u+";\n");return Function(["y"],"var x = this;\nif(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n"+s+"\nif(x.y) {  if(y.y) {    return new numeric.T("+i+");\n  }\n  return new numeric.T("+r+");\n}\nif(y.y) {\n  return new numeric.T("+n+");\n}\nreturn new numeric.T("+t+");\n")},numeric.T.prototype.add=numeric.Tbinop("add(x.x,y.x)","add(x.x,y.x),y.y","add(x.x,y.x),x.y","add(x.x,y.x),add(x.y,y.y)"),numeric.T.prototype.sub=numeric.Tbinop("sub(x.x,y.x)","sub(x.x,y.x),neg(y.y)","sub(x.x,y.x),x.y","sub(x.x,y.x),sub(x.y,y.y)"),numeric.T.prototype.mul=numeric.Tbinop("mul(x.x,y.x)","mul(x.x,y.x),mul(x.x,y.y)","mul(x.x,y.x),mul(x.y,y.x)","sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))"),numeric.T.prototype.reciprocal=function(){var t=numeric.mul,n=numeric.div;if(this.y){var r=numeric.add(t(this.x,this.x),t(this.y,this.y));return new numeric.T(n(this.x,r),n(numeric.neg(this.y),r))}return new T(n(1,this.x))},numeric.T.prototype.div=function div(e){if(e instanceof numeric.T||(e=new numeric.T(e)),e.y)return this.mul(e.reciprocal());var div=numeric.div;return this.y?new numeric.T(div(this.x,e.x),div(this.y,e.x)):new numeric.T(div(this.x,e.x))},numeric.T.prototype.dot=numeric.Tbinop("dot(x.x,y.x)","dot(x.x,y.x),dot(x.x,y.y)","dot(x.x,y.x),dot(x.y,y.x)","sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))"),numeric.T.prototype.transpose=function(){var t=numeric.transpose,n=this.x,r=this.y;return r?new numeric.T(t(n),t(r)):new numeric.T(t(n))},numeric.T.prototype.transjugate=function(){var t=numeric.transpose,n=this.x,r=this.y;return r?new numeric.T(t(n),numeric.negtranspose(r)):new numeric.T(t(n))},numeric.Tunop=function(t,n,r){return"string"!=typeof r&&(r=""),Function("var x = this;\n"+r+"\nif(x.y) {  "+n+";\n}\n"+t+";\n")},numeric.T.prototype.exp=numeric.Tunop("return new numeric.T(ex)","return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))","var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;"),numeric.T.prototype.conj=numeric.Tunop("return new numeric.T(x.x);","return new numeric.T(x.x,numeric.neg(x.y));"),numeric.T.prototype.neg=numeric.Tunop("return new numeric.T(neg(x.x));","return new numeric.T(neg(x.x),neg(x.y));","var neg = numeric.neg;"),numeric.T.prototype.sin=numeric.Tunop("return new numeric.T(numeric.sin(x.x))","return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));"),numeric.T.prototype.cos=numeric.Tunop("return new numeric.T(numeric.cos(x.x))","return x.exp().add(x.neg().exp()).div(2);"),numeric.T.prototype.abs=numeric.Tunop("return new numeric.T(numeric.abs(x.x));","return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));","var mul = numeric.mul;"),numeric.T.prototype.log=numeric.Tunop("return new numeric.T(numeric.log(x.x));","var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\nreturn new numeric.T(numeric.log(r.x),theta.x);"),numeric.T.prototype.norm2=numeric.Tunop("return numeric.norm2(x.x);","var f = numeric.norm2Squared;\nreturn Math.sqrt(f(x.x)+f(x.y));"),numeric.T.prototype.inv=function(){var t=this;if(void 0===t.y)return new numeric.T(numeric.inv(t.x));var n=t.x.length,r,i,s,o=numeric.identity(n),u=numeric.rep([n,n],0),a=numeric.clone(t.x),f=numeric.clone(t.y),l,c,h,p,d,v,m,g,r,i,s,y,b,w,E,S,x,T;for(r=0;r<n;r++){for(y=(w=a[r][r])*w+(E=f[r][r])*E,s=r,i=r+1;i<n;i++)(b=(w=a[i][r])*w+(E=f[i][r])*E)>y&&(s=i,y=b);for(s!==r&&(T=a[r],a[r]=a[s],a[s]=T,T=f[r],f[r]=f[s],f[s]=T,T=o[r],o[r]=o[s],o[s]=T,T=u[r],u[r]=u[s],u[s]=T),l=a[r],c=f[r],d=o[r],v=u[r],w=l[r],E=c[r],i=r+1;i<n;i++)S=l[i],x=c[i],l[i]=(S*w+x*E)/y,c[i]=(x*w-S*E)/y;for(i=0;i<n;i++)S=d[i],x=v[i],d[i]=(S*w+x*E)/y,v[i]=(x*w-S*E)/y;for(i=r+1;i<n;i++){for(h=a[i],p=f[i],m=o[i],g=u[i],w=h[r],E=p[r],s=r+1;s<n;s++)S=l[s],x=c[s],h[s]-=S*w-x*E,p[s]-=x*w+S*E;for(s=0;s<n;s++)S=d[s],x=v[s],m[s]-=S*w-x*E,g[s]-=x*w+S*E}}for(r=n-1;r>0;r--)for(d=o[r],v=u[r],i=r-1;i>=0;i--)for(m=o[i],g=u[i],w=a[i][r],E=f[i][r],s=n-1;s>=0;s--)S=d[s],x=v[s],m[s]-=w*S-E*x,g[s]-=w*x+E*S;return new numeric.T(o,u)},numeric.T.prototype.get=function(t){var n=this.x,r=this.y,i=0,s,o=t.length;if(r){for(;i<o;)n=n[s=t[i]],r=r[s],i++;return new numeric.T(n,r)}for(;i<o;)n=n[s=t[i]],i++;return new numeric.T(n)},numeric.T.prototype.set=function(t,n){var r=this.x,i=this.y,s=0,o,u=t.length,a=n.x,f=n.y;if(0===u)return f?this.y=f:i&&(this.y=void 0),this.x=r,this;if(f){for(i||(i=numeric.rep(numeric.dim(r),0),this.y=i);s<u-1;)r=r[o=t[s]],i=i[o],s++;return r[o=t[s]]=a,i[o]=f,this}if(i){for(;s<u-1;)r=r[o=t[s]],i=i[o],s++;return r[o=t[s]]=a,a instanceof Array?i[o]=numeric.rep(numeric.dim(a),0):i[o]=0,this}for(;s<u-1;)r=r[o=t[s]],s++;return r[o=t[s]]=a,this},numeric.T.prototype.getRows=function(t,n){var r=n-t+1,i,s=Array(r),o,u=this.x,a=this.y;for(i=t;i<=n;i++)s[i-t]=u[i];if(a){for(o=Array(r),i=t;i<=n;i++)o[i-t]=a[i];return new numeric.T(s,o)}return new numeric.T(s)},numeric.T.prototype.setRows=function(t,n,r){var i,s=this.x,o=this.y,u=r.x,a=r.y;for(i=t;i<=n;i++)s[i]=u[i-t];if(a)for(o||(o=numeric.rep(numeric.dim(s),0),this.y=o),i=t;i<=n;i++)o[i]=a[i-t];else if(o)for(i=t;i<=n;i++)o[i]=numeric.rep([u[i-t].length],0);return this},numeric.T.prototype.getRow=function(t){var n=this.x,r=this.y;return r?new numeric.T(n[t],r[t]):new numeric.T(n[t])},numeric.T.prototype.setRow=function(t,n){var r=this.x,i=this.y,s=n.x,o=n.y;return r[t]=s,o?(i||(i=numeric.rep(numeric.dim(r),0),this.y=i),i[t]=o):i&&(i=numeric.rep([s.length],0)),this},numeric.T.prototype.getBlock=function(t,n){var r=this.x,i=this.y,s=numeric.getBlock;return i?new numeric.T(s(r,t,n),s(i,t,n)):new numeric.T(s(r,t,n))},numeric.T.prototype.setBlock=function(t,n,r){r instanceof numeric.T||(r=new numeric.T(r));var i=this.x,s=this.y,o=numeric.setBlock,u=r.x,a=r.y;if(a)return s||(this.y=numeric.rep(numeric.dim(this),0),s=this.y),o(i,t,n,u),o(s,t,n,a),this;o(i,t,n,u),s&&o(s,t,n,numeric.rep(numeric.dim(u),0))},numeric.T.rep=function(t,n){var r=numeric.T;n instanceof r||(n=new r(n));var i=n.x,s=n.y,o=numeric.rep;return s?new r(o(t,i),o(t,s)):new r(o(t,i))},numeric.T.diag=function diag(e){e instanceof numeric.T||(e=new numeric.T(e));var t=e.x,n=e.y,diag=numeric.diag;return n?new numeric.T(diag(t),diag(n)):new numeric.T(diag(t))},numeric.T.eig=function(){if(this.y)throw new Error("eig: not implemented for complex matrices.");return numeric.eig(this.x)},numeric.T.identity=function(t){return new numeric.T(numeric.identity(t))},numeric.T.prototype.getDiag=function(){var t=numeric,n=this.x,r=this.y;return r?new t.T(t.getDiag(n),t.getDiag(r)):new t.T(t.getDiag(n))},numeric.house=function(t){var n=numeric.clone(t),r,i=(t[0]>=0?1:-1)*numeric.norm2(t);n[0]+=i;var s=numeric.norm2(n);if(0===s)throw new Error("eig: internal error");return numeric.div(n,s)},numeric.toUpperHessenberg=function(t){var n=numeric.dim(t);if(2!==n.length||n[0]!==n[1])throw new Error("numeric: toUpperHessenberg() only works on square matrices");var r=n[0],i,s,o,u,a,f=numeric.clone(t),l,c,h,p,d=numeric.identity(r),v;for(s=0;s<r-2;s++){for(u=Array(r-s-1),i=s+1;i<r;i++)u[i-s-1]=f[i][s];if(numeric.norm2(u)>0){for(a=numeric.house(u),l=numeric.getBlock(f,[s+1,s],[r-1,r-1]),c=numeric.tensor(a,numeric.dot(a,l)),i=s+1;i<r;i++)for(h=f[i],p=c[i-s-1],o=s;o<r;o++)h[o]-=2*p[o-s];for(l=numeric.getBlock(f,[0,s+1],[r-1,r-1]),c=numeric.tensor(numeric.dot(l,a),a),i=0;i<r;i++)for(h=f[i],p=c[i],o=s+1;o<r;o++)h[o]-=2*p[o-s-1];for(l=Array(r-s-1),i=s+1;i<r;i++)l[i-s-1]=d[i];for(c=numeric.tensor(a,numeric.dot(a,l)),i=s+1;i<r;i++)for(v=d[i],p=c[i-s-1],o=0;o<r;o++)v[o]-=2*p[o]}}return{H:f,Q:d}},numeric.epsilon=2.220446049250313e-16,numeric.QRFrancis=function(e,t){void 0===t&&(t=1e4),e=numeric.clone(e);var n=numeric.clone(e),r,i=numeric.dim(e)[0],s,o,u,a,f,l,c,h,p,d=numeric.identity(i),v,m,g,y,b,w,E,S,x;if(i<3)return{Q:d,B:[[0,i-1]]};var T=numeric.epsilon;for(x=0;x<t;x++){for(E=0;E<i-1;E++)if(Math.abs(e[E+1][E])<T*(Math.abs(e[E][E])+Math.abs(e[E+1][E+1]))){var N=numeric.QRFrancis(numeric.getBlock(e,[0,0],[E,E]),t),C=numeric.QRFrancis(numeric.getBlock(e,[E+1,E+1],[i-1,i-1]),t);for(g=Array(E+1),w=0;w<=E;w++)g[w]=d[w];for(y=numeric.dot(N.Q,g),w=0;w<=E;w++)d[w]=y[w];for(g=Array(i-E-1),w=E+1;w<i;w++)g[w-E-1]=d[w];for(y=numeric.dot(C.Q,g),w=E+1;w<i;w++)d[w]=y[w-E-1];return{Q:d,B:N.B.concat(numeric.add(C.B,E+1))}}var k,L,A;if(u=e[i-2][i-2],a=e[i-2][i-1],f=e[i-1][i-2],h=u+(l=e[i-1][i-1]),c=u*l-a*f,p=numeric.getBlock(e,[0,0],[2,2]),h*h>=4*c)k=.5*(h+Math.sqrt(h*h-4*c)),L=.5*(h-Math.sqrt(h*h-4*c)),p=numeric.add(numeric.sub(numeric.dot(p,p),numeric.mul(p,k+L)),numeric.diag(numeric.rep([3],k*L)));else p=numeric.add(numeric.sub(numeric.dot(p,p),numeric.mul(p,h)),numeric.diag(numeric.rep([3],c)));for(s=[p[0][0],p[1][0],p[2][0]],o=numeric.house(s),g=[e[0],e[1],e[2]],y=numeric.tensor(o,numeric.dot(o,g)),w=0;w<3;w++)for(m=e[w],b=y[w],S=0;S<i;S++)m[S]-=2*b[S];for(g=numeric.getBlock(e,[0,0],[i-1,2]),y=numeric.tensor(numeric.dot(g,o),o),w=0;w<i;w++)for(m=e[w],b=y[w],S=0;S<3;S++)m[S]-=2*b[S];for(g=[d[0],d[1],d[2]],y=numeric.tensor(o,numeric.dot(o,g)),w=0;w<3;w++)for(v=d[w],b=y[w],S=0;S<i;S++)v[S]-=2*b[S];for(E=0;E<i-2;E++){for(S=E;S<=E+1;S++)if(Math.abs(e[S+1][S])<T*(Math.abs(e[S][S])+Math.abs(e[S+1][S+1]))){var N=numeric.QRFrancis(numeric.getBlock(e,[0,0],[S,S]),t),C=numeric.QRFrancis(numeric.getBlock(e,[S+1,S+1],[i-1,i-1]),t);for(g=Array(S+1),w=0;w<=S;w++)g[w]=d[w];for(y=numeric.dot(N.Q,g),w=0;w<=S;w++)d[w]=y[w];for(g=Array(i-S-1),w=S+1;w<i;w++)g[w-S-1]=d[w];for(y=numeric.dot(C.Q,g),w=S+1;w<i;w++)d[w]=y[w-S-1];return{Q:d,B:N.B.concat(numeric.add(C.B,S+1))}}for(A=Math.min(i-1,E+3),s=Array(A-E),w=E+1;w<=A;w++)s[w-E-1]=e[w][E];for(o=numeric.house(s),g=numeric.getBlock(e,[E+1,E],[A,i-1]),y=numeric.tensor(o,numeric.dot(o,g)),w=E+1;w<=A;w++)for(m=e[w],b=y[w-E-1],S=E;S<i;S++)m[S]-=2*b[S-E];for(g=numeric.getBlock(e,[0,E+1],[i-1,A]),y=numeric.tensor(numeric.dot(g,o),o),w=0;w<i;w++)for(m=e[w],b=y[w],S=E+1;S<=A;S++)m[S]-=2*b[S-E-1];for(g=Array(A-E),w=E+1;w<=A;w++)g[w-E-1]=d[w];for(y=numeric.tensor(o,numeric.dot(o,g)),w=E+1;w<=A;w++)for(v=d[w],b=y[w-E-1],S=0;S<i;S++)v[S]-=2*b[S]}}throw new Error("numeric: eigenvalue iteration does not converge -- increase maxiter?")},numeric.eig=function(t,n){var r=numeric.toUpperHessenberg(t),i=numeric.QRFrancis(r.H,n),s=numeric.T,o=t.length,u,a,f=!1,l=i.B,c=numeric.dot(i.Q,numeric.dot(r.H,numeric.transpose(i.Q))),h=new s(numeric.dot(i.Q,r.Q)),p,d=l.length,v,m,g,y,b,w,E,S,x,T,N,C,k,L,A=Math.sqrt;for(a=0;a<d;a++)if((u=l[a][0])!==l[a][1]){if(v=u+1,m=c[u][u],g=c[u][v],y=c[v][u],b=c[v][v],0===g&&0===y)continue;(S=(w=-m-b)*w-4*(E=m*b-g*y))>=0?((k=(m-(x=w<0?-.5*(w-A(S)):-.5*(w+A(S))))*(m-x)+g*g)>(L=y*y+(b-x)*(b-x))?(N=(m-x)/(k=A(k)),C=g/k):(N=y/(L=A(L)),C=(b-x)/L),p=new s([[C,-N],[N,C]]),h.setRows(u,v,p.dot(h.getRows(u,v)))):(x=-.5*w,T=.5*A(-S),(k=(m-x)*(m-x)+g*g)>(L=y*y+(b-x)*(b-x))?(N=(m-x)/(k=A(k+T*T)),C=g/k,x=0,T/=k):(N=y/(L=A(L+T*T)),C=(b-x)/L,x=T/L,T=0),p=new s([[C,-N],[N,C]],[[x,T],[T,-x]]),h.setRows(u,v,p.dot(h.getRows(u,v))))}var O=h.dot(t).dot(h.transjugate()),o=t.length,M=numeric.T.identity(o);for(v=0;v<o;v++)if(v>0)for(a=v-1;a>=0;a--){var _=O.get([a,a]),D=O.get([v,v]);numeric.neq(_.x,D.x)||numeric.neq(_.y,D.y)?(x=O.getRow(a).getBlock([a],[v-1]),T=M.getRow(v).getBlock([a],[v-1]),M.set([v,a],O.get([a,v]).neg().sub(x.dot(T)).div(_.sub(D)))):M.setRow(v,M.getRow(a))}for(v=0;v<o;v++)x=M.getRow(v),M.setRow(v,x.div(x.norm2()));return M=M.transpose(),M=h.transjugate().dot(M),{lambda:O.getDiag(),E:M}},numeric.ccsSparse=function(t){var n=t.length,r,i,s,o,u=[];for(s=n-1;-1!==s;--s)for(o in i=t[s]){for(o=parseInt(o);o>=u.length;)u[u.length]=0;0!==i[o]&&u[o]++}var r=u.length,a=Array(r+1);for(a[0]=0,s=0;s<r;++s)a[s+1]=a[s]+u[s];var f=Array(a[r]),l=Array(a[r]);for(s=n-1;-1!==s;--s)for(o in i=t[s])0!==i[o]&&(u[o]--,f[a[o]+u[o]]=s,l[a[o]+u[o]]=i[o]);return[a,f,l]},numeric.ccsFull=function(t){var n=t[0],r=t[1],i=t[2],s=numeric.ccsDim(t),o=s[0],u=s[1],a,f,l,c,h,p=numeric.rep([o,u],0);for(a=0;a<u;a++)for(l=n[a],c=n[a+1],f=l;f<c;++f)p[r[f]][a]=i[f];return p},numeric.ccsTSolve=function(t,n,r,i,s){function h(e){var t;if(0===r[e]){for(r[e]=1,t=o[e];t<o[e+1];++t)h(u[t]);s[c]=e,++c}}var o=t[0],u=t[1],a=t[2],f=o.length-1,l=Math.max,c=0,p,d,v,m,g,y,b,w,E;for(void 0===i&&(r=numeric.rep([f],0)),void 0===i&&(i=numeric.linspace(0,r.length-1)),void 0===s&&(s=[]),p=i.length-1;-1!==p;--p)h(i[p]);for(s.length=c,p=s.length-1;-1!==p;--p)r[s[p]]=0;for(p=i.length-1;-1!==p;--p)d=i[p],r[d]=n[d];for(p=s.length-1;-1!==p;--p){for(d=s[p],v=o[d],m=l(o[d+1],v),g=v;g!==m;++g)if(u[g]===d){r[d]/=a[g];break}for(E=r[d],g=v;g!==m;++g)(y=u[g])!==d&&(r[y]-=E*a[g])}return r},numeric.ccsDFS=function(t){this.k=Array(t),this.k1=Array(t),this.j=Array(t)},numeric.ccsDFS.prototype.dfs=function(t,n,r,i,s,o){var u=0,a,f=s.length,l=this.k,c=this.k1,h=this.j,p,d;if(0===i[t])for(i[t]=1,h[0]=t,l[0]=p=n[t],c[0]=d=n[t+1];;)if(p>=d){if(s[f]=h[u],0===u)return;++f,p=l[--u],d=c[u]}else 0===i[a=o[r[p]]]?(i[a]=1,l[u]=p,h[++u]=a,p=n[a],c[u]=d=n[a+1]):++p},numeric.ccsLPSolve=function(t,n,r,i,s,o,u){var a=t[0],f=t[1],l=t[2],c=a.length-1,h=0,p=n[0],d=n[1],v=n[2],m,g,y,b,w,E,S,x,T,N,C,k;for(g=p[s],y=p[s+1],i.length=0,m=g;m<y;++m)u.dfs(o[d[m]],a,f,r,i,o);for(m=i.length-1;-1!==m;--m)r[i[m]]=0;for(m=g;m!==y;++m)r[b=o[d[m]]]=v[m];for(m=i.length-1;-1!==m;--m){for(E=a[b=i[m]],S=a[b+1],x=E;x<S;++x)if(o[f[x]]===b){r[b]/=l[x];break}for(k=r[b],x=E;x<S;++x)(T=o[f[x]])!==b&&(r[T]-=k*l[x])}return r},numeric.ccsLUP1=function(t,n){var r=t[0].length-1,i=[numeric.rep([r+1],0),[],[]],s=[numeric.rep([r+1],0),[],[]],o=i[0],u=i[1],a=i[2],f=s[0],l=s[1],c=s[2],h=numeric.rep([r],0),p=numeric.rep([r],0),d,v,m,g,y,b,w,E,S,x,T=numeric.ccsLPSolve,N=Math.max,C=Math.abs,k=numeric.linspace(0,r-1),L=numeric.linspace(0,r-1),A=new numeric.ccsDFS(r);for(void 0===n&&(n=1),d=0;d<r;++d){for(T(i,t,h,p,d,L,A),b=-1,w=-1,v=p.length-1;-1!==v;--v)(m=p[v])<=d||(E=C(h[m]))>b&&(w=m,b=E);for(C(h[d])<n*b&&(v=k[d],b=k[w],k[d]=b,L[b]=d,k[w]=v,L[v]=w,b=h[d],h[d]=h[w],h[w]=b),b=o[d],w=f[d],S=h[d],u[b]=k[d],a[b]=1,++b,v=p.length-1;-1!==v;--v)E=h[m=p[v]],p[v]=0,h[m]=0,m<=d?(l[w]=m,c[w]=E,++w):(u[b]=k[m],a[b]=E/S,++b);o[d+1]=b,f[d+1]=w}for(v=u.length-1;-1!==v;--v)u[v]=L[u[v]];return{L:i,U:s,P:k,Pinv:L}},numeric.ccsDFS0=function(t){this.k=Array(t),this.k1=Array(t),this.j=Array(t)},numeric.ccsDFS0.prototype.dfs=function(t,n,r,i,s,o,u){var a=0,f,l=s.length,c=this.k,h=this.k1,p=this.j,d,v;if(0===i[t])for(i[t]=1,p[0]=t,c[0]=d=n[o[t]],h[0]=v=n[o[t]+1];;){if(isNaN(d))throw new Error("Ow!");if(d>=v){if(s[l]=o[p[a]],0===a)return;++l,d=c[--a],v=h[a]}else 0===i[f=r[d]]?(i[f]=1,c[a]=d,p[++a]=f,d=n[f=o[f]],h[a]=v=n[f+1]):++d}},numeric.ccsLPSolve0=function(t,n,r,i,s,o,u,a){var f=t[0],l=t[1],c=t[2],h=f.length-1,p=0,d=n[0],v=n[1],m=n[2],g,y,b,w,E,S,x,T,N,C,k,L;for(y=d[s],b=d[s+1],i.length=0,g=y;g<b;++g)a.dfs(v[g],f,l,r,i,o,u);for(g=i.length-1;-1!==g;--g)r[u[w=i[g]]]=0;for(g=y;g!==b;++g)r[w=v[g]]=m[g];for(g=i.length-1;-1!==g;--g){for(N=u[w=i[g]],S=f[w],x=f[w+1],T=S;T<x;++T)if(l[T]===N){r[N]/=c[T];break}for(L=r[N],T=S;T<x;++T)r[l[T]]-=L*c[T];r[N]=L}},numeric.ccsLUP0=function(t,n){var r=t[0].length-1,i=[numeric.rep([r+1],0),[],[]],s=[numeric.rep([r+1],0),[],[]],o=i[0],u=i[1],a=i[2],f=s[0],l=s[1],c=s[2],h=numeric.rep([r],0),p=numeric.rep([r],0),d,v,m,g,y,b,w,E,S,x,T=numeric.ccsLPSolve0,N=Math.max,C=Math.abs,k=numeric.linspace(0,r-1),L=numeric.linspace(0,r-1),A=new numeric.ccsDFS0(r);for(void 0===n&&(n=1),d=0;d<r;++d){for(T(i,t,h,p,d,L,k,A),b=-1,w=-1,v=p.length-1;-1!==v;--v)(m=p[v])<=d||(E=C(h[k[m]]))>b&&(w=m,b=E);for(C(h[k[d]])<n*b&&(v=k[d],b=k[w],k[d]=b,L[b]=d,k[w]=v,L[v]=w),b=o[d],w=f[d],S=h[k[d]],u[b]=k[d],a[b]=1,++b,v=p.length-1;-1!==v;--v)E=h[k[m=p[v]]],p[v]=0,h[k[m]]=0,m<=d?(l[w]=m,c[w]=E,++w):(u[b]=k[m],a[b]=E/S,++b);o[d+1]=b,f[d+1]=w}for(v=u.length-1;-1!==v;--v)u[v]=L[u[v]];return{L:i,U:s,P:k,Pinv:L}},numeric.ccsLUP=numeric.ccsLUP0,numeric.ccsDim=function(t){return[numeric.sup(t[1])+1,t[0].length-1]},numeric.ccsGetBlock=function(t,n,r){var i=numeric.ccsDim(t),s=i[0],o=i[1];void 0===n?n=numeric.linspace(0,s-1):"number"==typeof n&&(n=[n]),void 0===r?r=numeric.linspace(0,o-1):"number"==typeof r&&(r=[r]);var u,a,f,l=n.length,c,h=r.length,p,d,v,m=numeric.rep([o],0),g=[],y=[],b=[m,g,y],w=t[0],E=t[1],S=t[2],x=numeric.rep([s],0),T=0,N=numeric.rep([s],0);for(c=0;c<h;++c){var C=w[d=r[c]],k=w[d+1];for(u=C;u<k;++u)N[p=E[u]]=1,x[p]=S[u];for(u=0;u<l;++u)N[v=n[u]]&&(g[T]=u,y[T]=x[n[u]],++T);for(u=C;u<k;++u)N[p=E[u]]=0;m[c+1]=T}return b},numeric.ccsDot=function(t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=numeric.ccsDim(t),l=numeric.ccsDim(n),c=f[0],h=f[1],p=l[1],d=numeric.rep([c],0),v=numeric.rep([c],0),m=Array(c),g=numeric.rep([p],0),y=[],b=[],w=[g,y,b],E,S,x,T,N,C,k,L,A,O,M;for(x=0;x!==p;++x){for(T=o[x],N=o[x+1],A=0,S=T;S<N;++S)for(O=u[S],M=a[S],C=r[O],k=r[O+1],E=C;E<k;++E)0===v[L=i[E]]&&(m[A]=L,v[L]=1,A+=1),d[L]=d[L]+s[E]*M;for(N=(T=g[x])+A,g[x+1]=N,S=A-1;-1!==S;--S)M=T+S,E=m[S],y[M]=E,b[M]=d[E],v[E]=0,d[E]=0;g[x+1]=g[x]+A}return w},numeric.ccsLUPSolve=function(t,n){var r=t.L,i=t.U,s=t.P,o=n[0],u=!1;"object"!=typeof o&&(o=(n=[[0,n.length],numeric.linspace(0,n.length-1),n])[0],u=!0);var a=n[1],f=n[2],l=r[0].length-1,c=o.length-1,h=numeric.rep([l],0),p=Array(l),d=numeric.rep([l],0),v=Array(l),m=numeric.rep([c+1],0),g=[],y=[],b=numeric.ccsTSolve,w,E,S,x,T,N,C=0;for(w=0;w<c;++w){for(T=0,S=o[w],x=o[w+1],E=S;E<x;++E)N=t.Pinv[a[E]],v[T]=N,d[N]=f[E],++T;for(v.length=T,b(r,d,h,v,p),E=v.length-1;-1!==E;--E)d[v[E]]=0;if(b(i,h,d,p,v),u)return d;for(E=p.length-1;-1!==E;--E)h[p[E]]=0;for(E=v.length-1;-1!==E;--E)N=v[E],g[C]=N,y[C]=d[N],d[N]=0,++C;m[w+1]=C}return[m,g,y]},numeric.ccsbinop=function(t,n){return void 0===n&&(n=""),Function("X","Y","var Xi = X[0], Xj = X[1], Xv = X[2];\nvar Yi = Y[0], Yj = Y[1], Yv = Y[2];\nvar n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\nvar Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\nvar x = numeric.rep([m],0),y = numeric.rep([m],0);\nvar xk,yk,zk;\nvar i,j,j0,j1,k,p=0;\n"+n+"for(i=0;i<n;++i) {\n  j0 = Xi[i]; j1 = Xi[i+1];\n  for(j=j0;j!==j1;++j) {\n    k = Xj[j];\n    x[k] = 1;\n    Zj[p] = k;\n    ++p;\n  }\n  j0 = Yi[i]; j1 = Yi[i+1];\n  for(j=j0;j!==j1;++j) {\n    k = Yj[j];\n    y[k] = Yv[j];\n    if(x[k] === 0) {\n      Zj[p] = k;\n      ++p;\n    }\n  }\n  Zi[i+1] = p;\n  j0 = Xi[i]; j1 = Xi[i+1];\n  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n  j0 = Zi[i]; j1 = Zi[i+1];\n  for(j=j0;j!==j1;++j) {\n    k = Zj[j];\n    xk = x[k];\n    yk = y[k];\n"+t+"\n    Zv[j] = zk;\n  }\n  j0 = Xi[i]; j1 = Xi[i+1];\n  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n  j0 = Yi[i]; j1 = Yi[i+1];\n  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n}\nreturn [Zi,Zj,Zv];")},function(){var k,A,B,C;for(k in numeric.ops2)A=isFinite(eval("1"+numeric.ops2[k]+"0"))?"[Y[0],Y[1],numeric."+k+"(X,Y[2])]":"NaN",B=isFinite(eval("0"+numeric.ops2[k]+"1"))?"[X[0],X[1],numeric."+k+"(X[2],Y)]":"NaN",C=isFinite(eval("1"+numeric.ops2[k]+"0"))&&isFinite(eval("0"+numeric.ops2[k]+"1"))?"numeric.ccs"+k+"MM(X,Y)":"NaN",numeric["ccs"+k+"MM"]=numeric.ccsbinop("zk = xk "+numeric.ops2[k]+"yk;"),numeric["ccs"+k]=Function("X","Y",'if(typeof X === "number") return '+A+';\nif(typeof Y === "number") return '+B+";\nreturn "+C+";\n")}(),numeric.ccsScatter=function(t){var n=t[0],r=t[1],i=t[2],s=numeric.sup(r)+1,o=n.length,u=numeric.rep([s],0),a=Array(o),f=Array(o),l=numeric.rep([s],0),c;for(c=0;c<o;++c)l[r[c]]++;for(c=0;c<s;++c)u[c+1]=u[c]+l[c];var h=u.slice(0),p,d;for(c=0;c<o;++c)a[p=h[d=r[c]]]=n[c],f[p]=i[c],h[d]=h[d]+1;return[u,a,f]},numeric.ccsGather=function(t){var n=t[0],r=t[1],i=t[2],s=n.length-1,o=r.length,u=Array(o),a=Array(o),f=Array(o),l,c,h,p,d;for(d=0,l=0;l<s;++l)for(h=n[l],p=n[l+1],c=h;c!==p;++c)a[d]=l,u[d]=r[c],f[d]=i[c],++d;return[u,a,f]},numeric.sdim=function dim(e,t,n){if(void 0===t&&(t=[]),"object"!=typeof e)return t;var r;for(r in void 0===n&&(n=0),n in t||(t[n]=0),e.length>t[n]&&(t[n]=e.length),e)e.hasOwnProperty(r)&&dim(e[r],t,n+1);return t},numeric.sclone=function clone(e,t,n){void 0===t&&(t=0),void 0===n&&(n=numeric.sdim(e).length);var r,i=Array(e.length);if(t===n-1){for(r in e)e.hasOwnProperty(r)&&(i[r]=e[r]);return i}for(r in e)e.hasOwnProperty(r)&&(i[r]=clone(e[r],t+1,n));return i},numeric.sdiag=function(t){var n=t.length,r,i=Array(n),s,o,u;for(r=n-1;r>=1;r-=2)s=r-1,i[r]=[],i[r][r]=t[r],i[s]=[],i[s][s]=t[s];return 0===r&&(i[0]=[],i[0][0]=t[r]),i},numeric.sidentity=function(t){return numeric.sdiag(numeric.rep([t],1))},numeric.stranspose=function(t){var n=[],r=t.length,i,s,o;for(i in t)if(t.hasOwnProperty(i))for(s in o=t[i])o.hasOwnProperty(s)&&("object"!=typeof n[s]&&(n[s]=[]),n[s][i]=o[s]);return n},numeric.sLUP=function(t,n){throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.")},numeric.sdotMM=function(t,n){var r=t.length,i=n.length,s=numeric.stranspose(n),o=s.length,u,a,f,l,c,h,p=Array(r),d;for(f=r-1;f>=0;f--){for(d=[],u=t[f],c=o-1;c>=0;c--){for(l in h=0,a=s[c],u)u.hasOwnProperty(l)&&l in a&&(h+=u[l]*a[l]);h&&(d[c]=h)}p[f]=d}return p},numeric.sdotMV=function(t,n){var r=t.length,i,s,o,u=Array(r),a;for(s=r-1;s>=0;s--){for(o in a=0,i=t[s])i.hasOwnProperty(o)&&n[o]&&(a+=i[o]*n[o]);a&&(u[s]=a)}return u},numeric.sdotVM=function(t,n){var r,i,s,o,u=[],a;for(r in t)if(t.hasOwnProperty(r))for(i in s=n[r],o=t[r],s)s.hasOwnProperty(i)&&(u[i]||(u[i]=0),u[i]+=o*s[i]);return u},numeric.sdotVV=function(t,n){var r,i=0;for(r in t)t[r]&&n[r]&&(i+=t[r]*n[r]);return i},numeric.sdot=function(t,n){var r=numeric.sdim(t).length,i=numeric.sdim(n).length,s;switch(1e3*r+i){case 0:return t*n;case 1001:return numeric.sdotVV(t,n);case 2001:return numeric.sdotMV(t,n);case 1002:return numeric.sdotVM(t,n);case 2002:return numeric.sdotMM(t,n);default:throw new Error("numeric.sdot not implemented for tensors of order "+r+" and "+i)}},numeric.sscatter=function(t){var n=t[0].length,r,i,s,o=t.length,u=[],a;for(i=n-1;i>=0;--i)if(t[o-1][i]){for(a=u,s=0;s<o-2;s++)a[r=t[s][i]]||(a[r]=[]),a=a[r];a[t[s][i]]=t[s+1][i]}return u},numeric.sgather=function gather(e,t,n){var r,i,s;for(i in void 0===t&&(t=[]),void 0===n&&(n=[]),r=n.length,e)if(e.hasOwnProperty(i))if(n[r]=parseInt(i),"number"==typeof(s=e[i])){if(s){if(0===t.length)for(i=r+1;i>=0;--i)t[i]=[];for(i=r;i>=0;--i)t[i].push(n[i]);t[r+1].push(s)}}else gather(s,t,n);return n.length>r&&n.pop(),t},numeric.cLU=function(t){var n=t[0],r=t[1],i=t[2],s=n.length,o=0,u,a,f,l,c,h;for(u=0;u<s;u++)n[u]>o&&(o=n[u]);o++;var p=Array(o),d=Array(o),v=numeric.rep([o],1/0),m=numeric.rep([o],-1/0),g,y,b;for(f=0;f<s;f++)u=n[f],(a=r[f])<v[u]&&(v[u]=a),a>m[u]&&(m[u]=a);for(u=0;u<o-1;u++)m[u]>m[u+1]&&(m[u+1]=m[u]);for(u=o-1;u>=1;u--)v[u]<v[u-1]&&(v[u-1]=v[u]);var w=0,E=0;for(u=0;u<o;u++)d[u]=numeric.rep([m[u]-v[u]+1],0),p[u]=numeric.rep([u-v[u]],0),w+=u-v[u]+1,E+=m[u]-u+1;for(f=0;f<s;f++)d[u=n[f]][r[f]-v[u]]=i[f];for(u=0;u<o-1;u++)for(l=u-v[u],g=d[u],a=u+1;v[a]<=u&&a<o;a++)if(c=u-v[a],h=m[u]-u,b=(y=d[a])[c]/g[l]){for(f=1;f<=h;f++)y[f+c]-=b*g[f+l];p[a][u-v[a]]=b}var g=[],y=[],S=[],x=[],T=[],N=[],s,C,k;for(s=0,C=0,u=0;u<o;u++){for(l=v[u],c=m[u],k=d[u],a=u;a<=c;a++)k[a-l]&&(g[s]=u,y[s]=a,S[s]=k[a-l],s++);for(k=p[u],a=l;a<u;a++)k[a-l]&&(x[C]=u,T[C]=a,N[C]=k[a-l],C++);x[C]=u,T[C]=u,N[C]=1,C++}return{U:[g,y,S],L:[x,T,N]}},numeric.cLUsolve=function(t,n){var r=t.L,i=t.U,s=numeric.clone(n),o=r[0],u=r[1],a=r[2],f=i[0],l=i[1],c=i[2],h=f.length,p=o.length,d=s.length,v,m,g;for(g=0,v=0;v<d;v++){for(;u[g]<v;)s[v]-=a[g]*s[u[g]],g++;g++}for(g=h-1,v=d-1;v>=0;v--){for(;l[g]>v;)s[v]-=c[g]*s[l[g]],g--;s[v]/=c[g],g--}return s},numeric.cgrid=function(t,n){"number"==typeof t&&(t=[t,t]);var r=numeric.rep(t,-1),i,s,o;if("function"!=typeof n)switch(n){case"L":n=function(e,n){return e>=t[0]/2||n<t[1]/2};break;default:n=function(e,t){return!0}}for(o=0,i=1;i<t[0]-1;i++)for(s=1;s<t[1]-1;s++)n(i,s)&&(r[i][s]=o,o++);return r},numeric.cdelsq=function(t){var n=[[-1,0],[0,-1],[0,1],[1,0]],r=numeric.dim(t),i=r[0],s=r[1],o,u,a,f,l,c=[],h=[],p=[];for(o=1;o<i-1;o++)for(u=1;u<s-1;u++)if(!(t[o][u]<0)){for(a=0;a<4;a++)f=o+n[a][0],l=u+n[a][1],t[f][l]<0||(c.push(t[o][u]),h.push(t[f][l]),p.push(-1));c.push(t[o][u]),h.push(t[o][u]),p.push(4)}return[c,h,p]},numeric.cdotMV=function(t,n){var r,i=t[0],s=t[1],o=t[2],u,a=i.length,f;for(f=0,u=0;u<a;u++)i[u]>f&&(f=i[u]);for(f++,r=numeric.rep([f],0),u=0;u<a;u++)r[i[u]]+=o[u]*n[s[u]];return r},numeric.Spline=function(t,n,r,i,s){this.x=t,this.yl=n,this.yr=r,this.kl=i,this.kr=s},numeric.Spline.prototype._at=function(t,n){var r=this.x,i=this.yl,s=this.yr,o=this.kl,u=this.kr,t,a,f,l,c=numeric.add,h=numeric.sub,p=numeric.mul;a=h(p(o[n],r[n+1]-r[n]),h(s[n+1],i[n])),f=c(p(u[n+1],r[n]-r[n+1]),h(s[n+1],i[n]));var d=(l=(t-r[n])/(r[n+1]-r[n]))*(1-l);return c(c(c(p(1-l,i[n]),p(l,s[n+1])),p(a,d*(1-l))),p(f,d*l))},numeric.Spline.prototype.at=function(t){if("number"==typeof t){var n=this.x,r=n.length,i,s,o,u=Math.floor,a,f,l;for(i=0,s=r-1;s-i>1;)n[o=u((i+s)/2)]<=t?i=o:s=o;return this._at(t,i)}var r=t.length,c,h=Array(r);for(c=r-1;-1!==c;--c)h[c]=this.at(t[c]);return h},numeric.Spline.prototype.diff=function(){var t=this.x,n=this.yl,r=this.yr,i=this.kl,s=this.kr,o=n.length,u,a,f,l=i,c=s,h=Array(o),p=Array(o),d=numeric.add,v=numeric.mul,m=numeric.div,g=numeric.sub;for(u=o-1;-1!==u;--u)a=t[u+1]-t[u],f=g(r[u+1],n[u]),h[u]=m(d(v(f,6),v(i[u],-4*a),v(s[u+1],-2*a)),a*a),p[u+1]=m(d(v(f,-6),v(i[u],2*a),v(s[u+1],4*a)),a*a);return new numeric.Spline(t,l,c,h,p)},numeric.Spline.prototype.roots=function(){function t(e){return e*e}function n(e,t,n,r,i){var s,o,u=.5*(i+1),a=u*(1-u);return(1-u)*e+u*t+(2*n-(t-e))*a*(1-u)+(2*-r+(t-e))*a*u}var r=[],i=this.x,s=this.yl,o=this.yr,u=this.kl,a=this.kr;"number"==typeof s[0]&&(s=[s],o=[o],u=[u],a=[a]);var f=s.length,l=i.length-1,c,h,p,d,v,m,g,y,b,w,r=Array(f),E,S,x,T,N,C,k,L,A,O,M,_,D,P,H,B,j,F=Math.sqrt;for(c=0;c!==f;++c){for(g=s[c],y=o[c],b=u[c],w=a[c],E=[],h=0;h!==l;h++){for(h>0&&y[h]*g[h]<0&&E.push(i[h]),A=i[h+1]-i[h],O=i[h],T=g[h],N=y[h+1],S=b[h]/A,C=(x=w[h+1]/A)+3*T+2*S-3*N,k=3*(x+S+2*(T-N)),(L=t(S-x+3*(T-N))+12*x*T)<=0?M=(_=C/k)>i[h]&&_<i[h+1]?[i[h],_,i[h+1]]:[i[h],i[h+1]]:(_=(C-F(L))/k,D=(C+F(L))/k,M=[i[h]],_>i[h]&&_<i[h+1]&&M.push(_),D>i[h]&&D<i[h+1]&&M.push(D),M.push(i[h+1])),H=M[0],_=this._at(H,h),p=0;p<M.length-1;p++)if(B=M[p+1],D=this._at(B,h),0!==_)if(0===D||_*D>0)H=B,_=D;else{for(var I=0;!((j=(_*B-D*H)/(_-D))<=H||j>=B);)if((P=this._at(j,h))*D>0)B=j,D=P,-1===I&&(_*=.5),I=-1;else{if(!(P*_>0))break;H=j,_=P,1===I&&(D*=.5),I=1}E.push(j),H=M[p+1],_=this._at(H,h)}else E.push(H),H=B,_=D;0===D&&E.push(B)}r[c]=E}return"number"==typeof this.yl[0]?r[0]:r},numeric.spline=function(t,n,r,i){var s=t.length,o=[],u=[],a=[],f,l=numeric.sub,c=numeric.mul,h=numeric.add;for(f=s-2;f>=0;f--)u[f]=t[f+1]-t[f],a[f]=l(n[f+1],n[f]);"string"!=typeof r&&"string"!=typeof i||(r=i="periodic");var p=[[],[],[]];switch(typeof r){case"undefined":o[0]=c(3/(u[0]*u[0]),a[0]),p[0].push(0,0),p[1].push(0,1),p[2].push(2/u[0],1/u[0]);break;case"string":o[0]=h(c(3/(u[s-2]*u[s-2]),a[s-2]),c(3/(u[0]*u[0]),a[0])),p[0].push(0,0,0),p[1].push(s-2,0,1),p[2].push(1/u[s-2],2/u[s-2]+2/u[0],1/u[0]);break;default:o[0]=r,p[0].push(0),p[1].push(0),p[2].push(1)}for(f=1;f<s-1;f++)o[f]=h(c(3/(u[f-1]*u[f-1]),a[f-1]),c(3/(u[f]*u[f]),a[f])),p[0].push(f,f,f),p[1].push(f-1,f,f+1),p[2].push(1/u[f-1],2/u[f-1]+2/u[f],1/u[f]);switch(typeof i){case"undefined":o[s-1]=c(3/(u[s-2]*u[s-2]),a[s-2]),p[0].push(s-1,s-1),p[1].push(s-2,s-1),p[2].push(1/u[s-2],2/u[s-2]);break;case"string":p[1][p[1].length-1]=0;break;default:o[s-1]=i,p[0].push(s-1),p[1].push(s-1),p[2].push(1)}o="number"!=typeof o[0]?numeric.transpose(o):[o];var d=Array(o.length);if("string"==typeof r)for(f=d.length-1;-1!==f;--f)d[f]=numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(p)),o[f]),d[f][s-1]=d[f][0];else for(f=d.length-1;-1!==f;--f)d[f]=numeric.cLUsolve(numeric.cLU(p),o[f]);return d="number"==typeof n[0]?d[0]:numeric.transpose(d),new numeric.Spline(t,n,n,d,d)},numeric.fftpow2=function fftpow2(e,t){var n=e.length;if(1!==n){var r=Math.cos,i=Math.sin,s,o,u=Array(n/2),a=Array(n/2),f=Array(n/2),l=Array(n/2);for(o=n/2,s=n-1;-1!==s;--s)f[--o]=e[s],l[o]=t[s],--s,u[o]=e[s],a[o]=t[s];fftpow2(u,a),fftpow2(f,l),o=n/2;var c,h=-6.283185307179586/n,p,d;for(s=n-1;-1!==s;--s)-1===--o&&(o=n/2-1),p=r(c=h*s),d=i(c),e[s]=u[o]+p*f[o]-d*l[o],t[s]=a[o]+p*l[o]+d*f[o]}},numeric._ifftpow2=function _ifftpow2(e,t){var n=e.length;if(1!==n){var r=Math.cos,i=Math.sin,s,o,u=Array(n/2),a=Array(n/2),f=Array(n/2),l=Array(n/2);for(o=n/2,s=n-1;-1!==s;--s)f[--o]=e[s],l[o]=t[s],--s,u[o]=e[s],a[o]=t[s];_ifftpow2(u,a),_ifftpow2(f,l),o=n/2;var c,h=6.283185307179586/n,p,d;for(s=n-1;-1!==s;--s)-1===--o&&(o=n/2-1),p=r(c=h*s),d=i(c),e[s]=u[o]+p*f[o]-d*l[o],t[s]=a[o]+p*l[o]+d*f[o]}},numeric.ifftpow2=function(t,n){numeric._ifftpow2(t,n),numeric.diveq(t,t.length),numeric.diveq(n,n.length)},numeric.convpow2=function(t,n,r,i){var s,o,u,a,f,l;for(numeric.fftpow2(t,n),numeric.fftpow2(r,i),s=t.length-1;-1!==s;--s)u=t[s],f=n[s],a=r[s],l=i[s],t[s]=u*a-f*l,n[s]=u*l+f*a;numeric.ifftpow2(t,n)},numeric.T.prototype.fft=function(){var t=this.x,n=this.y,r=t.length,i=Math.log,s=i(2),o=Math.ceil(i(2*r-1)/s),u=Math.pow(2,o),a=numeric.rep([u],0),f=numeric.rep([u],0),l=Math.cos,c=Math.sin,h,p=-3.141592653589793/r,d,v=numeric.rep([u],0),m=numeric.rep([u],0),g=Math.floor(r/2);for(h=0;h<r;h++)v[h]=t[h];if(void 0!==n)for(h=0;h<r;h++)m[h]=n[h];for(a[0]=1,h=1;h<=u/2;h++)d=p*h*h,a[h]=l(d),f[h]=c(d),a[u-h]=l(d),f[u-h]=c(d);var y=new numeric.T(v,m),b=new numeric.T(a,f);return y=y.mul(b),numeric.convpow2(y.x,y.y,numeric.clone(b.x),numeric.neg(b.y)),(y=y.mul(b)).x.length=r,y.y.length=r,y},numeric.T.prototype.ifft=function(){var t=this.x,n=this.y,r=t.length,i=Math.log,s=i(2),o=Math.ceil(i(2*r-1)/s),u=Math.pow(2,o),a=numeric.rep([u],0),f=numeric.rep([u],0),l=Math.cos,c=Math.sin,h,p=3.141592653589793/r,d,v=numeric.rep([u],0),m=numeric.rep([u],0),g=Math.floor(r/2);for(h=0;h<r;h++)v[h]=t[h];if(void 0!==n)for(h=0;h<r;h++)m[h]=n[h];for(a[0]=1,h=1;h<=u/2;h++)d=p*h*h,a[h]=l(d),f[h]=c(d),a[u-h]=l(d),f[u-h]=c(d);var y=new numeric.T(v,m),b=new numeric.T(a,f);return y=y.mul(b),numeric.convpow2(y.x,y.y,numeric.clone(b.x),numeric.neg(b.y)),(y=y.mul(b)).x.length=r,y.y.length=r,y.div(r)},numeric.gradient=function(t,n){var r=n.length,i=t(n);if(isNaN(i))throw new Error("gradient: f(x) is a NaN!");var s=Math.max,o,u=numeric.clone(n),a,f,l=Array(r),c=numeric.div,h=numeric.sub,p,d,s=Math.max,v=.001,m=Math.abs,g=Math.min,y,b,w,E=0,S,x,T;for(o=0;o<r;o++)for(var N=s(1e-6*i,1e-8);;){if(++E>20)throw new Error("Numerical gradient fails");if(u[o]=n[o]+N,a=t(u),u[o]=n[o]-N,f=t(u),u[o]=n[o],isNaN(a)||isNaN(f))N/=16;else{if(l[o]=(a-f)/(2*N),y=n[o]-N,b=n[o],w=n[o]+N,S=(a-i)/N,x=(i-f)/N,T=s(m(l[o]),m(i),m(a),m(f),m(y),m(b),m(w),1e-8),!((p=g(s(m(S-l[o]),m(x-l[o]),m(S-x))/T,N/T))>v))break;N/=16}}return l},numeric.uncmin=function(t,n,r,i,s,o,u){var a=numeric.gradient;void 0===u&&(u={}),void 0===r&&(r=1e-8),void 0===i&&(i=function(e){return a(t,e)}),void 0===s&&(s=1e3);var f=(n=numeric.clone(n)).length,l=t(n),c,h;if(isNaN(l))throw new Error("uncmin: f(x0) is a NaN!");var p=Math.max,d=numeric.norm2;r=p(r,numeric.epsilon);var v,m,g,y=u.Hinv||numeric.identity(f),b=numeric.dot,w=numeric.inv,E=numeric.sub,S=numeric.add,x=numeric.tensor,T=numeric.div,N=numeric.mul,C=numeric.all,k=numeric.isFinite,L=numeric.neg,A=0,O,M,_,D,P,H,B,j,F,I,q,R,U="";for(m=i(n);A<s;){if("function"==typeof o&&o(A,n,l,m,y)){U="Callback returned true";break}if(!C(k(m))){U="Gradient has Infinity or NaN";break}if(!C(k(v=L(b(y,m))))){U="Search direction has Infinity or NaN";break}if((I=d(v))<r){U="Newton step smaller than tol";break}for(F=1,h=b(m,v),_=n;A<s&&!(F*I<r)&&(_=S(n,M=N(v,F)),(c=t(_))-l>=.1*F*h||isNaN(c));)F*=.5,++A;if(F*I<r){U="Line search step size smaller than tol";break}if(A===s){U="maxit reached during line search";break}y=E(S(y,N(((B=b(D=E(g=i(_),m),M))+b(D,P=b(y,D)))/(B*B),x(M,M))),T(S(x(P,M),x(M,P)),B)),n=_,l=c,m=g,++A}return{solution:n,f:l,gradient:m,invHessian:y,iterations:A,message:U}},numeric.Dopri=function(t,n,r,i,s,o,u){this.x=t,this.y=n,this.f=r,this.ymid=i,this.iterations=s,this.events=u,this.message=o},numeric.Dopri.prototype._at=function(t,n){function r(e){return e*e}var i=this,s=i.x,o=i.y,u=i.f,a=i.ymid,f=s.length,l,c,h,p,d,v,t,m=Math.floor,g,y=.5,b=numeric.add,w=numeric.mul,E=numeric.sub,S,x,T;return l=s[n],c=s[n+1],p=o[n],d=o[n+1],h=l+y*(g=c-l),v=a[n],S=E(u[n],w(p,1/(l-h)+2/(l-c))),x=E(u[n+1],w(d,1/(c-h)+2/(c-l))),b(b(b(b(w(p,(T=[r(t-c)*(t-h)/r(l-c)/(l-h),r(t-l)*r(t-c)/r(l-h)/r(c-h),r(t-l)*(t-h)/r(c-l)/(c-h),(t-l)*r(t-c)*(t-h)/r(l-c)/(l-h),(t-c)*r(t-l)*(t-h)/r(l-c)/(c-h)])[0]),w(v,T[1])),w(d,T[2])),w(S,T[3])),w(x,T[4]))},numeric.Dopri.prototype.at=function(t){var n,r,i,s=Math.floor;if("number"!=typeof t){var o=t.length,u=Array(o);for(n=o-1;-1!==n;--n)u[n]=this.at(t[n]);return u}var a=this.x;for(n=0,r=a.length-1;r-n>1;)a[i=s(.5*(n+r))]<=t?n=i:r=i;return this._at(t,n)},numeric.dopri=function(t,n,r,i,s,o,u){void 0===s&&(s=1e-6),void 0===o&&(o=1e3);var a=[t],f=[r],l=[i(t,r)],c,h,p,d,v,m,g=[],y=.2,b=[.075,.225],w=[44/45,-56/15,32/9],E=[19372/6561,-25360/2187,64448/6561,-212/729],S=[9017/3168,-355/33,46732/5247,49/176,-5103/18656],x=[35/384,0,500/1113,125/192,-2187/6784,11/84],T=[.10013431883002395,0,.3918321794184259,-.02982460176594817,.05893268337240795,-.04497888809104361,.023904308236133973],N=[.2,.3,.8,8/9,1,1],C=[-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,.025],k=0,L,A,O=(n-t)/10,M=0,_=numeric.add,D=numeric.mul,P,H,B=Math.max,j=Math.min,F=Math.abs,I=numeric.norminf,q=Math.pow,R=numeric.any,U=numeric.lt,z=numeric.and,W=numeric.sub,X,V,$,J=new numeric.Dopri(a,f,l,g,-1,"");for("function"==typeof u&&(X=u(t,r));t<n&&M<o;)if(++M,t+O>n&&(O=n-t),c=i(t+N[0]*O,_(r,D(y*O,l[k]))),h=i(t+N[1]*O,_(_(r,D(b[0]*O,l[k])),D(b[1]*O,c))),p=i(t+N[2]*O,_(_(_(r,D(w[0]*O,l[k])),D(w[1]*O,c)),D(w[2]*O,h))),d=i(t+N[3]*O,_(_(_(_(r,D(E[0]*O,l[k])),D(E[1]*O,c)),D(E[2]*O,h)),D(E[3]*O,p))),v=i(t+N[4]*O,_(_(_(_(_(r,D(S[0]*O,l[k])),D(S[1]*O,c)),D(S[2]*O,h)),D(S[3]*O,p)),D(S[4]*O,d))),m=i(t+O,P=_(_(_(_(_(r,D(l[k],O*x[0])),D(h,O*x[2])),D(p,O*x[3])),D(d,O*x[4])),D(v,O*x[5]))),(H="number"==typeof(L=_(_(_(_(_(D(l[k],O*C[0]),D(h,O*C[2])),D(p,O*C[3])),D(d,O*C[4])),D(v,O*C[5])),D(m,O*C[6])))?F(L):I(L))>s){if(t+(O=.2*O*q(s/H,.25))===t){J.msg="Step size became too small";break}}else{if(g[k]=_(_(_(_(_(_(r,D(l[k],O*T[0])),D(h,O*T[2])),D(p,O*T[3])),D(d,O*T[4])),D(v,O*T[5])),D(m,O*T[6])),a[++k]=t+O,f[k]=P,l[k]=m,"function"==typeof u){var K,Q=t,G=t+.5*O,Y;if(V=u(G,g[k-1]),R($=z(U(X,0),U(0,V)))||(Q=G,X=V,V=u(G=t+O,P),$=z(U(X,0),U(0,V))),R($)){for(var Z,et,tt,nt,rt=0,it=1,st=1;;){if("number"==typeof X)Y=(st*V*Q-it*X*G)/(st*V-it*X);else for(Y=G,A=X.length-1;-1!==A;--A)X[A]<0&&V[A]>0&&(Y=j(Y,(st*V[A]*Q-it*X[A]*G)/(st*V[A]-it*X[A])));if(Y<=Q||Y>=G)break;nt=u(Y,K=J._at(Y,k-1)),R(tt=z(U(X,0),U(0,nt)))?(G=Y,V=nt,$=tt,st=1,-1===rt?it*=.5:it=1,rt=-1):(Q=Y,X=nt,it=1,1===rt?st*=.5:st=1,rt=1)}return P=J._at(.5*(t+Y),k-1),J.f[k]=i(Y,K),J.x[k]=Y,J.y[k]=K,J.ymid[k-1]=P,J.events=$,J.iterations=M,J}}t+=O,r=P,X=V,O=j(.8*O*q(s/H,.25),4*O)}return J.iterations=M,J},numeric.LU=function(e,t){t=t||!1;var n=Math.abs,r,i,s,o,u,a,f,l,c,h=e.length,p=h-1,d=new Array(h);for(t||(e=numeric.clone(e)),s=0;s<h;++s){for(f=s,c=n((a=e[s])[s]),i=s+1;i<h;++i)c<(o=n(e[i][s]))&&(c=o,f=i);for(d[s]=f,f!=s&&(e[s]=e[f],e[f]=a,a=e[s]),u=a[s],r=s+1;r<h;++r)e[r][s]/=u;for(r=s+1;r<h;++r){for(l=e[r],i=s+1;i<p;++i)l[i]-=l[s]*a[i],l[++i]-=l[s]*a[i];i===p&&(l[i]-=l[s]*a[i])}}return{LU:e,P:d}},numeric.LUsolve=function(t,n){var r,i,s=t.LU,o=s.length,u=numeric.clone(n),a=t.P,f,l,c,h;for(r=o-1;-1!==r;--r)u[r]=n[r];for(r=0;r<o;++r)for(f=a[r],a[r]!==r&&(h=u[r],u[r]=u[f],u[f]=h),l=s[r],i=0;i<r;++i)u[r]-=u[i]*l[i];for(r=o-1;r>=0;--r){for(l=s[r],i=r+1;i<o;++i)u[r]-=u[i]*l[i];u[r]/=l[r]}return u},numeric.solve=function(t,n,r){return numeric.LUsolve(numeric.LU(t,r),n)},numeric.echelonize=function(t){var n=numeric.dim(t),r=n[0],i=n[1],s=numeric.identity(r),o=Array(r),u,a,f,l,c,h,p,d,v=Math.abs,m=numeric.diveq;for(t=numeric.clone(t),u=0;u<r;++u){for(f=0,c=t[u],h=s[u],a=1;a<i;++a)v(c[f])<v(c[a])&&(f=a);for(o[u]=f,m(h,c[f]),m(c,c[f]),a=0;a<r;++a)if(a!==u){for(d=(p=t[a])[f],l=i-1;-1!==l;--l)p[l]-=c[l]*d;for(p=s[a],l=r-1;-1!==l;--l)p[l]-=h[l]*d}}return{I:s,A:t,P:o}},numeric.__solveLP=function(t,n,r,i,s,o,u){var a=numeric.sum,f=numeric.log,l=numeric.mul,c=numeric.sub,h=numeric.dot,p=numeric.div,d=numeric.add,v=t.length,m=r.length,g,y=!1,b,w=0,E=1,S,x,T=numeric.transpose(n),N=numeric.svd,C=numeric.transpose,k=numeric.leq,L=Math.sqrt,A=Math.abs,O=numeric.muleq,M=numeric.norminf,_=numeric.any,D=Math.min,P=numeric.all,H=numeric.gt,B=Array(v),j=Array(m),F=numeric.rep([m],1),I,q=numeric.solve,R=c(r,h(n,o)),U,z=h(t,t),W;for(U=0;U<s;++U){var X,V,$;for(X=m-1;-1!==X;--X)j[X]=p(n[X],R[X]);var J=C(j);for(X=v-1;-1!==X;--X)B[X]=a(J[X]);E=.25*A(z/h(t,B));var K=100*L(z/h(B,B));for((!isFinite(E)||E>K)&&(E=K),W=d(t,l(E,B)),I=h(J,j),X=v-1;-1!==X;--X)I[X][X]+=1;var Q=p(R,h(n,$=q(I,p(W,E),!0))),G=1;for(X=m-1;-1!==X;--X)Q[X]<0&&(G=D(G,-.999*Q[X]));if(!P(H(R=c(r,h(n,g=c(o,l($,G)))),0)))return{solution:o,message:"",iterations:U};if(o=g,E<i)return{solution:g,message:"",iterations:U};if(u){var Y=h(t,W),Z=h(n,W);for(y=!0,X=m-1;-1!==X;--X)if(Y*Z[X]<0){y=!1;break}}else y=!(o[v-1]>=0);if(y)return{solution:g,message:"Unbounded",iterations:U}}return{solution:o,message:"maximum iteration count exceeded",iterations:U}},numeric._solveLP=function(t,n,r,i,s){var o=t.length,u=r.length,a,f=numeric.sum,l=numeric.log,c=numeric.mul,h=numeric.sub,p=numeric.dot,d=numeric.div,v=numeric.add,m=numeric.rep([o],0).concat([1]),g=numeric.rep([u,1],-1),y=numeric.blockMatrix([[n,g]]),b=r,a=numeric.rep([o],0).concat(Math.max(0,numeric.sup(numeric.neg(r)))+1),w=numeric.__solveLP(m,y,b,i,s,a,!1),E=numeric.clone(w.solution),S;if(E.length=o,numeric.inf(h(r,p(n,E)))<0)return{solution:NaN,message:"Infeasible",iterations:w.iterations};var x=numeric.__solveLP(t,n,r,i,s-w.iterations,E,!0);return x.iterations+=w.iterations,x},numeric.solveLP=function(t,n,r,i,s,o,u){if(void 0===u&&(u=1e3),void 0===o&&(o=numeric.epsilon),void 0===i)return numeric._solveLP(t,n,r,o,u);var a=i.length,f=i[0].length,l=n.length,c=numeric.echelonize(i),h=numeric.rep([f],0),p=c.P,d=[],v;for(v=p.length-1;-1!==v;--v)h[p[v]]=1;for(v=f-1;-1!==v;--v)0===h[v]&&d.push(v);var m=numeric.getRange,g=numeric.linspace(0,a-1),y=numeric.linspace(0,l-1),b=m(i,g,d),w=m(n,y,p),E=m(n,y,d),S=numeric.dot,x=numeric.sub,T=S(w,c.I),N=x(E,S(T,b)),C=x(r,S(T,s)),k=Array(p.length),L=Array(d.length);for(v=p.length-1;-1!==v;--v)k[v]=t[p[v]];for(v=d.length-1;-1!==v;--v)L[v]=t[d[v]];var A=x(L,S(k,S(c.I,b))),O=numeric._solveLP(A,N,C,o,u),M=O.solution;if(M!=M)return O;var _=S(c.I,x(s,S(b,M))),D=Array(t.length);for(v=p.length-1;-1!==v;--v)D[p[v]]=_[v];for(v=d.length-1;-1!==v;--v)D[d[v]]=M[v];return{solution:D,message:O.message,iterations:O.iterations}},numeric.MPStoLP=function(t){function y(e){throw new Error("MPStoLP: "+e+"\nLine "+s+": "+t[s]+"\nCurrent state: "+r[n]+"\n")}t instanceof String&&t.split("\n");var n=0,r=["Initial state","NAME","ROWS","COLUMNS","RHS","BOUNDS","ENDATA"],i=t.length,s,o,u,a=0,f={},l=[],c=0,h={},p=0,d,v=[],m=[],g=[];for(s=0;s<i;++s){var b=(u=t[s]).match(/\S*/g),w=[];for(o=0;o<b.length;++o)""!==b[o]&&w.push(b[o]);if(0!==w.length){for(o=0;o<r.length&&u.substr(0,r[o].length)!==r[o];++o);if(o<r.length){if(n=o,1===o&&(d=w[1]),6===o)return{name:d,c:v,A:numeric.transpose(m),b:g,rows:f,vars:h}}else switch(n){case 0:case 1:y("Unexpected line");case 2:switch(w[0]){case"N":0===a?a=w[1]:y("Two or more N rows");break;case"L":f[w[1]]=c,l[c]=1,g[c]=0,++c;break;case"G":f[w[1]]=c,l[c]=-1,g[c]=0,++c;break;case"E":f[w[1]]=c,l[c]=0,g[c]=0,++c;break;default:y("Parse error "+numeric.prettyPrint(w))}break;case 3:h.hasOwnProperty(w[0])||(h[w[0]]=p,v[p]=0,m[p]=numeric.rep([c],0),++p);var E=h[w[0]];for(o=1;o<w.length;o+=2)if(w[o]!==a){var S=f[w[o]];m[E][S]=(l[S]<0?-1:1)*parseFloat(w[o+1])}else v[E]=parseFloat(w[o+1]);break;case 4:for(o=1;o<w.length;o+=2)g[f[w[o]]]=(l[f[w[o]]]<0?-1:1)*parseFloat(w[o+1]);break;case 5:break;case 6:y("Internal error")}}}y("Reached end of file without ENDATA")},numeric.seedrandom={pow:Math.pow,random:Math.random},function(e,t,n,r,i,s,o){function u(e){var t,r,i=this,s=e.length,o=0,u=i.i=i.j=i.m=0;for(i.S=[],i.c=[],s||(e=[s++]);o<n;)i.S[o]=o++;for(o=0;o<n;o++)u=l(u+(t=i.S[o])+e[o%s]),r=i.S[u],i.S[o]=r,i.S[u]=t;i.g=function(t){var r=i.S,s=l(i.i+1),o=r[s],u=l(i.j+o),a=r[u];r[s]=a,r[u]=o;for(var f=r[l(o+a)];--t;)a=r[u=l(u+(o=r[s=l(s+1)]))],r[s]=a,r[u]=o,f=f*n+r[l(o+a)];return i.i=s,i.j=u,f},i.g(n)}function a(e,t,n,r,i){if(n=[],i=typeof e,t&&"object"==i)for(r in e)if(r.indexOf("S")<5)try{n.push(a(e[r],t-1))}catch(s){}return n.length?n:e+("string"!=i?"\0":"")}function f(e,t,n,r){for(e+="",n=0,r=0;r<e.length;r++)t[l(r)]=l((n^=19*t[l(r)])+e.charCodeAt(r));for(r in e="",t)e+=String.fromCharCode(t[r]);return e}function l(e){return e&n-1}t.seedrandom=function(c,h){var p=[],d;return c=f(a(h?[c,e]:arguments.length?c:[(new Date).getTime(),e,window],3),p),f((d=new u(p)).S,e),t.random=function(){for(var t=d.g(6),u=o,a=0;t<i;)t=(t+a)*n,u*=n,a=d.g(1);for(;t>=s;)t/=2,u/=2,a>>>=1;return(t+a)/u},c},o=t.pow(n,6),i=t.pow(2,i),s=2*i,f(t.random(),e)}([],numeric.seedrandom,256,6,52),function(e){function t(e){if("object"!=typeof e)return e;var n=[],r,i=e.length;for(r=0;r<i;r++)n[r+1]=t(e[r]);return n}function n(e){if("object"!=typeof e)return e;var t=[],r,i=e.length;for(r=1;r<i;r++)t[r-1]=n(e[r]);return t}function r(e,t,n){var r,i,s,o,u;for(s=1;s<=n;s+=1){for(e[s][s]=1/e[s][s],u=-e[s][s],r=1;r<s;r+=1)e[r][s]=u*e[r][s];if(n<(o=s+1))break;for(i=o;i<=n;i+=1)for(u=e[s][i],e[s][i]=0,r=1;r<=s;r+=1)e[r][i]=e[r][i]+u*e[r][s]}}function i(e,t,n,r){var i,s,o,u;for(s=1;s<=n;s+=1){for(u=0,i=1;i<s;i+=1)u+=e[i][s]*r[i];r[s]=(r[s]-u)/e[s][s]}for(o=1;o<=n;o+=1)for(r[s=n+1-o]=r[s]/e[s][s],u=-r[s],i=1;i<s;i+=1)r[i]=r[i]+u*e[i][s]}function s(e,t,n,r){var i,s,o,u,a,f;for(s=1;s<=n;s+=1){if(r[1]=s,f=0,(o=s-1)<1){if((f=e[s][s]-f)<=0)break;e[s][s]=Math.sqrt(f)}else{for(u=1;u<=o;u+=1){for(a=e[u][s],i=1;i<u;i+=1)a-=e[i][s]*e[i][u];a/=e[u][u],e[u][s]=a,f+=a*a}if((f=e[s][s]-f)<=0)break;e[s][s]=Math.sqrt(f)}r[1]=0}}function o(e,t,n,o,u,a,f,l,c,h,p,d,v,m,g,y){function V(){for(m[1]=m[1]+1,E=L,b=1;b<=h;b+=1){for(E+=1,P=-l[b],w=1;w<=o;w+=1)P+=f[w][b]*u[w];if(Math.abs(P)<U&&(P=0),b>p)g[E]=P;else if(g[E]=-Math.abs(P),P>0){for(w=1;w<=o;w+=1)f[w][b]=-f[w][b];l[b]=-l[b]}}for(b=1;b<=v;b+=1)g[L+d[b]]=0;for(O=0,D=0,b=1;b<=h;b+=1)g[L+b]<D*g[_+b]&&(O=b,D=g[L+b]/g[_+b]);return 0===O?999:0}function $(){for(b=1;b<=o;b+=1){for(P=0,w=1;w<=o;w+=1)P+=e[w][b]*f[w][O];g[b]=P}for(S=N,b=1;b<=o;b+=1)g[S+b]=0;for(w=v+1;w<=o;w+=1)for(b=1;b<=o;b+=1)g[S+b]=g[S+b]+e[b][w]*g[w];for(q=!0,b=v;b>=1;b-=1){for(P=g[b],S=(E=k+b*(b+3)/2)-b,w=b+1;w<=v;w+=1)P-=g[E]*g[C+w],E+=w;if(P/=g[S],g[C+b]=P,d[b]<p)break;if(P<0)break;q=!1,T=b}if(!q)for(H=g[A+T]/g[C+T],b=1;b<=v&&!(d[b]<p)&&!(g[C+b]<0);b+=1)(D=g[A+b]/g[C+b])<H&&(H=D,T=b);for(P=0,b=N+1;b<=N+o;b+=1)P+=g[b]*g[b];if(Math.abs(P)<=U){if(q)return y[1]=1,999;for(b=1;b<=v;b+=1)g[A+b]=g[A+b]-H*g[C+b];return g[A+v+1]=g[A+v+1]+H,700}for(P=0,b=1;b<=o;b+=1)P+=g[N+b]*f[b][O];for(B=-g[L+O]/P,R=!0,q||H<B&&(B=H,R=!1),b=1;b<=o;b+=1)u[b]=u[b]+B*g[N+b],Math.abs(u[b])<U&&(u[b]=0);for(a[1]=a[1]+B*P*(B/2+g[A+v+1]),b=1;b<=v;b+=1)g[A+b]=g[A+b]-B*g[C+b];if(g[A+v+1]=g[A+v+1]+B,!R){for(P=-l[O],w=1;w<=o;w+=1)P+=u[w]*f[w][O];if(O>p)g[L+O]=P;else if(g[L+O]=-Math.abs(P),P>0){for(w=1;w<=o;w+=1)f[w][O]=-f[w][O];l[O]=-l[O]}return 700}for(d[v+=1]=O,E=k+(v-1)*v/2+1,b=1;b<=v-1;b+=1)g[E]=g[b],E+=1;if(v===o)g[E]=g[o];else{for(b=o;b>=v+1&&0!==g[b]&&(j=Math.max(Math.abs(g[b-1]),Math.abs(g[b])),F=Math.min(Math.abs(g[b-1]),Math.abs(g[b])),D=g[b-1]>=0?Math.abs(j*Math.sqrt(1+F*F/(j*j))):-Math.abs(j*Math.sqrt(1+F*F/(j*j))),j=g[b-1]/D,F=g[b]/D,1!==j);b-=1)if(0===j)for(g[b-1]=F*D,w=1;w<=o;w+=1)D=e[w][b-1],e[w][b-1]=e[w][b],e[w][b]=D;else for(g[b-1]=D,I=F/(1+j),w=1;w<=o;w+=1)D=j*e[w][b-1]+F*e[w][b],e[w][b]=I*(e[w][b-1]+D)-e[w][b],e[w][b-1]=D;g[E]=g[v]}return 0}function J(){if(0===g[S=(E=k+T*(T+1)/2+1)+T])return 798;if(j=Math.max(Math.abs(g[S-1]),Math.abs(g[S])),F=Math.min(Math.abs(g[S-1]),Math.abs(g[S])),D=g[S-1]>=0?Math.abs(j*Math.sqrt(1+F*F/(j*j))):-Math.abs(j*Math.sqrt(1+F*F/(j*j))),j=g[S-1]/D,F=g[S]/D,1===j)return 798;if(0===j){for(b=T+1;b<=v;b+=1)D=g[S-1],g[S-1]=g[S],g[S]=D,S+=b;for(b=1;b<=o;b+=1)D=e[b][T],e[b][T]=e[b][T+1],e[b][T+1]=D}else{for(I=F/(1+j),b=T+1;b<=v;b+=1)D=j*g[S-1]+F*g[S],g[S]=I*(g[S-1]+D)-g[S],g[S-1]=D,S+=b;for(b=1;b<=o;b+=1)D=j*e[b][T]+F*e[b][T+1],e[b][T+1]=I*(e[b][T]+D)-e[b][T+1],e[b][T]=D}return 0}function K(){for(S=E-T,b=1;b<=T;b+=1)g[S]=g[E],E+=1,S+=1;return g[A+T]=g[A+T+1],d[T]=d[T+1],(T+=1)<v?797:0}function Q(){return g[A+v]=g[A+v+1],g[A+v+1]=0,d[v]=0,v-=1,m[2]=m[2]+1,0}var b,w,E,S,x,T,N,C,k,L,A,O,M,_,D,P,H,B,j,F,I,q,R,U,z,W,X;M=Math.min(o,h),E=2*o+M*(M+5)/2+2*h+1,U=1e-60;do{z=1+.1*(U+=U),W=1+.2*U}while(z<=1||W<=1);for(b=1;b<=o;b+=1)g[b]=t[b];for(b=o+1;b<=E;b+=1)g[b]=0;for(b=1;b<=h;b+=1)d[b]=0;if(x=[],0===y[1]){if(s(e,n,o,x),0!==x[1])return void(y[1]=2);i(e,n,o,t),r(e,n,o)}else{for(w=1;w<=o;w+=1)for(u[w]=0,b=1;b<=w;b+=1)u[w]=u[w]+e[b][w]*t[b];for(w=1;w<=o;w+=1)for(t[w]=0,b=w;b<=o;b+=1)t[w]=t[w]+e[w][b]*u[b]}for(a[1]=0,w=1;w<=o;w+=1)for(u[w]=t[w],a[1]=a[1]+g[w]*u[w],g[w]=0,b=w+1;b<=o;b+=1)e[b][w]=0;for(a[1]=-a[1]/2,y[1]=0,_=(L=(k=(A=(C=(N=o)+o)+M)+M+1)+M*(M+1)/2)+h,b=1;b<=h;b+=1){for(P=0,w=1;w<=o;w+=1)P+=f[w][b]*f[w][b];g[_+b]=Math.sqrt(P)}for(v=0,m[1]=0,m[2]=0,X=0;;){if(999===(X=V()))return;for(;0!==(X=$());){if(999===X)return;if(700===X)if(T===v)Q();else{for(;J(),797===(X=K()););Q()}}}}function u(e,r,i,s,u,a){e=t(e),r=t(r),i=t(i);var f,l,c,h,p,d=[],v=[],m=[],g=[],y=[],b;if(u=u||0,a=a?t(a):[void 0,0],s=s?t(s):[],l=e.length-1,c=i[1].length-1,!s)for(f=1;f<=c;f+=1)s[f]=0;for(f=1;f<=c;f+=1)v[f]=0;for(h=0,p=Math.min(l,c),f=1;f<=l;f+=1)m[f]=0;for(d[1]=0,f=1;f<=2*l+p*(p+5)/2+2*c+1;f+=1)g[f]=0;for(f=1;f<=2;f+=1)y[f]=0;return o(e,r,l,l,m,d,i,s,l,c,u,v,0,y,g,a),b="",1===a[1]&&(b="constraints are inconsistent, no solution!"),2===a[1]&&(b="matrix D in quadratic function is not positive definite!"),{solution:n(m),value:n(d),unconstrained_solution:n(r),iterations:n(y),iact:n(v),message:b}}e.solveQP=u}(numeric),numeric.svd=function(t){function g(e,t){return(e=Math.abs(e))>(t=Math.abs(t))?e*Math.sqrt(1+t*t/e/e):0==t?e:t*Math.sqrt(1+e*e/t/t)}var n,r=numeric.epsilon,i=1e-64/r,s=50,o=0,u=0,a=0,f=0,l=0,c=numeric.clone(t),h=c.length,p=c[0].length;if(h<p)throw"Need more rows than columns";var d=new Array(p),v=new Array(p);for(u=0;u<p;u++)d[u]=v[u]=0;var m=numeric.rep([p,p],0),y=0,b=0,w=0,E=0,S=0,x=0,T=0;for(u=0;u<p;u++){for(d[u]=b,T=0,l=u+1,a=u;a<h;a++)T+=c[a][u]*c[a][u];if(T<=i)b=0;else for(y=c[u][u],b=Math.sqrt(T),y>=0&&(b=-b),w=y*b-T,c[u][u]=y-b,a=l;a<p;a++){for(T=0,f=u;f<h;f++)T+=c[f][u]*c[f][a];for(y=T/w,f=u;f<h;f++)c[f][a]+=y*c[f][u]}for(v[u]=b,T=0,a=l;a<p;a++)T+=c[u][a]*c[u][a];if(T<=i)b=0;else{for(y=c[u][u+1],b=Math.sqrt(T),y>=0&&(b=-b),w=y*b-T,c[u][u+1]=y-b,a=l;a<p;a++)d[a]=c[u][a]/w;for(a=l;a<h;a++){for(T=0,f=l;f<p;f++)T+=c[a][f]*c[u][f];for(f=l;f<p;f++)c[a][f]+=T*d[f]}}(S=Math.abs(v[u])+Math.abs(d[u]))>E&&(E=S)}for(u=p-1;-1!=u;u+=-1){if(0!=b){for(w=b*c[u][u+1],a=l;a<p;a++)m[a][u]=c[u][a]/w;for(a=l;a<p;a++){for(T=0,f=l;f<p;f++)T+=c[u][f]*m[f][a];for(f=l;f<p;f++)m[f][a]+=T*m[f][u]}}for(a=l;a<p;a++)m[u][a]=0,m[a][u]=0;m[u][u]=1,b=d[u],l=u}for(u=p-1;-1!=u;u+=-1){for(l=u+1,b=v[u],a=l;a<p;a++)c[u][a]=0;if(0!=b){for(w=c[u][u]*b,a=l;a<p;a++){for(T=0,f=l;f<h;f++)T+=c[f][u]*c[f][a];for(y=T/w,f=u;f<h;f++)c[f][a]+=y*c[f][u]}for(a=u;a<h;a++)c[a][u]=c[a][u]/b}else for(a=u;a<h;a++)c[a][u]=0;c[u][u]+=1}for(r*=E,f=p-1;-1!=f;f+=-1)for(var N=0;N<s;N++){var C=!1;for(l=f;-1!=l;l+=-1){if(Math.abs(d[l])<=r){C=!0;break}if(Math.abs(v[l-1])<=r)break}if(!C){o=0,T=1;var k=l-1;for(u=l;u<f+1&&(y=T*d[u],d[u]=o*d[u],!(Math.abs(y)<=r));u++)for(w=g(y,b=v[u]),v[u]=w,o=b/w,T=-y/w,a=0;a<h;a++)S=c[a][k],x=c[a][u],c[a][k]=S*o+x*T,c[a][u]=-S*T+x*o}if(x=v[f],l==f){if(x<0)for(v[f]=-x,a=0;a<p;a++)m[a][f]=-m[a][f];break}if(N>=49)throw"Error: no convergence.";for(E=v[l],b=g(y=(((S=v[f-1])-x)*(S+x)+((b=d[f-1])-(w=d[f]))*(b+w))/(2*w*S),1),y=y<0?((E-x)*(E+x)+w*(S/(y-b)-w))/E:((E-x)*(E+x)+w*(S/(y+b)-w))/E,o=1,T=1,u=l+1;u<f+1;u++){for(b=d[u],S=v[u],w=T*b,b*=o,x=g(y,w),d[u-1]=x,y=E*(o=y/x)+b*(T=w/x),b=-E*T+b*o,w=S*T,S*=o,a=0;a<p;a++)E=m[a][u-1],x=m[a][u],m[a][u-1]=E*o+x*T,m[a][u]=-E*T+x*o;for(x=g(y,w),v[u-1]=x,y=(o=y/x)*b+(T=w/x)*S,E=-T*b+o*S,a=0;a<h;a++)S=c[a][u-1],x=c[a][u],c[a][u-1]=S*o+x*T,c[a][u]=-S*T+x*o}d[l]=0,d[f]=y,v[f]=E}for(u=0;u<v.length;u++)v[u]<r&&(v[u]=0);for(u=0;u<p;u++)for(a=u-1;a>=0;a--)if(v[a]<v[u]){for(o=v[a],v[a]=v[u],v[u]=o,f=0;f<c.length;f++)n=c[f][u],c[f][u]=c[f][a],c[f][a]=n;for(f=0;f<m.length;f++)n=m[f][u],m[f][u]=m[f][a],m[f][a]=n;u=a}return{U:c,S:v,V:m}},function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?factory(exports):"function"==typeof define&&define.amd?define(["exports"],factory):factory((global=global||self).tf=global.tf||{})}(this,function(exports){"use strict";var extendStatics=function(d,b){return(extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])})(d,b)};function __extends(d,b){function __(){this.constructor=d}extendStatics(d,b),d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}function __awaiter(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})}function __generator(thisArg,body){var _={label:0,sent:function(){if(1&t[0])throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},"function"==typeof Symbol&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");for(;_;)try{if(f=1,y&&(t=2&op[0]?y.return:op[0]?y.throw||((t=y.return)&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;switch(y=0,t&&(op=[2&op[0],t.value]),op[0]){case 0:case 1:t=op;break;case 4:return _.label++,{value:op[1],done:!1};case 5:_.label++,y=op[1],op=[0];continue;case 7:op=_.ops.pop(),_.trys.pop();continue;default:if(!(t=(t=_.trys).length>0&&t[t.length-1])&&(6===op[0]||2===op[0])){_=0;continue}if(3===op[0]&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(6===op[0]&&_.label<t[1]){_.label=t[1],t=op;break}if(t&&_.label<t[2]){_.label=t[2],_.ops.push(op);break}t[2]&&_.ops.pop(),_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e],y=0}finally{f=t=0}if(5&op[0])throw op[1];return{value:op[0]?op[1]:void 0,done:!0}}}var TENSORFLOWJS_FLAGS_PREFIX="tfjsflags",Environment=function(){function Environment(global){this.global=global,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return Environment.prototype.setPlatform=function(platformName,platform){null!=this.platform&&console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+platform+"."),this.platformName=platformName,this.platform=platform},Environment.prototype.registerFlag=function(flagName,evaluationFn,setHook){if(this.flagRegistry[flagName]={evaluationFn:evaluationFn,setHook:setHook},null!=this.urlFlags[flagName]){var flagValue=this.urlFlags[flagName];console.warn("Setting feature override from URL "+flagName+": "+flagValue+"."),this.set(flagName,flagValue)}},Environment.prototype.get=function(flagName){return flagName in this.flags?this.flags[flagName]:(this.flags[flagName]=this.evaluateFlag(flagName),this.flags[flagName])},Environment.prototype.getNumber=function(flagName){return this.get(flagName)},Environment.prototype.getBool=function(flagName){return this.get(flagName)},Environment.prototype.getFlags=function(){return this.flags},Object.defineProperty(Environment.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),Environment.prototype.set=function(flagName,value){if(null==this.flagRegistry[flagName])throw new Error("Cannot set flag "+flagName+" as it has not been registered.");this.flags[flagName]=value,null!=this.flagRegistry[flagName].setHook&&this.flagRegistry[flagName].setHook(value)},Environment.prototype.evaluateFlag=function(flagName){if(null==this.flagRegistry[flagName])throw new Error("Cannot evaluate flag '"+flagName+"': no evaluation function found.");return this.flagRegistry[flagName].evaluationFn()},Environment.prototype.setFlags=function(flags){this.flags=Object.assign({},flags)},Environment.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},Environment.prototype.populateURLFlags=function(){var _this=this;if(void 0!==this.global&&void 0!==this.global.location&&void 0!==this.global.location.search){var urlParams=getQueryParams(this.global.location.search),keyValues;if("tfjsflags"in urlParams)urlParams.tfjsflags.split(",").forEach(function(keyValue){var _a=keyValue.split(":"),key=_a[0],value=_a[1];_this.urlFlags[key]=parseValue(key,value)})}},Environment}();function getQueryParams(queryString){var params={};return queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(s){for(var t=[],_i=1;_i<arguments.length;_i++)t[_i-1]=arguments[_i];return decodeParam(params,t[0],t[1]),t.join("=")}),params}function decodeParam(params,name,value){params[decodeURIComponent(name)]=decodeURIComponent(value||"")}function parseValue(flagName,value){if("true"===(value=value.toLowerCase())||"false"===value)return"true"===value;if(""+ +value===value)return+value;throw new Error("Could not parse value flag value "+value+" for flag "+flagName+".")}function env(){return exports.ENV}function setEnvironmentGlobal(environment){exports.ENV=environment}exports.ENV=null;var kernelRegistry=new Map,gradRegistry=new Map;function getKernel(kernelName,backendName){var key=makeKey(kernelName,backendName);return kernelRegistry.get(key)}function getGradient(kernelName){return gradRegistry.get(kernelName)}function getKernelsForBackend(backendName){for(var it=kernelRegistry.entries(),result=[];;){var _a=it.next(),done=_a.done,value=_a.value;if(done)break;var key=value[0],config=value[1],backend;key.split("_")[0]===backendName&&result.push(config)}return result}function registerKernel(config){var kernelName=config.kernelName,backendName=config.backendName,key=makeKey(kernelName,backendName);if(kernelRegistry.has(key))throw new Error("The kernel '"+kernelName+"' for backend '"+backendName+"' is already registered");kernelRegistry.set(key,config)}function registerGradient(config){var kernelName=config.kernelName;gradRegistry.has(kernelName)&&console.warn("Overriding the gradient for '"+kernelName+"'"),gradRegistry.set(kernelName,config)}function unregisterKernel(kernelName,backendName){var key=makeKey(kernelName,backendName);if(!kernelRegistry.has(key))throw new Error("The kernel '"+kernelName+"' for backend '"+backendName+"' is not registered");kernelRegistry.delete(key)}function unregisterGradient(kernelName){if(!gradRegistry.has(kernelName))throw new Error("The gradient '"+kernelName+"' for backend is not registered");gradRegistry.delete(kernelName)}function makeKey(kernelName,backendName){return backendName+"_"+kernelName}function shuffle(array){for(var counter=array.length,temp=0,index=0;counter>0;)index=Math.random()*counter|0,temp=array[--counter],array[counter]=array[index],array[index]=temp}function clamp(min,x,max){return Math.max(min,Math.min(x,max))}function nearestLargerEven(val){return val%2==0?val:val+1}function sum(arr){for(var sum=0,i=0;i<arr.length;i++)sum+=arr[i];return sum}function randUniform(a,b){var r=Math.random();return b*r+(1-r)*a}function distSquared(a,b){for(var result=0,i=0;i<a.length;i++){var diff=Number(a[i])-Number(b[i]);result+=diff*diff}return result}function assert(expr,msg){if(!expr)throw new Error("string"==typeof msg?msg:msg())}function assertShapesMatch(shapeA,shapeB,errorMessagePrefix){void 0===errorMessagePrefix&&(errorMessagePrefix=""),assert(arraysEqual(shapeA,shapeB),function(){return errorMessagePrefix+" Shapes "+shapeA+" and "+shapeB+" must match"})}function assertNonNull(a){assert(null!=a,function(){return"The input to the tensor constructor must be a non-null value."})}function flatten(arr,result,skipTypedArray){if(void 0===result&&(result=[]),void 0===skipTypedArray&&(skipTypedArray=!1),null==result&&(result=[]),Array.isArray(arr)||isTypedArray(arr)&&!skipTypedArray)for(var i=0;i<arr.length;++i)flatten(arr[i],result,skipTypedArray);else result.push(arr);return result}function sizeFromShape(shape){if(0===shape.length)return 1;for(var size=shape[0],i=1;i<shape.length;i++)size*=shape[i];return size}function isScalarShape(shape){return 0===shape.length}function arraysEqual(n1,n2){if(n1===n2)return!0;if(null==n1||null==n2)return!1;if(n1.length!==n2.length)return!1;for(var i=0;i<n1.length;i++)if(n1[i]!==n2[i])return!1;return!0}function isInt(a){return a%1==0}function tanh(x){if(null!=Math.tanh)return Math.tanh(x);if(x===1/0)return 1;if(x===-1/0)return-1;var e2x=Math.exp(2*x);return(e2x-1)/(e2x+1)}function sizeToSquarishShape(size){var width=Math.ceil(Math.sqrt(size));return[width,Math.ceil(size/width)]}function createShuffledIndices(n){for(var shuffledIndices=new Uint32Array(n),i=0;i<n;++i)shuffledIndices[i]=i;return shuffle(shuffledIndices),shuffledIndices}function rightPad(a,size){return size<=a.length?a:a+" ".repeat(size-a.length)}function repeatedTry(checkFn,delayFn,maxCounter){return void 0===delayFn&&(delayFn=function(counter){return 0}),new Promise(function(resolve,reject){var tryCount=0,tryFn=function(){if(checkFn())resolve();else{var nextBackoff=delayFn(++tryCount);null!=maxCounter&&tryCount>=maxCounter?reject():setTimeout(tryFn,nextBackoff)}};tryFn()})}function inferFromImplicitShape(shape,size){for(var shapeProd=1,implicitIdx=-1,i=0;i<shape.length;++i)if(shape[i]>=0)shapeProd*=shape[i];else if(-1===shape[i]){if(-1!==implicitIdx)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+implicitIdx+" and dim "+i);implicitIdx=i}else if(shape[i]<0)throw Error("Shapes can not be < 0. Found "+shape[i]+" at dim "+i);if(-1===implicitIdx){if(size>0&&size!==shapeProd)throw Error("Size("+size+") must match the product of shape "+shape);return shape}if(0===shapeProd)throw Error("Cannot infer the missing size in ["+shape+"] when there are 0 elements");if(size%shapeProd!=0)throw Error("The implicit shape can't be a fractional number. Got "+size+" / "+shapeProd);var newShape=shape.slice();return newShape[implicitIdx]=size/shapeProd,newShape}function parseAxisParam(axis,shape){var rank=shape.length;return assert((axis=null==axis?shape.map(function(s,i){return i}):[].concat(axis)).every(function(ax){return ax>=-rank&&ax<rank}),function(){return"All values in axis param must be in range [-"+rank+", "+rank+") but got axis "+axis}),assert(axis.every(function(ax){return isInt(ax)}),function(){return"All values in axis param must be integers but got axis "+axis}),axis.map(function(a){return a<0?rank+a:a})}function squeezeShape(shape,axis){for(var newShape=[],keptDims=[],isEmptyArray=null!=axis&&Array.isArray(axis)&&0===axis.length,axes=null==axis||isEmptyArray?null:parseAxisParam(axis,shape).sort(),j=0,i=0;i<shape.length;++i){if(null!=axes){if(axes[j]===i&&1!==shape[i])throw new Error("Can't squeeze axis "+i+" since its dim '"+shape[i]+"' is not 1");(null==axes[j]||axes[j]>i)&&1===shape[i]&&(newShape.push(shape[i]),keptDims.push(i)),axes[j]<=i&&j++}1!==shape[i]&&(newShape.push(shape[i]),keptDims.push(i))}return{newShape:newShape,keptDims:keptDims}}function getTypedArrayFromDType(dtype,size){var values=null;if(null==dtype||"float32"===dtype)values=new Float32Array(size);else if("int32"===dtype)values=new Int32Array(size);else{if("bool"!==dtype)throw new Error("Unknown data type "+dtype);values=new Uint8Array(size)}return values}function getArrayFromDType(dtype,size){var values=null;if(null==dtype||"float32"===dtype)values=new Float32Array(size);else if("int32"===dtype)values=new Int32Array(size);else if("bool"===dtype)values=new Uint8Array(size);else{if("string"!==dtype)throw new Error("Unknown data type "+dtype);values=new Array(size)}return values}function checkConversionForErrors(vals,dtype){for(var i=0;i<vals.length;i++){var num=vals[i];if(isNaN(num)||!isFinite(num))throw Error("A tensor of type "+dtype+" being uploaded contains "+num+".")}}function isValidDtype(dtype){return"bool"===dtype||"complex64"===dtype||"float32"===dtype||"int32"===dtype||"string"===dtype}function hasEncodingLoss(oldType,newType){return"complex64"!==newType&&(("float32"!==newType||"complex64"===oldType)&&(("int32"!==newType||"float32"===oldType||"complex64"===oldType)&&("bool"!==newType||"bool"!==oldType)))}function isTypedArray(a){return a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array}function bytesPerElement(dtype){if("float32"===dtype||"int32"===dtype)return 4;if("complex64"===dtype)return 8;if("bool"===dtype)return 1;throw new Error("Unknown dtype "+dtype)}function bytesFromStringArray(arr){if(null==arr)return 0;var bytes=0;return arr.forEach(function(x){return bytes+=x.length}),bytes}function isString(value){return"string"==typeof value||value instanceof String}function isBoolean(value){return"boolean"==typeof value}function isNumber(value){return"number"==typeof value}function inferDtype(values){return Array.isArray(values)?inferDtype(values[0]):values instanceof Float32Array?"float32":values instanceof Int32Array||values instanceof Uint8Array?"int32":isNumber(values)?"float32":isString(values)?"string":isBoolean(values)?"bool":"float32"}function isFunction(f){return!!(f&&f.constructor&&f.call&&f.apply)}function nearestDivisor(size,start){for(var i=start;i<size;++i)if(size%i==0)return i;return size}function computeStrides(shape){var rank=shape.length;if(rank<2)return[];var strides=new Array(rank-1);strides[rank-2]=shape[rank-1];for(var i=rank-3;i>=0;--i)strides[i]=strides[i+1]*shape[i+1];return strides}function toTypedArray(a,dtype,debugMode){if("string"===dtype)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(a)&&(a=flatten(a)),debugMode&&checkConversionForErrors(a,dtype),noConversionNeeded(a,dtype))return a;if(null==dtype||"float32"===dtype||"complex64"===dtype)return new Float32Array(a);if("int32"===dtype)return new Int32Array(a);if("bool"===dtype){for(var bool=new Uint8Array(a.length),i=0;i<bool.length;++i)0!==Math.round(a[i])&&(bool[i]=1);return bool}throw new Error("Unknown data type "+dtype)}function createNestedArray(offset,shape,a){var ret=new Array;if(1===shape.length)for(var d=shape[0],i=0;i<d;i++)ret[i]=a[offset+i];else for(var d=shape[0],rest=shape.slice(1),len=rest.reduce(function(acc,c){return acc*c}),i=0;i<d;i++)ret[i]=createNestedArray(offset+i*len,rest,a);return ret}function toNestedArray(shape,a){if(0===shape.length)return a[0];var size=shape.reduce(function(acc,c){return acc*c});if(0===size)return[];if(size!==a.length)throw new Error("["+shape+"] does not match the input size.");return createNestedArray(0,shape,a)}function noConversionNeeded(a,dtype){return a instanceof Float32Array&&"float32"===dtype||a instanceof Int32Array&&"int32"===dtype||a instanceof Uint8Array&&"bool"===dtype}function makeOnesTypedArray(size,dtype){for(var array=makeZerosTypedArray(size,dtype),i=0;i<array.length;i++)array[i]=1;return array}function makeZerosTypedArray(size,dtype){if(null==dtype||"float32"===dtype||"complex64"===dtype)return new Float32Array(size);if("int32"===dtype)return new Int32Array(size);if("bool"===dtype)return new Uint8Array(size);throw new Error("Unknown data type "+dtype)}function now(){return env().platform.now()}function assertNonNegativeIntegerDimensions(shape){shape.forEach(function(dimSize){assert(Number.isInteger(dimSize)&&dimSize>=0,function(){return"Tensor must have a shape comprised of positive integers but got shape ["+shape+"]."})})}function fetch$1(path,requestInits){return env().platform.fetch(path,requestInits)}function encodeString(s,encoding){return void 0===encoding&&(encoding="utf-8"),encoding=encoding||"utf-8",env().platform.encode(s,encoding)}function decodeString(bytes,encoding){return void 0===encoding&&(encoding="utf-8"),encoding=encoding||"utf-8",env().platform.decode(bytes,encoding)}function locToIndex(locs,rank,strides){if(0===rank)return 0;if(1===rank)return locs[0];for(var index=locs[locs.length-1],i=0;i<locs.length-1;++i)index+=strides[i]*locs[i];return index}function indexToLoc(index,rank,strides){if(0===rank)return[];if(1===rank)return[index];for(var locs=new Array(rank),i=0;i<locs.length-1;++i)locs[i]=Math.floor(index/strides[i]),index-=locs[i]*strides[i];return locs[locs.length-1]=index,locs}var util=Object.freeze({shuffle:shuffle,clamp:clamp,nearestLargerEven:nearestLargerEven,sum:sum,randUniform:randUniform,distSquared:distSquared,assert:assert,assertShapesMatch:assertShapesMatch,assertNonNull:assertNonNull,flatten:flatten,sizeFromShape:sizeFromShape,isScalarShape:isScalarShape,arraysEqual:arraysEqual,isInt:isInt,tanh:tanh,sizeToSquarishShape:sizeToSquarishShape,createShuffledIndices:createShuffledIndices,rightPad:rightPad,repeatedTry:repeatedTry,inferFromImplicitShape:inferFromImplicitShape,parseAxisParam:parseAxisParam,squeezeShape:squeezeShape,getTypedArrayFromDType:getTypedArrayFromDType,getArrayFromDType:getArrayFromDType,checkConversionForErrors:checkConversionForErrors,isValidDtype:isValidDtype,hasEncodingLoss:hasEncodingLoss,isTypedArray:isTypedArray,bytesPerElement:bytesPerElement,bytesFromStringArray:bytesFromStringArray,isString:isString,isBoolean:isBoolean,isNumber:isNumber,inferDtype:inferDtype,isFunction:isFunction,nearestDivisor:nearestDivisor,computeStrides:computeStrides,toTypedArray:toTypedArray,toNestedArray:toNestedArray,makeOnesTypedArray:makeOnesTypedArray,makeZerosTypedArray:makeZerosTypedArray,now:now,assertNonNegativeIntegerDimensions:assertNonNegativeIntegerDimensions,fetch:fetch$1,encodeString:encodeString,decodeString:decodeString,locToIndex:locToIndex,indexToLoc:indexToLoc}),Profiler=function(){function Profiler(backendTimer,logger){this.backendTimer=backendTimer,this.logger=logger,null==logger&&(this.logger=new Logger)}return Profiler.prototype.profileKernel=function(kernelName,inputs,f){var _this=this,outputs,holdResultWrapperFn=function(){outputs=f()},timer=this.backendTimer.time(holdResultWrapperFn);return outputs.forEach(function(r){r.data().then(function(vals){checkComputationForErrors(vals,r.dtype,kernelName),timer.then(function(timing){var extraInfo="";null!=timing.getExtraProfileInfo&&(extraInfo=timing.getExtraProfileInfo()),_this.logger.logKernelProfile(kernelName,r,vals,timing.kernelMs,inputs,extraInfo)})})}),outputs},Profiler}();function checkComputationForErrors(vals,dtype,kernelName){if("float32"!==dtype)return!1;for(var i=0;i<vals.length;i++){var num=vals[i];if(isNaN(num)||!isFinite(num))return console.warn("Found "+num+" in the result of '"+kernelName+"'"),!0}return!1}var Logger=function(){function Logger(){}return Logger.prototype.logKernelProfile=function(name,result,vals,timeMs,inputs,extraInfo){var time="number"==typeof timeMs?rightPad(timeMs+"ms",9):timeMs.error,paddedName=rightPad(name,25),rank=result.rank,size=result.size,shape=rightPad(result.shape.toString(),14),inputShapesDescription="";for(var name_1 in inputs){var input,inputShape=inputs[name_1].shape||result.shape,inputRank=inputShape.length;inputShapesDescription+=name_1+": "+inputRank+"D "+(inputRank>0?inputShape:"")+" "}console.log("%c"+paddedName+"\t%c"+time+"\t%c"+rank+"D "+shape+"\t%c"+size+"\t%c"+inputShapesDescription+"\t%c"+extraInfo,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")},Logger}();function getFilteredNodesXToY(tape,xs,y){for(var tensorsFromX={},nodesFromX={},i=0;i<xs.length;i++)tensorsFromX[xs[i].id]=!0;for(var i=0;i<tape.length;i++){var node,nodeInputs=(node=tape[i]).inputs;for(var inputName in nodeInputs){for(var input=nodeInputs[inputName],anyInputFromX=!1,j=0;j<xs.length;j++)if(tensorsFromX[input.id]){node.outputs.forEach(function(output){return tensorsFromX[output.id]=!0}),anyInputFromX=!0,nodesFromX[node.id]=!0;break}if(anyInputFromX)break}}var tensorsLeadToY={};tensorsLeadToY[y.id]=!0;for(var nodesToY={},i=tape.length-1;i>=0;i--)for(var node,nodeInputs=(node=tape[i]).inputs,j=0;j<node.outputs.length;j++)if(tensorsLeadToY[node.outputs[j].id]){for(var inputName in nodeInputs)tensorsLeadToY[nodeInputs[inputName].id]=!0,nodesToY[node.id]=!0;break}for(var filteredTape=[],i=0;i<tape.length;i++){var node;if(nodesFromX[(node=tape[i]).id]&&nodesToY[node.id]){var prunedInputs={};for(var inputName in node.inputs){var nodeInput=node.inputs[inputName];tensorsFromX[nodeInput.id]&&(prunedInputs[inputName]=nodeInput)}var prunedNode=Object.assign({},node);prunedNode.inputs=prunedInputs,prunedNode.outputs=node.outputs,filteredTape.push(prunedNode)}}return filteredTape}function backpropagateGradients(tensorAccumulatedGradientMap,filteredTape,tidy){for(var _loop_1=function(i){var node=filteredTape[i],dys=[];if(node.outputs.forEach(function(o){var gradTensor=tensorAccumulatedGradientMap[o.id];null!=gradTensor?dys.push(gradTensor):dys.push(null)}),null==node.gradient)throw new Error("Cannot compute gradient: gradient function not found for "+node.kernelName+".");var inputGradients=node.gradient(dys),_loop_2=function(inputName){if(!(inputName in inputGradients))throw new Error("Cannot backprop through input "+inputName+". Available gradients found: "+Object.keys(inputGradients)+".");var dx=tidy(function(){return inputGradients[inputName]()});if("float32"!==dx.dtype)throw new Error("Error in gradient for op "+node.kernelName+". The gradient of input "+inputName+" must have 'float32' dtype, but has '"+dx.dtype+"'");var x=node.inputs[inputName];if(!arraysEqual(dx.shape,x.shape))throw new Error("Error in gradient for op "+node.kernelName+". The gradient of input '"+inputName+"' has shape '"+dx.shape+"', which does not match the shape of the input '"+x.shape+"'");if(null==tensorAccumulatedGradientMap[x.id])tensorAccumulatedGradientMap[x.id]=dx;else{var curGradient=tensorAccumulatedGradientMap[x.id];tensorAccumulatedGradientMap[x.id]=curGradient.add(dx),curGradient.dispose()}};for(var inputName in node.inputs)_loop_2(inputName)},i=filteredTape.length-1;i>=0;i--)_loop_1(i)}var FORMAT_LIMIT_NUM_VALS=20,FORMAT_NUM_FIRST_LAST_VALS=3,FORMAT_NUM_SIG_DIGITS=7;function tensorToString(vals,shape,dtype,verbose){var strides=computeStrides(shape),padPerCol=computeMaxSizePerColumn(vals,shape,dtype,strides),rank=shape.length,valsLines=subTensorToString(vals,shape,dtype,strides,padPerCol),lines=["Tensor"];return verbose&&(lines.push("  dtype: "+dtype),lines.push("  rank: "+rank),lines.push("  shape: ["+shape+"]"),lines.push("  values:")),lines.push(valsLines.map(function(l){return"    "+l}).join("\n")),lines.join("\n")}function computeMaxSizePerColumn(vals,shape,dtype,strides){var n=sizeFromShape(shape),numCols=strides[strides.length-1],padPerCol=new Array(numCols).fill(0),rank=shape.length,valuesOrTuples="complex64"===dtype?createComplexTuples(vals):vals;if(rank>1)for(var row=0;row<n/numCols;row++)for(var offset=row*numCols,j=0;j<numCols;j++)padPerCol[j]=Math.max(padPerCol[j],valToString(valuesOrTuples[offset+j],0,dtype).length);return padPerCol}function valToString(val,pad,dtype){var valStr;return rightPad(valStr=Array.isArray(val)?parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))+" + "+parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))+"j":isString(val)?"'"+val+"'":"bool"===dtype?boolNumToString(val):parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(),pad)}function boolNumToString(v){return 0===v?"false":"true"}function subTensorToString(vals,shape,dtype,strides,padPerCol,isLast){void 0===isLast&&(isLast=!0);var storagePerElement="complex64"===dtype?2:1,size=shape[0],rank=shape.length,complexTuple;if(0===rank)return"complex64"===dtype?[valToString(createComplexTuples(vals)[0],0,dtype)]:"bool"===dtype?[boolNumToString(vals[0])]:[vals[0].toString()];if(1===rank){if(size>FORMAT_LIMIT_NUM_VALS){var firstValsSize=FORMAT_NUM_FIRST_LAST_VALS*storagePerElement,firstVals=Array.from(vals.slice(0,firstValsSize)),lastVals=Array.from(vals.slice((size-FORMAT_NUM_FIRST_LAST_VALS)*storagePerElement,size*storagePerElement));return"complex64"===dtype&&(firstVals=createComplexTuples(firstVals),lastVals=createComplexTuples(lastVals)),["["+firstVals.map(function(x,i){return valToString(x,padPerCol[i],dtype)}).join(", ")+", ..., "+lastVals.map(function(x,i){return valToString(x,padPerCol[size-FORMAT_NUM_FIRST_LAST_VALS+i],dtype)}).join(", ")+"]"]}var displayVals;return["["+("complex64"===dtype?createComplexTuples(vals):Array.from(vals)).map(function(x,i){return valToString(x,padPerCol[i],dtype)}).join(", ")+"]"]}var subshape=shape.slice(1),substrides=strides.slice(1),stride=strides[0]*storagePerElement,lines=[];if(size>FORMAT_LIMIT_NUM_VALS){for(var i=0;i<FORMAT_NUM_FIRST_LAST_VALS;i++){var start,end=(start=i*stride)+stride;lines.push.apply(lines,subTensorToString(vals.slice(start,end),subshape,dtype,substrides,padPerCol,!1))}lines.push("...");for(var i=size-FORMAT_NUM_FIRST_LAST_VALS;i<size;i++){var start,end=(start=i*stride)+stride;lines.push.apply(lines,subTensorToString(vals.slice(start,end),subshape,dtype,substrides,padPerCol,i===size-1))}}else for(var i=0;i<size;i++){var start,end=(start=i*stride)+stride;lines.push.apply(lines,subTensorToString(vals.slice(start,end),subshape,dtype,substrides,padPerCol,i===size-1))}var sep=2===rank?",":"";lines[0]="["+lines[0]+sep;for(var i=1;i<lines.length-1;i++)lines[i]=" "+lines[i]+sep;for(var newLineSep=",\n",i=2;i<rank;i++)newLineSep+="\n";return lines[lines.length-1]=" "+lines[lines.length-1]+"]"+(isLast?"":newLineSep),lines}function createComplexTuples(vals){for(var complexTuples=[],i=0;i<vals.length;i+=2)complexTuples.push([vals[i],vals[i+1]]);return complexTuples}var TensorBuffer=function(){function TensorBuffer(shape,dtype,values){var _this=this;if(this.dtype=dtype,this.shape=shape.slice(),this.size=sizeFromShape(shape),null!=values){var n_1=values.length;assert(n_1===this.size,function(){return"Length of values '"+n_1+"' does not match the size inferred by the shape '"+_this.size+"'."})}if("complex64"===dtype)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=values||getArrayFromDType(dtype,this.size),this.strides=computeStrides(shape)}return TensorBuffer.prototype.set=function(value){for(var _this=this,locs=[],_i=1;_i<arguments.length;_i++)locs[_i-1]=arguments[_i];0===locs.length&&(locs=[0]),assert(locs.length===this.rank,function(){return"The number of provided coordinates ("+locs.length+") must match the rank ("+_this.rank+")"});var index=this.locToIndex(locs);this.values[index]=value},TensorBuffer.prototype.get=function(){for(var locs=[],_i=0;_i<arguments.length;_i++)locs[_i]=arguments[_i];0===locs.length&&(locs=[0]);for(var i=0,_a=0,locs_1=locs;_a<locs_1.length;_a++){var loc=locs_1[_a];if(loc<0||loc>=this.shape[i]){var msg="Requested out of range element at "+locs+".   Buffer shape="+this.shape;throw new Error(msg)}i++}for(var index=locs[locs.length-1],i_1=0;i_1<locs.length-1;++i_1)index+=this.strides[i_1]*locs[i_1];return this.values[index]},TensorBuffer.prototype.locToIndex=function(locs){if(0===this.rank)return 0;if(1===this.rank)return locs[0];for(var index=locs[locs.length-1],i=0;i<locs.length-1;++i)index+=this.strides[i]*locs[i];return index},TensorBuffer.prototype.indexToLoc=function(index){if(0===this.rank)return[];if(1===this.rank)return[index];for(var locs=new Array(this.shape.length),i=0;i<locs.length-1;++i)locs[i]=Math.floor(index/this.strides[i]),index-=locs[i]*this.strides[i];return locs[locs.length-1]=index,locs},Object.defineProperty(TensorBuffer.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),TensorBuffer.prototype.toTensor=function(){return trackerFn().makeTensor(this.values,this.shape,this.dtype)},TensorBuffer}(),trackerFn=null,opHandler=null,deprecationWarningFn=null;function setTensorTracker(fn){trackerFn=fn}function setOpHandler(handler){opHandler=handler}function setDeprecationWarningFn(fn){deprecationWarningFn=fn}var Tensor=function(){function Tensor(shape,dtype,dataId,id){this.kept=!1,this.isDisposedInternal=!1,this.shape=shape.slice(),this.dtype=dtype||"float32",this.size=sizeFromShape(shape),this.strides=computeStrides(shape),this.dataId=dataId,this.id=id,this.rankType=this.rank<5?this.rank.toString():"higher"}return Tensor.prototype.flatten=function(){return this.throwIfDisposed(),this.as1D()},Tensor.prototype.asScalar=function(){return this.throwIfDisposed(),assert(1===this.size,function(){return"The array must have only 1 element."}),this.reshape([])},Tensor.prototype.as1D=function(){return this.throwIfDisposed(),this.reshape([this.size])},Tensor.prototype.as2D=function(rows,columns){return this.throwIfDisposed(),this.reshape([rows,columns])},Tensor.prototype.as3D=function(rows,columns,depth){return this.throwIfDisposed(),this.reshape([rows,columns,depth])},Tensor.prototype.as4D=function(rows,columns,depth,depth2){return this.throwIfDisposed(),this.reshape([rows,columns,depth,depth2])},Tensor.prototype.as5D=function(rows,columns,depth,depth2,depth3){return this.throwIfDisposed(),this.reshape([rows,columns,depth,depth2,depth3])},Tensor.prototype.asType=function(dtype){return this.throwIfDisposed(),opHandler.cast(this,dtype)},Object.defineProperty(Tensor.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),Tensor.prototype.buffer=function(){return __awaiter(this,void 0,void 0,function(){var vals;return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.data()];case 1:return vals=_a.sent(),[2,opHandler.buffer(this.shape,this.dtype,vals)]}})})},Tensor.prototype.bufferSync=function(){return opHandler.buffer(this.shape,this.dtype,this.dataSync())},Tensor.prototype.array=function(){return __awaiter(this,void 0,void 0,function(){var vals;return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.data()];case 1:return vals=_a.sent(),[2,toNestedArray(this.shape,vals)]}})})},Tensor.prototype.arraySync=function(){return toNestedArray(this.shape,this.dataSync())},Tensor.prototype.data=function(){return __awaiter(this,void 0,void 0,function(){var data,bytes;return __generator(this,function(_a){switch(_a.label){case 0:return this.throwIfDisposed(),data=trackerFn().read(this.dataId),"string"!==this.dtype?[3,2]:[4,data];case 1:bytes=_a.sent();try{return[2,bytes.map(function(b){return decodeString(b)})]}catch(_b){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}_a.label=2;case 2:return[2,data]}})})},Tensor.prototype.dataSync=function(){this.throwIfDisposed();var data=trackerFn().readSync(this.dataId);if("string"===this.dtype)try{return data.map(function(b){return decodeString(b)})}catch(_a){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return data},Tensor.prototype.bytes=function(){return __awaiter(this,void 0,void 0,function(){var data;return __generator(this,function(_a){switch(_a.label){case 0:return this.throwIfDisposed(),[4,trackerFn().read(this.dataId)];case 1:return data=_a.sent(),"string"===this.dtype?[2,data]:[2,new Uint8Array(data.buffer)]}})})},Tensor.prototype.dispose=function(){this.isDisposed||(trackerFn().disposeTensor(this),this.isDisposedInternal=!0)},Object.defineProperty(Tensor.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),Tensor.prototype.throwIfDisposed=function(){if(this.isDisposed)throw new Error("Tensor is disposed.")},Tensor.prototype.toFloat=function(){return this.asType("float32")},Tensor.prototype.toInt=function(){return this.asType("int32")},Tensor.prototype.toBool=function(){return this.asType("bool")},Tensor.prototype.print=function(verbose){return void 0===verbose&&(verbose=!1),opHandler.print(this,verbose)},Tensor.prototype.reshape=function(newShape){return this.throwIfDisposed(),opHandler.reshape(this,newShape)},Tensor.prototype.reshapeAs=function(x){return this.throwIfDisposed(),this.reshape(x.shape)},Tensor.prototype.expandDims=function(axis){return void 0===axis&&(axis=0),opHandler.expandDims(this,axis)},Tensor.prototype.cumsum=function(axis,exclusive,reverse){return void 0===axis&&(axis=0),void 0===exclusive&&(exclusive=!1),void 0===reverse&&(reverse=!1),opHandler.cumsum(this,axis,exclusive,reverse)},Tensor.prototype.squeeze=function(axis){return this.throwIfDisposed(),opHandler.squeeze(this,axis)},Tensor.prototype.clone=function(){return this.throwIfDisposed(),opHandler.clone(this)},Tensor.prototype.toString=function(verbose){var vals;return void 0===verbose&&(verbose=!1),tensorToString(this.dataSync(),this.shape,this.dtype,verbose)},Tensor.prototype.gather=function(indices,axis){return void 0===axis&&(axis=0),this.throwIfDisposed(),opHandler.gather(this,indices,axis)},Tensor.prototype.matMul=function(b,transposeA,transposeB){return void 0===transposeA&&(transposeA=!1),void 0===transposeB&&(transposeB=!1),this.throwIfDisposed(),opHandler.matMul(this,b,transposeA,transposeB)},Tensor.prototype.dot=function(b){return this.throwIfDisposed(),opHandler.dot(this,b)},Tensor.prototype.norm=function(ord,axis,keepDims){return void 0===ord&&(ord="euclidean"),void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1),this.throwIfDisposed(),opHandler.norm(this,ord,axis,keepDims)},Tensor.prototype.slice=function(begin,size){return this.throwIfDisposed(),opHandler.slice(this,begin,size)},Tensor.prototype.reverse=function(axis){return this.throwIfDisposed(),opHandler.reverse(this,axis)},Tensor.prototype.concat=function(x,axis){return void 0===axis&&(axis=0),this.throwIfDisposed(),x instanceof Tensor&&(x=[x]),opHandler.concat([this].concat(x),axis)},Tensor.prototype.split=function(numOrSizeSplits,axis){return void 0===axis&&(axis=0),this.throwIfDisposed(),opHandler.split(this,numOrSizeSplits,axis)},Tensor.prototype.stack=function(x,axis){return void 0===axis&&(axis=0),opHandler.stack([this,x],axis)},Tensor.prototype.unstack=function(axis){return void 0===axis&&(axis=0),opHandler.unstack(this,axis)},Tensor.prototype.batchNormalization=function(mean,variance,varianceEpsilon,scale,offset){return void 0===varianceEpsilon&&(varianceEpsilon=.001),deprecationWarningFn("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"),this.batchNorm(mean,variance,offset,scale,varianceEpsilon)},Tensor.prototype.all=function(axis,keepDims){return void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1),this.throwIfDisposed(),opHandler.all(this,axis,keepDims)},Tensor.prototype.any=function(axis,keepDims){return void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1),this.throwIfDisposed(),opHandler.any(this,axis,keepDims)},Tensor.prototype.logSumExp=function(axis,keepDims){return void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1),this.throwIfDisposed(),opHandler.logSumExp(this,axis,keepDims)},Tensor.prototype.sum=function(axis,keepDims){return void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1),this.throwIfDisposed(),opHandler.sum(this,axis,keepDims)},Tensor.prototype.prod=function(axis,keepDims){return void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1),this.throwIfDisposed(),opHandler.prod(this,axis,keepDims)},Tensor.prototype.mean=function(axis,keepDims){return void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1),this.throwIfDisposed(),opHandler.mean(this,axis,keepDims)},Tensor.prototype.min=function(axis,keepDims){return void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1),this.throwIfDisposed(),opHandler.min(this,axis,keepDims)},Tensor.prototype.max=function(axis,keepDims){return void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1),this.throwIfDisposed(),opHandler.max(this,axis,keepDims)},Tensor.prototype.argMin=function(axis){return void 0===axis&&(axis=null),this.throwIfDisposed(),opHandler.argMin(this,axis)},Tensor.prototype.argMax=function(axis){return void 0===axis&&(axis=null),this.throwIfDisposed(),opHandler.argMax(this,axis)},Tensor.prototype.cast=function(dtype){return this.throwIfDisposed(),opHandler.cast(this,dtype)},Tensor.prototype.addStrict=function(x){return this.throwIfDisposed(),opHandler.addStrict(this,x)},Tensor.prototype.atan2=function(x){return this.throwIfDisposed(),opHandler.atan2(this,x)},Tensor.prototype.sub=function(x){return this.throwIfDisposed(),opHandler.sub(this,x)},Tensor.prototype.subStrict=function(x){return this.throwIfDisposed(),opHandler.subStrict(this,x)},Tensor.prototype.pow=function(exp){return this.throwIfDisposed(),opHandler.pow(this,exp)},Tensor.prototype.powStrict=function(exp){return this.throwIfDisposed(),opHandler.powStrict(this,exp)},Tensor.prototype.mul=function(x){return this.throwIfDisposed(),opHandler.mul(this,x)},Tensor.prototype.mulStrict=function(x){return this.throwIfDisposed(),opHandler.mulStrict(this,x)},Tensor.prototype.floorDiv=function(x){return this.throwIfDisposed(),opHandler.floorDiv(this,x)},Tensor.prototype.divStrict=function(x){return this.throwIfDisposed(),opHandler.divStrict(this,x)},Tensor.prototype.minimum=function(x){return this.throwIfDisposed(),opHandler.minimum(this,x)},Tensor.prototype.minimumStrict=function(x){return this.throwIfDisposed(),opHandler.minimumStrict(this,x)},Tensor.prototype.maximum=function(x){return this.throwIfDisposed(),opHandler.maximum(this,x)},Tensor.prototype.maximumStrict=function(x){return this.throwIfDisposed(),opHandler.maximumStrict(this,x)},Tensor.prototype.mod=function(x){return this.throwIfDisposed(),opHandler.mod(this,x)},Tensor.prototype.modStrict=function(x){return this.throwIfDisposed(),opHandler.modStrict(this,x)},Tensor.prototype.squaredDifferenceStrict=function(x){return this.throwIfDisposed(),opHandler.squaredDifferenceStrict(this,x)},Tensor.prototype.notEqual=function(x){return this.throwIfDisposed(),opHandler.notEqual(this,x)},Tensor.prototype.notEqualStrict=function(x){return this.throwIfDisposed(),opHandler.notEqualStrict(this,x)},Tensor.prototype.less=function(x){return this.throwIfDisposed(),opHandler.less(this,x)},Tensor.prototype.lessStrict=function(x){return this.throwIfDisposed(),opHandler.lessStrict(this,x)},Tensor.prototype.equal=function(x){return this.throwIfDisposed(),opHandler.equal(this,x)},Tensor.prototype.equalStrict=function(x){return this.throwIfDisposed(),opHandler.equalStrict(this,x)},Tensor.prototype.lessEqual=function(x){return this.throwIfDisposed(),opHandler.lessEqual(this,x)},Tensor.prototype.lessEqualStrict=function(x){return this.throwIfDisposed(),opHandler.lessEqualStrict(this,x)},Tensor.prototype.greater=function(x){return this.throwIfDisposed(),opHandler.greater(this,x)},Tensor.prototype.greaterStrict=function(x){return this.throwIfDisposed(),opHandler.greaterStrict(this,x)},Tensor.prototype.greaterEqual=function(x){return this.throwIfDisposed(),opHandler.greaterEqual(this,x)},Tensor.prototype.greaterEqualStrict=function(x){return this.throwIfDisposed(),opHandler.greaterEqualStrict(this,x)},Tensor.prototype.logicalAnd=function(x){return this.throwIfDisposed(),opHandler.logicalAnd(this,x)},Tensor.prototype.logicalOr=function(x){return this.throwIfDisposed(),opHandler.logicalOr(this,x)},Tensor.prototype.logicalNot=function(){return this.throwIfDisposed(),opHandler.logicalNot(this)},Tensor.prototype.logicalXor=function(x){return this.throwIfDisposed(),opHandler.logicalXor(this,x)},Tensor.prototype.where=function(condition,x){return this.throwIfDisposed(),opHandler.where(condition,this,x)},Tensor.prototype.neg=function(){return this.throwIfDisposed(),opHandler.neg(this)},Tensor.prototype.ceil=function(){return this.throwIfDisposed(),opHandler.ceil(this)},Tensor.prototype.floor=function(){return this.throwIfDisposed(),opHandler.floor(this)},Tensor.prototype.sign=function(){return this.throwIfDisposed(),opHandler.sign(this)},Tensor.prototype.isNaN=function(){return this.throwIfDisposed(),opHandler.isNaN(this)},Tensor.prototype.isInf=function(){return this.throwIfDisposed(),opHandler.isInf(this)},Tensor.prototype.isFinite=function(){return this.throwIfDisposed(),opHandler.isFinite(this)},Tensor.prototype.exp=function(){return this.throwIfDisposed(),opHandler.exp(this)},Tensor.prototype.expm1=function(){return this.throwIfDisposed(),opHandler.expm1(this)},Tensor.prototype.log=function(){return this.throwIfDisposed(),opHandler.log(this)},Tensor.prototype.log1p=function(){return this.throwIfDisposed(),opHandler.log1p(this)},Tensor.prototype.sqrt=function(){return this.throwIfDisposed(),opHandler.sqrt(this)},Tensor.prototype.rsqrt=function(){return this.throwIfDisposed(),opHandler.rsqrt(this)},Tensor.prototype.square=function(){return this.throwIfDisposed(),opHandler.square(this)},Tensor.prototype.reciprocal=function(){return this.throwIfDisposed(),opHandler.reciprocal(this)},Tensor.prototype.abs=function(){return this.throwIfDisposed(),opHandler.abs(this)},Tensor.prototype.clipByValue=function(min,max){return this.throwIfDisposed(),opHandler.clipByValue(this,min,max)},Tensor.prototype.relu=function(){return this.throwIfDisposed(),opHandler.relu(this)},Tensor.prototype.relu6=function(){return this.throwIfDisposed(),opHandler.relu6(this)},Tensor.prototype.elu=function(){return this.throwIfDisposed(),opHandler.elu(this)},Tensor.prototype.selu=function(){return this.throwIfDisposed(),opHandler.selu(this)},Tensor.prototype.leakyRelu=function(alpha){return void 0===alpha&&(alpha=.2),this.throwIfDisposed(),opHandler.leakyRelu(this,alpha)},Tensor.prototype.prelu=function(alpha){return this.throwIfDisposed(),opHandler.prelu(this,alpha)},Tensor.prototype.sigmoid=function(){return this.throwIfDisposed(),opHandler.sigmoid(this)},Tensor.prototype.logSigmoid=function(){return this.throwIfDisposed(),opHandler.logSigmoid(this)},Tensor.prototype.softplus=function(){return this.throwIfDisposed(),opHandler.softplus(this)},Tensor.prototype.zerosLike=function(){return this.throwIfDisposed(),opHandler.zerosLike(this)},Tensor.prototype.onesLike=function(){return this.throwIfDisposed(),opHandler.onesLike(this)},Tensor.prototype.sin=function(){return this.throwIfDisposed(),opHandler.sin(this)},Tensor.prototype.cos=function(){return this.throwIfDisposed(),opHandler.cos(this)},Tensor.prototype.tan=function(){return this.throwIfDisposed(),opHandler.tan(this)},Tensor.prototype.asin=function(){return this.throwIfDisposed(),opHandler.asin(this)},Tensor.prototype.acos=function(){return this.throwIfDisposed(),opHandler.acos(this)},Tensor.prototype.atan=function(){return this.throwIfDisposed(),opHandler.atan(this)},Tensor.prototype.sinh=function(){return this.throwIfDisposed(),opHandler.sinh(this)},Tensor.prototype.cosh=function(){return this.throwIfDisposed(),opHandler.cosh(this)},Tensor.prototype.tanh=function(){return this.throwIfDisposed(),opHandler.tanh(this)},Tensor.prototype.asinh=function(){return this.throwIfDisposed(),opHandler.asinh(this)},Tensor.prototype.acosh=function(){return this.throwIfDisposed(),opHandler.acosh(this)},Tensor.prototype.atanh=function(){return this.throwIfDisposed(),opHandler.atanh(this)},Tensor.prototype.erf=function(){return this.throwIfDisposed(),opHandler.erf(this)},Tensor.prototype.round=function(){return this.throwIfDisposed(),opHandler.round(this)},Tensor.prototype.step=function(alpha){return void 0===alpha&&(alpha=0),this.throwIfDisposed(),opHandler.step(this,alpha)},Tensor.prototype.softmax=function(dim){return void 0===dim&&(dim=-1),this.throwIfDisposed(),opHandler.softmax(this,dim)},Tensor.prototype.logSoftmax=function(axis){return void 0===axis&&(axis=-1),this.throwIfDisposed(),opHandler.logSoftmax(this,axis)},Tensor.prototype.resizeBilinear=function(newShape2D,alignCorners){return void 0===alignCorners&&(alignCorners=!1),this.throwIfDisposed(),opHandler.image.resizeBilinear(this,newShape2D,alignCorners)},Tensor.prototype.resizeNearestNeighbor=function(newShape2D,alignCorners){return void 0===alignCorners&&(alignCorners=!1),this.throwIfDisposed(),opHandler.image.resizeNearestNeighbor(this,newShape2D,alignCorners)},Tensor.prototype.conv1d=function(filter,stride,pad,dataFormat,dilation,dimRoundingMode){return void 0===dataFormat&&(dataFormat="NWC"),void 0===dilation&&(dilation=1),this.throwIfDisposed(),opHandler.conv1d(this,filter,stride,pad,dataFormat,dilation,dimRoundingMode)},Tensor.prototype.conv2d=function(filter,strides,pad,dataFormat,dilations,dimRoundingMode){return void 0===dataFormat&&(dataFormat="NHWC"),void 0===dilations&&(dilations=[1,1]),this.throwIfDisposed(),opHandler.conv2d(this,filter,strides,pad,dataFormat,dilations,dimRoundingMode)},Tensor.prototype.conv2dTranspose=function(filter,outputShape,strides,pad,dimRoundingMode){return this.throwIfDisposed(),opHandler.conv2dTranspose(this,filter,outputShape,strides,pad,dimRoundingMode)},Tensor.prototype.depthwiseConv2D=function(filter,strides,pad,dataFormat,dilations,dimRoundingMode){return void 0===dataFormat&&(dataFormat="NHWC"),void 0===dilations&&(dilations=[1,1]),this.throwIfDisposed(),opHandler.depthwiseConv2d(this,filter,strides,pad,dataFormat,dilations,dimRoundingMode)},Tensor.prototype.separableConv2d=function(depthwiseFilter,pointwiseFilter,strides,pad,dilation,dataFormat){return void 0===dilation&&(dilation=[1,1]),void 0===dataFormat&&(dataFormat="NHWC"),this.throwIfDisposed(),opHandler.separableConv2d(this,depthwiseFilter,pointwiseFilter,strides,pad,dilation,dataFormat)},Tensor.prototype.avgPool=function(filterSize,strides,pad,dimRoundingMode){return this.throwIfDisposed(),opHandler.avgPool(this,filterSize,strides,pad,dimRoundingMode)},Tensor.prototype.maxPool=function(filterSize,strides,pad,dimRoundingMode){return this.throwIfDisposed(),opHandler.maxPool(this,filterSize,strides,pad,dimRoundingMode)},Tensor.prototype.localResponseNormalization=function(radius,bias,alpha,beta){return void 0===radius&&(radius=5),void 0===bias&&(bias=1),void 0===alpha&&(alpha=1),void 0===beta&&(beta=.5),opHandler.localResponseNormalization(this,radius,bias,alpha,beta)},Tensor.prototype.pool=function(windowShape,poolingType,padding,dilationRate,strides){return this.throwIfDisposed(),opHandler.pool(this,windowShape,poolingType,padding,dilationRate,strides)},Tensor.prototype.variable=function(trainable,name,dtype){return void 0===trainable&&(trainable=!0),this.throwIfDisposed(),trackerFn().makeVariable(this,trainable,name,dtype)},Tensor.prototype.unsortedSegmentSum=function(segmentIds,numSegments){return this.throwIfDisposed(),opHandler.unsortedSegmentSum(this,segmentIds,numSegments)},Tensor.prototype.batchToSpaceND=function(blockShape,crops){return this.throwIfDisposed(),opHandler.batchToSpaceND(this,blockShape,crops)},Tensor.prototype.spaceToBatchND=function(blockShape,paddings){return this.throwIfDisposed(),opHandler.spaceToBatchND(this,blockShape,paddings)},Tensor.prototype.topk=function(k,sorted){return void 0===k&&(k=1),void 0===sorted&&(sorted=!0),this.throwIfDisposed(),opHandler.topk(this,k,sorted)},Tensor.prototype.stridedSlice=function(begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask){return void 0===beginMask&&(beginMask=0),void 0===endMask&&(endMask=0),void 0===ellipsisMask&&(ellipsisMask=0),void 0===newAxisMask&&(newAxisMask=0),void 0===shrinkAxisMask&&(shrinkAxisMask=0),this.throwIfDisposed(),opHandler.stridedSlice(this,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask)},Tensor.prototype.depthToSpace=function(blockSize,dataFormat){return this.throwIfDisposed(),opHandler.depthToSpace(this,blockSize,dataFormat)},Tensor.prototype.fft=function(){return this.throwIfDisposed(),opHandler.spectral.fft(this)},Tensor.prototype.ifft=function(){return this.throwIfDisposed(),opHandler.spectral.ifft(this)},Tensor.prototype.rfft=function(){return this.throwIfDisposed(),opHandler.spectral.rfft(this)},Tensor.prototype.irfft=function(){return this.throwIfDisposed(),opHandler.spectral.irfft(this)},Tensor}();Object.defineProperty(Tensor,Symbol.hasInstance,{value:function(instance){return!!instance&&null!=instance.dataId&&null!=instance.shape&&null!=instance.dtype}});var Variable=function(_super){function Variable(initialValue,trainable,name,tensorId){var _this=_super.call(this,initialValue.shape,initialValue.dtype,initialValue.dataId,tensorId)||this;return _this.trainable=trainable,_this.name=name,_this}return __extends(Variable,_super),Variable.prototype.assign=function(newValue){if(newValue.dtype!==this.dtype)throw new Error("dtype of the new value ("+newValue.dtype+") and previous value ("+this.dtype+") must match");if(!arraysEqual(newValue.shape,this.shape))throw new Error("shape of the new value ("+newValue.shape+") and previous value ("+this.shape+") must match");trackerFn().disposeTensor(this),this.dataId=newValue.dataId,trackerFn().incRef(this,null)},Variable.prototype.dispose=function(){trackerFn().disposeVariable(this),this.isDisposedInternal=!0},Variable}(Tensor),Rank,UpcastInt32AndMap,UpcastBoolAndMap,UpcastFloat32AndMap,UpcastComplex64AndMap;Object.defineProperty(Variable,Symbol.hasInstance,{value:function(instance){return instance instanceof Tensor&&null!=instance.assign&&instance.assign instanceof Function}}),(Rank=exports.Rank||(exports.Rank={})).R0="R0",Rank.R1="R1",Rank.R2="R2",Rank.R3="R3",Rank.R4="R4",Rank.R5="R5",Rank.R6="R6",function(UpcastInt32AndMap){UpcastInt32AndMap.float32="float32",UpcastInt32AndMap.int32="int32",UpcastInt32AndMap.bool="int32",UpcastInt32AndMap.complex64="complex64"}(UpcastInt32AndMap||(UpcastInt32AndMap={})),function(UpcastBoolAndMap){UpcastBoolAndMap.float32="float32",UpcastBoolAndMap.int32="int32",UpcastBoolAndMap.bool="bool",UpcastBoolAndMap.complex64="complex64"}(UpcastBoolAndMap||(UpcastBoolAndMap={})),function(UpcastFloat32AndMap){UpcastFloat32AndMap.float32="float32",UpcastFloat32AndMap.int32="float32",UpcastFloat32AndMap.bool="float32",UpcastFloat32AndMap.complex64="complex64"}(UpcastFloat32AndMap||(UpcastFloat32AndMap={})),function(UpcastComplex64AndMap){UpcastComplex64AndMap.float32="complex64",UpcastComplex64AndMap.int32="complex64",UpcastComplex64AndMap.bool="complex64",UpcastComplex64AndMap.complex64="complex64"}(UpcastComplex64AndMap||(UpcastComplex64AndMap={}));var upcastTypeMap={float32:UpcastFloat32AndMap,int32:UpcastInt32AndMap,bool:UpcastBoolAndMap,complex64:UpcastComplex64AndMap};function upcastType(typeA,typeB){if("string"===typeA||"string"===typeB){if("string"===typeA&&"string"===typeB)return"string";throw new Error("Can not upcast "+typeA+" with "+typeB)}return upcastTypeMap[typeA][typeB]}function sumOutType(type){return upcastType(type,"int32")}function makeTypesMatch(a,b){if(a.dtype===b.dtype)return[a,b];var dtype=upcastType(a.dtype,b.dtype);return[a.cast(dtype),b.cast(dtype)]}function assertTypesMatch(a,b){assert(a.dtype===b.dtype,function(){return"The dtypes of the first("+a.dtype+") and second("+b.dtype+") input must match"})}function isTensorInList(tensor,tensorList){return tensorList.some(function(x){return x.id===tensor.id})}function getTensorsInContainer(result){var list=[],seen;return walkTensorContainer(result,list,new Set),list}function walkTensorContainer(container,list,seen){if(null!=container)if(container instanceof Tensor)list.push(container);else if(isIterable(container)){var iterable=container;for(var k in iterable){var val=iterable[k];seen.has(val)||(seen.add(val),walkTensorContainer(val,list,seen))}}}function isIterable(obj){return Array.isArray(obj)||"object"==typeof obj}var tensor_util=Object.freeze({makeTypesMatch:makeTypesMatch,assertTypesMatch:assertTypesMatch,isTensorInList:isTensorInList,getTensorsInContainer:getTensorsInContainer}),EngineState=function(){function EngineState(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}return EngineState.prototype.dispose=function(){for(var variableName in this.registeredVariables)this.registeredVariables[variableName].dispose()},EngineState}(),Engine=function(){function Engine(ENV){this.ENV=ENV,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new EngineState}return Engine.prototype.ready=function(){return __awaiter(this,void 0,void 0,function(){var sortedBackends,i,backendName,success;return __generator(this,function(_a){switch(_a.label){case 0:if(null!=this.pendingBackendInit)return[2,this.pendingBackendInit.then(function(){})];if(null!=this.backendInstance)return[2];sortedBackends=this.getSortedBackends(),i=0,_a.label=1;case 1:return i<sortedBackends.length?(backendName=sortedBackends[i],[4,this.initializeBackend(backendName).success]):[3,5];case 2:return(success=_a.sent())?[4,this.setBackend(backendName)]:[3,4];case 3:return _a.sent(),[2];case 4:return i++,[3,1];case 5:throw new Error("Could not initialize any backends, all backend initializations failed.")}})})},Object.defineProperty(Engine.prototype,"backend",{get:function(){if(null!=this.pendingBackendInit)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){var _a=this.initializeBackendsAndReturnBest(),name_1=_a.name,asyncInit;if(_a.asyncInit)throw new Error("The highest priority backend '"+name_1+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(name_1)}return this.backendInstance},enumerable:!0,configurable:!0}),Engine.prototype.backendNames=function(){return Object.keys(this.registryFactory)},Engine.prototype.findBackend=function(backendName){if(!(backendName in this.registry)){if(!(backendName in this.registryFactory))return null;var asyncInit;if(this.initializeBackend(backendName).asyncInit)return null}return this.registry[backendName]},Engine.prototype.findBackendFactory=function(backendName){return backendName in this.registryFactory?this.registryFactory[backendName].factory:null},Engine.prototype.registerBackend=function(backendName,factory,priority){return void 0===priority&&(priority=1),backendName in this.registryFactory?(console.warn(backendName+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[backendName]={factory:factory,priority:priority},!0)},Engine.prototype.setBackend=function(backendName){return __awaiter(this,void 0,void 0,function(){var _a,success,asyncInit,result,_b;return __generator(this,function(_c){switch(_c.label){case 0:if(null==this.registryFactory[backendName])throw new Error("Backend name '"+backendName+"' not found in registry");return this.backendName=backendName,null!=this.registry[backendName]?[3,4]:(this.backendInstance=null,_a=this.initializeBackend(backendName),success=_a.success,(asyncInit=_a.asyncInit)?[4,success]:[3,2]);case 1:return _b=_c.sent(),[3,3];case 2:_b=success,_c.label=3;case 3:if(!(result=_b))return[2,!1];_c.label=4;case 4:return this.backendInstance=this.registry[backendName],this.setupRegisteredKernels(),this.profiler=new Profiler(this.backendInstance),[2,!0]}})})},Engine.prototype.setupRegisteredKernels=function(){var _this=this,kernels;getKernelsForBackend(this.backendName).forEach(function(kernel){null!=kernel.setupFunc&&kernel.setupFunc(_this.backendInstance)})},Engine.prototype.disposeRegisteredKernels=function(backendName){var _this=this,kernels;getKernelsForBackend(backendName).forEach(function(kernel){null!=kernel.disposeFunc&&kernel.disposeFunc(_this.registry[backendName])})},Engine.prototype.initializeBackend=function(backendName){var _this=this,registryFactoryEntry=this.registryFactory[backendName];if(null==registryFactoryEntry)throw new Error("Cannot initialize backend "+backendName+", no registration found.");try{var backend=registryFactoryEntry.factory();if(Promise.resolve(backend)===backend){var promiseId_1=++this.pendingBackendInitId,success=backend.then(function(backendInstance){return!(promiseId_1<_this.pendingBackendInitId)&&(_this.registry[backendName]=backendInstance,_this.pendingBackendInit=null,!0)}).catch(function(err){return!(promiseId_1<_this.pendingBackendInitId)&&(_this.pendingBackendInit=null,console.warn("Initialization of backend "+backendName+" failed"),console.warn(err.stack||err.message),!1)});return this.pendingBackendInit=success,{success:success,asyncInit:!0}}return this.registry[backendName]=backend,{success:!0,asyncInit:!1}}catch(err){return console.warn("Initialization of backend "+backendName+" failed"),console.warn(err.stack||err.message),{success:!1,asyncInit:!1}}},Engine.prototype.removeBackend=function(backendName){if(!(backendName in this.registryFactory))throw new Error(backendName+" backend not found in registry");this.backendName===backendName&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,backendName in this.registry&&(this.disposeRegisteredKernels(backendName),this.registry[backendName].dispose(),delete this.registry[backendName]),delete this.registryFactory[backendName],this.backendName===backendName&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)},Engine.prototype.getSortedBackends=function(){var _this=this;if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(function(a,b){return _this.registryFactory[b].priority-_this.registryFactory[a].priority})},Engine.prototype.initializeBackendsAndReturnBest=function(){for(var sortedBackends=this.getSortedBackends(),i=0;i<sortedBackends.length;i++){var backendName=sortedBackends[i],_a=this.initializeBackend(backendName),success=_a.success,asyncInit=_a.asyncInit;if(asyncInit||success)return{name:backendName,asyncInit:asyncInit}}throw new Error("Could not initialize any backends, all backend initializations failed.")},Engine.prototype.moveData=function(destBackend,dataId){var info=this.state.tensorInfo.get(dataId),srcBackend=info.backend,values=this.readSync(dataId);srcBackend.disposeData(dataId),info.backend=destBackend,destBackend.move(dataId,values,info.shape,info.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++},Engine.prototype.tidy=function(nameOrFn,fn){var _this=this,name=null,result;if(null==fn){if("function"!=typeof nameOrFn)throw new Error("Please provide a function to tidy()");fn=nameOrFn}else{if("string"!=typeof nameOrFn&&!(nameOrFn instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof fn)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");name=nameOrFn}return this.scopedRun(function(){return _this.startScope(name)},function(){return _this.endScope(result)},function(){return(result=fn())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),result})},Engine.prototype.scopedRun=function(start,end,f){start();try{var res=f();return end(),res}catch(ex){throw end(),ex}},Engine.prototype.nextTensorId=function(){return Engine.nextTensorId++},Engine.prototype.nextVariableId=function(){return Engine.nextVariableId++},Engine.prototype.clone=function(x){var y=this.makeTensorFromDataId(x.dataId,x.shape,x.dtype),inputs={x:x},grad=function(dy){return{x:function(){return dy.toFloat()}}},saved=[];return this.addTapeNode(this.state.activeScope.name,inputs,[y],grad,saved,{}),y},Engine.prototype.runKernel=function(kernelName,inputs,attrs,inputsToSave,outputsToSave){var forwardFunc=null,backwardsFunc=null;return this.runKernelFunc(null,inputs,null,kernelName,attrs,inputsToSave,outputsToSave)},Engine.prototype.shouldCheckForMemLeaks=function(){return this.ENV.getBool("IS_TEST")},Engine.prototype.checkKernelForMemLeak=function(kernelName,numDataIdsBefore,outInfos){var numDataIdsAfter=this.backend.numDataIds(),numOutputDataIds=0;outInfos.forEach(function(info){numOutputDataIds+="complex64"===info.dtype?3:1});var numMoves=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],dataIdsLeaked=numDataIdsAfter-numDataIdsBefore-numOutputDataIds-numMoves;if(dataIdsLeaked>0)throw new Error("Backend '"+this.backendName+"' has an internal memory leak ("+dataIdsLeaked+" data ids) after running '"+kernelName+"'")},Engine.prototype.runKernelFunc=function(forwardFunc,inputs,backwardsFunc,kernelName,attrs,inputsToSave,outputsToSave){var _this=this,outputs,saved=[],isTapeOn=this.isTapeOn();null==kernelName&&(kernelName=null!=this.state.activeScope?this.state.activeScope.name:"");var startingBytecount=this.state.numBytes,startingNumTensors=this.state.numTensors,kernelFunc;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);var kernel=getKernel(kernelName,this.backendName),out;if(null!=kernel)kernelFunc=function(){var numDataIdsBefore=_this.backend.numDataIds();out=kernel.kernelFunc({inputs:inputs,attrs:attrs,backend:_this.backend});var outInfos=Array.isArray(out)?out:[out];_this.shouldCheckForMemLeaks()&&_this.checkKernelForMemLeak(kernelName,numDataIdsBefore,outInfos);var outTensors=outInfos.map(function(_a){var dataId=_a.dataId,shape=_a.shape,dtype=_a.dtype;return _this.makeTensorFromDataId(dataId,shape,dtype)});if(isTapeOn){var tensorsToSave=_this.getTensorsForGradient(kernelName,inputs,outTensors);if(null==tensorsToSave){null==outputsToSave&&(outputsToSave=[]);var outsToSave=outTensors.filter(function(_,i){return outputsToSave[i]});tensorsToSave=(inputsToSave||[]).slice().concat(outsToSave)}saved=_this.saveTensorsForBackwardMode(tensorsToSave)}return outTensors};else{var saveFunc_1=function(tensors){isTapeOn&&(saved=tensors.map(function(tensor){return _this.keep(_this.clone(tensor))}))};kernelFunc=function(){var numDataIdsBefore=_this.backend.numDataIds();out=_this.tidy(function(){return forwardFunc(_this.backend,saveFunc_1)});var outs=Array.isArray(out)?out:[out];return _this.shouldCheckForMemLeaks()&&_this.checkKernelForMemLeak(kernelName,numDataIdsBefore,outs),outs}}return this.scopedRun(function(){return _this.state.kernelDepth++},function(){return _this.state.kernelDepth--},function(){outputs=_this.ENV.getBool("DEBUG")?_this.profiler.profileKernel(kernelName,inputs,function(){return kernelFunc()}):kernelFunc()}),isTapeOn&&this.addTapeNode(kernelName,inputs,outputs,backwardsFunc,saved,attrs),this.state.profiling&&this.state.activeProfile.kernels.push({name:kernelName,bytesAdded:this.state.numBytes-startingBytecount,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-startingNumTensors,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(inputs).map(function(key){return inputs[key].shape}),outputShapes:outputs.map(function(item){return item.shape})}),Array.isArray(out)?outputs:outputs[0]},Engine.prototype.saveTensorsForBackwardMode=function(tensors){var _this=this,saved;return tensors.map(function(tensor){return _this.keep(_this.clone(tensor))})},Engine.prototype.getTensorsForGradient=function(kernelName,inputs,outputs){var gradConfig=getGradient(kernelName);if(null!=gradConfig){var inputsToSave=gradConfig.inputsToSave||[],outputsToSave_1=gradConfig.outputsToSave||[],inputTensorsToSave=void 0;gradConfig.saveAllInputs?(assert(Array.isArray(inputs),function(){return"saveAllInputs is true, expected inputs to be an array."}),inputTensorsToSave=Object.keys(inputs).map(function(key){return inputs[key]})):inputTensorsToSave=inputsToSave.map(function(inputName){return inputs[inputName]});var outputTensorsToSave=outputs.filter(function(_,i){return outputsToSave_1[i]});return inputTensorsToSave.concat(outputTensorsToSave)}return null},Engine.prototype.makeTensor=function(values,shape,dtype,backend){if(null==values)throw new Error("Values passed to engine.makeTensor() are null");dtype=dtype||"float32",backend=backend||this.backend;var backendVals=values;"string"===dtype&&isString(values[0])&&(backendVals=values.map(function(d){return encodeString(d)}));var dataId=backend.write(backendVals,shape,dtype),t=new Tensor(shape,dtype,dataId,this.nextTensorId());if(this.incRef(t,backend),"string"===dtype){var info=this.state.tensorInfo.get(dataId),newBytes=bytesFromStringArray(backendVals);this.state.numBytes+=newBytes-info.bytes,info.bytes=newBytes}return t},Engine.prototype.makeTensorFromDataId=function(dataId,shape,dtype,backend){var t=new Tensor(shape,dtype=dtype||"float32",dataId,this.nextTensorId());return this.incRef(t,backend),t},Engine.prototype.makeVariable=function(initialValue,trainable,name,dtype){void 0===trainable&&(trainable=!0),name=name||this.nextVariableId().toString(),null!=dtype&&dtype!==initialValue.dtype&&(initialValue=initialValue.asType(dtype));var v=new Variable(initialValue,trainable,name,this.nextTensorId());if(null!=this.state.registeredVariables[v.name])throw new Error("Variable with name "+v.name+" was already registered");return this.state.registeredVariables[v.name]=v,this.incRef(v,this.backend),v},Engine.prototype.incRef=function(a,backend){var refCount=this.state.tensorInfo.has(a.dataId)?this.state.tensorInfo.get(a.dataId).refCount:0;if(this.state.numTensors++,"string"===a.dtype&&this.state.numStringTensors++,0===refCount){this.state.numDataBuffers++;var bytes=0;"complex64"!==a.dtype&&"string"!==a.dtype&&(bytes=a.size*bytesPerElement(a.dtype)),this.state.tensorInfo.set(a.dataId,{backend:backend||this.backend,dtype:a.dtype,shape:a.shape,bytes:bytes,refCount:0}),this.state.numBytes+=bytes}this.state.tensorInfo.get(a.dataId).refCount++,a instanceof Variable||this.track(a)},Engine.prototype.disposeTensor=function(a){if(this.state.tensorInfo.has(a.dataId)){this.state.numTensors--,"string"===a.dtype&&this.state.numStringTensors--;var info=this.state.tensorInfo.get(a.dataId),refCount;info.refCount<=1?("complex64"!==a.dtype&&(this.state.numBytes-=info.bytes),this.state.numDataBuffers--,info.backend.disposeData(a.dataId),this.state.tensorInfo.delete(a.dataId)):this.state.tensorInfo.get(a.dataId).refCount--}},Engine.prototype.disposeVariables=function(){for(var varName in this.state.registeredVariables){var v=this.state.registeredVariables[varName];this.disposeVariable(v)}},Engine.prototype.disposeVariable=function(v){this.disposeTensor(v),null!=this.state.registeredVariables[v.name]&&delete this.state.registeredVariables[v.name]},Engine.prototype.memory=function(){var info=this.backend.memory();return info.numTensors=this.state.numTensors,info.numDataBuffers=this.state.numDataBuffers,info.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(info.unreliable=!0,null==info.reasons&&(info.reasons=[]),info.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),info},Engine.prototype.profile=function(query){return __awaiter(this,void 0,void 0,function(){var startBytes,startNumTensors;return __generator(this,function(_a){return this.state.profiling=!0,startBytes=this.state.numBytes,startNumTensors=this.state.numTensors,this.state.activeProfile.kernels=[],this.state.activeProfile.result=query(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max.apply(Math,this.state.activeProfile.kernels.map(function(d){return d.totalBytesSnapshot})),this.state.activeProfile.newBytes=this.state.numBytes-startBytes,this.state.activeProfile.newTensors=this.state.numTensors-startNumTensors,[2,this.state.activeProfile]})})},Engine.prototype.isTapeOn=function(){return this.state.gradientDepth>0&&0===this.state.kernelDepth},Engine.prototype.addTapeNode=function(kernelName,inputs,outputs,gradientsFunc,saved,attrs){var _this=this,tapeNode={id:this.state.nextTapeNodeId++,kernelName:kernelName,inputs:inputs,outputs:outputs,saved:saved},gradConfig=getGradient(kernelName);null!=gradConfig&&(gradientsFunc=gradConfig.gradFunc),null!=gradientsFunc&&(tapeNode.gradient=function(dys){return dys=dys.map(function(dy,i){if(null==dy){var output=outputs[i],vals=makeZerosTypedArray(output.size,output.dtype);return _this.makeTensor(vals,output.shape,output.dtype)}return dy}),gradientsFunc(dys.length>1?dys:dys[0],saved,attrs)}),this.state.activeTape.push(tapeNode)},Engine.prototype.keep=function(result){return result.kept=!0,result},Engine.prototype.startTape=function(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++},Engine.prototype.endTape=function(){this.state.gradientDepth--},Engine.prototype.startScope=function(name){var scopeInfo={track:[],name:"unnamed scope",id:this.state.nextScopeId++};name&&(scopeInfo.name=name),this.state.scopeStack.push(scopeInfo),this.state.activeScope=scopeInfo},Engine.prototype.endScope=function(result){for(var _this=this,tensorsToTrackInParent=getTensorsInContainer(result),tensorsToTrackInParentSet=new Set(tensorsToTrackInParent.map(function(t){return t.id})),i=0;i<this.state.activeScope.track.length;i++){var tensor=this.state.activeScope.track[i];tensor.kept||tensorsToTrackInParentSet.has(tensor.id)||tensor.dispose()}var oldScope=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],tensorsToTrackInParent.forEach(function(tensor){tensor.kept||tensor.scopeId!==oldScope.id||_this.track(tensor)})},Engine.prototype.gradients=function(f,xs,dy,allowNoGradients){var _this=this;if(void 0===allowNoGradients&&(allowNoGradients=!1),assert(xs.length>0,function(){return"gradients() received an empty list of xs."}),null!=dy&&"float32"!==dy.dtype)throw new Error("dy must have 'float32' dtype, but has '"+dy.dtype+"'");var y=this.scopedRun(function(){return _this.startTape()},function(){return _this.endTape()},function(){return _this.tidy("forward",f)});assert(y instanceof Tensor,function(){return"The result y returned by f() must be a tensor."});var filteredTape=getFilteredNodesXToY(this.state.activeTape,xs,y);if(!allowNoGradients&&0===filteredTape.length&&xs.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",function(){var accumulatedGradientMap={};accumulatedGradientMap[y.id]=null==dy?ones(y.shape):dy,backpropagateGradients(accumulatedGradientMap,filteredTape,function(f){return _this.tidy(f)});var grads=xs.map(function(x){return accumulatedGradientMap[x.id]});return 0===_this.state.gradientDepth&&(_this.state.activeTape.forEach(function(node){for(var _i=0,_a=node.saved;_i<_a.length;_i++){var tensor;_a[_i].dispose()}}),_this.state.activeTape=null),{value:y,grads:grads}})},Engine.prototype.customGrad=function(f){var _this=this;return assert(isFunction(f),function(){return"The f passed in customGrad(f) must be a function."}),function(){for(var inputs=[],_i=0,res;_i<arguments.length;_i++)inputs[_i]=arguments[_i];assert(inputs.every(function(t){return t instanceof Tensor}),function(){return"The args passed in customGrad(f)(x1, x2,...) must all be tensors"});var inputMap={};return inputs.forEach(function(input,i){inputMap[i]=input}),_this.runKernelFunc(function(_,save){return assert((res=f.apply(void 0,inputs.concat([save]))).value instanceof Tensor,function(){return"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"}),assert(isFunction(res.gradFunc),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."}),res.value},inputMap,function(dy,saved){var gradRes=res.gradFunc(dy,saved),grads=Array.isArray(gradRes)?gradRes:[gradRes];assert(grads.length===inputs.length,function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."}),assert(grads.every(function(t){return t instanceof Tensor}),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."});var gradMap={};return grads.forEach(function(grad,i){gradMap[i]=function(){return grad}}),gradMap})}},Engine.prototype.readSync=function(dataId){var info;return this.state.tensorInfo.get(dataId).backend.readSync(dataId)},Engine.prototype.read=function(dataId){var info;return this.state.tensorInfo.get(dataId).backend.read(dataId)},Engine.prototype.time=function(query){return __awaiter(this,void 0,void 0,function(){var start,timingInfo;return __generator(this,function(_a){switch(_a.label){case 0:return start=now(),[4,this.backend.time(query)];case 1:return(timingInfo=_a.sent()).wallMs=now()-start,[2,timingInfo]}})})},Engine.prototype.track=function(result){return null!=this.state.activeScope&&(result.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(result)),result},Object.defineProperty(Engine.prototype,"registeredVariables",{get:function(){return this.state.registeredVariables},enumerable:!0,configurable:!0}),Engine.prototype.reset=function(){for(var backendName in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new EngineState,this.registry)this.disposeRegisteredKernels(backendName),this.registry[backendName].dispose(),delete this.registry[backendName];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null},Engine.nextTensorId=0,Engine.nextVariableId=0,Engine}(),GLOBAL;function ones(shape){var values=makeOnesTypedArray(sizeFromShape(shape),"float32");return ENGINE.makeTensor(values,shape,"float32")}function getGlobalNamespace(){if(null==GLOBAL){var ns=void 0;if("undefined"!=typeof window)ns=window;else if("undefined"!=typeof global)ns=global;else if("undefined"!=typeof process)ns=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");ns=self}GLOBAL=ns}return GLOBAL}function getOrMakeEngine(){var ns=getGlobalNamespace();if(null==ns._tfengine){var environment=new Environment(ns);ns._tfengine=new Engine(environment)}return setEnvironmentGlobal(ns._tfengine.ENV),setTensorTracker(function(){return ns._tfengine}),ns._tfengine}var ENGINE=getOrMakeEngine();function isMobile(){var a=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))}function isBrowser(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var ENV=env();ENV.registerFlag("DEBUG",function(){return!1},function(debugValue){debugValue&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ENV.registerFlag("IS_BROWSER",function(){return isBrowser()}),ENV.registerFlag("IS_NODE",function(){return"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node}),ENV.registerFlag("IS_CHROME",function(){return"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)}),ENV.registerFlag("PROD",function(){return!1}),ENV.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",function(){return ENV.getBool("DEBUG")}),ENV.registerFlag("DEPRECATION_WARNINGS_ENABLED",function(){return!0}),ENV.registerFlag("IS_TEST",function(){return!1});var contexts={},WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0},PackingScheme,TextureUsage,PhysicalTextureType;function setWebGLContext(webGLVersion,gl){contexts[webGLVersion]=gl}function getWebGLContext(webGLVersion){webGLVersion in contexts||(contexts[webGLVersion]=getWebGLRenderingContext(webGLVersion));var gl=contexts[webGLVersion];return gl.isContextLost()?(delete contexts[webGLVersion],getWebGLContext(webGLVersion)):(gl.disable(gl.DEPTH_TEST),gl.disable(gl.STENCIL_TEST),gl.disable(gl.BLEND),gl.disable(gl.DITHER),gl.disable(gl.POLYGON_OFFSET_FILL),gl.disable(gl.SAMPLE_COVERAGE),gl.enable(gl.SCISSOR_TEST),gl.enable(gl.CULL_FACE),gl.cullFace(gl.BACK),contexts[webGLVersion])}function createCanvas(webGLVersion){if("undefined"!=typeof OffscreenCanvas&&2===webGLVersion)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function getWebGLRenderingContext(webGLVersion){if(1!==webGLVersion&&2!==webGLVersion)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");var canvas=createCanvas(webGLVersion);return canvas.addEventListener("webglcontextlost",function(ev){ev.preventDefault(),delete contexts[webGLVersion]},!1),1===webGLVersion?canvas.getContext("webgl",WEBGL_ATTRIBUTES)||canvas.getContext("experimental-webgl",WEBGL_ATTRIBUTES):canvas.getContext("webgl2",WEBGL_ATTRIBUTES)}function getUnpackedMatrixTextureShapeWidthHeight(rows,columns){return[columns,rows]}function getUnpackedArraySizeFromMatrixSize(matrixSize,channelsPerTexture){return matrixSize*channelsPerTexture}function getDenseTexShape(shape){var size=sizeFromShape(shape),texelsNeeded;return sizeToSquarishShape(Math.ceil(size/4))}function getPackedMatrixTextureShapeWidthHeight(rows,columns){return[Math.max(1,Math.ceil(columns/2)),Math.max(1,Math.ceil(rows/2))]}function getPackedRGBAArraySizeFromMatrixShape(rows,columns){var _a=getPackedMatrixTextureShapeWidthHeight(rows,columns),w,h;return _a[0]*_a[1]*4}function getTextureConfig(gl,textureHalfFloatExtension){var glany=gl,internalFormatFloat,internalFormatHalfFloat,internalFormatPackedHalfFloat,internalFormatPackedFloat,textureFormatFloat,downloadTextureFormat,downloadUnpackNumChannels,defaultNumChannels,textureTypeHalfFloat,textureTypeFloat;return 2===env().getNumber("WEBGL_VERSION")?(internalFormatFloat=glany.R32F,internalFormatHalfFloat=glany.R16F,internalFormatPackedHalfFloat=glany.RGBA16F,internalFormatPackedFloat=glany.RGBA32F,textureFormatFloat=glany.RED,downloadUnpackNumChannels=4,defaultNumChannels=1,textureTypeHalfFloat=glany.HALF_FLOAT,textureTypeFloat=glany.FLOAT):(internalFormatFloat=gl.RGBA,internalFormatHalfFloat=gl.RGBA,internalFormatPackedHalfFloat=gl.RGBA,internalFormatPackedFloat=glany.RGBA,textureFormatFloat=gl.RGBA,downloadUnpackNumChannels=4,defaultNumChannels=4,textureTypeHalfFloat=null!=textureHalfFloatExtension?textureHalfFloatExtension.HALF_FLOAT_OES:null,textureTypeFloat=gl.FLOAT),{internalFormatFloat:internalFormatFloat,internalFormatHalfFloat:internalFormatHalfFloat,internalFormatPackedHalfFloat:internalFormatPackedHalfFloat,internalFormatPackedFloat:internalFormatPackedFloat,textureFormatFloat:textureFormatFloat,downloadTextureFormat:downloadTextureFormat=gl.RGBA,downloadUnpackNumChannels:downloadUnpackNumChannels,defaultNumChannels:defaultNumChannels,textureTypeHalfFloat:textureTypeHalfFloat,textureTypeFloat:textureTypeFloat}}function callAndCheck(gl,debugMode,func){var returnValue=func();return debugMode&&checkWebGLError(gl),returnValue}function checkWebGLError(gl){var error=gl.getError();if(error!==gl.NO_ERROR)throw new Error("WebGL Error: "+getWebGLErrorMessage(gl,error))}!function(PackingScheme){PackingScheme[PackingScheme.DENSE=0]="DENSE",PackingScheme[PackingScheme.SHARED_BATCH=1]="SHARED_BATCH"}(PackingScheme||(PackingScheme={})),function(TextureUsage){TextureUsage[TextureUsage.RENDER=0]="RENDER",TextureUsage[TextureUsage.UPLOAD=1]="UPLOAD",TextureUsage[TextureUsage.PIXELS=2]="PIXELS",TextureUsage[TextureUsage.DOWNLOAD=3]="DOWNLOAD"}(TextureUsage||(TextureUsage={})),function(PhysicalTextureType){PhysicalTextureType[PhysicalTextureType.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",PhysicalTextureType[PhysicalTextureType.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",PhysicalTextureType[PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",PhysicalTextureType[PhysicalTextureType.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",PhysicalTextureType[PhysicalTextureType.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(PhysicalTextureType||(PhysicalTextureType={}));var MIN_FLOAT16=5.96e-8,MAX_FLOAT16=65504;function canBeRepresented(num){return!!(env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===num||MIN_FLOAT16<Math.abs(num)&&Math.abs(num)<MAX_FLOAT16)}function getWebGLErrorMessage(gl,status){switch(status){case gl.NO_ERROR:return"NO_ERROR";case gl.INVALID_ENUM:return"INVALID_ENUM";case gl.INVALID_VALUE:return"INVALID_VALUE";case gl.INVALID_OPERATION:return"INVALID_OPERATION";case gl.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case gl.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case gl.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+status}}function getExtensionOrThrow(gl,debug,extensionName){return throwIfNull(gl,debug,function(){return gl.getExtension(extensionName)},'Extension "'+extensionName+'" not supported on this browser.')}function createVertexShader(gl,debug,vertexShaderSource){var vertexShader=throwIfNull(gl,debug,function(){return gl.createShader(gl.VERTEX_SHADER)},"Unable to create vertex WebGLShader.");if(callAndCheck(gl,debug,function(){return gl.shaderSource(vertexShader,vertexShaderSource)}),callAndCheck(gl,debug,function(){return gl.compileShader(vertexShader)}),!1===gl.getShaderParameter(vertexShader,gl.COMPILE_STATUS))throw console.log(gl.getShaderInfoLog(vertexShader)),new Error("Failed to compile vertex shader.");return vertexShader}function createFragmentShader(gl,debug,fragmentShaderSource){var fragmentShader=throwIfNull(gl,debug,function(){return gl.createShader(gl.FRAGMENT_SHADER)},"Unable to create fragment WebGLShader.");if(callAndCheck(gl,debug,function(){return gl.shaderSource(fragmentShader,fragmentShaderSource)}),callAndCheck(gl,debug,function(){return gl.compileShader(fragmentShader)}),!1===gl.getShaderParameter(fragmentShader,gl.COMPILE_STATUS))throw logShaderSourceAndInfoLog(fragmentShaderSource,gl.getShaderInfoLog(fragmentShader)),new Error("Failed to compile fragment shader.");return fragmentShader}var lineNumberRegex=/ERROR: [0-9]+:([0-9]+):/g,MAX_TEXTURE_SIZE,MAX_TEXTURES_IN_SHADER;function logShaderSourceAndInfoLog(shaderSource,shaderInfoLog){var lineNumberRegexResult=lineNumberRegex.exec(shaderInfoLog);if(null==lineNumberRegexResult)return console.log("Couldn't parse line number in error: "+shaderInfoLog),void console.log(shaderSource);for(var lineNumber=+lineNumberRegexResult[1],shaderLines=shaderSource.split("\n"),pad=shaderLines.length.toString().length+2,linesWithLineNumbers=shaderLines.map(function(line,lineNumber){return rightPad((lineNumber+1).toString(),pad)+line}),maxLineLength=0,i=0;i<linesWithLineNumbers.length;i++)maxLineLength=Math.max(linesWithLineNumbers[i].length,maxLineLength);var beforeErrorLines=linesWithLineNumbers.slice(0,lineNumber-1),errorLine=linesWithLineNumbers.slice(lineNumber-1,lineNumber),afterErrorLines=linesWithLineNumbers.slice(lineNumber);console.log(beforeErrorLines.join("\n")),console.log(shaderInfoLog.split("\n")[0]),console.log("%c "+rightPad(errorLine[0],maxLineLength),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(afterErrorLines.join("\n"))}function createProgram(gl,debug){return throwIfNull(gl,debug,function(){return gl.createProgram()},"Unable to create WebGLProgram.")}function linkProgram(gl,debug,program){if(callAndCheck(gl,debug,function(){return gl.linkProgram(program)}),!1===gl.getProgramParameter(program,gl.LINK_STATUS))throw console.log(gl.getProgramInfoLog(program)),new Error("Failed to link vertex and fragment shaders.")}function validateProgram(gl,debug,program){if(callAndCheck(gl,debug,function(){return gl.validateProgram(program)}),!1===gl.getProgramParameter(program,gl.VALIDATE_STATUS))throw console.log(gl.getProgramInfoLog(program)),new Error("Shader program validation failed.")}function createStaticVertexBuffer(gl,debug,data){var buffer=throwIfNull(gl,debug,function(){return gl.createBuffer()},"Unable to create WebGLBuffer");return callAndCheck(gl,debug,function(){return gl.bindBuffer(gl.ARRAY_BUFFER,buffer)}),callAndCheck(gl,debug,function(){return gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW)}),buffer}function createStaticIndexBuffer(gl,debug,data){var buffer=throwIfNull(gl,debug,function(){return gl.createBuffer()},"Unable to create WebGLBuffer");return callAndCheck(gl,debug,function(){return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,buffer)}),callAndCheck(gl,debug,function(){return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,data,gl.STATIC_DRAW)}),buffer}function getNumChannels(){return 2===env().getNumber("WEBGL_VERSION")?1:4}function createTexture(gl,debug){return throwIfNull(gl,debug,function(){return gl.createTexture()},"Unable to create WebGLTexture.")}function validateTextureSize(width,height){var maxTextureSize=env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(width<=0||height<=0){var requested="["+width+"x"+height+"]";throw new Error("Requested texture size "+requested+" is invalid.")}if(width>maxTextureSize||height>maxTextureSize){var requested="["+width+"x"+height+"]",max;throw new Error("Requested texture size "+requested+" greater than WebGL maximum on this browser / GPU "+("["+maxTextureSize+"x"+maxTextureSize+"]")+".")}}function createFramebuffer(gl,debug){return throwIfNull(gl,debug,function(){return gl.createFramebuffer()},"Unable to create WebGLFramebuffer.")}function bindVertexBufferToProgramAttribute(gl,debug,program,attribute,buffer,arrayEntriesPerItem,itemStrideInBytes,itemOffsetInBytes){var loc=gl.getAttribLocation(program,attribute);return-1!==loc&&(callAndCheck(gl,debug,function(){return gl.bindBuffer(gl.ARRAY_BUFFER,buffer)}),callAndCheck(gl,debug,function(){return gl.vertexAttribPointer(loc,arrayEntriesPerItem,gl.FLOAT,!1,itemStrideInBytes,itemOffsetInBytes)}),callAndCheck(gl,debug,function(){return gl.enableVertexAttribArray(loc)}),!0)}function bindTextureUnit(gl,debug,texture,textureUnit){validateTextureUnit(gl,textureUnit),callAndCheck(gl,debug,function(){return gl.activeTexture(gl.TEXTURE0+textureUnit)}),callAndCheck(gl,debug,function(){return gl.bindTexture(gl.TEXTURE_2D,texture)})}function unbindTextureUnit(gl,debug,textureUnit){validateTextureUnit(gl,textureUnit),callAndCheck(gl,debug,function(){return gl.activeTexture(gl.TEXTURE0+textureUnit)}),callAndCheck(gl,debug,function(){return gl.bindTexture(gl.TEXTURE_2D,null)})}function getProgramUniformLocationOrThrow(gl,debug,program,uniformName){return throwIfNull(gl,debug,function(){return gl.getUniformLocation(program,uniformName)},'uniform "'+uniformName+'" not present in program.')}function getProgramUniformLocation(gl,program,uniformName){return gl.getUniformLocation(program,uniformName)}function bindTextureToProgramUniformSampler(gl,debug,program,texture,uniformSamplerLocation,textureUnit){callAndCheck(gl,debug,function(){return bindTextureUnit(gl,debug,texture,textureUnit)}),callAndCheck(gl,debug,function(){return gl.uniform1i(uniformSamplerLocation,textureUnit)})}function bindCanvasToFramebuffer(gl,debug){callAndCheck(gl,debug,function(){return gl.bindFramebuffer(gl.FRAMEBUFFER,null)}),callAndCheck(gl,debug,function(){return gl.viewport(0,0,gl.canvas.width,gl.canvas.height)}),callAndCheck(gl,debug,function(){return gl.scissor(0,0,gl.canvas.width,gl.canvas.height)})}function bindColorTextureToFramebuffer(gl,debug,texture,framebuffer){callAndCheck(gl,debug,function(){return gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer)}),callAndCheck(gl,debug,function(){return gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0)})}function unbindColorTextureFromFramebuffer(gl,debug,framebuffer){callAndCheck(gl,debug,function(){return gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer)}),callAndCheck(gl,debug,function(){return gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,null,0)})}function validateFramebuffer(gl){var status=gl.checkFramebufferStatus(gl.FRAMEBUFFER);if(status!==gl.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+getFramebufferErrorMessage(gl,status))}function getFramebufferErrorMessage(gl,status){switch(status){case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case gl.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+status}}function throwIfNull(gl,debug,returnTOrNull,failureMessage){var tOrNull=callAndCheck(gl,debug,function(){return returnTOrNull()});if(null==tOrNull)throw new Error(failureMessage);return tOrNull}function validateTextureUnit(gl,textureUnit){var maxTextureUnit=gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,glTextureUnit=textureUnit+gl.TEXTURE0,textureUnitRange;if(glTextureUnit<gl.TEXTURE0||glTextureUnit>maxTextureUnit)throw new Error("textureUnit must be in "+("[gl.TEXTURE0, gl.TEXTURE"+maxTextureUnit+"]")+".")}function getBatchDim(shape,dimsToSkip){return void 0===dimsToSkip&&(dimsToSkip=2),sizeFromShape(shape.slice(0,shape.length-dimsToSkip))}function getRowsCols(shape){if(0===shape.length)throw Error("Cannot get rows and columns of an empty shape array.");return[shape.length>1?shape[shape.length-2]:1,shape[shape.length-1]]}function getShapeAs3D(shape){var shapeAs3D=[1,1,1],isScalar;return 0===shape.length||1===shape.length&&1===shape[0]||(shapeAs3D=[getBatchDim(shape)].concat(getRowsCols(shape))),shapeAs3D}function getTextureShapeFromLogicalShape(logShape,isPacked){var _a;void 0===isPacked&&(isPacked=!1);var maxTexSize=env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(isPacked&&(maxTexSize*=2,1===(logShape=logShape.map(function(d,i){return i>=logShape.length-2?nearestLargerEven(logShape[i]):logShape[i]})).length&&(logShape=[2,logShape[0]])),2!==logShape.length){var squeezeResult=squeezeShape(logShape);logShape=squeezeResult.newShape}var size=sizeFromShape(logShape);if(logShape.length<=1&&size<=maxTexSize)return[1,size];if(2===logShape.length&&logShape[0]<=maxTexSize&&logShape[1]<=maxTexSize)return logShape;if(3===logShape.length&&logShape[0]*logShape[1]<=maxTexSize&&logShape[2]<=maxTexSize)return[logShape[0]*logShape[1],logShape[2]];if(3===logShape.length&&logShape[0]<=maxTexSize&&logShape[1]*logShape[2]<=maxTexSize)return[logShape[0],logShape[1]*logShape[2]];if(4===logShape.length&&logShape[0]*logShape[1]*logShape[2]<=maxTexSize&&logShape[3]<=maxTexSize)return[logShape[0]*logShape[1]*logShape[2],logShape[3]];if(4===logShape.length&&logShape[0]<=maxTexSize&&logShape[1]*logShape[2]*logShape[3]<=maxTexSize)return[logShape[0],logShape[1]*logShape[2]*logShape[3]];if(isPacked){var batchDim=getBatchDim(logShape),rows=2,cols=2;return logShape.length&&(rows=(_a=getRowsCols(logShape))[0],cols=_a[1]),sizeToSquarishShape(size=batchDim*(rows/2)*(cols/2)).map(function(d){return 2*d})}return sizeToSquarishShape(size)}function isEven(n){return n%2==0}function isReshapeFree(shape1,shape2){if(arraysEqual(shape1=shape1.slice(-2),shape2=shape2.slice(-2)))return!0;if(!shape1.length||!shape2.length)return!0;if(0===shape1[0]||0===shape1[1]||0===shape2[0]||0===shape2[1])return!0;if(shape1.length!==shape2.length){var shape1Cols=shape1.slice(-1)[0],shape2Cols=shape2.slice(-1)[0];if(shape1Cols===shape2Cols)return!0;if(isEven(shape1Cols)&&isEven(shape2Cols)&&(1===shape1[0]||1===shape2[0]))return!0}return shape1[1]===shape2[1]&&isEven(shape1[0])&&isEven(shape2[0])}function getWebGLMaxTextureSize(webGLVersion){if(null==MAX_TEXTURE_SIZE){var gl=getWebGLContext(webGLVersion);MAX_TEXTURE_SIZE=gl.getParameter(gl.MAX_TEXTURE_SIZE)}return MAX_TEXTURE_SIZE}function resetMaxTextureSize(){MAX_TEXTURE_SIZE=null}function resetMaxTexturesInShader(){MAX_TEXTURES_IN_SHADER=null}function getMaxTexturesInShader(webGLVersion){if(null==MAX_TEXTURES_IN_SHADER){var gl=getWebGLContext(webGLVersion);MAX_TEXTURES_IN_SHADER=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,MAX_TEXTURES_IN_SHADER)}function getWebGLDisjointQueryTimerVersion(webGLVersion){if(0===webGLVersion)return 0;var queryTimerVersion,gl=getWebGLContext(webGLVersion);return queryTimerVersion=hasExtension(gl,"EXT_disjoint_timer_query_webgl2")&&2===webGLVersion?2:hasExtension(gl,"EXT_disjoint_timer_query")?1:0}function hasExtension(gl,extensionName){var ext;return null!=gl.getExtension(extensionName)}function isWebGLVersionEnabled(webGLVersion){try{var gl;if(null!=getWebGLContext(webGLVersion))return!0}catch(e){return!1}return!1}function isCapableOfRenderingToFloatTexture(webGLVersion){if(0===webGLVersion)return!1;var gl=getWebGLContext(webGLVersion),isFrameBufferComplete;if(1===webGLVersion){if(!hasExtension(gl,"OES_texture_float"))return!1}else if(!hasExtension(gl,"EXT_color_buffer_float"))return!1;return createFloatTextureAndBindToFramebuffer(gl)}function isDownloadFloatTextureEnabled(webGLVersion){if(0===webGLVersion)return!1;var gl=getWebGLContext(webGLVersion),isFrameBufferComplete;if(1!==webGLVersion){if(hasExtension(gl,"EXT_color_buffer_float"))return createFloatTextureAndBindToFramebuffer(gl);var COLOR_BUFFER_HALF_FLOAT="EXT_color_buffer_half_float",textureHalfFloatExtension;return!!hasExtension(gl,COLOR_BUFFER_HALF_FLOAT)&&createHalfFloatTextureAndBindToFramebuffer(gl,gl.getExtension(COLOR_BUFFER_HALF_FLOAT))}return!!hasExtension(gl,"OES_texture_float")&&(!!hasExtension(gl,"WEBGL_color_buffer_float")&&createFloatTextureAndBindToFramebuffer(gl))}function createFloatTextureAndBindToFramebuffer(gl){var texConfig=getTextureConfig(gl),texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);var width=1,height=1;gl.texImage2D(gl.TEXTURE_2D,0,texConfig.internalFormatFloat,1,1,0,texConfig.textureFormatFloat,texConfig.textureTypeFloat,null);var frameBuffer=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,frameBuffer),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);var isFrameBufferComplete=gl.checkFramebufferStatus(gl.FRAMEBUFFER)===gl.FRAMEBUFFER_COMPLETE;return gl.bindTexture(gl.TEXTURE_2D,null),gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.deleteTexture(texture),gl.deleteFramebuffer(frameBuffer),isFrameBufferComplete}function createHalfFloatTextureAndBindToFramebuffer(gl,textureHalfFloatExtension){var texConfig=getTextureConfig(gl,textureHalfFloatExtension),texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);var width=1,height=1;gl.texImage2D(gl.TEXTURE_2D,0,texConfig.internalFormatHalfFloat,1,1,0,texConfig.textureFormatFloat,texConfig.textureTypeHalfFloat,null);var frameBuffer=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,frameBuffer),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);var isFrameBufferComplete=gl.checkFramebufferStatus(gl.FRAMEBUFFER)===gl.FRAMEBUFFER_COMPLETE;return gl.bindTexture(gl.TEXTURE_2D,null),gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.deleteTexture(texture),gl.deleteFramebuffer(frameBuffer),isFrameBufferComplete}function isWebGLFenceEnabled(webGLVersion){return 2===webGLVersion&&null!=getWebGLContext(webGLVersion).fenceSync;var gl,isEnabled}var webgl_util=Object.freeze({callAndCheck:callAndCheck,canBeRepresented:canBeRepresented,getWebGLErrorMessage:getWebGLErrorMessage,getExtensionOrThrow:getExtensionOrThrow,createVertexShader:createVertexShader,createFragmentShader:createFragmentShader,createProgram:createProgram,linkProgram:linkProgram,validateProgram:validateProgram,createStaticVertexBuffer:createStaticVertexBuffer,createStaticIndexBuffer:createStaticIndexBuffer,getNumChannels:getNumChannels,createTexture:createTexture,validateTextureSize:validateTextureSize,createFramebuffer:createFramebuffer,bindVertexBufferToProgramAttribute:bindVertexBufferToProgramAttribute,bindTextureUnit:bindTextureUnit,unbindTextureUnit:unbindTextureUnit,getProgramUniformLocationOrThrow:getProgramUniformLocationOrThrow,getProgramUniformLocation:getProgramUniformLocation,bindTextureToProgramUniformSampler:bindTextureToProgramUniformSampler,bindCanvasToFramebuffer:bindCanvasToFramebuffer,bindColorTextureToFramebuffer:bindColorTextureToFramebuffer,unbindColorTextureFromFramebuffer:unbindColorTextureFromFramebuffer,validateFramebuffer:validateFramebuffer,getFramebufferErrorMessage:getFramebufferErrorMessage,getBatchDim:getBatchDim,getRowsCols:getRowsCols,getShapeAs3D:getShapeAs3D,getTextureShapeFromLogicalShape:getTextureShapeFromLogicalShape,isReshapeFree:isReshapeFree,getWebGLMaxTextureSize:getWebGLMaxTextureSize,resetMaxTextureSize:resetMaxTextureSize,resetMaxTexturesInShader:resetMaxTexturesInShader,getMaxTexturesInShader:getMaxTexturesInShader,getWebGLDisjointQueryTimerVersion:getWebGLDisjointQueryTimerVersion,hasExtension:hasExtension,isWebGLVersionEnabled:isWebGLVersionEnabled,isCapableOfRenderingToFloatTexture:isCapableOfRenderingToFloatTexture,isDownloadFloatTextureEnabled:isDownloadFloatTextureEnabled,isWebGLFenceEnabled:isWebGLFenceEnabled}),ENV$1=env();function enableProdMode(){env().set("PROD",!0)}function enableDebugMode(){env().set("DEBUG",!0)}function disableDeprecationWarnings(){env().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function deprecationWarn(msg){env().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(msg+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function disposeVariables(){ENGINE.disposeVariables()}function engine(){return ENGINE}function memory(){return ENGINE.memory()}function profile(f){return ENGINE.profile(f)}function tidy(nameOrFn,fn){return ENGINE.tidy(nameOrFn,fn)}function dispose(container){var tensors;getTensorsInContainer(container).forEach(function(tensor){return tensor.dispose()})}function keep(result){return ENGINE.keep(result)}function time(f){return ENGINE.time(f)}function setBackend(backendName){return ENGINE.setBackend(backendName)}function ready(){return ENGINE.ready()}function getBackend(){return ENGINE.backendName}function removeBackend(name){ENGINE.removeBackend(name)}function findBackend(name){return ENGINE.findBackend(name)}function findBackendFactory(name){return ENGINE.findBackendFactory(name)}function registerBackend(name,factory,priority){return void 0===priority&&(priority=1),ENGINE.registerBackend(name,factory,priority)}function backend(){return ENGINE.backend}function setPlatform(platformName,platform){env().setPlatform(platformName,platform)}function warn(){for(var msg=[],_i=0;_i<arguments.length;_i++)msg[_i]=arguments[_i];env().getBool("IS_TEST")||console.warn.apply(console,msg)}function inferShape(val,dtype){var firstElem=val;if(isTypedArray(val))return"string"===dtype?[]:[val.length];if(!Array.isArray(val))return[];for(var shape=[];Array.isArray(firstElem)||isTypedArray(firstElem)&&"string"!==dtype;)shape.push(firstElem.length),firstElem=firstElem[0];return Array.isArray(val)&&env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&deepAssertShapeConsistency(val,shape,[]),shape}function deepAssertShapeConsistency(val,shape,indices){if(indices=indices||[],Array.isArray(val)||isTypedArray(val)){assert(shape.length>0,function(){return"Element arr["+indices.join("][")+"] should be a primitive, but is an array of "+val.length+" elements"}),assert(val.length===shape[0],function(){return"Element arr["+indices.join("][")+"] should have "+shape[0]+" elements, but has "+val.length+" elements"});for(var subShape=shape.slice(1),i=0;i<val.length;++i)deepAssertShapeConsistency(val[i],subShape,indices.concat(i))}else assert(0===shape.length,function(){return"Element arr["+indices.join("][")+"] is a primitive, but should be an array/TypedArray of "+shape[0]+" elements"})}function assertDtype(expectedDtype,actualDType,argName,functionName){if(null!=expectedDtype&&("numeric"!==expectedDtype&&expectedDtype!==actualDType||"numeric"===expectedDtype&&"string"===actualDType))throw new Error("Argument '"+argName+"' passed to '"+functionName+"' must be "+expectedDtype+" tensor, but got "+actualDType+" tensor")}function convertToTensor(x,argName,functionName,parseAsDtype){if(void 0===parseAsDtype&&(parseAsDtype="numeric"),x instanceof Tensor)return assertDtype(parseAsDtype,x.dtype,argName,functionName),x;var inferredDtype=inferDtype(x);if("string"!==inferredDtype&&["bool","int32","float32"].indexOf(parseAsDtype)>=0&&(inferredDtype=parseAsDtype),assertDtype(parseAsDtype,inferredDtype,argName,functionName),null==x||!isTypedArray(x)&&!Array.isArray(x)&&"number"!=typeof x&&"boolean"!=typeof x&&"string"!=typeof x){var type=null==x?"null":x.constructor.name;throw new Error("Argument '"+argName+"' passed to '"+functionName+"' must be a Tensor or TensorLike, but got '"+type+"'")}var inferredShape=inferShape(x,inferredDtype);isTypedArray(x)||Array.isArray(x)||(x=[x]);var skipTypedArray=!0,values="string"!==inferredDtype?toTypedArray(x,inferredDtype,env().getBool("DEBUG")):flatten(x,[],!0);return ENGINE.makeTensor(values,inferredShape,inferredDtype)}function convertToTensorArray(arg,argName,functionName,parseAsDtype){if(void 0===parseAsDtype&&(parseAsDtype="numeric"),!Array.isArray(arg))throw new Error("Argument "+argName+" passed to "+functionName+" must be a `Tensor[]` or `TensorLike[]`");var tensors;return arg.map(function(t,i){return convertToTensor(t,argName+"["+i+"]",functionName)},parseAsDtype)}function axesAreInnerMostDims(axes,rank){for(var i=0;i<axes.length;++i)if(axes[axes.length-i-1]!==rank-1-i)return!1;return!0}function combineLocations(outputLoc,reduceLoc,axes){for(var rank=outputLoc.length+reduceLoc.length,loc=[],outIdx=0,reduceIdx=0,dim=0;dim<rank;dim++)-1===axes.indexOf(dim)?loc.push(outputLoc[outIdx++]):loc.push(reduceLoc[reduceIdx++]);return loc}function computeOutAndReduceShapes(aShape,axes){for(var outShape=[],rank=aShape.length,dim=0;dim<rank;dim++)-1===axes.indexOf(dim)&&outShape.push(aShape[dim]);var reduceShape;return[outShape,axes.map(function(dim){return aShape[dim]})]}function expandShapeToKeepDim(shape,axes){var reduceSubShape;return combineLocations(shape,axes.map(function(x){return 1}),axes)}function assertAxesAreInnerMostDims(msg,axes,rank){assert(axesAreInnerMostDims(axes,rank),function(){return msg+" supports only inner-most axes for now. Got axes "+axes+" and rank-"+rank+" input."})}function getAxesPermutation(axes,rank){if(axesAreInnerMostDims(axes,rank))return null;for(var result=[],i=0;i<rank;++i)-1===axes.indexOf(i)&&result.push(i);return axes.forEach(function(axis){return result.push(axis)}),result}function getUndoAxesPermutation(axes){return axes.map(function(axis,i){return[i,axis]}).sort(function(a,b){return a[1]-b[1]}).map(function(x){return x[0]})}function getInnerMostAxes(numAxes,rank){for(var res=[],i=rank-numAxes;i<rank;++i)res.push(i);return res}function assertParamsConsistent(shapes,axis){var rank=shapes[0].length;shapes.forEach(function(shape,i){assert(shape.length===rank,function(){return"Error in concat"+rank+"D: rank of tensors["+i+"] must be the same as the rank of the rest ("+rank+")"})}),assert(axis>=0&&axis<rank,function(){return"Error in concat"+rank+"D: axis must be between 0 and "+(rank-1)+"."});var firstShape=shapes[0];shapes.forEach(function(shape,i){for(var r=0;r<rank;r++)assert(r===axis||shape[r]===firstShape[r],function(){return"Error in concat"+rank+"D: Shape of tensors["+i+"] ("+shape+") does not match the shape of the rest ("+firstShape+") along the non-concatenated axis "+i+"."})})}function computeOutShape(shapes,axis){for(var outputShape=shapes[0].slice(),i=1;i<shapes.length;i++)outputShape[axis]+=shapes[i][axis];return outputShape}function op(f){var keys=Object.keys(f);if(1!==keys.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+keys.length+" keys.");var opName=keys[0],fn=f[opName];opName.endsWith("_")&&(opName=opName.substring(0,opName.length-1));var f2=function(){for(var args=[],_i=0;_i<arguments.length;_i++)args[_i]=arguments[_i];ENGINE.startScope(opName);try{var result=fn.apply(void 0,args);return result instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),ENGINE.endScope(result),result}catch(ex){throw ENGINE.endScope(null),ex}};return Object.defineProperty(f2,"name",{value:opName,configurable:!0}),f2}function complex_(real,imag){var $real=convertToTensor(real,"real","complex"),$imag=convertToTensor(imag,"imag","complex");return assertShapesMatch($real.shape,$imag.shape,"real and imag shapes, "+$real.shape+" and "+$imag.shape+", must match in call to tf.complex()."),ENGINE.runKernelFunc(function(backend){return backend.complex($real,$imag)},{$real:$real,$imag:$imag})}function real_(input){var $input=convertToTensor(input,"input","real");return ENGINE.runKernelFunc(function(backend){return backend.real($input)},{$input:$input})}function imag_(input){var $input=convertToTensor(input,"input","imag");return ENGINE.runKernelFunc(function(backend){return backend.imag($input)},{$input:$input})}ENV$1.registerFlag("HAS_WEBGL",function(){return ENV$1.getNumber("WEBGL_VERSION")>0}),ENV$1.registerFlag("WEBGL_VERSION",function(){return isWebGLVersionEnabled(2)?2:isWebGLVersionEnabled(1)?1:0}),ENV$1.registerFlag("WEBGL_BUFFER_SUPPORTED",function(){return 2===ENV$1.get("WEBGL_VERSION")}),ENV$1.registerFlag("WEBGL_CPU_FORWARD",function(){return!0}),ENV$1.registerFlag("WEBGL_FORCE_F16_TEXTURES",function(){return!1}),ENV$1.registerFlag("WEBGL_PACK",function(){return ENV$1.getBool("HAS_WEBGL")}),ENV$1.registerFlag("WEBGL_PACK_NORMALIZATION",function(){return ENV$1.getBool("WEBGL_PACK")}),ENV$1.registerFlag("WEBGL_PACK_CLIP",function(){return ENV$1.getBool("WEBGL_PACK")}),ENV$1.registerFlag("WEBGL_PACK_DEPTHWISECONV",function(){return!1}),ENV$1.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",function(){return ENV$1.getBool("WEBGL_PACK")}),ENV$1.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",function(){return ENV$1.getBool("WEBGL_PACK")}),ENV$1.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",function(){return ENV$1.getBool("WEBGL_PACK")}),ENV$1.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",function(){return ENV$1.getBool("WEBGL_PACK")}),ENV$1.registerFlag("WEBGL_PACK_REDUCE",function(){return ENV$1.getBool("WEBGL_PACK")}),ENV$1.registerFlag("WEBGL_LAZILY_UNPACK",function(){return ENV$1.getBool("WEBGL_PACK")}),ENV$1.registerFlag("WEBGL_CONV_IM2COL",function(){return ENV$1.getBool("WEBGL_PACK")}),ENV$1.registerFlag("WEBGL_MAX_TEXTURE_SIZE",function(){return getWebGLMaxTextureSize(ENV$1.getNumber("WEBGL_VERSION"))}),ENV$1.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",function(){return getMaxTexturesInShader(ENV$1.getNumber("WEBGL_VERSION"))}),ENV$1.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",function(){var webGLVersion=ENV$1.getNumber("WEBGL_VERSION");return 0===webGLVersion?0:getWebGLDisjointQueryTimerVersion(webGLVersion)}),ENV$1.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",function(){return ENV$1.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!isMobile()}),ENV$1.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",function(){return isCapableOfRenderingToFloatTexture(ENV$1.getNumber("WEBGL_VERSION"))}),ENV$1.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",function(){return!ENV$1.getBool("WEBGL_FORCE_F16_TEXTURES")&&ENV$1.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")}),ENV$1.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",function(){return isDownloadFloatTextureEnabled(ENV$1.getNumber("WEBGL_VERSION"))}),ENV$1.registerFlag("WEBGL_FENCE_API_ENABLED",function(){return isWebGLFenceEnabled(ENV$1.getNumber("WEBGL_VERSION"))}),ENV$1.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",function(){var useUniforms;return ENV$1.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0}),setDeprecationWarningFn(deprecationWarn);var complex=op({complex_:complex_}),real=op({real_:real_}),imag=op({imag_:imag_});function tensor(values,shape,dtype){var inferredShape;return makeTensor(values,shape,inferShape(values,dtype),dtype)}function makeTensor(values,shape,inferredShape,dtype){if(null==dtype&&(dtype=inferDtype(values)),"complex64"===dtype)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!isTypedArray(values)&&!Array.isArray(values)&&"number"!=typeof values&&"boolean"!=typeof values&&"string"!=typeof values)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=shape){assertNonNegativeIntegerDimensions(shape);var providedSize_1=sizeFromShape(shape),inferredSize_1=sizeFromShape(inferredShape);assert(providedSize_1===inferredSize_1,function(){return"Based on the provided shape, ["+shape+"], the tensor should have "+providedSize_1+" values but has "+inferredSize_1});for(var i=0;i<inferredShape.length;++i){var inferred=inferredShape[i],flatDimsDontMatch=i!==inferredShape.length-1||inferred!==sizeFromShape(shape.slice(i));assert(inferredShape[i]===shape[i]||!flatDimsDontMatch,function(){return"Error creating a new Tensor. Inferred shape ("+inferredShape+") does not match the provided shape ("+shape+"). "})}}return isTypedArray(values)||Array.isArray(values)||(values=[values]),shape=shape||inferredShape,values="string"!==dtype?toTypedArray(values,dtype,env().getBool("DEBUG")):flatten(values,[],!0),ENGINE.makeTensor(values,shape,dtype)}function scalar(value,dtype){if((isTypedArray(value)&&"string"!==dtype||Array.isArray(value))&&"complex64"!==dtype)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===dtype&&isTypedArray(value)&&!(value instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");var shape,inferredShape;return makeTensor(value,[],[],dtype)}function tensor1d(values,dtype){assertNonNull(values);var inferredShape=inferShape(values,dtype);if(1!==inferredShape.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");var shape=null;return makeTensor(values,null,inferredShape,dtype)}function tensor2d(values,shape,dtype){if(assertNonNull(values),null!=shape&&2!==shape.length)throw new Error("tensor2d() requires shape to have two numbers");var inferredShape=inferShape(values,dtype);if(2!==inferredShape.length&&1!==inferredShape.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===inferredShape.length&&null==shape)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return makeTensor(values,shape,inferredShape,dtype)}function tensor3d(values,shape,dtype){if(assertNonNull(values),null!=shape&&3!==shape.length)throw new Error("tensor3d() requires shape to have three numbers");var inferredShape=inferShape(values,dtype);if(3!==inferredShape.length&&1!==inferredShape.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===inferredShape.length&&null==shape)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return makeTensor(values,shape,inferredShape,dtype)}function tensor4d(values,shape,dtype){if(assertNonNull(values),null!=shape&&4!==shape.length)throw new Error("tensor4d() requires shape to have four numbers");var inferredShape=inferShape(values,dtype);if(4!==inferredShape.length&&1!==inferredShape.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===inferredShape.length&&null==shape)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return makeTensor(values,shape,inferredShape,dtype)}function tensor5d(values,shape,dtype){if(assertNonNull(values),null!=shape&&5!==shape.length)throw new Error("tensor5d() requires shape to have five numbers");var inferredShape=inferShape(values,dtype);if(5!==inferredShape.length&&1!==inferredShape.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===inferredShape.length&&null==shape)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return makeTensor(values,shape,inferredShape,dtype)}function tensor6d(values,shape,dtype){if(assertNonNull(values),null!=shape&&6!==shape.length)throw new Error("tensor6d() requires shape to have six numbers");var inferredShape=inferShape(values,dtype);if(6!==inferredShape.length&&1!==inferredShape.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===inferredShape.length&&null==shape)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return makeTensor(values,shape=shape||inferredShape,inferredShape,dtype)}function variable(initialValue,trainable,name,dtype){return void 0===trainable&&(trainable=!0),ENGINE.makeVariable(initialValue,trainable,name,dtype)}function ones$1(shape,dtype){if(void 0===dtype&&(dtype="float32"),"complex64"===dtype){var real_1=ones$1(shape,"float32"),imag_1=zeros(shape,"float32");return complex(real_1,imag_1)}var values=makeOnesTypedArray(sizeFromShape(shape),dtype);return ENGINE.makeTensor(values,shape,dtype)}function zeros(shape,dtype){if(void 0===dtype&&(dtype="float32"),"complex64"===dtype){var real_2=zeros(shape,"float32"),imag_2=zeros(shape,"float32");return complex(real_2,imag_2)}var values=makeZerosTypedArray(sizeFromShape(shape),dtype);return ENGINE.makeTensor(values,shape,dtype)}function fill(shape,value,dtype){return ENGINE.runKernelFunc(function(backend){return backend.fill(shape,value,dtype)},{})}function onesLike_(x){var $x=convertToTensor(x,"x","onesLike");if("complex64"===$x.dtype){var r=onesLike(real($x)),i=zerosLike(imag($x));return complex(r,i)}var der=function(dy,saved){return{x:function(){return zerosLike(dy)}}};return ENGINE.runKernelFunc(function(backend){return backend.onesLike($x)},{x:$x},der,"OnesLike")}function zerosLike_(x){var $x=convertToTensor(x,"x","zerosLike"),der=function(dy,saved){return{x:function(){return zerosLike(dy)}}};return ENGINE.runKernelFunc(function(backend){return backend.zerosLike($x)},{x:$x},der,"ZerosLike")}function linspace(start,stop,num){if(num<=0)throw new Error("The number of values should be positive.");return ENGINE.runKernelFunc(function(backend){return backend.linspace(start,stop,num)},{})}function range(start,stop,step,dtype){if(void 0===step&&(step=1),void 0===dtype&&(dtype="float32"),0===step)throw new Error("Cannot have a step of zero");var sameStartStop,increasingRangeNegativeStep,decreasingRangePositiveStep;if(start===stop||start<stop&&step<0||stop<start&&step>1)return zeros([0],dtype);var numElements,values=makeZerosTypedArray(Math.abs(Math.ceil((stop-start)/step)),dtype);stop<start&&1===step&&(step=-1),values[0]=start;for(var i=1;i<values.length;i++)values[i]=values[i-1]+step;return tensor1d(values,dtype)}var onesLike=op({onesLike_:onesLike_}),zerosLike=op({zerosLike_:zerosLike_});function concat1d_(tensors){return concat(tensors,0)}function concat2d_(tensors,axis){return concat(tensors,axis)}function concat3d_(tensors,axis){return concat(tensors,axis)}function concat4d_(tensors,axis){return concat(tensors,axis)}function concat_(tensors,axis){void 0===axis&&(axis=0),assert(tensors.length>=1,function(){return"Pass at least one tensor to concat"});var $tensors=convertToTensorArray(tensors,"tensors","concat");"complex64"===$tensors[0].dtype&&$tensors.forEach(function(tensor){if("complex64"!==tensor.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype "+tensor.dtype+". ")}),axis=parseAxisParam(axis,$tensors[0].shape)[0];var outShape=computeOutShape($tensors.map(function(t){return t.shape}),axis);if(0===sizeFromShape(outShape))return tensor([],outShape);if(1===($tensors=$tensors.filter(function(t){return t.size>0})).length)return $tensors[0];var shapes=$tensors.map(function(t){return t.shape});assertParamsConsistent(shapes,axis);var der=function(dy){var sizeSplits=shapes.map(function(s){return s[axis]}),derTensors;return split(dy,sizeSplits,axis).map(function(t){return function(){return t}})},inputs=$tensors,attr={axis:axis};return ENGINE.runKernelFunc(function(backend){return backend.concat($tensors,axis)},inputs,der,"Concat",attr)}function split_(x,numOrSizeSplits,axis){void 0===axis&&(axis=0);var $x=convertToTensor(x,"x","split"),splitSizes;axis=parseAxisParam(axis,$x.shape)[0],"number"==typeof numOrSizeSplits?(assert($x.shape[axis]%numOrSizeSplits==0,function(){return"Number of splits must evenly divide the axis."}),splitSizes=new Array(numOrSizeSplits).fill($x.shape[axis]/numOrSizeSplits)):(assert($x.shape[axis]===numOrSizeSplits.reduce(function(a,b){return a+b}),function(){return"The sum of sizes must match the size of the axis dimension."}),splitSizes=numOrSizeSplits);var der=function(dy){return{$x:function(){return concat(dy,axis)}}};return ENGINE.runKernelFunc(function(backend){return backend.split($x,splitSizes,axis)},{$x:$x},der)}var concat=op({concat_:concat_}),concat1d=op({concat1d_:concat1d_}),concat2d=op({concat2d_:concat2d_}),concat3d=op({concat3d_:concat3d_}),concat4d=op({concat4d_:concat4d_}),split=op({split_:split_});function reshape_(x,shape){var $x=convertToTensor(x,"x","reshape",null);shape=inferFromImplicitShape(shape,$x.size),assert($x.size===sizeFromShape(shape),function(){return"new shape and old shape must have the same number of elements."});var grad=function(dy){return{x:function(){return dy.reshape($x.shape)}}},attrs={shape:shape};return ENGINE.runKernelFunc(function(backend){return backend.reshape($x,shape)},{x:$x},grad,"Reshape",attrs)}function squeeze_(x,axis){var $x=convertToTensor(x,"x","squeeze");return reshape($x,squeezeShape($x.shape,axis).newShape)}function cast_(x,dtype){var $x=convertToTensor(x,"x","cast");if(!isValidDtype(dtype))throw new Error("Failed to cast to unknown dtype "+dtype);if("string"===dtype&&"string"!==$x.dtype||"string"!==dtype&&"string"===$x.dtype)throw new Error("Only strings can be casted to strings");var grad=function(dy){return{x:function(){return dy.clone()}}},attrs={dtype:dtype};return ENGINE.runKernelFunc(function(backend){return backend.cast($x,dtype)},{x:$x},grad,"Cast",attrs)}function stack_(tensors,axis){void 0===axis&&(axis=0);var $tensors=convertToTensorArray(tensors,"tensors","stack");if(assert($tensors.length>=1,function(){return"Pass at least one tensor to tf.stack"}),1===$tensors.length)return $tensors[0].expandDims(axis);var rank=$tensors[0].rank,shape=$tensors[0].shape,dtype=$tensors[0].dtype;assert(axis<=rank,function(){return"Axis must be <= rank of the tensor"}),$tensors.forEach(function(t){assertShapesMatch(shape,t.shape,"All tensors passed to stack must have matching shapes")}),$tensors.forEach(function(t){assert(dtype===t.dtype,function(){return"All tensors passed to stack must have matching dtypes"})});var expandedTensors=$tensors.map(function(t){return t.expandDims(axis)});return concat(expandedTensors,axis)}function batchToSpaceND_(x,blockShape,crops){var $x=convertToTensor(x,"x","batchToSpaceND"),prod=blockShape.reduce(function(a,b){return a*b});assert($x.rank>=1+blockShape.length,function(){return"input rank is "+$x.rank+" but should be > than blockShape.length "+blockShape.length}),assert(crops.length===blockShape.length,function(){return"crops.length is "+crops.length+" but should be equal to blockShape.length  "+blockShape.length}),assert($x.shape[0]%prod==0,function(){return"input tensor batch is "+$x.shape[0]+" but is not divisible by the product of the elements of blockShape "+blockShape.join(" * ")+" === "+prod});var grad=function(dy){return{$x:function(){return dy.spaceToBatchND(blockShape,crops)}}};return ENGINE.runKernelFunc(function(backend){return backend.batchToSpaceND($x,blockShape,crops)},{$x:$x},grad)}function spaceToBatchND_(x,blockShape,paddings){var $x=convertToTensor(x,"x","spaceToBatchND");assert($x.rank>=1+blockShape.length,function(){return"input rank "+$x.rank+" should be > than [blockShape] "+blockShape.length}),assert(paddings.length===blockShape.length,function(){return"paddings.shape[0] "+paddings.length+" must be equal to [blockShape] "+blockShape.length}),assert($x.shape.reduce(function(a,b,i){return i>0&&i<=blockShape.length?a&&(b+paddings[i-1][0]+paddings[i-1][1])%blockShape[i-1]==0:a},!0),function(){return"input spatial dimensions "+$x.shape.slice(1)+" with paddings "+paddings.toString()+" must be divisible by blockShapes "+blockShape.toString()});var grad=function(dy){return{$x:function(){return dy.batchToSpaceND(blockShape,paddings)}}};return ENGINE.runKernelFunc(function(backend){return backend.spaceToBatchND($x,blockShape,paddings)},{$x:$x},grad)}function unstack_(x,axis){void 0===axis&&(axis=0),axis=axis||0;var $x=convertToTensor(x,"x","unstack");assert(axis>=-$x.shape.length&&axis<$x.shape.length,function(){return"Axis = "+axis+" is not in [-"+$x.shape.length+", "+$x.shape.length+")"}),axis<0&&(axis+=$x.shape.length);var grad=function(dy){return{x:function(){return stack(dy,axis)}}},attrs={axis:axis};return ENGINE.runKernelFunc(function(backend){return backend.unstack($x,axis)},{x:$x},grad,"Unpack",attrs)}function cumsum_(x,axis,exclusive,reverse){void 0===axis&&(axis=0),void 0===exclusive&&(exclusive=!1),void 0===reverse&&(reverse=!1);var $x=convertToTensor(x,"x","cumsum"),permutation=getAxesPermutation([axis|=0],$x.rank),permutedX=$x;null!=permutation&&(permutedX=$x.transpose(permutation));var permutedAxis=getInnerMostAxes(1,$x.rank)[0],grad=function(dy){return{permutedX:function(){return dy.cumsum(axis,exclusive,!reverse)}}},value=ENGINE.runKernelFunc(function(backend){return backend.cumsum(permutedX,permutedAxis,exclusive,reverse)},{permutedX:permutedX},grad);return null!=permutation&&(value=value.transpose(permutation)),value}function expandDims_(x,axis){void 0===axis&&(axis=0);var parseAs=null,$x=convertToTensor(x,"x","expandDims",null);assert(axis<=$x.rank,function(){return"Axis must be <= rank of the tensor"});var newShape=$x.shape.slice();return axis<0&&(assert(-($x.rank+1)<=axis,function(){return"Axis must be in the interval ["+-($x.rank+1)+", "+$x.rank+"]"}),axis=$x.rank+axis+1),newShape.splice(axis,0,1),reshape($x,newShape)}function depthToSpace_(x,blockSize,dataFormat){void 0===dataFormat&&(dataFormat="NHWC");var $x=convertToTensor(x,"x","depthToSpace"),inputHeight="NHWC"===dataFormat?$x.shape[1]:$x.shape[2],inputWidth="NHWC"===dataFormat?$x.shape[2]:$x.shape[3],inputDepth="NHWC"===dataFormat?$x.shape[3]:$x.shape[1];return assert(inputHeight*blockSize>=0,function(){return"Negative dimension size caused by overflow when multiplying\n      "+inputHeight+" and "+blockSize+"  for depthToSpace with input shape\n      "+$x.shape}),assert(inputWidth*blockSize>=0,function(){return"Negative dimension size caused by overflow when multiplying\n      "+inputWidth+" and "+blockSize+" for depthToSpace with input shape\n          "+$x.shape}),assert(inputDepth%(blockSize*blockSize)==0,function(){return"Dimension size must be evenly divisible by "+blockSize*blockSize+" but is "+inputDepth+" for depthToSpace with input shape "+$x.shape}),ENGINE.runKernelFunc(function(backend){return backend.depthToSpace($x,blockSize,dataFormat)},{$x:$x})}function setdiff1dAsync_(x,y){return __awaiter(this,void 0,void 0,function(){var $x,$y,xVals,yVals,ySet,outputSize,i,buffer,indices,i,p;return __generator(this,function(_a){switch(_a.label){case 0:return $x=convertToTensor(x,"x","setdiff1d"),$y=convertToTensor(y,"y","setdiff1d"),assert($x.dtype===$y.dtype,function(){return"x and y should have the same dtype, but got x ("+$x.dtype+") and y ("+$y.dtype+")."}),assert(1===$x.rank,function(){return"x should be 1D tensor, but got x ("+$x.shape+")."}),assert(1===$y.rank,function(){return"y should be 1D tensor, but got y ("+$y.shape+")."}),[4,$x.data()];case 1:return xVals=_a.sent(),[4,$y.data()];case 2:for(yVals=_a.sent(),ySet=new Set(yVals),outputSize=0,i=0;i<xVals.length;i++)ySet.has(xVals[i])||outputSize++;for(buffer=new TensorBuffer([outputSize],$x.dtype),indices=new TensorBuffer([outputSize],"int32"),i=0,p=0;i<xVals.length;i++)ySet.has(xVals[i])||(buffer.values[p]=xVals[i],indices.values[p]=i,p++);return[2,[buffer.toTensor(),indices.toTensor()]]}})})}function buffer(shape,dtype,values){return void 0===dtype&&(dtype="float32"),dtype=dtype||"float32",assertNonNegativeIntegerDimensions(shape),new TensorBuffer(shape,dtype,values)}function print(x,verbose){void 0===verbose&&(verbose=!1),console.log(x.toString(verbose))}var batchToSpaceND=op({batchToSpaceND_:batchToSpaceND_}),cast=op({cast_:cast_}),cumsum=op({cumsum_:cumsum_}),depthToSpace=op({depthToSpace_:depthToSpace_}),expandDims=op({expandDims_:expandDims_}),reshape=op({reshape_:reshape_}),spaceToBatchND=op({spaceToBatchND_:spaceToBatchND_}),squeeze=op({squeeze_:squeeze_}),stack=op({stack_:stack_}),unstack=op({unstack_:unstack_}),setdiff1dAsync=setdiff1dAsync_;function getReshaped(inputShape,blockShape,prod,batchToSpace){void 0===batchToSpace&&(batchToSpace=!0);var reshaped=[];if(batchToSpace)(reshaped=reshaped.concat(blockShape.slice(0))).push(inputShape[0]/prod),reshaped=reshaped.concat(inputShape.slice(1));else{reshaped=reshaped.concat(inputShape[0]);for(var spatialLength=blockShape.length,i=0;i<spatialLength;++i)reshaped=reshaped.concat([inputShape[i+1]/blockShape[i],blockShape[i]]);reshaped=reshaped.concat(inputShape.slice(spatialLength+1))}return reshaped}function getPermuted(reshapedRank,blockShapeRank,batchToSpace){void 0===batchToSpace&&(batchToSpace=!0);var permuted=[];if(batchToSpace){permuted.push(blockShapeRank);for(var i=blockShapeRank+1;i<reshapedRank;++i)i<=2*blockShapeRank?(permuted.push(i),permuted.push(i-(blockShapeRank+1))):permuted.push(i)}else{for(var permutedBeforeBatch=[],permutedAfterBatch=[],i=1;i<reshapedRank;++i)i>=2*blockShapeRank+1||i%2==1?permutedAfterBatch.push(i):permutedBeforeBatch.push(i);permuted.push.apply(permuted,permutedBeforeBatch),permuted.push(0),permuted.push.apply(permuted,permutedAfterBatch)}return permuted}function getReshapedPermuted(inputShape,blockShape,prod,batchToSpace){void 0===batchToSpace&&(batchToSpace=!0);var reshapedPermuted=[];batchToSpace?reshapedPermuted.push(inputShape[0]/prod):reshapedPermuted.push(inputShape[0]*prod);for(var i=1;i<inputShape.length;++i)i<=blockShape.length?batchToSpace?reshapedPermuted.push(blockShape[i-1]*inputShape[i]):reshapedPermuted.push(inputShape[i]/blockShape[i-1]):reshapedPermuted.push(inputShape[i]);return reshapedPermuted}function getSliceBeginCoords(crops,blockShape){for(var sliceBeginCoords=[0],i=0;i<blockShape;++i)sliceBeginCoords.push(crops[i][0]);return sliceBeginCoords}function getSliceSize(uncroppedShape,crops,blockShape){for(var sliceSize=uncroppedShape.slice(0,1),i=0;i<blockShape;++i)sliceSize.push(uncroppedShape[i+1]-crops[i][0]-crops[i][1]);return sliceSize}var Add="Add",AddN="AddN",Div="Div",FusedBatchNorm="FusedBatchNorm",SquaredDifference="SquaredDifference",Square="Square",Transpose="Transpose",NonMaxSuppressionV5="NonMaxSuppressionV5",BroadcastTo="BroadcastTo",OneHot="OneHot",Identity="Identity",Tile="Tile",PadV2="PadV2",FromPixels="FromPixels",MaxPoolWithArgmax="MaxPoolWithArgmax";function add_(a,b){var _a,$a=convertToTensor(a,"a","add"),$b=convertToTensor(b,"b","add");_a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1];var forward=function(backend,save){var res=backend.add($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,Add)}var add=op({add_:add_});function getBroadcastDims(inShape,outShape){for(var inRank=inShape.length,dims=[],i=0;i<inRank;i++){var dim=inRank-1-i,a=inShape[dim]||1,b;(outShape[outShape.length-1-i]||1)>1&&1===a&&dims.unshift(dim)}return dims}function getReductionAxes(inShape,outShape){for(var result=[],i=0;i<outShape.length;i++){var inDim=inShape[inShape.length-i-1],outAxis=outShape.length-i-1,outDim=outShape[outAxis];(null==inDim||1===inDim&&outDim>1)&&result.unshift(outAxis)}return result}function assertAndGetBroadcastShape(shapeA,shapeB){for(var result=[],l=Math.max(shapeA.length,shapeB.length),i=0;i<l;i++){var a=shapeA[shapeA.length-i-1];null==a&&(a=1);var b=shapeB[shapeB.length-i-1];if(null==b&&(b=1),1===a)result.unshift(b);else if(1===b)result.unshift(a);else{var errMsg;if(a!==b)throw Error("Operands could not be broadcast together with shapes "+shapeA+" and "+shapeB+".");result.unshift(a)}}return result}function neg_(x){var $x=convertToTensor(x,"x","neg"),grad=function(dy){return{x:function(){return dy.neg()}}},attrs={},inputsToSave=[$x];return ENGINE.runKernelFunc(function(backend){return backend.neg($x)},{x:$x},grad,"Neg",attrs,inputsToSave)}function ceil_(x){var $x=convertToTensor(x,"x","ceil"),grad=function(dy){return{$x:function(){return zerosLike(dy)}}};return ENGINE.runKernelFunc(function(backend){return backend.ceil($x)},{$x:$x},grad)}function floor_(x){var $x=convertToTensor(x,"x","floor"),grad=function(dy){return{$x:function(){return zerosLike(dy)}}};return ENGINE.runKernelFunc(function(backend){return backend.floor($x)},{$x:$x},grad)}function sign_(x){var $x=convertToTensor(x,"x","sign"),grad=function(dy){return{$x:function(){return zerosLike(dy)}}};return ENGINE.runKernelFunc(function(backend){return backend.sign($x)},{$x:$x},grad)}function isNaN_(x){var $x=convertToTensor(x,"x","isNaN"),grad=function(dy){return{$x:function(){return zerosLike(dy)}}};return ENGINE.runKernelFunc(function(backend){return backend.isNaN($x)},{$x:$x},grad)}function isInf_(x){var $x=convertToTensor(x,"x","isInf"),grad=function(dy){return{$x:function(){return zerosLike(dy)}}};return ENGINE.runKernelFunc(function(backend){return backend.isInf($x)},{$x:$x},grad)}function isFinite_(x){var $x=convertToTensor(x,"x","isFinite"),grad=function(dy){return{$x:function(){return zerosLike(dy)}}};return ENGINE.runKernelFunc(function(backend){return backend.isFinite($x)},{$x:$x},grad)}function round_(x){var $x=convertToTensor(x,"x","round"),grad=function(dy){return{$x:function(){return zerosLike(dy)}}};return ENGINE.runKernelFunc(function(backend){return backend.round($x)},{$x:$x},grad)}function exp_(x){var $x=convertToTensor(x,"x","exp"),bck=function(dy,saved){return{x:function(){return dy.mulStrict(saved[0])}}},attrs={},inputsToSave=[],outputsToSave=[!0];return ENGINE.runKernelFunc(function(backend,save){var y=backend.exp($x);return save([y]),y},{x:$x},bck,"Exp",attrs,inputsToSave,outputsToSave)}function expm1_(x){var $x=convertToTensor(x,"x","expm1"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.mul($x.exp())}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.expm1($x);return save([$x]),res},{$x:$x},grad)}function log_(x){var $x=convertToTensor(x,"x","log"),grad=function(dy,saved){var $x=saved[0];return{x:function(){return dy.div($x.toFloat())}}},attrs={},inputsToSave=[$x];return ENGINE.runKernelFunc(function(backend,save){var res=backend.log($x);return save([$x]),res},{x:$x},grad,"Log",attrs,inputsToSave)}function log1p_(x){var $x=convertToTensor(x,"x","log1p"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.div($x.add(1))}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.log1p($x);return save([$x]),res},{$x:$x},grad)}function sqrt_(x){var $x=convertToTensor(x,"x","sqrt"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.div($x.toFloat().sqrt().mul(2))}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.sqrt($x);return save([$x]),res},{$x:$x},grad)}function rsqrt_(x){var $x=convertToTensor(x,"x","rsqrt"),grad=function(dy,saved){var $x=saved[0];return{x:function(){return dy.div($x.pow(1.5).mul(2)).neg()}}},inputsToSave=[$x];return ENGINE.runKernelFunc(function(backend,save){var res=backend.rsqrt($x);return save([$x]),res},{x:$x},grad,"Rsqrt",{},inputsToSave)}function reciprocal_(x){var $x=convertToTensor(x,"x","reciprocal"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.div($x.square().neg())}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.reciprocal($x);return save([$x]),res},{$x:$x},grad)}function abs_(x){var $x=convertToTensor(x,"x","abs");if("complex64"===$x.dtype)return ENGINE.runKernelFunc(function(backend){return backend.complexAbs($x)},{$x:$x});var grad=function(dy,saved){var $x=saved[0];return{x:function(){return dy.mul($x.toFloat().step(-1))}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.abs($x);return save([$x]),res},{x:$x},grad,"Abs")}function clipByValue_(x,clipValueMin,clipValueMax){var $x=convertToTensor(x,"x","clipByValue");assert(clipValueMin<=clipValueMax,function(){return"Error in clip: min ("+clipValueMin+") must be less than or equal to max ("+clipValueMax+")."});var grad=function(dy,saved){var $x=saved[0];return{x:function(){return dy.where($x.greaterEqual(clipValueMin).logicalAnd($x.lessEqual(clipValueMax)),zerosLike(dy))}}},inputsToSave=[$x],attr={min:clipValueMin,max:clipValueMax};return ENGINE.runKernelFunc(function(backend,save){var res=backend.clip($x,clipValueMin,clipValueMax);return save([$x]),res},{x:$x},grad,"ClipByValue",attr,inputsToSave)}function sigmoid_(x){var $x=convertToTensor(x,"x","sigmoid"),grad=function(dy,saved){var y=saved[0];return{x:function(){return dy.mul(y.mul(scalar(1).sub(y)))}}};return ENGINE.runKernelFunc(function(backend,save){var y=backend.sigmoid($x);return save([y]),y},{x:$x},grad,"Sigmoid")}function logSigmoid_(x){var $x=convertToTensor(x,"x","logSigmoid"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.mul($x.neg().sigmoid())}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.softplus($x.neg()).neg();return save([$x]),res},{$x:$x},grad)}function softplus_(x){var $x=convertToTensor(x,"x","softplus"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.mul($x.sigmoid())}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.softplus($x);return save([$x]),res},{$x:$x},grad)}function sin_(x){var $x=convertToTensor(x,"x","sin"),grad=function(dy,saved){var $x=saved[0];return{x:function(){return $x.toFloat().cos().mul(dy)}}},inputsToSave=[$x];return ENGINE.runKernelFunc(function(backend,save){var res=backend.sin($x);return save([$x]),res},{x:$x},grad,"Sin",{},inputsToSave)}function cos_(x){var $x=convertToTensor(x,"x","cos"),grad=function(dy,saved){var $x=saved[0];return{x:function(){return $x.toFloat().sin().neg().mul(dy)}}},inputsToSave=[$x];return ENGINE.runKernelFunc(function(backend,save){var res=backend.cos($x);return save([$x]),res},{x:$x},grad,"Cos",{},inputsToSave)}function tan_(x){var $x=convertToTensor(x,"x","tan"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.div($x.cos().square())}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.tan($x);return save([$x]),res},{$x:$x},grad)}function asin_(x){var $x=convertToTensor(x,"x","asin"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.divStrict(scalar(1).sub($x.toFloat().square()).sqrt())}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.asin($x);return save([$x]),res},{$x:$x},grad)}function acos_(x){var $x=convertToTensor(x,"x","acos"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.divStrict(scalar(1).sub($x.toFloat().square()).sqrt()).neg()}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.acos($x);return save([$x]),res},{$x:$x},grad)}function atan_(x){var $x=convertToTensor(x,"x","atan"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.div($x.toFloat().square().add(1))}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.atan($x);return save([$x]),res},{$x:$x},grad)}function sinh_(x){var $x=convertToTensor(x,"x","sinh"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return $x.toFloat().cosh().mulStrict(dy)}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.sinh($x);return save([$x]),res},{$x:$x},grad)}function cosh_(x){var $x=convertToTensor(x,"x","cosh"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return $x.toFloat().sinh().mulStrict(dy)}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.cosh($x);return save([$x]),res},{$x:$x},grad)}function tanh_(x){var $x=convertToTensor(x,"x","tanh"),grad=function(dy,saved){var y=saved[0];return{x:function(){return scalar(1).sub(y.square()).mulStrict(dy)}}},outputsToSave=[!0];return ENGINE.runKernelFunc(function(backend,save){var y=backend.tanh($x);return save([y]),y},{x:$x},grad,"Tanh",{},null,outputsToSave)}function asinh_(x){var $x=convertToTensor(x,"x","asinh"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.divStrict(scalar(1).add($x.toFloat().square()).sqrt())}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.asinh($x);return save([$x]),res},{$x:$x},grad)}function acosh_(x){var $x=convertToTensor(x,"x","acosh"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.divStrict($x.toFloat().square().sub(1).sqrt())}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.acosh($x);return save([$x]),res},{$x:$x},grad)}function atanh_(x){var $x=convertToTensor(x,"x","atanh"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.div(scalar(1).sub($x.toFloat().square()))}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.atanh($x);return save([$x]),res},{$x:$x},grad)}function erf_(x){var $x=convertToTensor(x,"x","erf");assert("int32"===$x.dtype||"float32"===$x.dtype,function(){return"Input dtype must be `int32` or `float32`."}),"int32"===$x.dtype&&($x=$x.toFloat());var grad=function(dy,saved){var $x=saved[0];return{$x:function(){return dy.mul($x.square().neg().exp().mul(2/Math.sqrt(Math.PI)))}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.erf($x);return save([$x]),res},{$x:$x},grad)}function step_(x,alpha){void 0===alpha&&(alpha=0);var $x=convertToTensor(x,"x","step"),grad=function(dy){return{$x:function(){return zerosLike(dy)}}};return ENGINE.runKernelFunc(function(backend){return backend.step($x,alpha)},{$x:$x},grad)}var abs=op({abs_:abs_}),acos=op({acos_:acos_}),acosh=op({acosh_:acosh_}),asin=op({asin_:asin_}),asinh=op({asinh_:asinh_}),atan=op({atan_:atan_}),atanh=op({atanh_:atanh_}),ceil=op({ceil_:ceil_}),clipByValue=op({clipByValue_:clipByValue_}),cos=op({cos_:cos_}),cosh=op({cosh_:cosh_}),erf=op({erf_:erf_}),exp=op({exp_:exp_}),expm1=op({expm1_:expm1_}),floor=op({floor_:floor_}),log=op({log_:log_}),log1p=op({log1p_:log1p_}),logSigmoid=op({logSigmoid_:logSigmoid_}),neg=op({neg_:neg_}),reciprocal=op({reciprocal_:reciprocal_}),round=op({round_:round_}),rsqrt=op({rsqrt_:rsqrt_}),sigmoid=op({sigmoid_:sigmoid_}),sign=op({sign_:sign_}),isNaN$1=op({isNaN_:isNaN_}),isInf=op({isInf_:isInf_}),isFinite$1=op({isFinite_:isFinite_}),sin=op({sin_:sin_}),sinh=op({sinh_:sinh_}),softplus=op({softplus_:softplus_}),sqrt=op({sqrt_:sqrt_}),step=op({step_:step_}),tan=op({tan_:tan_}),tanh$1=op({tanh_:tanh_});function addStrict_(a,b){var $a=convertToTensor(a,"a","addStrict"),$b=convertToTensor(b,"b","addStrict");return assertShapesMatch($a.shape,$b.shape,"Error in addStrict: "),$a.add($b)}function sub_(a,b){var _a,$a=convertToTensor(a,"a","sub"),$b=convertToTensor(b,"b","sub");_a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1];var outShape=assertAndGetBroadcastShape($a.shape,$b.shape),der=function(dy){var derA,derB;return{a:function(){var res=dy,reduceAxes=getReductionAxes($a.shape,outShape);return reduceAxes.length>0&&(res=res.sum(reduceAxes)),res.reshape($a.shape)},b:function(){var res=dy,reduceAxes=getReductionAxes($b.shape,outShape);return reduceAxes.length>0&&(res=res.sum(reduceAxes)),res.neg().reshape($b.shape)}}};return ENGINE.runKernelFunc(function(backend){return backend.subtract($a,$b)},{a:$a,b:$b},der,"Sub")}function subStrict_(a,b){var $a=convertToTensor(a,"a","subStrict"),$b=convertToTensor(b,"b","subStrict");return assertShapesMatch($a.shape,$b.shape,"Error in subStrict: "),$a.sub($b)}function pow_(base,exp){var _a,$base=convertToTensor(base,"base","pow"),$exp=convertToTensor(exp,"exp","pow");_a=makeTypesMatch($base,$exp),$base=_a[0],$exp=_a[1];var outShape=assertAndGetBroadcastShape($base.shape,$exp.shape),grad=function(dy,saved){var $base=saved[0],$exp=saved[1],y=saved[2],derBase,derExp;return{a:function(){var expFloat=$exp.toFloat(),res=dy.mul(expFloat.mul($base.pow(expFloat.sub(scalar(1))))),reduceAxes=getReductionAxes($base.shape,outShape);return reduceAxes.length>0&&(res=res.sum(reduceAxes)),res.reshape($base.shape)},b:function(){var condition=$base.greater(0),logBase=$base.log().where(condition,zerosLike($base)),res=dy.mul(y.mul(logBase)),reduceAxes=getReductionAxes($exp.shape,outShape);return reduceAxes.length>0&&(res=res.sum(reduceAxes)),res.reshape($exp.shape)}}},attrs={},inputsToSave=[$base,$exp],outputsToSave=[!0];return ENGINE.runKernelFunc(function(backend,save){var y=backend.pow($base,$exp);return save([$base,$exp,y]),y},{a:$base,b:$exp},grad,"Pow",attrs,inputsToSave,outputsToSave)}function powStrict_(base,exp){return assertShapesMatch(base.shape,exp.shape,"Error in powStrict: "),base.pow(exp)}function mul_(a,b){var _a,$a=convertToTensor(a,"a","mul"),$b=convertToTensor(b,"b","mul");_a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1];var outShape=assertAndGetBroadcastShape($a.shape,$b.shape),der=function(dy,saved){var $a=saved[0],$b=saved[1],derA,derB;return{a:function(){var res=dy.mul($b.toFloat()),reduceAxes=getReductionAxes($a.shape,outShape);return reduceAxes.length>0?res.sum(reduceAxes).reshape($a.shape):res},b:function(){var res=dy.mul($a.toFloat()),reduceAxes=getReductionAxes($b.shape,outShape);return reduceAxes.length>0?res.sum(reduceAxes).reshape($b.shape):res}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.multiply($a,$b);return save([$a,$b]),res},{a:$a,b:$b},der,"Mul")}function mulStrict_(a,b){var $a=convertToTensor(a,"a","mul"),$b=convertToTensor(b,"b","mul");return assertShapesMatch($a.shape,$b.shape,"Error in multiplyStrict: "),$a.mul($b)}function floorDiv_(a,b){var _a,$a=convertToTensor(a,"a","floorDiv"),$b=convertToTensor(b,"b","floorDiv");_a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1];var outShape=assertAndGetBroadcastShape($a.shape,$b.shape),der=function(dy,saved){var $a=saved[0],$b=saved[1],derA,derB;return{a:function(){var res=dy.div($b.toFloat()),reduceAxes=getReductionAxes($a.shape,outShape);return reduceAxes.length>0?res.sum(reduceAxes).reshape($a.shape):res},b:function(){var res=dy.mul($a.toFloat()),reduceAxes=getReductionAxes($b.shape,outShape);reduceAxes.length>0&&(res=res.sum(reduceAxes).reshape($b.shape));var tmp=$b.square();return res.div(tmp.toFloat()).neg()}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.floorDiv($a,$b);return save([$a,$b]),res},{a:$a,b:$b},der,"FloorDiv")}function divStrict_(a,b){var $a=convertToTensor(a,"a","div"),$b=convertToTensor(b,"b","div");return assertShapesMatch($a.shape,$b.shape,"Error in divideStrict: "),$a.div($b)}function mod_(a,b){var _a,$a=convertToTensor(a,"a","mod"),$b=convertToTensor(b,"b","mod");_a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1];var outShape=assertAndGetBroadcastShape($a.shape,$b.shape),der=function(dy,saved){var $a=saved[0],$b=saved[1],derA,derB;return{$a:function(){var reduceAxes=getReductionAxes($a.shape,outShape);return reduceAxes.length>0?dy.sum(reduceAxes).reshape($a.shape):dy},$b:function(){var res=dy.mul($a.div($b).floor().neg()),reduceAxes=getReductionAxes($b.shape,outShape);return reduceAxes.length>0?res.sum(reduceAxes).reshape($b.shape):res}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.mod($a,$b);return save([$a,$b]),res},{$a:$a,$b:$b},der)}function modStrict_(a,b){var $a=convertToTensor(a,"a","modStrict"),$b=convertToTensor(b,"b","modStrict");return assertShapesMatch($a.shape,$b.shape,"Error in modStrict: "),$a.mod($b)}function minimum_(a,b){var _a,$a=convertToTensor(a,"a","minimum"),$b=convertToTensor(b,"b","minimum");_a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1],"bool"===$a.dtype&&($a=$a.toInt(),$b=$b.toInt()),assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy,saved){var $a=saved[0],$b=saved[1],derA,derB;return{a:function(){return dy.mul($a.lessEqual($b).toFloat())},b:function(){return dy.mul($a.greater($b).toFloat())}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.minimum($a,$b);return save([$a,$b]),res},{a:$a,b:$b},der,"Minimum")}function minimumStrict_(a,b){var $a=convertToTensor(a,"a","minimumStrict"),$b=convertToTensor(b,"b","minimumStrict");return assertShapesMatch($a.shape,$b.shape,"Error in minimumStrict: "),$a.minimum($b)}function maximum_(a,b){var _a,$a=convertToTensor(a,"a","maximum"),$b=convertToTensor(b,"b","maximum");_a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1],"bool"===$a.dtype&&($a=$a.toInt(),$b=$b.toInt()),assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy,saved){var $a=saved[0],$b=saved[1],derA,derB;return{a:function(){return dy.mul($a.greaterEqual($b).toFloat())},b:function(){return dy.mul($a.less($b).toFloat())}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.maximum($a,$b);return save([$a,$b]),res},{a:$a,b:$b},der,"Maximum")}function maximumStrict_(a,b){var $a=convertToTensor(a,"a","maximumStrict"),$b=convertToTensor(b,"b","maximumStrict");return assertShapesMatch($a.shape,$b.shape,"Error in maximumStrict: "),$a.maximum($b)}function squaredDifferenceStrict_(a,b){var $a=convertToTensor(a,"a","squaredDifferenceStrict"),$b=convertToTensor(b,"b","squaredDifferenceStrict");return assertShapesMatch($a.shape,$b.shape,"Error in squaredDifferenceStrict: "),$a.squaredDifference($b)}function atan2_(a,b){var _a,$a=convertToTensor(a,"a","atan2"),$b=convertToTensor(b,"b","atan2");_a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1];var outShape=assertAndGetBroadcastShape($a.shape,$b.shape),der=function(dy,saved){var $a=saved[0],$b=saved[1],derA,derB;return{$a:function(){var d=add($a.square(),$b.square()),res=dy.mul($b.div(d)),reduceAxes=getReductionAxes($a.shape,outShape);return reduceAxes.length>0&&(res=res.sum(reduceAxes)),res.reshape($a.shape)},$b:function(){var d=add($a.square(),$b.square()),res=neg(dy.mul($a.div(d))),reduceAxes=getReductionAxes($b.shape,outShape);return reduceAxes.length>0&&(res=res.sum(reduceAxes)),res.reshape($b.shape)}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.atan2($a,$b);return save([$a,$b]),res},{$a:$a,$b:$b},der)}var addStrict=op({addStrict_:addStrict_}),atan2=op({atan2_:atan2_}),divStrict=op({divStrict_:divStrict_}),floorDiv=op({floorDiv_:floorDiv_}),maximum=op({maximum_:maximum_}),maximumStrict=op({maximumStrict_:maximumStrict_}),minimum=op({minimum_:minimum_}),minimumStrict=op({minimumStrict_:minimumStrict_}),mod=op({mod_:mod_}),modStrict=op({modStrict_:modStrict_}),mul=op({mul_:mul_}),mulStrict=op({mulStrict_:mulStrict_}),pow=op({pow_:pow_}),powStrict=op({powStrict_:powStrict_}),squaredDifferenceStrict=op({squaredDifferenceStrict_:squaredDifferenceStrict_}),sub=op({sub_:sub_}),subStrict=op({subStrict_:subStrict_});function div_(a,b){var _a,$a=convertToTensor(a,"a","div"),$b=convertToTensor(b,"b","div");if(_a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1],"int32"===$a.dtype&&"int32"===$b.dtype)return floorDiv($a,$b);var forward=function(backend,save){var res=backend.realDivide($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b},attrs={};return ENGINE.runKernelFunc(forward,inputs,null,Div,attrs)}var div=op({div_:div_});function prepareAndValidate(tensor,indices){if(tensor.rank<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+tensor.rank+".");if(indices.rank<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+indices.rank+".");if("int32"!==indices.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+indices.dtype+".");if(indices.shape[indices.rank-1]>tensor.rank)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+indices.shape[indices.rank-1]+" vs. "+tensor.rank);if(0===tensor.size)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+tensor.shape+".");for(var indicesShape=indices.shape,sliceRank=indicesShape[indicesShape.length-1],nResult=1,i=0;i<indicesShape.length-1;++i)nResult*=indicesShape[i];var inputShape=tensor.shape,resultShape=indicesShape.slice();resultShape.pop();for(var sliceSize=1,i=sliceRank;i<tensor.rank;++i)sliceSize*=inputShape[i],resultShape.push(inputShape[i]);var strides=computeStrides(tensor.shape).map(function(stride){return stride/sliceSize}).concat([1]).slice(0,sliceRank);return[resultShape,nResult,sliceSize,strides]}var gather_nd_util=Object.freeze({prepareAndValidate:prepareAndValidate}),PARALLELIZE_THRESHOLD=30;function computeOptimalWindowSize(inSize){return inSize<=PARALLELIZE_THRESHOLD?inSize:nearestDivisor(inSize,Math.floor(Math.sqrt(inSize)))}function validateUpdateShape(shape,indices,updates){var sliceDim=indices.rank>1?indices.shape[indices.rank-1]:1,batchDim=indices.rank>1?indices.rank-1:1,shapeError="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+updates.shape+", indices.shape: "+indices.shape+", shape: "+shape+", sliceDim: "+sliceDim+", and batchDim: "+batchDim+".";if(updates.rank<batchDim)throw new Error(shapeError+" update.rank < "+batchDim+". ");if(shape.length<sliceDim+(updates.rank-batchDim))throw new Error(shapeError+" Output shape length < "+(sliceDim+(updates.rank-batchDim)));if(updates.rank!==batchDim+shape.length-sliceDim)throw new Error(shapeError+" update.rank != "+(batchDim+shape.length-sliceDim));for(var d=0;d<batchDim;++d)if(updates.shape[d]!==indices.shape[d])throw new Error(shapeError+" updates.shape["+d+"] ("+updates.shape[d]+") != indices.shape["+d+"] ("+indices.shape[d]+").");for(var d=0;d<updates.rank-batchDim;++d)if(updates.shape[d+batchDim]!==shape[d+sliceDim])throw new Error(shapeError+" updates.shape["+(d+batchDim)+"] ("+updates.shape[d+batchDim]+") != shape["+(d+batchDim)+"] ("+shape[d+batchDim]+")")}function validateInput(updates,indices,shape){if(indices.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+indices.rank+".");if(updates.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+updates.rank+".");if("int32"!==indices.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+indices.dtype);if(shape.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+shape);if(0===shape.length){if(0===indices.size)throw new Error("Indices specified for empty output. indices shape: "+indices.shape);if(0===updates.size)throw new Error("Updates specified for empty output. updates shape: "+updates.shape)}validateUpdateShape(shape,indices,updates)}function calculateShapes(updates,indices,shape){for(var indicesRank=indices.shape.length,sliceRank=indicesRank>1?indices.shape[indicesRank-1]:1,totalNd=shape.length,sliceSize=1,i=sliceRank;i<totalNd;++i)sliceSize*=shape[i];var safeSliceDim=sliceRank<1?1:sliceRank,numUpdates,strides,outputSize;return{sliceRank:sliceRank,numUpdates:sizeFromShape(indices.shape)/safeSliceDim,sliceSize:sliceSize,strides:computeStrides(shape.slice(0,sliceRank)).concat([1]),outputSize:sizeFromShape(shape)}}var scatter_nd_util=Object.freeze({validateUpdateShape:validateUpdateShape,validateInput:validateInput,calculateShapes:calculateShapes});function segOpComputeOptimalWindowSize(inSize,numSegments){var done=!1,res;for(inSize<=PARALLELIZE_THRESHOLD?(res=inSize,done=!0):res=nearestDivisor(inSize,Math.floor(Math.sqrt(inSize)));!done;)res>numSegments||res===inSize?done=!0:res=nearestDivisor(inSize,res+1);return res}function computeOutShape$1(aShape,axis,numSegments){for(var outShape=[],rank=aShape.length,dim=0;dim<rank;dim++)dim!==axis?outShape.push(aShape[dim]):outShape.push(numSegments);return outShape}function collectGatherOpShapeInfo(x,indices,axis){for(var dimSize=x.shape[axis],outputShape=[],batchSize=1,sliceSize=1,i=0;i<axis;i++)outputShape.push(x.shape[i]),batchSize*=x.shape[i];for(var i=0;i<indices.rank;i++)outputShape.push(indices.shape[i]);for(var i=axis+1;i<x.rank;i++)outputShape.push(x.shape[i]),sliceSize*=x.shape[i];return{batchSize:batchSize,sliceSize:sliceSize,dimSize:dimSize,outputShape:outputShape}}function assertParamsValid(input,begin,size){assert(input.rank===begin.length,function(){return"Error in slice"+input.rank+"D: Length of begin "+begin+" must match the rank of the array ("+input.rank+")."}),assert(input.rank===size.length,function(){return"Error in slice"+input.rank+"D: Length of size "+size+" must match the rank of the array ("+input.rank+")."});for(var _loop_1=function(i){assert(begin[i]+size[i]<=input.shape[i],function(){return"Error in slice"+input.rank+"D: begin["+i+"] + size["+i+"] ("+(begin[i]+size[i])+") would overflow input.shape["+i+"] ("+input.shape[i]+")"})},i=0;i<input.rank;++i)_loop_1(i)}function maskToAxes(mask){for(var axes=[],axis=0;mask>0;)1&mask&&axes.push(axis),mask/=2,axis++;return axes}function computeOutShape$2(begin,end,strides){for(var size=[],axis=0;axis<begin.length;axis++)size[axis]=Math.ceil((end[axis]-begin[axis])/strides[axis]);return size}function startForAxis(beginMask,startIndices,strides,inputShape,axis){var start=startIndices[axis],stride=strides[axis]||1;(beginMask&1<<axis||null==start)&&(start=stride>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);var axisSize=inputShape[axis];return start<0&&(start+=axisSize),start=clamp(0,start,axisSize-1)}function stopForAxis(endMask,stopIndices,strides,inputShape,axis){var stop=stopIndices[axis],stride=strides[axis]||1;(endMask&1<<axis||null==stop)&&(stop=stride>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);var axisSize=inputShape[axis];return stop<0&&(stop+=axisSize),stop=stride>0?clamp(0,stop,axisSize):clamp(-1,stop,axisSize-1)}function isSliceContinous(shape,begin,size){for(var firstNonOneAxis=size.length,i=0;i<size.length;i++)if(size[i]>1){firstNonOneAxis=i;break}for(var i=firstNonOneAxis+1;i<size.length;i++)if(begin[i]>0||size[i]!==shape[i])return!1;return!0}function computeFlatOffset(begin,strides){for(var flatOffset=begin.length>0?begin[begin.length-1]:1,i=0;i<begin.length-1;i++)flatOffset+=begin[i]*strides[i];return flatOffset}var slice_util=Object.freeze({assertParamsValid:assertParamsValid,maskToAxes:maskToAxes,computeOutShape:computeOutShape$2,startForAxis:startForAxis,stopForAxis:stopForAxis,isSliceContinous:isSliceContinous,computeFlatOffset:computeFlatOffset});function grad(f){return assert(isFunction(f),function(){return"The f passed in grad(f) must be a function"}),function(x,dy){var $x=convertToTensor(x,"x","tf.grad",null),$dy=null!=dy?convertToTensor(dy,"dy","tf.grad"):null;return ENGINE.tidy(function(){var _a=ENGINE.gradients(function(){return f($x)},[$x],$dy),value=_a.value,grads=_a.grads;return null!=$dy&&assertShapesMatch(value.shape,$dy.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),checkGrads(grads),grads[0]})}}function grads(f){return assert(isFunction(f),function(){return"The f passed in grads(f) must be a function"}),function(args,dy){assert(Array.isArray(args),function(){return"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"});var $args=convertToTensorArray(args,"args","tf.grads",null),$dy=null!=dy?convertToTensor(dy,"dy","tf.grads"):null;return ENGINE.tidy(function(){var _a=ENGINE.gradients(function(){return f.apply(void 0,$args)},$args,$dy),value=_a.value,grads=_a.grads;return null!=$dy&&assertShapesMatch(value.shape,$dy.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),checkGrads(grads),grads})}}function valueAndGrad(f){return assert(isFunction(f),function(){return"The f passed in valueAndGrad(f) must be a function"}),function(x,dy){assert(x instanceof Tensor,function(){return"The x passed in valueAndGrad(f)(x) must be a tensor"}),assert(null==dy||dy instanceof Tensor,function(){return"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"});var _a=ENGINE.gradients(function(){return f(x)},[x],dy),grads=_a.grads,value=_a.value;return checkGrads(grads),{grad:grads[0],value:value}}}function valueAndGrads(f){return assert(isFunction(f),function(){return"The f passed in valueAndGrads(f) must be a function"}),function(args,dy){assert(Array.isArray(args)&&args.every(function(arg){return arg instanceof Tensor}),function(){return"The args passed in valueAndGrads(f)(args) must be array of tensors"}),assert(null==dy||dy instanceof Tensor,function(){return"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"});var res=ENGINE.gradients(function(){return f.apply(void 0,args)},args,dy);return null!=dy&&assertShapesMatch(res.value.shape,dy.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),checkGrads(res.grads),res}}function variableGrads(f,varList){assert(isFunction(f),function(){return"The f passed in variableGrads(f) must be a function"}),assert(null==varList||Array.isArray(varList)&&varList.every(function(v){return v instanceof Variable}),function(){return"The varList passed in variableGrads(f, varList) must be an array of variables"});var specifiedVarList=null!=varList;if(!specifiedVarList)for(var varName in varList=[],ENGINE.registeredVariables)varList.push(ENGINE.registeredVariables[varName]);var specifiedNonTrainable=specifiedVarList?varList.filter(function(variable){return!variable.trainable}):null,originalVarCount=varList.length;assert((varList=varList.filter(function(variable){return variable.trainable})).length>0,function(){return"variableGrads() expects at least one of the input variables to be trainable, but none of the "+originalVarCount+" variables is trainable."});var allowNoGradients=!0,_a=ENGINE.gradients(f,varList,null,!0),value=_a.value,grads=_a.grads;assert(grads.some(function(g){return null!=g}),function(){return"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."}),assert(0===value.rank,function(){return"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+value.rank+" tensor"});var namedGrads={};return varList.forEach(function(v,i){null!=grads[i]&&(namedGrads[v.name]=grads[i])}),null!=specifiedNonTrainable&&specifiedNonTrainable.forEach(function(v){return namedGrads[v.name]=null}),{value:value,grads:namedGrads}}function customGrad(f){return ENGINE.customGrad(f)}function checkGrads(grads){var numNullGradients;if(grads.filter(function(g){return null==g}).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function softmax_(logits,dim){void 0===dim&&(dim=-1);var $logits=convertToTensor(logits,"logits","softmax","float32");if(-1===dim&&(dim=$logits.rank-1),dim!==$logits.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+$logits.rank+" and dim was "+dim);var inputsToSave=[],outputsToSave=[!0];return ENGINE.runKernelFunc(function(backend,save){var y=backend.softmax($logits,dim);return save([y]),y},{logits:$logits},function(dy,saved){var y=saved[0],dyTimesY=dy.mul(y),keepDims=!0;return{logits:function(){return dyTimesY.sub(dyTimesY.sum([dim],!0).mul(y))}}},"Softmax",{dim:dim},inputsToSave,outputsToSave)}function logSoftmax_(logits,axis){void 0===axis&&(axis=-1);var $logits=convertToTensor(logits,"logits","logSoftmax"),customOp;if(-1===axis&&(axis=$logits.rank-1),axis!==$logits.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+$logits.rank+" and axis was "+axis);return customGrad(function(logits,save){var keepDims=!0,xMax=logits.max(axis,!0),shifted=logits.sub(xMax),value=shifted.toFloat().sub(shifted.exp().sum(axis,!0).log()),gradFunc;return save([value]),{value:value,gradFunc:function(dy,saved){var value,softmax=saved[0].exp();return dy.sub(dy.sum(axis,!0).mul(softmax))}}})($logits)}var softmax=op({softmax_:softmax_}),logSoftmax=op({logSoftmax_:logSoftmax_});function transpose_(x,perm){var $x=convertToTensor(x,"x","transpose");if(null==perm&&(perm=$x.shape.map(function(s,i){return i}).reverse()),assert($x.rank===perm.length,function(){return"Error in transpose: rank of input "+$x.rank+" must match length of perm "+perm+"."}),perm.forEach(function(axis){assert(axis>=0&&axis<$x.rank,function(){return"All entries in 'perm' must be between 0 and "+($x.rank-1)+" but got "+perm})}),$x.rank<=1)return $x.clone();var attrs={perm:perm};return ENGINE.runKernelFunc(function(backend){return backend.transpose($x,perm)},{x:$x},null,"Transpose",attrs)}var transpose=op({transpose_:transpose_}),EPSILON_FLOAT32=1e-7,EPSILON_FLOAT16=1e-4,DataStorage=function(){function DataStorage(backend,dataMover){this.backend=backend,this.dataMover=dataMover,this.data=new WeakMap,this.dataIdsCount=0}return DataStorage.prototype.get=function(dataId){return this.data.has(dataId)||this.dataMover.moveData(this.backend,dataId),this.data.get(dataId)},DataStorage.prototype.set=function(dataId,value){this.dataIdsCount++,this.data.set(dataId,value)},DataStorage.prototype.has=function(dataId){return this.data.has(dataId)},DataStorage.prototype.delete=function(dataId){return this.dataIdsCount--,this.data.delete(dataId)},DataStorage.prototype.numDataIds=function(){return this.dataIdsCount},DataStorage}(),KernelBackend=function(){function KernelBackend(){}return KernelBackend.prototype.time=function(f){return notYetImplemented("time")},KernelBackend.prototype.read=function(dataId){return notYetImplemented("read")},KernelBackend.prototype.readSync=function(dataId){return notYetImplemented("readSync")},KernelBackend.prototype.numDataIds=function(){return notYetImplemented("numDataIds")},KernelBackend.prototype.disposeData=function(dataId){return notYetImplemented("disposeData")},KernelBackend.prototype.write=function(values,shape,dtype){return notYetImplemented("write")},KernelBackend.prototype.move=function(dataId,values,shape,dtype){return notYetImplemented("move")},KernelBackend.prototype.memory=function(){return notYetImplemented("memory")},KernelBackend.prototype.floatPrecision=function(){return notYetImplemented("floatPrecision")},KernelBackend.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},KernelBackend.prototype.batchMatMul=function(a,b,transposeA,transposeB){return notYetImplemented("batchMatMul")},KernelBackend.prototype.fusedBatchMatMul=function(_a){var a=_a.a,b=_a.b,transposeA=_a.transposeA,transposeB=_a.transposeB,bias=_a.bias,activation=_a.activation,preluActivationWeights=_a.preluActivationWeights;return notYetImplemented("fusedBatchMatMul")},KernelBackend.prototype.slice=function(x,begin,size){return notYetImplemented("slice")},KernelBackend.prototype.stridedSlice=function(x,begin,end,strides){return notYetImplemented("stridedSlice")},KernelBackend.prototype.unstack=function(x,axis){return notYetImplemented("unstack")},KernelBackend.prototype.reverse=function(a,axis){return notYetImplemented("reverse")},KernelBackend.prototype.concat=function(tensors,axis){return notYetImplemented("concat")},KernelBackend.prototype.neg=function(a){return notYetImplemented("neg")},KernelBackend.prototype.add=function(a,b){return notYetImplemented("add")},KernelBackend.prototype.addN=function(tensors){return notYetImplemented("addN")},KernelBackend.prototype.subtract=function(a,b){return notYetImplemented("subtract")},KernelBackend.prototype.multiply=function(a,b){return notYetImplemented("multiply")},KernelBackend.prototype.realDivide=function(a,b){return notYetImplemented("realDivide")},KernelBackend.prototype.floorDiv=function(a,b){return notYetImplemented("floorDiv")},KernelBackend.prototype.sum=function(x,axes){return notYetImplemented("sum")},KernelBackend.prototype.prod=function(x,axes){return notYetImplemented("prod")},KernelBackend.prototype.unsortedSegmentSum=function(x,segmentIds,numSegments){return notYetImplemented("unsortedSegmentSum")},KernelBackend.prototype.argMin=function(x,axis){return notYetImplemented("argMin")},KernelBackend.prototype.argMax=function(x,axis){return notYetImplemented("argMax")},KernelBackend.prototype.equal=function(a,b){return notYetImplemented("equal")},KernelBackend.prototype.notEqual=function(a,b){return notYetImplemented("notEqual")},KernelBackend.prototype.less=function(a,b){return notYetImplemented("less")},KernelBackend.prototype.lessEqual=function(a,b){return notYetImplemented("lessEqual")},KernelBackend.prototype.greater=function(a,b){return notYetImplemented("greater")},KernelBackend.prototype.greaterEqual=function(a,b){return notYetImplemented("greaterEqual")},KernelBackend.prototype.logicalNot=function(a){return notYetImplemented("logicalNot")},KernelBackend.prototype.logicalAnd=function(a,b){return notYetImplemented("logicalAnd")},KernelBackend.prototype.logicalOr=function(a,b){return notYetImplemented("logicalOr")},KernelBackend.prototype.where=function(condition){return notYetImplemented("where")},KernelBackend.prototype.select=function(condition,a,b){return notYetImplemented("select")},KernelBackend.prototype.topk=function(x,k,sorted){return notYetImplemented("topk")},KernelBackend.prototype.min=function(x,axes){return notYetImplemented("min")},KernelBackend.prototype.minimum=function(a,b){return notYetImplemented("minimum")},KernelBackend.prototype.mod=function(a,b){return notYetImplemented("mod")},KernelBackend.prototype.max=function(x,axes){return notYetImplemented("max")},KernelBackend.prototype.maximum=function(a,b){return notYetImplemented("maximum")},KernelBackend.prototype.all=function(x,axes){return notYetImplemented("all")},KernelBackend.prototype.any=function(x,axes){return notYetImplemented("any")},KernelBackend.prototype.squaredDifference=function(a,b){return notYetImplemented("squaredDifference")},KernelBackend.prototype.ceil=function(x){return notYetImplemented("ceil")},KernelBackend.prototype.floor=function(x){return notYetImplemented("floor")},KernelBackend.prototype.round=function(x){return notYetImplemented("round")},KernelBackend.prototype.sign=function(x){return notYetImplemented("sign")},KernelBackend.prototype.isNaN=function(x){return notYetImplemented("isNaN")},KernelBackend.prototype.isInf=function(x){return notYetImplemented("isInf")},KernelBackend.prototype.isFinite=function(x){return notYetImplemented("isFinite")},KernelBackend.prototype.pow=function(a,b){return notYetImplemented("pow")},KernelBackend.prototype.exp=function(x){return notYetImplemented("exp")},KernelBackend.prototype.expm1=function(x){return notYetImplemented("expm1")},KernelBackend.prototype.softmax=function(x,dim){return notYetImplemented("softmax")},KernelBackend.prototype.log=function(x){return notYetImplemented("log")},KernelBackend.prototype.log1p=function(x){return notYetImplemented("log1p")},KernelBackend.prototype.sqrt=function(x){return notYetImplemented("sqrt")},KernelBackend.prototype.rsqrt=function(x){return notYetImplemented("rsqrt")},KernelBackend.prototype.square=function(x){return notYetImplemented("square")},KernelBackend.prototype.reciprocal=function(x){return notYetImplemented("reciprocal")},KernelBackend.prototype.relu=function(x){return notYetImplemented("relu")},KernelBackend.prototype.relu6=function(x){return notYetImplemented("relu6")},KernelBackend.prototype.prelu=function(x,a){return notYetImplemented("prelu")},KernelBackend.prototype.elu=function(x){return notYetImplemented("elu")},KernelBackend.prototype.eluDer=function(dy,y){return notYetImplemented("eluDer")},KernelBackend.prototype.selu=function(x){return notYetImplemented("selu")},KernelBackend.prototype.int=function(x){return notYetImplemented("int")},KernelBackend.prototype.clip=function(x,min,max){return notYetImplemented("clip")},KernelBackend.prototype.abs=function(x){return notYetImplemented("abs")},KernelBackend.prototype.complexAbs=function(x){return notYetImplemented("complexAbs")},KernelBackend.prototype.sigmoid=function(x){return notYetImplemented("sigmoid")},KernelBackend.prototype.softplus=function(x){return notYetImplemented("softplus")},KernelBackend.prototype.sin=function(x){return notYetImplemented("sin")},KernelBackend.prototype.cos=function(x){return notYetImplemented("cos")},KernelBackend.prototype.tan=function(x){return notYetImplemented("tan")},KernelBackend.prototype.asin=function(x){return notYetImplemented("asin")},KernelBackend.prototype.acos=function(x){return notYetImplemented("acos")},KernelBackend.prototype.atan=function(x){return notYetImplemented("atan")},KernelBackend.prototype.atan2=function(a,b){return notYetImplemented("atan2")},KernelBackend.prototype.sinh=function(x){return notYetImplemented("sinh")},KernelBackend.prototype.cosh=function(x){return notYetImplemented("cosh")},KernelBackend.prototype.tanh=function(x){return notYetImplemented("tanh")},KernelBackend.prototype.asinh=function(x){return notYetImplemented("asinh")},KernelBackend.prototype.acosh=function(x){return notYetImplemented("acosh")},KernelBackend.prototype.atanh=function(x){return notYetImplemented("atanh")},KernelBackend.prototype.erf=function(x){return notYetImplemented("erf")},KernelBackend.prototype.step=function(x,alpha){return notYetImplemented("step")},KernelBackend.prototype.fusedConv2d=function(_a){var input=_a.input,filter=_a.filter,convInfo=_a.convInfo,bias=_a.bias,activation=_a.activation,preluActivationWeights=_a.preluActivationWeights;return notYetImplemented("fusedConv2d")},KernelBackend.prototype.conv2d=function(x,filter,convInfo){return notYetImplemented("conv2d")},KernelBackend.prototype.conv2dDerInput=function(dy,filter,convInfo){return notYetImplemented("conv2dDerInput")},KernelBackend.prototype.conv2dDerFilter=function(x,dY,convInfo){return notYetImplemented("conv2dDerFilter")},KernelBackend.prototype.fusedDepthwiseConv2D=function(_a){var input=_a.input,filter=_a.filter,convInfo=_a.convInfo,bias=_a.bias,activation=_a.activation,preluActivationWeights=_a.preluActivationWeights;return notYetImplemented("fusedDepthwiseConv2D")},KernelBackend.prototype.depthwiseConv2D=function(input,filter,convInfo){return notYetImplemented("depthwiseConv2D")},KernelBackend.prototype.depthwiseConv2DDerInput=function(dy,filter,convInfo){return notYetImplemented("depthwiseConv2DDerInput")},KernelBackend.prototype.depthwiseConv2DDerFilter=function(x,dY,convInfo){return notYetImplemented("depthwiseConv2DDerFilter")},KernelBackend.prototype.conv3d=function(x,filter,convInfo){return notYetImplemented("conv3d")},KernelBackend.prototype.conv3dDerInput=function(dy,filter,convInfo){return notYetImplemented("conv3dDerInput")},KernelBackend.prototype.conv3dDerFilter=function(x,dY,convInfo){return notYetImplemented("conv3dDerFilter")},KernelBackend.prototype.maxPool=function(x,convInfo){return notYetImplemented("maxPool")},KernelBackend.prototype.maxPoolBackprop=function(dy,x,y,convInfo){return notYetImplemented("maxPoolBackprop")},KernelBackend.prototype.avgPool=function(x,convInfo){return notYetImplemented("avgPool")},KernelBackend.prototype.avgPoolBackprop=function(dy,x,convInfo){return notYetImplemented("avgPoolBackprop")},KernelBackend.prototype.avgPool3d=function(x,convInfo){return notYetImplemented("avgPool3d")},KernelBackend.prototype.avgPool3dBackprop=function(dy,x,convInfo){return notYetImplemented("avgPool3dBackprop")},KernelBackend.prototype.maxPool3d=function(x,convInfo){return notYetImplemented("maxPool3d")},KernelBackend.prototype.maxPool3dBackprop=function(dy,x,y,convInfo){return notYetImplemented("maxPool3dBackprop")},KernelBackend.prototype.reshape=function(x,shape){return notYetImplemented("reshape")},KernelBackend.prototype.cast=function(x,dtype){return notYetImplemented("cast")},KernelBackend.prototype.tile=function(x,reps){return notYetImplemented("tile")},KernelBackend.prototype.pad=function(x,paddings,constantValue){return notYetImplemented("pad")},KernelBackend.prototype.transpose=function(x,perm){return notYetImplemented("transpose")},KernelBackend.prototype.gather=function(x,indices,axis){return notYetImplemented("gather")},KernelBackend.prototype.gatherND=function(x,indices){return notYetImplemented("gatherND")},KernelBackend.prototype.scatterND=function(indices,updates,shape){return notYetImplemented("scatterND")},KernelBackend.prototype.batchToSpaceND=function(x,blockShape,crops){return notYetImplemented("batchToSpaceND")},KernelBackend.prototype.spaceToBatchND=function(x,blockShape,paddings){return notYetImplemented("spaceToBatchND")},KernelBackend.prototype.resizeBilinear=function(x,newHeight,newWidth,alignCorners){return notYetImplemented("resizeBilinear")},KernelBackend.prototype.resizeBilinearBackprop=function(dy,x,alignCorners){return notYetImplemented("resizeBilinearBackprop")},KernelBackend.prototype.resizeNearestNeighbor=function(x,newHEight,newWidth,alignCorners){return notYetImplemented("resizeNearestNeighbor")},KernelBackend.prototype.resizeNearestNeighborBackprop=function(dy,x,alignCorners){return notYetImplemented("resizeNearestNeighborBackprop")},KernelBackend.prototype.batchNormalization=function(x,mean,variance,varianceEpsilon,scale,offset){return notYetImplemented("batchNormalization")},KernelBackend.prototype.localResponseNormalization4D=function(x,radius,bias,alpha,beta){return notYetImplemented("localResponseNormalization4D")},KernelBackend.prototype.LRNGrad=function(dy,inputImage,outputImage,radius,bias,alpha,beta){return notYetImplemented("LRNGrad")},KernelBackend.prototype.multinomial=function(logits,normalized,numSamples,seed){return notYetImplemented("multinomial")},KernelBackend.prototype.oneHot=function(indices,depth,onValue,offValue){return notYetImplemented("oneHot")},KernelBackend.prototype.cumsum=function(x,axis,exclusive,reverse){return notYetImplemented("cumsum")},KernelBackend.prototype.nonMaxSuppression=function(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){return notYetImplemented("nonMaxSuppression")},KernelBackend.prototype.fft=function(x){return notYetImplemented("fft")},KernelBackend.prototype.ifft=function(x){return notYetImplemented("ifft")},KernelBackend.prototype.complex=function(real,imag){return notYetImplemented("complex")},KernelBackend.prototype.real=function(input){return notYetImplemented("real")},KernelBackend.prototype.imag=function(input){return notYetImplemented("imag")},KernelBackend.prototype.cropAndResize=function(image,boxes,boxIndex,cropSize,method,extrapolationValue){return notYetImplemented("cropAndResize")},KernelBackend.prototype.depthToSpace=function(x,blockSize,dataFormat){return notYetImplemented("depthToSpace")},KernelBackend.prototype.split=function(value,sizeSplits,axis){return notYetImplemented("split")},KernelBackend.prototype.sparseToDense=function(sparseIndices,sparseValues,outputShape,defaultValue){return notYetImplemented("sparseToDense")},KernelBackend.prototype.diag=function(x){return notYetImplemented("diag")},KernelBackend.prototype.fill=function(shape,value,dtype){return notYetImplemented("fill")},KernelBackend.prototype.onesLike=function(x){return notYetImplemented("onesLike")},KernelBackend.prototype.zerosLike=function(x){return notYetImplemented("zerosLike")},KernelBackend.prototype.linspace=function(start,stop,num){return notYetImplemented("linspace")},KernelBackend.prototype.dispose=function(){return notYetImplemented("dispose")},KernelBackend}();function notYetImplemented(kernelName){throw new Error("'"+kernelName+"' not yet implemented or not found in the registry. Did you forget to import the kernel?")}function computePool2DInfo(inShape,filterSize,strides,dilations,pad,roundingMode,dataFormat){void 0===dataFormat&&(dataFormat="channelsLast");var _a=parseTupleParam(filterSize),filterHeight=_a[0],filterWidth=_a[1],filterShape;if("channelsLast"===dataFormat)filterShape=[filterHeight,filterWidth,inShape[3],inShape[3]];else{if("channelsFirst"!==dataFormat)throw new Error("Unknown dataFormat "+dataFormat);filterShape=[filterHeight,filterWidth,inShape[1],inShape[1]]}return computeConv2DInfo(inShape,filterShape,strides,dilations,pad,roundingMode,!1,dataFormat)}function computePool3DInfo(inShape,filterSize,strides,dilations,pad,roundingMode,dataFormat){void 0===dataFormat&&(dataFormat="NDHWC");var _a=parse3TupleParam(filterSize),filterDepth=_a[0],filterHeight=_a[1],filterWidth=_a[2],filterShape,$dataFormat;if("NDHWC"===dataFormat)$dataFormat="channelsLast",filterShape=[filterDepth,filterHeight,filterWidth,inShape[4],inShape[4]];else{if("NCDHW"!==dataFormat)throw new Error("Unknown dataFormat "+dataFormat);$dataFormat="channelsFirst",filterShape=[filterDepth,filterHeight,filterWidth,inShape[1],inShape[1]]}return computeConv3DInfo(inShape,filterShape,strides,dilations,pad,!1,$dataFormat,roundingMode)}function computeConv2DInfo(inShape,filterShape,strides,dilations,pad,roundingMode,depthwise,dataFormat){void 0===depthwise&&(depthwise=!1),void 0===dataFormat&&(dataFormat="channelsLast");var _a=[-1,-1,-1,-1],batchSize=_a[0],inHeight=_a[1],inWidth=_a[2],inChannels=_a[3];if("channelsLast"===dataFormat)batchSize=inShape[0],inHeight=inShape[1],inWidth=inShape[2],inChannels=inShape[3];else{if("channelsFirst"!==dataFormat)throw new Error("Unknown dataFormat "+dataFormat);batchSize=inShape[0],inChannels=inShape[1],inHeight=inShape[2],inWidth=inShape[3]}var filterHeight=filterShape[0],filterWidth=filterShape[1],filterChannels=filterShape[3],_b=parseTupleParam(strides),strideHeight=_b[0],strideWidth=_b[1],_c=parseTupleParam(dilations),dilationHeight=_c[0],dilationWidth=_c[1],effectiveFilterHeight=getEffectiveFilterSize(filterHeight,dilationHeight),effectiveFilterWidth=getEffectiveFilterSize(filterWidth,dilationWidth),_d=getPadAndOutInfo(pad,inHeight,inWidth,strideHeight,strideWidth,effectiveFilterHeight,effectiveFilterWidth,roundingMode),padInfo=_d.padInfo,outHeight=_d.outHeight,outWidth=_d.outWidth,outChannels=depthwise?filterChannels*inChannels:filterChannels,outShape;return"channelsFirst"===dataFormat?outShape=[batchSize,outChannels,outHeight,outWidth]:"channelsLast"===dataFormat&&(outShape=[batchSize,outHeight,outWidth,outChannels]),{batchSize:batchSize,dataFormat:dataFormat,inHeight:inHeight,inWidth:inWidth,inChannels:inChannels,outHeight:outHeight,outWidth:outWidth,outChannels:outChannels,padInfo:padInfo,strideHeight:strideHeight,strideWidth:strideWidth,filterHeight:filterHeight,filterWidth:filterWidth,effectiveFilterHeight:effectiveFilterHeight,effectiveFilterWidth:effectiveFilterWidth,dilationHeight:dilationHeight,dilationWidth:dilationWidth,inShape:inShape,outShape:outShape,filterShape:filterShape}}function computeConv3DInfo(inShape,filterShape,strides,dilations,pad,depthwise,dataFormat,roundingMode){void 0===depthwise&&(depthwise=!1),void 0===dataFormat&&(dataFormat="channelsLast");var _a=[-1,-1,-1,-1,-1],batchSize=_a[0],inDepth=_a[1],inHeight=_a[2],inWidth=_a[3],inChannels=_a[4];if("channelsLast"===dataFormat)batchSize=inShape[0],inDepth=inShape[1],inHeight=inShape[2],inWidth=inShape[3],inChannels=inShape[4];else{if("channelsFirst"!==dataFormat)throw new Error("Unknown dataFormat "+dataFormat);batchSize=inShape[0],inChannels=inShape[1],inDepth=inShape[2],inHeight=inShape[3],inWidth=inShape[4]}var filterDepth=filterShape[0],filterHeight=filterShape[1],filterWidth=filterShape[2],filterChannels=filterShape[4],_b=parse3TupleParam(strides),strideDepth=_b[0],strideHeight=_b[1],strideWidth=_b[2],_c=parse3TupleParam(dilations),dilationDepth=_c[0],dilationHeight=_c[1],dilationWidth=_c[2],effectiveFilterDepth=getEffectiveFilterSize(filterDepth,dilationDepth),effectiveFilterHeight=getEffectiveFilterSize(filterHeight,dilationHeight),effectiveFilterWidth=getEffectiveFilterSize(filterWidth,dilationWidth),_d=get3DPadAndOutInfo(pad,inDepth,inHeight,inWidth,strideDepth,strideHeight,strideWidth,effectiveFilterDepth,effectiveFilterHeight,effectiveFilterWidth,roundingMode),padInfo=_d.padInfo,outDepth=_d.outDepth,outHeight=_d.outHeight,outWidth=_d.outWidth,outChannels=depthwise?filterChannels*inChannels:filterChannels,outShape;return"channelsFirst"===dataFormat?outShape=[batchSize,outChannels,outDepth,outHeight,outWidth]:"channelsLast"===dataFormat&&(outShape=[batchSize,outDepth,outHeight,outWidth,outChannels]),{batchSize:batchSize,dataFormat:dataFormat,inDepth:inDepth,inHeight:inHeight,inWidth:inWidth,inChannels:inChannels,outDepth:outDepth,outHeight:outHeight,outWidth:outWidth,outChannels:outChannels,padInfo:padInfo,strideDepth:strideDepth,strideHeight:strideHeight,strideWidth:strideWidth,filterDepth:filterDepth,filterHeight:filterHeight,filterWidth:filterWidth,effectiveFilterDepth:effectiveFilterDepth,effectiveFilterHeight:effectiveFilterHeight,effectiveFilterWidth:effectiveFilterWidth,dilationDepth:dilationDepth,dilationHeight:dilationHeight,dilationWidth:dilationWidth,inShape:inShape,outShape:outShape,filterShape:filterShape}}function computeOutputShape2D(inShape,fieldSize,stride,zeroPad,roundingMode){null==zeroPad&&(zeroPad=computeDefaultPad(inShape,fieldSize,stride));var inputRows=inShape[0],inputCols=inShape[1],outputRows=conditionalRound((inputRows-fieldSize+2*zeroPad)/stride+1,roundingMode);assert(isInt(outputRows),function(){return"The output # of rows ("+outputRows+") must be an integer. Change the stride and/or zero pad parameters"});var outputCols=conditionalRound((inputCols-fieldSize+2*zeroPad)/stride+1,roundingMode);return assert(isInt(outputCols),function(){return"The output # of columns ("+outputCols+") must be an integer. Change the stride and/or zero pad parameters"}),[outputRows,outputCols]}function computeOutputShape4D(inShape,fieldSize,outChannels,stride,zeroPad,roundingMode){null==zeroPad&&(zeroPad=computeDefaultPad(inShape,fieldSize,stride));var inputDepth=inShape[0],inputRows=inShape[1],inputCols=inShape[2],outputDepths=conditionalRound((inputDepth-fieldSize+2*zeroPad)/stride+1,roundingMode);assert(isInt(outputDepths),function(){return"The output # of depths ("+outputDepths+") must be an integer. Change the stride and/or zero pad parameters"});var outputRows=conditionalRound((inputRows-fieldSize+2*zeroPad)/stride+1,roundingMode);assert(isInt(outputRows),function(){return"The output # of rows ("+outputRows+") must be an integer. Change the stride and/or zero pad parameters"});var outputCols=conditionalRound((inputCols-fieldSize+2*zeroPad)/stride+1,roundingMode);return assert(isInt(outputCols),function(){return"The output # of columns ("+outputCols+") must be an integer. Change the stride and/or zero pad parameters"}),[outputDepths,outputRows,outputCols,outChannels]}function computeDefaultPad(inputShape,fieldSize,stride,dilation){void 0===dilation&&(dilation=1);var effectiveFieldSize=getEffectiveFilterSize(fieldSize,dilation);return Math.floor((inputShape[0]*(stride-1)-stride+effectiveFieldSize)/2)}function parseTupleParam(param){return"number"==typeof param?[param,param,param]:2===param.length?[param[0],param[1],1]:param}function parse3TupleParam(param){return"number"==typeof param?[param,param,param]:param}function getEffectiveFilterSize(filterSize,dilation){return dilation<=1?filterSize:filterSize+(filterSize-1)*(dilation-1)}function getPadAndOutInfo(pad,inHeight,inWidth,strideHeight,strideWidth,filterHeight,filterWidth,roundingMode){var padInfo,outHeight,outWidth;if("number"==typeof pad){var padType;padInfo={top:pad,bottom:pad,left:pad,right:pad,type:0===pad?"VALID":"NUMBER"};var outShape=computeOutputShape2D([inHeight,inWidth],filterHeight,strideHeight,pad,roundingMode);outHeight=outShape[0],outWidth=outShape[1]}else if("same"===pad){outHeight=Math.ceil(inHeight/strideHeight),outWidth=Math.ceil(inWidth/strideWidth);var padAlongHeight=Math.max(0,(outHeight-1)*strideHeight+filterHeight-inHeight),padAlongWidth=Math.max(0,(outWidth-1)*strideWidth+filterWidth-inWidth),top_1=Math.floor(padAlongHeight/2),bottom=padAlongHeight-top_1,left=Math.floor(padAlongWidth/2),right;padInfo={top:top_1,bottom:bottom,left:left,right:padAlongWidth-left,type:"SAME"}}else{if("valid"!==pad)throw Error("Unknown padding parameter: "+pad);padInfo={top:0,bottom:0,left:0,right:0,type:"VALID"},outHeight=Math.ceil((inHeight-filterHeight+1)/strideHeight),outWidth=Math.ceil((inWidth-filterWidth+1)/strideWidth)}return{padInfo:padInfo,outHeight:outHeight,outWidth:outWidth}}function get3DPadAndOutInfo(pad,inDepth,inHeight,inWidth,strideDepth,strideHeight,strideWidth,filterDepth,filterHeight,filterWidth,roundingMode){var padInfo,outDepth,outHeight,outWidth;if("number"==typeof pad){var padType;padInfo={top:pad,bottom:pad,left:pad,right:pad,front:pad,back:pad,type:0===pad?"VALID":"NUMBER"};var outShape=computeOutputShape4D([inDepth,inHeight,inWidth,1],filterDepth,1,strideDepth,pad,roundingMode);outDepth=outShape[0],outHeight=outShape[1],outWidth=outShape[2]}else if("same"===pad){var padAlongDepth=((outDepth=Math.ceil(inDepth/strideDepth))-1)*strideDepth+filterDepth-inDepth,padAlongHeight=((outHeight=Math.ceil(inHeight/strideHeight))-1)*strideHeight+filterHeight-inHeight,padAlongWidth=((outWidth=Math.ceil(inWidth/strideWidth))-1)*strideWidth+filterWidth-inWidth,front=Math.floor(padAlongDepth/2),back=padAlongDepth-front,top_2=Math.floor(padAlongHeight/2),bottom=padAlongHeight-top_2,left=Math.floor(padAlongWidth/2),right;padInfo={top:top_2,bottom:bottom,left:left,right:padAlongWidth-left,front:front,back:back,type:"SAME"}}else{if("valid"!==pad)throw Error("Unknown padding parameter: "+pad);padInfo={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},outDepth=Math.ceil((inDepth-filterDepth+1)/strideDepth),outHeight=Math.ceil((inHeight-filterHeight+1)/strideHeight),outWidth=Math.ceil((inWidth-filterWidth+1)/strideWidth)}return{padInfo:padInfo,outDepth:outDepth,outHeight:outHeight,outWidth:outWidth}}function conditionalRound(value,roundingMode){if(!roundingMode)return value;switch(roundingMode){case"round":return Math.round(value);case"ceil":return Math.ceil(value);case"floor":return Math.floor(value);default:throw new Error("Unknown roundingMode "+roundingMode)}}function tupleValuesAreOne(param){var _a=parseTupleParam(param),dimA=_a[0],dimB=_a[1],dimC=_a[2];return 1===dimA&&1===dimB&&1===dimC}function eitherStridesOrDilationsAreOne(strides,dilations){return tupleValuesAreOne(strides)||tupleValuesAreOne(dilations)}function convertConv2DDataFormat(dataFormat){if("NHWC"===dataFormat)return"channelsLast";if("NCHW"===dataFormat)return"channelsFirst";throw new Error("Unknown dataFormat "+dataFormat)}function castTensor(x,dtype,backend){if("complex64"===dtype){if("complex64"===x.dtype)return x.clone();var zerosTensor=zeros(x.shape),floatX=x.toFloat(),result=backend.complex(floatX,zerosTensor);return zerosTensor.dispose(),floatX.dispose(),result}if(!hasEncodingLoss(x.dtype,dtype))return ENGINE.makeTensorFromDataId(x.dataId,x.shape,dtype);if("complex64"===x.dtype){var real=backend.real(x),result=real.cast(dtype);return real.dispose(),result}if("int32"===dtype)return backend.int(x);if("bool"===dtype){var zero=scalar(0,x.dtype),result=backend.notEqual(x,zero);return zero.dispose(),result}throw new Error("Error in Cast: failed to cast "+x.dtype+" to "+dtype)}function reshapeTensor(x,shape){return ENGINE.makeTensorFromDataId(x.dataId,shape,x.dtype)}function linspaceImpl(start,stop,num){var step=(stop-start)/(num-1),values=makeZerosTypedArray(num,"float32");values[0]=start;for(var i=1;i<values.length;i++)values[i]=values[i-1]+step;return tensor1d(values,"float32")}var backend_util=Object.freeze({castTensor:castTensor,reshapeTensor:reshapeTensor,linspaceImpl:linspaceImpl,upcastType:upcastType,axesAreInnerMostDims:axesAreInnerMostDims,combineLocations:combineLocations,computeOutAndReduceShapes:computeOutAndReduceShapes,expandShapeToKeepDim:expandShapeToKeepDim,assertAxesAreInnerMostDims:assertAxesAreInnerMostDims,getAxesPermutation:getAxesPermutation,getUndoAxesPermutation:getUndoAxesPermutation,getInnerMostAxes:getInnerMostAxes,getBroadcastDims:getBroadcastDims,getReductionAxes:getReductionAxes,assertAndGetBroadcastShape:assertAndGetBroadcastShape,assertParamsConsistent:assertParamsConsistent,computeOutShape:computeOutShape,computePool2DInfo:computePool2DInfo,computePool3DInfo:computePool3DInfo,computeConv2DInfo:computeConv2DInfo,computeConv3DInfo:computeConv3DInfo,computeDefaultPad:computeDefaultPad,tupleValuesAreOne:tupleValuesAreOne,eitherStridesOrDilationsAreOne:eitherStridesOrDilationsAreOne,convertConv2DDataFormat:convertConv2DDataFormat,PARALLELIZE_THRESHOLD:PARALLELIZE_THRESHOLD,computeOptimalWindowSize:computeOptimalWindowSize});function mergeRealAndImagArrays(real,imag){if(real.length!==imag.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+real.length+", imag: "+imag.length+".");for(var result=new Float32Array(2*real.length),i=0;i<result.length;i+=2)result[i]=real[i/2],result[i+1]=imag[i/2];return result}function splitRealAndImagArrays(complex){for(var real=new Float32Array(complex.length/2),imag=new Float32Array(complex.length/2),i=0;i<complex.length;i+=2)real[i/2]=complex[i],imag[i/2]=complex[i+1];return{real:real,imag:imag}}function complexWithEvenIndex(complex){for(var len=Math.ceil(complex.length/4),real=new Float32Array(len),imag=new Float32Array(len),i=0;i<complex.length;i+=4)real[Math.floor(i/4)]=complex[i],imag[Math.floor(i/4)]=complex[i+1];return{real:real,imag:imag}}function complexWithOddIndex(complex){for(var len=Math.floor(complex.length/4),real=new Float32Array(len),imag=new Float32Array(len),i=2;i<complex.length;i+=4)real[Math.floor(i/4)]=complex[i],imag[Math.floor(i/4)]=complex[i+1];return{real:real,imag:imag}}function getComplexWithIndex(complex,index){var real,imag;return{real:complex[2*index],imag:complex[2*index+1]}}function assignToTypedArray(data,real,imag,index){data[2*index]=real,data[2*index+1]=imag}function exponents(n,inverse){for(var real=new Float32Array(n/2),imag=new Float32Array(n/2),i=0;i<Math.ceil(n/2);i++){var x=(inverse?2:-2)*Math.PI*(i/n);real[i]=Math.cos(x),imag[i]=Math.sin(x)}return{real:real,imag:imag}}function exponent(k,n,inverse){var x=(inverse?2:-2)*Math.PI*(k/n),real,imag;return{real:Math.cos(x),imag:Math.sin(x)}}function binaryInsert(arr,element,comparator){var index=binarySearch(arr,element,comparator),insertionPoint=index<0?-(index+1):index;arr.splice(insertionPoint,0,element)}function binarySearch(arr,target,comparator){return binarySearch_(arr,target,comparator||defaultComparator)}function defaultComparator(a,b){return a>b?1:a<b?-1:0}function binarySearch_(arr,target,comparator){for(var left=0,right=arr.length,middle=0,found=!1;left<right;){var compareResult=comparator(target,arr[middle=left+(right-left>>>1)]);compareResult>0?left=middle+1:(right=middle,found=!compareResult)}return found?left:-left-1}function nonMaxSuppressionV3(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){var dummySoftNmsSigma=0;return nonMaxSuppressionImpl_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,0).selectedIndices}function nonMaxSuppressionV5(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma){var returnScoresTensor=!0,result=nonMaxSuppressionImpl_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma,!0);return result.numValidOutputs.dispose(),{selectedIndices:result.selectedIndices,selectedScores:result.selectedScores}}function nonMaxSuppressionImpl_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma,returnScoresTensor,padToMaxOutputSize){void 0===returnScoresTensor&&(returnScoresTensor=!1),void 0===padToMaxOutputSize&&(padToMaxOutputSize=!1);for(var candidates=Array.from(scores).map(function(score,boxIndex){return{score:score,boxIndex:boxIndex,suppressBeginIndex:0}}).filter(function(c){return c.score>scoreThreshold}).sort(ascendingComparator),scale=softNmsSigma>0?-.5/softNmsSigma:0,selectedIndices=[],selectedScores=[];selectedIndices.length<maxOutputSize&&candidates.length>0;){var candidate=candidates.pop(),originalScore=candidate.score,boxIndex=candidate.boxIndex,suppressBeginIndex=candidate.suppressBeginIndex;if(originalScore<scoreThreshold)break;for(var ignoreCandidate=!1,j=selectedIndices.length-1;j>=suppressBeginIndex;--j){var iou=intersectionOverUnion(boxes,boxIndex,selectedIndices[j]);if(iou>=iouThreshold){ignoreCandidate=!0;break}if(candidate.score=candidate.score*suppressWeight(iouThreshold,scale,iou),candidate.score<=scoreThreshold)break}candidate.suppressBeginIndex=selectedIndices.length,ignoreCandidate||(candidate.score===originalScore?(selectedIndices.push(boxIndex),selectedScores.push(candidate.score)):candidate.score>scoreThreshold&&binaryInsert(candidates,candidate,ascendingComparator))}var numValidOutputs=selectedIndices.length;return padToMaxOutputSize&&(selectedIndices.fill(0,numValidOutputs),selectedScores.fill(0,numValidOutputs)),{selectedIndices:tensor1d(selectedIndices,"int32"),selectedScores:tensor1d(selectedScores,"float32"),numValidOutputs:scalar(numValidOutputs,"int32")}}function intersectionOverUnion(boxes,i,j){var iCoord=boxes.subarray(4*i,4*i+4),jCoord=boxes.subarray(4*j,4*j+4),yminI=Math.min(iCoord[0],iCoord[2]),xminI=Math.min(iCoord[1],iCoord[3]),ymaxI=Math.max(iCoord[0],iCoord[2]),xmaxI=Math.max(iCoord[1],iCoord[3]),yminJ=Math.min(jCoord[0],jCoord[2]),xminJ=Math.min(jCoord[1],jCoord[3]),ymaxJ=Math.max(jCoord[0],jCoord[2]),xmaxJ=Math.max(jCoord[1],jCoord[3]),areaI=(ymaxI-yminI)*(xmaxI-xminI),areaJ=(ymaxJ-yminJ)*(xmaxJ-xminJ);if(areaI<=0||areaJ<=0)return 0;var intersectionYmin=Math.max(yminI,yminJ),intersectionXmin=Math.max(xminI,xminJ),intersectionYmax=Math.min(ymaxI,ymaxJ),intersectionXmax=Math.min(xmaxI,xmaxJ),intersectionArea=Math.max(intersectionYmax-intersectionYmin,0)*Math.max(intersectionXmax-intersectionXmin,0);return intersectionArea/(areaI+areaJ-intersectionArea)}function suppressWeight(iouThreshold,scale,iou){var weight=Math.exp(scale*iou*iou);return iou<=iouThreshold?weight:0}function ascendingComparator(c1,c2){return c1.score-c2.score||c1.score===c2.score&&c2.boxIndex-c1.boxIndex}function split$1(x,sizeSplits,axis){var begin=new Array(x.rank).fill(0),size=x.shape.slice();return sizeSplits.map(function(s){size[axis]=s;var slice=x.slice(begin,size);return begin[axis]+=s,slice})}function tile(xBuf,reps){for(var newShape=new Array(xBuf.rank),i=0;i<newShape.length;i++)newShape[i]=xBuf.shape[i]*reps[i];for(var result=buffer(newShape,xBuf.dtype),i=0;i<result.values.length;++i){for(var newLoc=result.indexToLoc(i),originalLoc=new Array(xBuf.rank),j=0;j<originalLoc.length;j++)originalLoc[j]=newLoc[j]%xBuf.shape[j];var originalIndex=xBuf.locToIndex(originalLoc);result.values[i]=xBuf.values[originalIndex]}return result.toTensor()}function topkImpl(x,xShape,xDtype,k,sorted){for(var lastDim=xShape[xShape.length-1],_a=[x.length/lastDim,lastDim],batch=_a[0],size=_a[1],allTopKVals=getTypedArrayFromDType(xDtype,batch*k),allTopKIndices=getTypedArrayFromDType("int32",batch*k),b=0;b<batch;b++){for(var offset=b*size,vals=x.subarray(offset,offset+size),valAndInd=[],i=0;i<vals.length;i++)valAndInd.push({value:vals[i],index:i});valAndInd.sort(function(a,b){return b.value-a.value});for(var outOffset=b*k,topKVals=allTopKVals.subarray(outOffset,outOffset+k),topKIndices=allTopKIndices.subarray(outOffset,outOffset+k),i=0;i<k;i++)topKVals[i]=valAndInd[i].value,topKIndices[i]=valAndInd[i].index}var outputShape=xShape.slice();return outputShape[outputShape.length-1]=k,[tensor(allTopKVals,outputShape,xDtype),tensor(allTopKIndices,outputShape,"int32")]}function whereImpl(condShape,condVals){for(var indices=[],i=0;i<condVals.length;i++)condVals[i]&&indices.push(i);for(var inBuffer=buffer(condShape,"int32"),out=buffer([indices.length,condShape.length],"int32"),i=0;i<indices.length;i++){var loc=inBuffer.indexToLoc(indices[i]),offset=i*condShape.length;out.values.set(loc,offset)}return out.toTensor()}var AddNProgram=function(){function AddNProgram(outputShape,shapes){this.outputShape=[],this.outputShape=outputShape,this.variableNames=shapes.map(function(_,i){return"T"+i});var snippets=[];this.variableNames.forEach(function(variable){snippets.push("float v"+variable+" = get"+variable+"AtOutCoords();")});var operation=this.variableNames.map(function(variable){return"v"+variable}).join(" + ");this.userCode="\n      void main() {\n        "+snippets.join("\n        ")+"\n\n        float result = "+operation+";\n        setOutput(result);\n      }\n    "}return AddNProgram}(),AddNPackedProgram=function(){function AddNPackedProgram(outputShape,shapes){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=outputShape,this.variableNames=shapes.map(function(_,i){return"T"+i});var snippets=[];this.variableNames.forEach(function(variable){snippets.push("vec4 v"+variable+" = get"+variable+"AtOutCoords();")});var operation=this.variableNames.map(function(variable){return"v"+variable}).join(" + ");this.userCode="\n      void main() {\n        "+snippets.join("\n        ")+"\n\n        vec4 result = "+operation+";\n        setOutput(result);\n      }\n    "}return AddNPackedProgram}(),ArgMinMaxProgram=function(){function ArgMinMaxProgram(reduceInfo,op,firstPass){this.variableNames=["A"];var windowSize=reduceInfo.windowSize,batchSize=reduceInfo.batchSize,inSize=reduceInfo.inSize,outSize=Math.ceil(inSize/windowSize);firstPass||this.variableNames.push("bestIndicesA"),this.outputShape=[batchSize,outSize];var compOp="max"===op?">":"<",indexSnippet=firstPass?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+windowSize+";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < "+windowSize+"; i++) {\n          int inIdx = "+indexSnippet+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+compOp+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "}return ArgMinMaxProgram}();function getVecChannels(name,rank){return["x","y","z","w","u","v"].slice(0,rank).map(function(d){return name+"."+d})}function getChannels(name,rank){return 1===rank?[name]:getVecChannels(name,rank)}function getSourceCoords(rank,dims){if(1===rank)return"rc";for(var coords="",i=0;i<rank;i++)coords+=dims[i],i<rank-1&&(coords+=",");return coords}function getGlslDifferences(){var version,attribute,varyingVs,varyingFs,texture2D,output,defineOutput,defineSpecialNaN,defineSpecialInf,defineRound;return 2===env().getNumber("WEBGL_VERSION")?(version="#version 300 es",attribute="in",varyingVs="out",varyingFs="in",texture2D="texture",output="outputColor",defineOutput="out vec4 outputColor;",defineSpecialNaN="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",defineSpecialInf="",defineRound="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(version="",attribute="attribute",varyingVs="varying",varyingFs="varying",texture2D="texture2D",output="gl_FragColor",defineOutput="",defineSpecialNaN="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",defineSpecialInf="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",defineRound="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:version,attribute:attribute,varyingVs:varyingVs,varyingFs:varyingFs,texture2D:texture2D,output:output,defineOutput:defineOutput,defineSpecialNaN:defineSpecialNaN,defineSpecialInf:defineSpecialInf,defineRound:defineRound}}function getLogicalCoordinatesFromFlatIndex(coords,shape,index){void 0===index&&(index="index");var strides=computeStrides(shape);return strides.map(function(stride,i){var line1,line2;return"int "+coords[i]+" = "+index+" / "+stride+"; "+(i===strides.length-1?"int "+coords[i+1]+" = "+index+" - "+coords[i]+" * "+stride:"index -= "+coords[i]+" * "+stride)+";"}).join("")}function getFlatIndexFrom3D(shape){var strides=computeStrides(shape).map(function(d){return d.toString()});return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * "+strides[0]+" + coords.y * "+strides[1]+" + coords.z;\n  }\n"}var ENCODE_FLOAT_SNIPPET="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";function makeShader(inputsInfo,outputShape,userCode,usesPackedTextures){var prefixSnippets=[];inputsInfo.forEach(function(x){var size=sizeFromShape(x.shapeInfo.logicalShape);x.shapeInfo.isUniform?prefixSnippets.push("uniform float "+x.name+(size>1?"["+size+"]":"")+";"):(prefixSnippets.push("uniform sampler2D "+x.name+";"),prefixSnippets.push("uniform int offset"+x.name+";"))});var inputPrefixSnippet=prefixSnippets.join("\n"),inputSamplingSnippet=inputsInfo.map(function(x){return getInputSamplingSnippet(x,outputShape,usesPackedTextures)}).join("\n"),outTexShape=outputShape.texShape,glsl=getGlslDifferences(),floatTextureSampleSnippet=getFloatTextureSampleSnippet(glsl),outputSamplingSnippet,floatTextureSetOutputSnippet,shaderPrefix=getShaderPrefix(glsl),source;return outputShape.isPacked?(outputSamplingSnippet=getPackedOutputSamplingSnippet(outputShape.logicalShape,outTexShape),floatTextureSetOutputSnippet=getFloatTextureSetRGBASnippet(glsl)):(outputSamplingSnippet=getOutputSamplingSnippet(outputShape.logicalShape,outTexShape),floatTextureSetOutputSnippet=getFloatTextureSetRSnippet(glsl)),usesPackedTextures&&(shaderPrefix+=SHADER_PACKED_PREFIX),[shaderPrefix,floatTextureSampleSnippet,floatTextureSetOutputSnippet,inputPrefixSnippet,outputSamplingSnippet,inputSamplingSnippet,userCode].join("\n")}function getSamplerFromInInfo(inInfo){var shape=inInfo.shapeInfo.logicalShape;switch(shape.length){case 0:return getSamplerScalar(inInfo);case 1:return getSampler1D(inInfo);case 2:return getSampler2D(inInfo);case 3:return getSampler3D(inInfo);case 4:return getSampler4D(inInfo);case 5:return getSampler5D(inInfo);case 6:return getSampler6D(inInfo);default:throw new Error(shape.length+"-D input sampling is not yet supported")}}function getPackedSamplerFromInInfo(inInfo){var shape;switch(inInfo.shapeInfo.logicalShape.length){case 0:return getPackedSamplerScalar(inInfo);case 1:return getPackedSampler1D(inInfo);case 2:return getPackedSampler2D(inInfo);case 3:return getPackedSampler3D(inInfo);default:return getPackedSamplerND(inInfo)}}function getInputSamplingSnippet(inInfo,outShapeInfo,usesPackedTextures){void 0===usesPackedTextures&&(usesPackedTextures=!1);var res="";res+=usesPackedTextures?getPackedSamplerFromInInfo(inInfo):getSamplerFromInInfo(inInfo);var inShape=inInfo.shapeInfo.logicalShape,outShape=outShapeInfo.logicalShape;return inShape.length<=outShape.length&&(res+=usesPackedTextures?getPackedSamplerAtOutputCoords(inInfo,outShapeInfo):getSamplerAtOutputCoords(inInfo,outShapeInfo)),res}function getPackedOutputSamplingSnippet(outShape,outTexShape){switch(outShape.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return getOutputPacked1DCoords(outShape,outTexShape);case 2:return getOutputPacked2DCoords(outShape,outTexShape);case 3:return getOutputPacked3DCoords(outShape,outTexShape);default:return getOutputPackedNDCoords(outShape,outTexShape)}}function getOutputSamplingSnippet(outShape,outTexShape){switch(outShape.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return getOutput1DCoords(outShape,outTexShape);case 2:return getOutput2DCoords(outShape,outTexShape);case 3:return getOutput3DCoords(outShape,outTexShape);case 4:return getOutput4DCoords(outShape,outTexShape);case 5:return getOutput5DCoords(outShape,outTexShape);case 6:return getOutput6DCoords(outShape,outTexShape);default:throw new Error(outShape.length+"-D output sampling is not yet supported")}}function getFloatTextureSampleSnippet(glsl){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return "+glsl.texture2D+"(textureSampler, uv).r;\n    }\n  "}function getFloatTextureSetRSnippet(glsl){return"\n    void setOutput(float val) {\n      "+glsl.output+" = vec4(val, 0, 0, 0);\n    }\n  "}function getFloatTextureSetRGBASnippet(glsl){return"\n    void setOutput(vec4 val) {\n      "+glsl.output+" = val;\n    }\n  "}function getShaderPrefix(glsl){var SHADER_PREFIX;return glsl.version+"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    "+glsl.varyingFs+" vec2 resultUV;\n    "+glsl.defineOutput+"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    "+glsl.defineSpecialNaN+"\n    "+glsl.defineSpecialInf+"\n    "+glsl.defineRound+"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    "+SAMPLE_1D_SNIPPET+"\n    "+SAMPLE_2D_SNIPPET+"\n    "+SAMPLE_3D_SNIPPET+"\n  "}var SAMPLE_1D_SNIPPET="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_2D_SNIPPET="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_3D_SNIPPET="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SHADER_PACKED_PREFIX="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function getOutputScalarCoords(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function getOutputPacked1DCoords(shape,texShape){var packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)];return 1===packedTexShape[0]?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+packedTexShape[1]+".0);\n      }\n    ":1===packedTexShape[1]?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+packedTexShape[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+packedTexShape[0]+", "+packedTexShape[1]+"));\n      return 2 * (resTexRC.x * "+packedTexShape[1]+" + resTexRC.y);\n    }\n  "}function getOutput1DCoords(shape,texShape){return 1===texShape[0]?"\n      int getOutputCoords() {\n        return int(resultUV.x * "+texShape[1]+".0);\n      }\n    ":1===texShape[1]?"\n      int getOutputCoords() {\n        return int(resultUV.y * "+texShape[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+texShape[0]+", "+texShape[1]+"));\n      return resTexRC.x * "+texShape[1]+" + resTexRC.y;\n    }\n  "}function getOutputPacked3DCoords(shape,texShape){var packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)],texelsInLogicalRow=Math.ceil(shape[2]/2),texelsInBatch=texelsInLogicalRow*Math.ceil(shape[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+packedTexShape[0]+", "+packedTexShape[1]+"));\n      int index = resTexRC.x * "+packedTexShape[1]+" + resTexRC.y;\n\n      int b = index / "+texelsInBatch+";\n      index -= b * "+texelsInBatch+";\n\n      int r = 2 * (index / "+texelsInLogicalRow+");\n      int c = imod(index, "+texelsInLogicalRow+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  "}function getOutput3DCoords(shape,texShape){var coordsFromIndexSnippet=getLogicalCoordinatesFromFlatIndex(["r","c","d"],shape);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+texShape[0]+", "+texShape[1]+"));\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n      "+coordsFromIndexSnippet+"\n      return ivec3(r, c, d);\n    }\n  "}function getOutputPackedNDCoords(shape,texShape){for(var packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)],texelsInLogicalRow=Math.ceil(shape[shape.length-1]/2),texelsInBatch=texelsInLogicalRow*Math.ceil(shape[shape.length-2]/2),texelsInBatchN=texelsInBatch,batches="",coords="b, r, c",b=2;b<shape.length-1;b++)batches="\n      int b"+b+" = index / "+(texelsInBatchN*=shape[shape.length-b-1])+";\n      index -= b"+b+" * "+texelsInBatchN+";\n    "+batches,coords="b"+b+", "+coords;return"\n    ivec"+shape.length+" getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+packedTexShape[0]+", "+packedTexShape[1]+"));\n      int index = resTexRC.x * "+packedTexShape[1]+" + resTexRC.y;\n\n      "+batches+"\n\n      int b = index / "+texelsInBatch+";\n      index -= b * "+texelsInBatch+";\n\n      int r = 2 * (index / "+texelsInLogicalRow+");\n      int c = imod(index, "+texelsInLogicalRow+") * 2;\n\n      return ivec"+shape.length+"("+coords+");\n    }\n  "}function getOutput4DCoords(shape,texShape){var coordsFromIndexSnippet=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2"],shape);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+texShape[0]+", "+texShape[1]+"));\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n      "+coordsFromIndexSnippet+"\n      return ivec4(r, c, d, d2);\n    }\n  "}function getOutput5DCoords(shape,texShape){var coordsFromIndexSnippet=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3"],shape);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+texShape[0]+",\n                             "+texShape[1]+"));\n\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n\n      "+coordsFromIndexSnippet+"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "}function getOutput6DCoords(shape,texShape){var coordsFromIndexSnippet=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3","d4"],shape);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+texShape[0]+", "+texShape[1]+"));\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n\n      "+coordsFromIndexSnippet+"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "}function getOutputPacked2DCoords(shape,texShape){var packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)];if(arraysEqual(shape,texShape))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+packedTexShape[0]+", "+packedTexShape[1]+"));\n      }\n    ";var texelsInLogicalRow=Math.ceil(shape[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+packedTexShape[0]+", "+packedTexShape[1]+"));\n\n      int index = resTexRC.x * "+packedTexShape[1]+" + resTexRC.y;\n      int r = 2 * (index / "+texelsInLogicalRow+");\n      int c = imod(index, "+texelsInLogicalRow+") * 2;\n\n      return ivec2(r, c);\n    }\n  "}function getOutput2DCoords(shape,texShape){return arraysEqual(shape,texShape)?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+texShape[0]+", "+texShape[1]+"));\n      }\n    ":1===shape[1]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+texShape[0]+", "+texShape[1]+"));\n        int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":1===shape[0]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+texShape[0]+", "+texShape[1]+"));\n        int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+texShape[0]+", "+texShape[1]+"));\n      int index = resTexRC.x * "+texShape[1]+" + resTexRC.y;\n      int r = index / "+shape[1]+";\n      int c = index - r * "+shape[1]+";\n      return ivec2(r, c);\n    }\n  "}function getFlatOffsetUniformName(texName){return"offset"+texName}function getPackedSamplerScalar(inputInfo){var texName=inputInfo.name,funcName,glsl;return"\n    vec4 "+("get"+texName.charAt(0).toUpperCase()+texName.slice(1))+"() {\n      return "+getGlslDifferences().texture2D+"("+texName+", halfCR);\n    }\n  "}function getSamplerScalar(inputInfo){var texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1);if(inputInfo.shapeInfo.isUniform)return"float "+funcName+"() {return "+texName+";}";var _a=inputInfo.shapeInfo.texShape,texNumR=_a[0],texNumC=_a[1];if(1===texNumR&&1===texNumC)return"\n      float "+funcName+"() {\n        return sampleTexture("+texName+", halfCR);\n      }\n    ";var _b=inputInfo.shapeInfo.texShape,tNumR,tNumC,offset;return"\n    float "+funcName+"() {\n      vec2 uv = uvFromFlat("+_b[0]+", "+_b[1]+", "+getFlatOffsetUniformName(texName)+");\n      return sampleTexture("+texName+", uv);\n    }\n  "}function getPackedSampler1D(inputInfo){var texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),texShape=inputInfo.shapeInfo.texShape,packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)],glsl=getGlslDifferences();return"\n    vec4 "+funcName+"(int index) {\n      vec2 uv = packedUVfrom1D(\n        "+packedTexShape[0]+", "+packedTexShape[1]+", index);\n      return "+glsl.texture2D+"("+texName+", uv);\n    }\n  "}function getSampler1D(inputInfo){var texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1);if(inputInfo.shapeInfo.isUniform)return"\n      float "+funcName+"(int index) {\n        "+getUniformSampler(inputInfo)+"\n      }\n    ";var texShape=inputInfo.shapeInfo.texShape,tNumR=texShape[0],tNumC=texShape[1];if(1===tNumC&&1===tNumR)return"\n      float "+funcName+"(int index) {\n        return sampleTexture("+texName+", halfCR);\n      }\n    ";var offset=getFlatOffsetUniformName(texName);return 1===tNumC?"\n      float "+funcName+"(int index) {\n        vec2 uv = vec2(0.5, (float(index + "+offset+") + 0.5) / "+tNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    ":1===tNumR?"\n      float "+funcName+"(int index) {\n        vec2 uv = vec2((float(index + "+offset+") + 0.5) / "+tNumC+".0, 0.5);\n        return sampleTexture("+texName+", uv);\n      }\n    ":"\n    float "+funcName+"(int index) {\n      vec2 uv = uvFromFlat("+tNumR+", "+tNumC+", index + "+offset+");\n      return sampleTexture("+texName+", uv);\n    }\n  "}function getPackedSampler2D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),texShape=inputInfo.shapeInfo.texShape,texNumR=texShape[0],texNumC=texShape[1],glsl=getGlslDifferences();if(null!=texShape&&arraysEqual(shape,texShape))return"\n      vec4 "+funcName+"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2("+texNumC+".0, "+texNumR+".0);\n\n        return "+glsl.texture2D+"("+texName+", uv);\n      }\n    ";var packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)],valuesPerRow;return"\n    vec4 "+funcName+"(int row, int col) {\n      vec2 uv = packedUVfrom2D("+Math.ceil(shape[1]/2)+", "+packedTexShape[0]+", "+packedTexShape[1]+", row, col);\n      return "+glsl.texture2D+"("+texName+", uv);\n    }\n  "}function getSampler2D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),texShape=inputInfo.shapeInfo.texShape;if(null!=texShape&&arraysEqual(shape,texShape)){var texNumR_1=texShape[0],texNumC_1;return"\n    float "+funcName+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+texShape[1]+".0, "+texNumR_1+".0);\n      return sampleTexture("+texName+", uv);\n    }\n  "}var _a=squeezeShape(shape),newShape=_a.newShape,keptDims=_a.keptDims,squeezedShape=newShape;if(squeezedShape.length<shape.length){var newInputInfo,params=["row","col"];return"\n      "+getSamplerFromInInfo(squeezeInputInfo(inputInfo,squeezedShape))+"\n      float "+funcName+"(int row, int col) {\n        return "+funcName+"("+getSqueezedParams(params,keptDims)+");\n      }\n    "}if(inputInfo.shapeInfo.isUniform)return"\n      float "+funcName+"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2("+shape[1]+", 1)));\n        "+getUniformSampler(inputInfo)+"\n      }\n    ";var texNumR=texShape[0],texNumC=texShape[1],offset=getFlatOffsetUniformName(texName);return 1===texNumC?"\n    float "+funcName+"(int row, int col) {\n      float index = dot(vec3(row, col, "+offset+"), vec3("+shape[1]+", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / "+texNumR+".0);\n      return sampleTexture("+texName+", uv);\n    }\n  ":1===texNumR?"\n    float "+funcName+"(int row, int col) {\n      float index = dot(vec3(row, col, "+offset+"), vec3("+shape[1]+", 1, 1));\n      vec2 uv = vec2((index + 0.5) / "+texNumC+".0, 0.5);\n      return sampleTexture("+texName+", uv);\n    }\n  ":"\n  float "+funcName+"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * "+shape[1]+" + col + "+offset+";\n    vec2 uv = uvFromFlat("+texNumR+", "+texNumC+", index);\n    return sampleTexture("+texName+", uv);\n  }\n"}function getPackedSampler3D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),texShape=inputInfo.shapeInfo.texShape,packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)];if(1===shape[0]){var squeezedShape,keptDims=[1,2],newInputInfo,params=["b","row","col"];return"\n        "+getPackedSamplerFromInInfo(squeezeInputInfo(inputInfo,shape.slice(1)))+"\n        vec4 "+funcName+"(int b, int row, int col) {\n          return "+funcName+"("+getSqueezedParams(params,keptDims)+");\n        }\n      "}var texNumR=packedTexShape[0],texNumC=packedTexShape[1],valuesPerRow=Math.ceil(shape[2]/2),texelsInBatch,glsl;return"\n    vec4 "+funcName+"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        "+texNumR+", "+texNumC+", "+valuesPerRow*Math.ceil(shape[1]/2)+", "+valuesPerRow+", b, row, col);\n      return "+getGlslDifferences().texture2D+"("+texName+", uv);\n    }\n  "}function getSampler3D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),stride0=shape[1]*shape[2],stride1=shape[2],_a=squeezeShape(shape),newShape=_a.newShape,keptDims=_a.keptDims,squeezedShape=newShape;if(squeezedShape.length<shape.length){var newInputInfo,params=["row","col","depth"];return"\n        "+getSamplerFromInInfo(squeezeInputInfo(inputInfo,squeezedShape))+"\n        float "+funcName+"(int row, int col, int depth) {\n          return "+funcName+"("+getSqueezedParams(params,keptDims)+");\n        }\n      "}if(inputInfo.shapeInfo.isUniform)return"\n      float "+funcName+"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3("+stride0+", "+stride1+", 1)));\n        "+getUniformSampler(inputInfo)+"\n      }\n    ";var texShape=inputInfo.shapeInfo.texShape,texNumR=texShape[0],texNumC=texShape[1],flatOffset=inputInfo.shapeInfo.flatOffset,offset;return texNumC===stride0&&null==flatOffset?"\n        float "+funcName+"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2("+stride1+", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+texNumC+".0, "+texNumR+".0);\n          return sampleTexture("+texName+", uv);\n        }\n      ":texNumC===stride1&&null==flatOffset?"\n    float "+funcName+"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2("+shape[1]+", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+texNumC+".0, "+texNumR+".0);\n      return sampleTexture("+texName+", uv);\n    }\n  ":"\n      float "+funcName+"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * "+stride0+" + col * "+stride1+" + depth + "+getFlatOffsetUniformName(texName)+";\n        vec2 uv = uvFromFlat("+texNumR+", "+texNumC+", index);\n        return sampleTexture("+texName+", uv);\n      }\n  "}function getPackedSamplerND(inputInfo){for(var shape=inputInfo.shapeInfo.logicalShape,rank=shape.length,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),texShape=inputInfo.shapeInfo.texShape,packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)],texNumR=packedTexShape[0],texNumC=packedTexShape[1],valuesPerRow=Math.ceil(shape[rank-1]/2),texelsInBatch=valuesPerRow*Math.ceil(shape[rank-2]/2),params="int b, int row, int col",index="b * "+texelsInBatch+" + (row / 2) * "+valuesPerRow+" + (col / 2)",b=2;b<rank-1;b++)params="int b"+b+", "+params,index="b"+b+" * "+(texelsInBatch*=shape[rank-b-1])+" + "+index;var glsl;return"\n    vec4 "+funcName+"("+params+") {\n      int index = "+index+";\n      int texR = index / "+texNumC+";\n      int texC = index - texR * "+texNumC+";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+texNumC+", "+texNumR+");\n      return "+getGlslDifferences().texture2D+"("+texName+", uv);\n    }\n  "}function getSampler4D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),stride2=shape[3],stride1=shape[2]*stride2,stride0=shape[1]*stride1,_a=squeezeShape(shape),newShape=_a.newShape,keptDims=_a.keptDims;if(newShape.length<shape.length){var newInputInfo,params=["row","col","depth","depth2"];return"\n      "+getSamplerFromInInfo(squeezeInputInfo(inputInfo,newShape))+"\n      float "+funcName+"(int row, int col, int depth, int depth2) {\n        return "+funcName+"("+getSqueezedParams(params,keptDims)+");\n      }\n    "}if(inputInfo.shapeInfo.isUniform)return"\n      float "+funcName+"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4("+stride0+", "+stride1+", "+stride2+", 1)));\n        "+getUniformSampler(inputInfo)+"\n      }\n    ";var flatOffset=inputInfo.shapeInfo.flatOffset,texShape=inputInfo.shapeInfo.texShape,texNumR=texShape[0],texNumC=texShape[1],offset;return texNumC===stride0&&null==flatOffset?"\n      float "+funcName+"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3("+stride1+", "+stride2+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+texNumC+".0, "+texNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    ":texNumC===stride2&&null==flatOffset?"\n      float "+funcName+"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3("+shape[1]*shape[2]+", "+shape[2]+", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+texNumC+".0, "+texNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    ":"\n    float "+funcName+"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+stride0+" + col * "+stride1+" +\n          depth * "+stride2+" + depth2;\n      vec2 uv = uvFromFlat("+texNumR+", "+texNumC+", index + "+getFlatOffsetUniformName(texName)+");\n      return sampleTexture("+texName+", uv);\n    }\n  "}function getSampler5D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),stride3=shape[4],stride2=shape[3]*stride3,stride1=shape[2]*stride2,stride0=shape[1]*stride1,_a=squeezeShape(shape),newShape=_a.newShape,keptDims=_a.keptDims;if(newShape.length<shape.length){var newInputInfo,params=["row","col","depth","depth2","depth3"];return"\n      "+getSamplerFromInInfo(squeezeInputInfo(inputInfo,newShape))+"\n      float "+funcName+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+funcName+"("+getSqueezedParams(params,keptDims)+");\n      }\n    "}if(inputInfo.shapeInfo.isUniform)return"\n      float "+funcName+"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+stride0+", "+stride1+", "+stride2+", "+stride3+")) +\n          depth3;\n        "+getUniformSampler(inputInfo)+"\n      }\n    ";var flatOffset=inputInfo.shapeInfo.flatOffset,texShape=inputInfo.shapeInfo.texShape,texNumR=texShape[0],texNumC=texShape[1],offset;return texNumC===stride0&&null==flatOffset?"\n      float "+funcName+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4("+stride1+", "+stride2+", "+stride3+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+texNumC+".0, "+texNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    ":texNumC===stride3&&null==flatOffset?"\n      float "+funcName+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+shape[1]*shape[2]*shape[3]+",\n               "+shape[2]*shape[3]+", "+shape[3]+", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+texNumC+".0, "+texNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    ":"\n    float "+funcName+"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+stride0+" + col * "+stride1+" + depth * "+stride2+" +\n          depth2 * "+stride3+" + depth3 + "+getFlatOffsetUniformName(texName)+";\n      vec2 uv = uvFromFlat("+texNumR+", "+texNumC+", index);\n      return sampleTexture("+texName+", uv);\n    }\n  "}function getSampler6D(inputInfo){var shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),_a=squeezeShape(shape),newShape=_a.newShape,keptDims=_a.keptDims;if(newShape.length<shape.length){var newInputInfo,params=["row","col","depth","depth2","depth3","depth4"];return"\n      "+getSamplerFromInInfo(squeezeInputInfo(inputInfo,newShape))+"\n      float "+funcName+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+funcName+"("+getSqueezedParams(params,keptDims)+");\n      }\n    "}var stride4=shape[5],stride3=shape[4]*stride4,stride2=shape[3]*stride3,stride1=shape[2]*stride2,stride0=shape[1]*stride1;if(inputInfo.shapeInfo.isUniform)return"\n      float "+funcName+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4("+stride0+", "+stride1+", "+stride2+", "+stride3+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+stride4+", 1)));\n        "+getUniformSampler(inputInfo)+"\n      }\n    ";var flatOffset=inputInfo.shapeInfo.flatOffset,texShape=inputInfo.shapeInfo.texShape,texNumR=texShape[0],texNumC=texShape[1],offset;return texNumC===stride0&&null==flatOffset?"\n      float "+funcName+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4("+stride1+", "+stride2+", "+stride3+", "+stride4+")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+texNumC+".0, "+texNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    ":texNumC===stride4&&null==flatOffset?"\n      float "+funcName+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4("+shape[1]*shape[2]*shape[3]*shape[4]+",\n               "+shape[2]*shape[3]*shape[4]+",\n               "+shape[3]*shape[4]+",\n               "+shape[4]+")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+texNumC+".0, "+texNumR+".0);\n        return sampleTexture("+texName+", uv);\n      }\n    ":"\n    float "+funcName+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+stride0+" + col * "+stride1+" + depth * "+stride2+" +\n          depth2 * "+stride3+" + depth3 * "+stride4+" + depth4 + "+getFlatOffsetUniformName(texName)+";\n      vec2 uv = uvFromFlat("+texNumR+", "+texNumC+", index);\n      return sampleTexture("+texName+", uv);\n    }\n  "}function getUniformSampler(inputInfo){var texName=inputInfo.name,inSize=sizeFromShape(inputInfo.shapeInfo.logicalShape);return inSize<2?"return "+texName+";":"\n    for (int i = 0; i < "+inSize+"; i++) {\n      if (i == index) {\n        return "+texName+"[i];\n      }\n    }\n  "}function getPackedSamplerAtOutputCoords(inputInfo,outShapeInfo){var texName=inputInfo.name,texFuncSnippet=texName.charAt(0).toUpperCase()+texName.slice(1),funcName="get"+texFuncSnippet+"AtOutCoords",inRank=inputInfo.shapeInfo.logicalShape.length,outRank=outShapeInfo.logicalShape.length,broadcastDims=getBroadcastDims(inputInfo.shapeInfo.logicalShape,outShapeInfo.logicalShape),type=getCoordsDataType(outRank),rankDiff=outRank-inRank,coordsSnippet,fields=["x","y","z","w","u","v"];coordsSnippet=0===inRank?"":outRank<2&&broadcastDims.length>=1?"coords = 0;":broadcastDims.map(function(d){return"coords."+fields[d+rankDiff]+" = 0;"}).join("\n");var unpackedCoordsSnippet="";unpackedCoordsSnippet=outRank<2&&inRank>0?"coords":inputInfo.shapeInfo.logicalShape.map(function(s,i){return"coords."+fields[i+rankDiff]}).join(", ");var output="return outputValue;",inSize,isInputScalar=1===sizeFromShape(inputInfo.shapeInfo.logicalShape),outSize,isOutputScalar=1===sizeFromShape(outShapeInfo.logicalShape);if(1!==inRank||isInputScalar||isOutputScalar){if(isInputScalar&&!isOutputScalar)output=1===outRank?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(broadcastDims.length){var rows=inRank-2,cols=inRank-1;broadcastDims.indexOf(rows)>-1&&broadcastDims.indexOf(cols)>-1?output="return vec4(outputValue.x);":broadcastDims.indexOf(rows)>-1?output="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":broadcastDims.indexOf(cols)>-1&&(output="return vec4(outputValue.xx, outputValue.zz);")}}else output="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 "+funcName+"() {\n      "+type+" coords = getOutputCoords();\n      "+coordsSnippet+"\n      vec4 outputValue = get"+texFuncSnippet+"("+unpackedCoordsSnippet+");\n      "+output+"\n    }\n  "}function getSamplerAtOutputCoords(inputInfo,outShapeInfo){var texName=inputInfo.name,texFuncSnippet=texName.charAt(0).toUpperCase()+texName.slice(1),funcName="get"+texFuncSnippet+"AtOutCoords",outTexShape=outShapeInfo.texShape,inTexShape=inputInfo.shapeInfo.texShape,inRank=inputInfo.shapeInfo.logicalShape.length,outRank=outShapeInfo.logicalShape.length;if(!inputInfo.shapeInfo.isUniform&&inRank===outRank&&null==inputInfo.shapeInfo.flatOffset&&arraysEqual(inTexShape,outTexShape))return"\n      float "+funcName+"() {\n        return sampleTexture("+texName+", resultUV);\n      }\n    ";var type=getCoordsDataType(outRank),broadcastDims=getBroadcastDims(inputInfo.shapeInfo.logicalShape,outShapeInfo.logicalShape),rankDiff=outRank-inRank,coordsSnippet,fields=["x","y","z","w","u","v"],unpackedCoordsSnippet="";return"\n    float "+funcName+"() {\n      "+type+" coords = getOutputCoords();\n      "+(coordsSnippet=0===inRank?"":outRank<2&&broadcastDims.length>=1?"coords = 0;":broadcastDims.map(function(d){return"coords."+fields[d+rankDiff]+" = 0;"}).join("\n"))+"\n      return get"+texFuncSnippet+"("+(unpackedCoordsSnippet=outRank<2&&inRank>0?"coords":inputInfo.shapeInfo.logicalShape.map(function(s,i){return"coords."+fields[i+rankDiff]}).join(", "))+");\n    }\n  "}function getCoordsDataType(rank){if(rank<=1)return"int";if(2===rank)return"ivec2";if(3===rank)return"ivec3";if(4===rank)return"ivec4";if(5===rank)return"ivec5";if(6===rank)return"ivec6";throw Error("GPU for rank "+rank+" is not yet supported")}function squeezeInputInfo(inInfo,squeezedShape){var newInputInfo=JSON.parse(JSON.stringify(inInfo));return newInputInfo.shapeInfo.logicalShape=squeezedShape,newInputInfo}function getSqueezedParams(params,keptDims){return keptDims.map(function(d){return params[d]}).join(", ")}var ArgMinMaxPackedProgram=function(){function ArgMinMaxPackedProgram(shape,windowSize,op,firstPass){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,assert(shape.length>2,function(){return"Packed arg"+(op.charAt(0).toUpperCase()+op.slice(1))+" supports only inputs with rank above 2."});var inSize=shape[shape.length-1],outSize=Math.ceil(inSize/windowSize);this.outputShape=shape.slice(0,-1),outSize>1&&this.outputShape.push(outSize),firstPass||this.variableNames.push("bestIndicesA");var outShape=this.outputShape,rank=outShape.length,dtype=getCoordsDataType(rank),coords=getChannels("coords",rank),sourceLocSetup,sourceRank;if(1===outSize){var sourceLocDType=getCoordsDataType(sourceRank=rank+1);sourceLocSetup="\n        "+sourceLocDType+" sourceLocR = "+sourceLocDType+"("+coords.join()+", 0);\n        ++"+coords[rank-1]+";\n        "+sourceLocDType+" sourceLocG = "+sourceLocDType+"("+coords.join()+", 0);\n        ++"+coords[rank-2]+";\n        "+sourceLocDType+" sourceLocA = "+sourceLocDType+"("+coords.join()+", 0);\n        --"+coords[rank-1]+";\n        "+sourceLocDType+" sourceLocB = "+sourceLocDType+"("+coords.join()+", 0);\n        --"+coords[rank-2]+";"}else sourceRank=rank,sourceLocSetup="\n        "+dtype+" sourceLocR = coords;\n        ++"+coords[rank-1]+";\n        "+dtype+" sourceLocG = coords;\n        ++"+coords[rank-2]+";\n        "+dtype+" sourceLocA = coords;\n        --"+coords[rank-1]+";\n        "+dtype+" sourceLocB = coords;\n        --"+coords[rank-2]+";";var channels=["x","y","z","w","u","v"].slice(0,sourceRank),inChannel="."+channels[sourceRank-1],intChannels=channels.map(function(x){return"int "+x}),srcRCoords=getChannels("sourceLocR",sourceRank-1).concat("inIdx.r"),srcGCoords=getChannels("sourceLocG",sourceRank-1).concat("inIdx.g"),srcBCoords=getChannels("sourceLocB",sourceRank-1).concat("inIdx.b"),srcACoords=getChannels("sourceLocA",sourceRank-1).concat("inIdx.a"),compOp="max"===op?"greaterThan":"lessThan",fetchCandidateIdx=firstPass?"":"\n          inIdx = round(vec4(getBestIndicesAChannel("+srcRCoords.join()+"),\n                             getBestIndicesAChannel("+srcGCoords.join()+"),\n                             getBestIndicesAChannel("+srcBCoords.join()+"),\n                             getBestIndicesAChannel("+srcACoords.join()+")));",fetchValue="vec4(\n            getAChannel("+srcRCoords.join()+"),\n            hasNextCol ? getAChannel("+srcGCoords.join()+") : 0.,\n            hasNextRow ? getAChannel("+srcBCoords.join()+") : 0.,\n            hasNextRow && hasNextCol ? getAChannel("+srcACoords.join()+") : 0.)",getBestIndicesAChannelSnippet=firstPass?"":"\n      float getBestIndicesAChannel("+intChannels.join()+") {\n        return getChannel(getBestIndicesA("+channels.join()+"),\n                                          vec2("+channels.slice(-2).join()+"));\n      }";this.userCode="\n      float getAChannel("+intChannels.join()+") {\n        return getChannel(getA("+channels.join()+"),\n                               vec2("+channels.slice(-2).join()+"));\n      }\n      "+getBestIndicesAChannelSnippet+"\n      void main() {\n        "+dtype+" coords = getOutputCoords();\n        bool hasNextCol = "+coords[rank-1]+" < "+(outShape[rank-1]-1)+";\n        bool hasNextRow = "+coords[rank-2]+" < "+(outShape[rank-2]-1)+";\n        "+sourceLocSetup+"\n        ivec4 srcIdx = ivec4(sourceLocR"+inChannel+", sourceLocG"+inChannel+",\n          sourceLocB"+inChannel+", sourceLocA"+inChannel+") * "+windowSize+";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = "+fetchValue+";\n\n        for (int i = 0; i < "+windowSize+"; i++) {\n          inIdx = srcIdx;\n          "+fetchCandidateIdx+"\n          vec4 candidate = "+fetchValue+";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4("+compOp+"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "}return ArgMinMaxPackedProgram}(),AvgPool2DBackpropProgram=function(){function AvgPool2DBackpropProgram(convInfo){this.variableNames=["dy"],this.outputShape=convInfo.inShape;var filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,avgMultiplier=1/(filterHeight*filterWidth);this.userCode="\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n      const float avgMultiplier = float("+avgMultiplier+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+effectiveFilterHeight+";\n            wR += "+dilationHeight+") {\n          float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n          if (dyR < 0.0 || dyR >= "+convInfo.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+effectiveFilterWidth+";\n            wC+= "+dilationWidth+") {\n            float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n            if (dyC < 0.0 || dyC >= "+convInfo.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return AvgPool2DBackpropProgram}(),AvgPool3DBackpropProgram=function(){function AvgPool3DBackpropProgram(convInfo){this.variableNames=["dy"],this.outputShape=convInfo.inShape;var filterDepth=convInfo.filterDepth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=effectiveFilterDepth-1-convInfo.padInfo.front,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,avgMultiplier=1/(filterDepth*filterHeight*filterWidth);this.userCode="\n      const ivec3 pads = ivec3("+padFront+", "+padTop+", "+padLeft+");\n      const float avgMultiplier = float("+avgMultiplier+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+effectiveFilterDepth+";\n            wD += "+dilationDepth+") {\n          float dyD = float(dyDCorner + wD) / "+strideDepth+".0;\n\n          if (dyD < 0.0 || dyD >= "+convInfo.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+effectiveFilterHeight+";\n              wR += "+dilationHeight+") {\n            float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n            if (dyR < 0.0 || dyR >= "+convInfo.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+effectiveFilterWidth+";\n                wC += "+dilationWidth+") {\n              float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n              if (dyC < 0.0 || dyC >= "+convInfo.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return AvgPool3DBackpropProgram}(),BatchNormProgram=function(){function BatchNormProgram(xShape,meanShape,varianceShape,offsetShape,scaleShape,varianceEpsilon){this.outputShape=[],this.variableNames=["x","mean","variance"],assertAndGetBroadcastShape(xShape,meanShape),assertAndGetBroadcastShape(xShape,varianceShape);var offsetSnippet="0.0";null!=offsetShape&&(assertAndGetBroadcastShape(xShape,offsetShape),this.variableNames.push("offset"),offsetSnippet="getOffsetAtOutCoords()");var scaleSnippet="1.0";null!=scaleShape&&(assertAndGetBroadcastShape(xShape,scaleShape),this.variableNames.push("scale"),scaleSnippet="getScaleAtOutCoords()"),this.outputShape=xShape,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+offsetSnippet+";\n        float scale = "+scaleSnippet+";\n        float inv = scale * inversesqrt(variance + float("+varianceEpsilon+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "}return BatchNormProgram}(),BatchNormPackedProgram=function(){function BatchNormPackedProgram(xShape,meanShape,varianceShape,offsetShape,scaleShape,varianceEpsilon){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],assertAndGetBroadcastShape(xShape,meanShape),assertAndGetBroadcastShape(xShape,varianceShape);var offsetSnippet="vec4(0.0)";null!=offsetShape&&(assertAndGetBroadcastShape(xShape,offsetShape),this.variableNames.push("offset"),offsetSnippet="getOffsetAtOutCoords()");var scaleSnippet="vec4(1.0)";null!=scaleShape&&(assertAndGetBroadcastShape(xShape,scaleShape),this.variableNames.push("scale"),scaleSnippet="getScaleAtOutCoords()"),this.outputShape=xShape,this.userCode="\n      void main() {\n        vec4 offset = "+offsetSnippet+";\n        vec4 scale = "+scaleSnippet+";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+varianceEpsilon+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "}return BatchNormPackedProgram}(),COMPLEX_MULTIPLY_REAL="return areal * breal - aimag * bimag;",COMPLEX_MULTIPLY_IMAG="return areal * bimag + aimag * breal;",BinaryOpComplexProgram=function(){function BinaryOpComplexProgram(op,aShape,bShape){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=assertAndGetBroadcastShape(aShape,bShape),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+op+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "}return BinaryOpComplexProgram}(),CHECK_NAN_SNIPPET="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",ADD="return a + b;",SUB="return a - b;",MUL="return a * b;",DIV="\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",INT_DIV="\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",POW="\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",EQUAL="return float(a == b);",NOT_EQUAL="return float(a != b);",LESS="return float(a < b);",LESS_EQUAL="return float(a <= b);",GREATER="return float(a > b);",GREATER_EQUAL="return float(a >= b);",LOGICAL_AND="return float(a >= 1.0 && b >= 1.0);",LOGICAL_OR="return float(a >= 1.0 || b >= 1.0);",MAX=CHECK_NAN_SNIPPET+"\n  return max(a, b);\n",MIN=CHECK_NAN_SNIPPET+"\n  return min(a, b);\n",MOD="if (b == 0.0) return NAN;\n  return mod(a, b);",ATAN2=CHECK_NAN_SNIPPET+"\n  return atan(a, b);\n",ELU_DER="return (b >= 1.0) ? a : a * (b + 1.0);",PRELU="return (a < 0.) ? b * a : a;",BinaryOpProgram=function(){function BinaryOpProgram(op,aShape,bShape){this.variableNames=["A","B"],this.outputShape=assertAndGetBroadcastShape(aShape,bShape),this.userCode="\n      float binaryOperation(float a, float b) {\n        "+op+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "}return BinaryOpProgram}(),CHECK_NAN_SNIPPET$1="\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n",DIV$1="\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",INT_DIV$1="\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",POW$1="\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  "+CHECK_NAN_SNIPPET$1+"\n  return result;\n",PRELU$1="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",ELU_DER$1="\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",ATAN2$1="\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+CHECK_NAN_SNIPPET$1+"\n  return result;\n",EQUAL$1="\n  return vec4(equal(a, b));\n",NOT_EQUAL$1="\n  return vec4(notEqual(a, b));\n",LESS$1="\n  return vec4(lessThan(a, b));\n",LESS_EQUAL$1="\n  return vec4(lessThanEqual(a, b));\n",GREATER$1="\n  return vec4(greaterThan(a, b));\n",GREATER_EQUAL$1="\n  return vec4(greaterThanEqual(a, b));\n",LOGICAL_AND$1="\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",LOGICAL_OR$1="\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",MAX$1="\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+CHECK_NAN_SNIPPET$1+"\n  return result;\n",MIN$1="\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+CHECK_NAN_SNIPPET$1+"\n  return result;\n",MOD$1="\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  "+CHECK_NAN_SNIPPET$1+"\n  return result;\n",BinaryOpPackedProgram=function(){function BinaryOpPackedProgram(op,aShape,bShape,checkOutOfBounds){void 0===checkOutOfBounds&&(checkOutOfBounds=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=assertAndGetBroadcastShape(aShape,bShape);var rank=this.outputShape.length,checkOutOfBoundsString="",dtype;if(checkOutOfBounds)if(0===rank||1===sizeFromShape(this.outputShape))checkOutOfBoundsString="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(checkOutOfBoundsString="\n          "+getCoordsDataType(rank)+" coords = getOutputCoords();\n        ",1===rank)checkOutOfBoundsString+="\n            result.y = (coords + 1) >= "+this.outputShape[0]+" ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else{var channels=getChannels("coords",rank);checkOutOfBoundsString+="\n            bool nextRowOutOfBounds =\n              ("+channels[rank-2]+" + 1) >= "+this.outputShape[rank-2]+";\n            bool nextColOutOfBounds =\n              ("+channels[rank-1]+" + 1) >= "+this.outputShape[rank-1]+";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        "+op+"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        "+checkOutOfBoundsString+"\n\n        setOutput(result);\n      }\n    "}return BinaryOpPackedProgram}(),ClipProgram=function(){function ClipProgram(aShape){this.variableNames=["A"],this.outputShape=aShape,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}return ClipProgram.prototype.getCustomSetupFunc=function(min,max){var _this=this;return function(gpgpu,webGLProgram){null==_this.minLoc&&(_this.minLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"minVal"),_this.maxLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"maxVal")),gpgpu.gl.uniform1f(_this.minLoc,min),gpgpu.gl.uniform1f(_this.maxLoc,max)}},ClipProgram}(),ClipPackedProgram=function(){function ClipPackedProgram(aShape){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=aShape,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}return ClipPackedProgram.prototype.getCustomSetupFunc=function(min,max){var _this=this;return function(gpgpu,webGLProgram){null==_this.minLoc&&(_this.minLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"minVal"),_this.maxLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"maxVal")),gpgpu.gl.uniform1f(_this.minLoc,min),gpgpu.gl.uniform1f(_this.maxLoc,max)}},ClipPackedProgram}(),ComplexAbsProgram=function(){function ComplexAbsProgram(shape){this.variableNames=["real","imag"],this.outputShape=shape,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}return ComplexAbsProgram}(),ConcatProgram=function(){function ConcatProgram(shapes){this.outputShape=[],this.outputShape=computeOutShape(shapes,1),this.variableNames=shapes.map(function(_,i){return"T"+i});var offsets=new Array(shapes.length-1);offsets[0]=shapes[0][1];for(var i=1;i<offsets.length;i++)offsets[i]=offsets[i-1]+shapes[i][1];for(var snippets=["if (yC < "+offsets[0]+") setOutput(getT0(yR, yC));"],i=1;i<offsets.length;i++){var shift=offsets[i-1];snippets.push("else if (yC < "+offsets[i]+") setOutput(getT"+i+"(yR, yC-"+shift+"));")}var lastIndex=offsets.length,lastShift=offsets[offsets.length-1];snippets.push("else setOutput(getT"+lastIndex+"(yR, yC-"+lastShift+"));"),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        "+snippets.join("\n        ")+"\n      }\n    "}return ConcatProgram}(),ConcatPackedProgram=function(){function ConcatPackedProgram(shapes,axis){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=computeOutShape(shapes,axis);var shape=this.outputShape,rank=shape.length,dtype=getCoordsDataType(rank),coords=getChannels("coords",rank),channels=["x","y","z","w","u","v"].slice(0,rank);this.variableNames=shapes.map(function(_,i){return"T"+i});var offsets=new Array(shapes.length-1);offsets[0]=shapes[0][axis];for(var i=1;i<offsets.length;i++)offsets[i]=offsets[i-1]+shapes[i][axis];for(var channel=channels[axis],lastChannels=channels.slice(-2),allChannels=channels.join(),getValueSnippet="if ("+channel+" < "+offsets[0]+") {\n        return getChannel(\n            getT0("+allChannels+"), vec2("+lastChannels.join()+"));\n        }",i=1;i<offsets.length;i++){var shift_1=offsets[i-1];getValueSnippet+="\n        if ("+channel+" < "+offsets[i]+"  && "+channel+" >= "+offsets[i-1]+") {\n          return getChannel(\n            getT"+i+"("+shiftedChannels(channels,channel,shift_1)+"),\n            vec2("+shiftedChannels(lastChannels,channel,shift_1)+"));\n        }"}var lastIndex=offsets.length,shift=offsets[offsets.length-1];getValueSnippet+="\n        return getChannel(\n          getT"+lastIndex+"("+shiftedChannels(channels,channel,shift)+"),\n          vec2("+shiftedChannels(lastChannels,channel,shift)+"));",this.userCode="\n      float getValue("+channels.map(function(x){return"int "+x})+") {\n        "+getValueSnippet+"\n      }\n\n      void main() {\n        "+dtype+" coords = getOutputCoords();\n        vec4 result = vec4(getValue("+coords+"), 0., 0., 0.);\n\n        "+coords[rank-1]+" = "+coords[rank-1]+" + 1;\n        if ("+coords[rank-1]+" < "+shape[rank-1]+") {\n          result.g = getValue("+coords+");\n        }\n\n        "+coords[rank-2]+" = "+coords[rank-2]+" + 1;\n        if ("+coords[rank-2]+" < "+shape[rank-2]+") {\n          result.a = getValue("+coords+");\n        }\n\n        "+coords[rank-1]+" = "+coords[rank-1]+" - 1;\n        if ("+coords[rank-2]+" < "+shape[rank-2]+" &&\n            "+coords[rank-1]+" < "+shape[rank-1]+") {\n          result.b = getValue("+coords+");\n        }\n        setOutput(result);\n      }\n    "}return ConcatPackedProgram}();function shiftedChannels(channels,channel,shift){var channelIdx=channels.indexOf(channel),res;return channels.map(function(c,idx){return idx===channelIdx?c+" - "+shift:c}).join()}var Conv2DDerFilterProgram=function(){function Conv2DDerFilterProgram(convInfo){this.variableNames=["x","dy"],this.outputShape=convInfo.filterShape;var strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,isChannelsLast="channelsLast"===convInfo.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+convInfo.batchSize+"; b++) {\n          for (int yR = 0; yR < "+convInfo.outHeight+"; yR++) {\n            int xR = wR + yR * "+strideHeight+" - "+padTop+";\n\n            if (xR < 0 || xR >= "+convInfo.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+convInfo.outWidth+"; yC++) {\n              int xC = wC + yC * "+strideWidth+" - "+padLeft+";\n\n              if (xC < 0 || xC >= "+convInfo.inWidth+") {\n                continue;\n              }\n\n              if ("+isChannelsLast+") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return Conv2DDerFilterProgram}(),Conv2DDerInputProgram=function(){function Conv2DDerInputProgram(convInfo){this.variableNames=["dy","W"],this.outputShape=convInfo.inShape;var filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,isChannelsLast="channelsLast"===convInfo.dataFormat,padTop=filterHeight-1-convInfo.padInfo.top,padLeft=filterWidth-1-convInfo.padInfo.left,rowDim=isChannelsLast?1:2,colDim=isChannelsLast?2:3,channelDim=isChannelsLast?3:1;this.userCode="\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords["+channelDim+"];\n\n        ivec2 dyCorner = ivec2(coords["+rowDim+"], coords["+colDim+"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n          if (dyR < 0.0 || dyR >= "+convInfo.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+filterHeight+" - 1 - wR;\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n            if (dyC < 0.0 || dyC >= "+convInfo.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+filterWidth+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+convInfo.outChannels+"; d2++) {\n\n              if ("+isChannelsLast+") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return Conv2DDerInputProgram}(),Conv3DDerFilterProgram=function(){function Conv3DDerFilterProgram(convInfo){this.variableNames=["x","dy"],this.outputShape=convInfo.filterShape;var strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,padFront=convInfo.padInfo.front,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+convInfo.batchSize+"; b++) {\n          for (int yF = 0; yF < "+convInfo.outDepth+"; yF++) {\n            int xF = wF + yF * "+strideDepth+" - "+padFront+";\n\n            if (xF < 0 || xF >= "+convInfo.inDepth+") {\n              continue;\n            }\n\n            for (int yR = 0; yR < "+convInfo.outHeight+"; yR++) {\n              int xR = wR + yR * "+strideHeight+" - "+padTop+";\n\n              if (xR < 0 || xR >= "+convInfo.inHeight+") {\n                continue;\n              }\n\n              for (int yC = 0; yC < "+convInfo.outWidth+"; yC++) {\n                int xC = wC + yC * "+strideWidth+" - "+padLeft+";\n\n                if (xC < 0 || xC >= "+convInfo.inWidth+") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return Conv3DDerFilterProgram}(),Conv3DDerInputProgram=function(){function Conv3DDerInputProgram(convInfo){this.variableNames=["dy","W"],this.outputShape=convInfo.inShape;var filterDepth=convInfo.filterDepth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,padFront=filterDepth-1-convInfo.padInfo.front,padTop=filterHeight-1-convInfo.padInfo.top,padLeft=filterWidth-1-convInfo.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+padFront+", "+padTop+", "+padLeft+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+filterDepth+"; wF++) {\n          float dyF = float(dyFCorner + wF) / "+strideDepth+".0;\n\n          if (dyF < 0.0 || dyF >= "+convInfo.outDepth+".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = "+filterDepth+" - 1 - wF;\n\n          for (int wR = 0; wR < "+filterHeight+"; wR++) {\n            float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n            if (dyR < 0.0 || dyR >= "+convInfo.outHeight+".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = "+filterHeight+" - 1 - wR;\n\n            for (int wC = 0; wC < "+filterWidth+"; wC++) {\n              float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n              if (dyC < 0.0 || dyC >= "+convInfo.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = "+filterWidth+" - 1 - wC;\n\n              for (int d2 = 0; d2 < "+convInfo.outChannels+"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return Conv3DDerInputProgram}(),DepthwiseConv2DDerFilterProgram=function(){function DepthwiseConv2DDerFilterProgram(convInfo){this.variableNames=["x","dy"],this.outputShape=convInfo.filterShape;var strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,channelMul=convInfo.outChannels/convInfo.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+channelMul+" + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < "+convInfo.batchSize+"; b++) {\n          for (int yR = 0; yR < "+convInfo.outHeight+"; yR++) {\n            int xR = wR + yR * "+strideHeight+" - "+padTop+";\n\n            if (xR < 0 || xR >= "+convInfo.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+convInfo.outWidth+"; yC++) {\n              int xC = wC + yC * "+strideWidth+" - "+padLeft+";\n\n              if (xC < 0 || xC >= "+convInfo.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return DepthwiseConv2DDerFilterProgram}(),DepthwiseConv2DDerInputProgram=function(){function DepthwiseConv2DDerInputProgram(convInfo){this.variableNames=["dy","W"],this.outputShape=convInfo.inShape;var filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,padTop=filterHeight-1-convInfo.padInfo.top,padLeft=filterWidth-1-convInfo.padInfo.left,channelMul=convInfo.outChannels/convInfo.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n          if (dyR < 0.0 || dyR >= "+convInfo.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+filterHeight+" - 1 - wR;\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n            if (dyC < 0.0 || dyC >= "+convInfo.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+filterWidth+" - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+channelMul+"; dm++) {\n              int d2 = d1 * "+channelMul+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return DepthwiseConv2DDerInputProgram}(),Conv2DProgram=function(){function Conv2DProgram(convInfo,addBias,activation,hasPreluActivationWeights){void 0===addBias&&(addBias=!1),void 0===activation&&(activation=null),void 0===hasPreluActivationWeights&&(hasPreluActivationWeights=!1),this.variableNames=["x","W"],this.outputShape=convInfo.outShape;var padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,inputDepthNearestVec4=4*Math.floor(convInfo.inChannels/4),inputDepthVec4Remainder=convInfo.inChannels%4,isChannelsLast="channelsLast"===convInfo.dataFormat,rowDim=isChannelsLast?1:2,colDim=isChannelsLast?2:3,channelDim=isChannelsLast?3:1,activationSnippet="",applyActivationSnippet="";activation&&(activationSnippet=hasPreluActivationWeights?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+activation+"\n        }":"\n          float activation(float x) {\n            "+activation+"\n          }\n        ",applyActivationSnippet="result = activation(result);");var addBiasSnippet=addBias?"result += getBiasAtOutCoords();":"";addBias&&this.variableNames.push("bias"),hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+activationSnippet+"\n\n      const ivec2 strides = ivec2("+strideHeight+", "+strideWidth+");\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords["+channelDim+"];\n\n        ivec2 xRCCorner =\n            ivec2(coords["+rowDim+"], coords["+colDim+"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          int xR = xRCorner + wR * "+dilationHeight+";\n\n          if (xR < 0 || xR >= "+convInfo.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            int xC = xCCorner + wC * "+dilationWidth+";\n\n            if (xC < 0 || xC >= "+convInfo.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+inputDepthNearestVec4+"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if ("+isChannelsLast+") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if ("+(1===inputDepthVec4Remainder)+") {\n\n              if ("+isChannelsLast+") {\n                dotProd +=\n                    getX(batch, xR, xC, "+inputDepthNearestVec4+") *\n                    getW(wR, wC, "+inputDepthNearestVec4+", d2);\n              } else {\n                dotProd +=\n                    getX(batch, "+inputDepthNearestVec4+", xR, xC) *\n                    getW(wR, wC, "+inputDepthNearestVec4+", d2);\n              }\n\n            } else if ("+(2===inputDepthVec4Remainder)+") {\n              vec2 wValues = vec2(\n                getW(wR, wC, "+inputDepthNearestVec4+", d2),\n                getW(wR, wC, "+inputDepthNearestVec4+" + 1, d2)\n              );\n\n              if ("+isChannelsLast+") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, "+inputDepthNearestVec4+"),\n                  getX(batch, xR, xC, "+inputDepthNearestVec4+" + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, "+inputDepthNearestVec4+", xR, xC),\n                  getX(batch, "+inputDepthNearestVec4+" + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if ("+(3===inputDepthVec4Remainder)+") {\n              vec3 wValues = vec3(\n                getW(wR, wC, "+inputDepthNearestVec4+", d2),\n                getW(wR, wC, "+inputDepthNearestVec4+" + 1, d2),\n                getW(wR, wC, "+inputDepthNearestVec4+" + 2, d2)\n              );\n\n              if ("+isChannelsLast+") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, "+inputDepthNearestVec4+"),\n                  getX(batch, xR, xC, "+inputDepthNearestVec4+" + 1),\n                  getX(batch, xR, xC, "+inputDepthNearestVec4+" + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, "+inputDepthNearestVec4+", xR, xC),\n                  getX(batch, "+inputDepthNearestVec4+" + 1, xR, xC),\n                  getX(batch, "+inputDepthNearestVec4+" + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        "+addBiasSnippet+"\n        "+applyActivationSnippet+"\n        setOutput(result);\n      }\n    "}return Conv2DProgram}(),Conv3DProgram=function(){function Conv3DProgram(convInfo){this.variableNames=["x","W"],this.outputShape=convInfo.outShape;var padFront=convInfo.padInfo.front,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,filterDepth=convInfo.filterDepth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,inputDepthNearestVec4=4*Math.floor(convInfo.inChannels/4),inputDepthVec4Remainder=convInfo.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3("+strideDepth+", "+strideHeight+", "+strideWidth+");\n      const ivec3 pads = ivec3("+padFront+", "+padTop+", "+padLeft+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+filterDepth+"; wF++) {\n          int xF = xFCorner + wF * "+dilationDepth+";\n\n          if (xF < 0 || xF >= "+convInfo.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+filterHeight+"; wR++) {\n            int xR = xRCorner + wR * "+dilationHeight+";\n\n            if (xR < 0 || xR >= "+convInfo.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+filterWidth+"; wC++) {\n              int xC = xCCorner + wC * "+dilationWidth+";\n\n              if (xC < 0 || xC >= "+convInfo.inWidth+") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < "+inputDepthNearestVec4+"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if ("+(1===inputDepthVec4Remainder)+") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, "+inputDepthNearestVec4+") *\n                  getW(wF, wR, wC, "+inputDepthNearestVec4+", d2);\n              } else if ("+(2===inputDepthVec4Remainder)+") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, "+inputDepthNearestVec4+"),\n                  getX(batch, xF, xR, xC, "+inputDepthNearestVec4+" + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, "+inputDepthNearestVec4+", d2),\n                  getW(wF, wR, wC, "+inputDepthNearestVec4+" + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if ("+(3===inputDepthVec4Remainder)+") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, "+inputDepthNearestVec4+"),\n                  getX(batch, xF, xR, xC, "+inputDepthNearestVec4+" + 1),\n                  getX(batch, xF, xR, xC, "+inputDepthNearestVec4+" + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, "+inputDepthNearestVec4+", d2),\n                  getW(wF, wR, wC, "+inputDepthNearestVec4+" + 1, d2),\n                  getW(wF, wR, wC, "+inputDepthNearestVec4+" + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return Conv3DProgram}(),DepthwiseConv2DProgram=function(){function DepthwiseConv2DProgram(convInfo,addBias,activation,hasPreluActivation){void 0===addBias&&(addBias=!1),void 0===activation&&(activation=null),void 0===hasPreluActivation&&(hasPreluActivation=!1),this.variableNames=["x","W"],this.outputShape=convInfo.outShape;var xNumRows=convInfo.inHeight,xNumCols=convInfo.inWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,channelMul=convInfo.outChannels/convInfo.inChannels,activationSnippet="",applyActivationSnippet="";activation&&(activationSnippet=hasPreluActivation?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+activation+"\n        }":"\n          float activation(float x) {\n            "+activation+"\n          }\n        ",applyActivationSnippet="result = activation(result);");var addBiasSnippet=addBias?"result += getBiasAtOutCoords();":"";addBias&&this.variableNames.push("bias"),hasPreluActivation&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+activationSnippet+"\n\n      const ivec2 strides = ivec2("+strideHeight+", "+strideWidth+");\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+channelMul+";\n        int q = d2 - d1 * "+channelMul+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+filterHeight+"; wR++) {\n          int xR = xRCorner + wR * "+dilationHeight+";\n\n          if (xR < 0 || xR >= "+xNumRows+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+filterWidth+"; wC++) {\n            int xC = xCCorner + wC * "+dilationWidth+";\n\n            if (xC < 0 || xC >= "+xNumCols+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        "+addBiasSnippet+"\n        "+applyActivationSnippet+"\n        setOutput(result);\n      }\n    "}return DepthwiseConv2DProgram}(),DepthwiseConvPacked2DProgram=function(){function DepthwiseConvPacked2DProgram(convInfo,addBias,activation,hasPreluActivation){void 0===addBias&&(addBias=!1),void 0===activation&&(activation=null),void 0===hasPreluActivation&&(hasPreluActivation=!1),this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=convInfo.outShape;for(var xNumRows=convInfo.inHeight,xNumCols=convInfo.inWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,texelsAcross=filterWidth,mainLoop="int xR; int xC; int xCOffset;",r=0;r<filterHeight;r++)for(var c=0;c<filterWidth;c++)mainLoop+="\n          vec4 xTexelR"+r+"C"+2*c+" = vec4(0.);\n          vec4 wR"+r+"C"+c+" = vec4(0.);\n          vec4 xR"+r+"C"+c+" = vec4(0.);";for(var r=0;r<filterHeight;r++)for(var texelC=0;texelC<texelsAcross;texelC++){var c;if(mainLoop+="\n          xR = xRCorner + "+r*dilationHeight+";\n          xC = xCCorner + "+(c=2*texelC)*dilationWidth+";\n        ",1===strideWidth){if(c<filterWidth&&(mainLoop+=padLeft%2==1?"\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < "+xNumRows+" && xCOffset >= 0 && xCOffset < "+xNumCols+") {\n                  xTexelR"+r+"C"+c+" = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= "+xNumCols+") {\n                    xTexelR"+r+"C"+c+".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR"+r+"C"+c+" = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < "+xNumRows+" && xCOffset >= 0 && xCOffset < "+xNumCols+") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= "+xNumCols+") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR"+r+"C"+c+" = vec4(previous.zw, xTexelR"+r+"C"+c+".xy);\n                } else {\n                  xR"+r+"C"+c+" = vec4(0, 0, xTexelR"+r+"C"+c+".xy);\n                }\n              ":"\n                if(xR >= 0 && xR < "+xNumRows+" && xC >= 0 && xC < "+xNumCols+") {\n                  xTexelR"+r+"C"+c+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+r+"C"+c+" = vec4(0.);\n                }\n\n                xR"+r+"C"+c+" = xTexelR"+r+"C"+c+";\n              ",c+1<filterWidth)){var nextTexelOffset=padLeft%2==0?nearestLargerEven(dilationWidth):dilationWidth;dilationWidth%2==0&&padLeft%2==1||dilationWidth%2!=0&&padLeft%2!=1?(mainLoop+="\n                  xCOffset = xC + "+padLeft%2+" + "+nextTexelOffset+";\n\n                  if(xR >= 0 && xR < "+xNumRows+" &&\n                    xCOffset >= 0 && xCOffset < "+xNumCols+") {\n                    xTexelR"+r+"C"+(c+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n                ",dilationWidth>1&&(mainLoop+="\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < "+xNumRows+" &&\n                      xCOffset >= 0 && xCOffset < "+xNumCols+") {\n                      xTexelR"+r+"C"+c+" = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR"+r+"C"+c+" = vec4(0.);\n                    }\n                  "),mainLoop+="\n                  xR"+r+"C"+(c+1)+" = vec4(\n                    xTexelR"+r+"C"+c+".zw, xTexelR"+r+"C"+(c+2)+".xy);\n                "):mainLoop+="\n                  xCOffset = xC + "+nextTexelOffset+";\n\n                  if(xR >= 0 && xR < "+xNumRows+" &&\n                    xCOffset >= 0 && xCOffset < "+xNumCols+") {\n                    xTexelR"+r+"C"+(c+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR"+r+"C"+(c+1)+" = xTexelR"+r+"C"+(c+2)+";\n                "}}else c<filterWidth&&(mainLoop+="\n              if(xR >= 0 && xR < "+xNumRows+") {\n            ",padLeft%2==1?(mainLoop+="\n                xCOffset = xC + 1 - "+strideWidth+";\n                if(xCOffset >= 0 && xCOffset < "+xNumCols+") {\n                  xTexelR"+r+"C"+c+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+r+"C"+c+" = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < "+xNumCols+") {\n                  xTexelR"+r+"C"+(c+2)+" = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR"+r+"C"+(c+2)+" = vec4(0.);\n                }\n\n                xR"+r+"C"+c+" = vec4(\n                  xTexelR"+r+"C"+c+".zw, xTexelR"+r+"C"+(c+2)+".zw);\n              ",c+1<filterWidth&&(mainLoop+="\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + "+strideWidth+";\n                  if(xCOffset >= 0 && xCOffset < "+xNumCols+") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR"+r+"C"+(c+1)+" = vec4(xTexelR"+r+"C"+(c+2)+".xy, final.xy);\n                ")):(mainLoop+="\n                if(xC >= 0 && xC < "+xNumCols+") {\n                  xTexelR"+r+"C"+c+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+r+"C"+c+" = vec4(0.);\n                }\n\n                xCOffset = xC + "+strideWidth+";\n                if(xCOffset >= 0 && xCOffset < "+xNumCols+") {\n                  xTexelR"+r+"C"+(c+2)+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+r+"C"+(c+2)+" = vec4(0.);\n                }\n\n                xR"+r+"C"+c+" = vec4(\n                  xTexelR"+r+"C"+c+".xy, xTexelR"+r+"C"+(c+2)+".xy);\n              ",c+1<filterWidth&&(mainLoop+="\n                  xR"+r+"C"+(c+1)+" = vec4(\n                    xTexelR"+r+"C"+c+".zw, xTexelR"+r+"C"+(c+2)+".zw);\n                ")),mainLoop+="}");c<filterWidth&&(mainLoop+="\n            vec4 wTexelR"+r+"C"+c+" = getW("+r+", "+c+", d1, q);\n            wR"+r+"C"+c+" = vec4(wTexelR"+r+"C"+c+".xz, wTexelR"+r+"C"+c+".xz);\n          ",c+1<filterWidth&&(mainLoop+="\n              vec4 wTexelR"+r+"C"+(c+1)+" = getW("+r+", "+(c+1)+", d1, q);\n              wR"+r+"C"+(c+1)+" =\n                vec4(wTexelR"+r+"C"+(c+1)+".xz, wTexelR"+r+"C"+(c+1)+".xz);"))}for(var r=0;r<filterHeight;r++)for(var c=0;c<filterWidth;c++)mainLoop+="dotProd += xR"+r+"C"+c+" * wR"+r+"C"+c+";";var activationSnippet="",applyActivationSnippet="";activation&&(activationSnippet=hasPreluActivation?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+activation+"\n        }":"vec4 activation(vec4 x) {\n          "+activation+"\n        }",applyActivationSnippet="result = activation(result);");var addBiasSnippet=addBias?"result += getBiasAtOutCoords();":"";addBias&&this.variableNames.push("bias"),hasPreluActivation&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+activationSnippet+"\n\n      const ivec2 strides = ivec2("+strideHeight+", "+strideWidth+");\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        "+mainLoop+"\n\n        vec4 result = dotProd;\n        "+addBiasSnippet+"\n        "+applyActivationSnippet+"\n        setOutput(result);\n      }\n    "}return DepthwiseConvPacked2DProgram}(),CropAndResizeProgram=function(){function CropAndResizeProgram(imageShape,boxShape,cropSize,method,extrapolationValue){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var batch=imageShape[0],imageHeight=imageShape[1],imageWidth=imageShape[2],depth=imageShape[3],numBoxes=boxShape[0],cropHeight=cropSize[0],cropWidth=cropSize[1];this.outputShape=[numBoxes,cropHeight,cropWidth,depth];var methodId="bilinear"===method?1:0,_a=[imageHeight-1+".0",imageWidth-1+".0"],inputHeightFloat=_a[0],inputWidthFloat=_a[1],_b=cropHeight>1?[""+(imageHeight-1)/(cropHeight-1),"(y2-y1) * height_ratio","y1*"+inputHeightFloat+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+inputHeightFloat],heightRatio=_b[0],heightScale=_b[1],inY=_b[2],_c=cropWidth>1?[""+(imageWidth-1)/(cropWidth-1),"(x2-x1) * width_ratio","x1*"+inputWidthFloat+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+inputWidthFloat],widthRatio=_c[0],widthScale=_c[1],inX=_c[2];this.userCode="\n      const float height_ratio = float("+heightRatio+");\n      const float width_ratio = float("+widthRatio+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+batch+") {\n          return;\n        }\n\n        float height_scale = "+heightScale+";\n        float width_scale = "+widthScale+";\n\n        float in_y = "+inY+";\n        if( in_y < 0.0 || in_y > "+inputHeightFloat+" ) {\n          setOutput(float("+extrapolationValue+"));\n          return;\n        }\n        float in_x = "+inX+";\n        if( in_x < 0.0 || in_x > "+inputWidthFloat+" ) {\n          setOutput(float("+extrapolationValue+"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if("+methodId+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "}return CropAndResizeProgram}(),CumSumProgram=function(){function CumSumProgram(shape,exclusive,reverse){this.variableNames=["x"],this.outputShape=shape;var rank=shape.length,finalDim=shape[shape.length-1],comparator=reverse?"<":">";this.userCode="\n      int getIndex(int i) {\n        "+(reverse?"return "+finalDim+" -i - 1;":"return i;")+"\n      }\n\n      void main() {\n        "+getCoordsDataType(rank)+" coords = getOutputCoords();\n        int end = "+getFinalCoord(rank,"coords")+";\n        float val = 0.0;\n        for (int i = "+finalDim+" - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx "+comparator+" end) {\n            continue;\n          }\n          if (idx == end && "+exclusive+") {\n            continue;\n          }\n          "+getFinalCoord(rank,"coords")+" = idx;\n          val += getX("+getCoords(rank,"coords")+");\n        }\n        setOutput(val);\n      }\n    "}return CumSumProgram}();function getCoords(rank,name){if(1===rank)return""+name;if(2===rank)return name+".x, "+name+".y";if(3===rank)return name+".x, "+name+".y, "+name+".z";if(4===rank)return name+".x, "+name+".y, "+name+".z, "+name+".w";throw Error("Cumulative sum for rank "+rank+" is not yet supported")}function getFinalCoord(rank,name){if(1===rank)return""+name;if(2===rank)return name+".y";if(3===rank)return name+".z";if(4===rank)return name+".w";throw Error("Cumulative sum for rank "+rank+" is not yet supported")}var DecodeMatrixProgram=function(){function DecodeMatrixProgram(outputShape){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=PackingScheme.DENSE;var texShape=getDenseTexShape(outputShape),glsl=getGlslDifferences();this.outputShape=outputShape,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+getLogicalCoordinatesFromFlatIndex(["r","c","d"],outputShape)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+texShape[0]+", "+texShape[1]+"));\n        int index = 4 * (resTexRC.x * "+texShape[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        "+glsl.output+" = result;\n      }\n    "}return DecodeMatrixProgram}(),DecodeMatrixPackedProgram=function(){function DecodeMatrixPackedProgram(outputShape){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=PackingScheme.DENSE;var texShape=getDenseTexShape(outputShape),glsl=getGlslDifferences();this.outputShape=outputShape,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+getLogicalCoordinatesFromFlatIndex(["r","c","d"],outputShape)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+texShape[0]+", "+texShape[1]+"));\n        int index = 4 * (resTexRC.x * "+texShape[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        "+glsl.output+" = result;\n      }\n    "}return DecodeMatrixPackedProgram}(),DepthToSpaceProgram=function(){function DepthToSpaceProgram(outputShape,blockSize,dataFormat){this.variableNames=["x"],this.outputShape=[],this.outputShape=outputShape,this.blockSize=blockSize,this.dataFormat=dataFormat,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+blockSize+";\n      int offset_h = imod(h, "+blockSize+");\n      int in_w = w / "+blockSize+";\n      int offset_w = imod(w, "+blockSize+");\n      int offset_d = (offset_h * "+blockSize+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}return DepthToSpaceProgram.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},DepthToSpaceProgram.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},DepthToSpaceProgram.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},DepthToSpaceProgram.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},DepthToSpaceProgram.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},DepthToSpaceProgram}(),DiagProgram=function(){function DiagProgram(size){this.variableNames=["X"],this.outputShape=[size,size],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}return DiagProgram}(),EncodeFloatProgram=function(){function EncodeFloatProgram(outputShape){this.variableNames=["A"],this.outTexUsage=TextureUsage.DOWNLOAD;var glsl=getGlslDifferences();this.outputShape=outputShape,this.userCode="\n      "+ENCODE_FLOAT_SNIPPET+"\n\n      void main() {\n        float x = getAAtOutCoords();\n        "+glsl.output+" = encode_float(x);\n      }\n    "}return EncodeFloatProgram}(),EncodeFloatPackedProgram=function(){function EncodeFloatPackedProgram(outputShape){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=TextureUsage.DOWNLOAD;var glsl=getGlslDifferences();this.outputShape=outputShape,this.userCode="\n      "+ENCODE_FLOAT_SNIPPET+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        "+glsl.output+" = encode_float(x);\n      }\n    "}return EncodeFloatPackedProgram}(),EncodeMatrixProgram=function(){function EncodeMatrixProgram(outputShape,texShape,inputIsUnsignedByte){void 0===inputIsUnsignedByte&&(inputIsUnsignedByte=!1),this.variableNames=["A"];var glsl=getGlslDifferences(),height=texShape[0],width=texShape[1];this.outputShape=outputShape;var output="result";inputIsUnsignedByte&&(output="floor(result * 255. + 0.5)"),this.userCode="\n      "+getFlatIndexFrom3D(outputShape)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / "+width+";\n        int c = imod(flatIndex, "+width+");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2("+width+".0, "+height+".0);\n        vec4 values = "+glsl.texture2D+"(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        "+glsl.output+" = vec4("+output+", 0., 0., 0.);\n      }\n    "}return EncodeMatrixProgram}(),EncodeMatrixPackedProgram=function(){function EncodeMatrixPackedProgram(outputShape,texShape,inputIsUnsignedByte){void 0===inputIsUnsignedByte&&(inputIsUnsignedByte=!1),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var glsl=getGlslDifferences(),height=texShape[0],width=texShape[1];this.outputShape=outputShape;var mainLoop="",output="result";inputIsUnsignedByte&&(output="floor(result * 255. + 0.5)");for(var row=0;row<=1;row++)for(var col=0;col<=1;col++){var channel=2*row+col;mainLoop+="\n          localCoords = coords;\n          if(localCoords[2] + "+col+" < "+outputShape[2]+") {\n            localCoords[2] += "+col+";\n            if(localCoords[1] + "+row+" < "+outputShape[1]+") {\n              localCoords[1] += "+row+";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / "+width+";\n              c = imod(flatIndex, "+width+");\n              uv = (vec2(c, r) + halfCR) / vec2("+width+".0, "+height+".0);\n              values = "+glsl.texture2D+"(A, uv);\n\n              if(offset == 0) {\n                result["+channel+"] = values[0];\n              } else if(offset == 1) {\n                result["+channel+"] = values[1];\n              } else if(offset == 2) {\n                result["+channel+"] = values[2];\n              } else {\n                result["+channel+"] = values[3];\n              }\n            }\n          }\n        "}this.userCode="\n      "+getFlatIndexFrom3D(outputShape)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        "+mainLoop+"\n\n        "+glsl.output+" = "+output+";\n      }\n    "}return EncodeMatrixPackedProgram}(),COMPLEX_FFT_REAL="return real * expR - imag * expI;",COMPLEX_FFT_IMAG="return real * expI + imag * expR;",FFTProgram=function(){function FFTProgram(op,inputShape,inverse){this.variableNames=["real","imag"];var innerDim=inputShape[1];this.outputShape=inputShape;var exponentMultiplierSnippet=inverse?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,resultDenominator=inverse?innerDim+".0":"1.0";this.userCode="\n      const float exponentMultiplier = "+exponentMultiplierSnippet+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+op+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float("+innerDim+");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < "+innerDim+"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / "+resultDenominator+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "}return FFTProgram}(),FillProgram=function(){function FillProgram(shape,value){this.outputShape=[],this.variableNames=["x"],this.outputShape=shape,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}return FillProgram.prototype.getCustomSetupFunc=function(value){var _this=this;return function(gpgpu,webGLProgram){null==_this.valueLoc&&(_this.valueLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"value")),gpgpu.gl.uniform1f(_this.valueLoc,value)}},FillProgram}(),GatherProgram=function(){function GatherProgram(aShape,indicesLength,axis){this.variableNames=["A","indices"];var outputShape=aShape.slice();outputShape[axis]=indicesLength,this.outputShape=outputShape,this.rank=outputShape.length;var dtype=getCoordsDataType(this.rank),sourceCoords=getSourceCoords$1(aShape,axis);this.userCode="\n      void main() {\n        "+dtype+" resRC = getOutputCoords();\n        setOutput(getA("+sourceCoords+"));\n      }\n    "}return GatherProgram}();function getSourceCoords$1(aShape,axis){var rank=aShape.length;if(rank>4)throw Error("Gather for rank "+rank+" is not yet supported");if(1===rank)return"int(getIndices(resRC))";for(var currentCoords=["resRC.x","resRC.y","resRC.z","resRC.w"],sourceCoords=[],i=0;i<aShape.length;i++)i===axis?sourceCoords.push("int(getIndices("+currentCoords[i]+"))"):sourceCoords.push(""+currentCoords[i]);return sourceCoords.join()}var GatherNDProgram=function(){function GatherNDProgram(sliceDim,strides,shape){this.sliceDim=sliceDim,this.strides=strides,this.variableNames=["x","indices"],this.outputShape=shape;var stridesType=getCoordsDataType(strides.length),dtype=getCoordsDataType(shape.length),strideString=this.sliceDim>1?"strides[j]":"strides";this.userCode="\n        "+stridesType+" strides = "+stridesType+"("+this.strides+");\n         void main() {\n          "+dtype+" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < "+this.sliceDim+"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * "+strideString+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "}return GatherNDProgram}();function createVertexShader$1(gl,debug){var glsl=getGlslDifferences(),vertexShaderSource;return createVertexShader(gl,debug,glsl.version+"\n    precision highp float;\n    "+glsl.attribute+" vec3 clipSpacePos;\n    "+glsl.attribute+" vec2 uv;\n    "+glsl.varyingVs+" vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function createVertexBuffer(gl,debug){var vertexArray;return createStaticVertexBuffer(gl,debug,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function createIndexBuffer(gl,debug){var triangleVertexIndices;return createStaticIndexBuffer(gl,debug,new Uint16Array([0,1,2,2,1,3]))}function createAndConfigureTexture(gl,debug,width,height,internalFormat,textureFormat,textureType){validateTextureSize(width,height);var texture=createTexture(gl,debug),tex2d=gl.TEXTURE_2D;return callAndCheck(gl,debug,function(){return gl.bindTexture(tex2d,texture)}),callAndCheck(gl,debug,function(){return gl.texParameteri(tex2d,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE)}),callAndCheck(gl,debug,function(){return gl.texParameteri(tex2d,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE)}),callAndCheck(gl,debug,function(){return gl.texParameteri(tex2d,gl.TEXTURE_MIN_FILTER,gl.NEAREST)}),callAndCheck(gl,debug,function(){return gl.texParameteri(tex2d,gl.TEXTURE_MAG_FILTER,gl.NEAREST)}),callAndCheck(gl,debug,function(){return gl.texImage2D(tex2d,0,internalFormat,width,height,0,textureFormat,textureType,null)}),callAndCheck(gl,debug,function(){return gl.bindTexture(gl.TEXTURE_2D,null)}),texture}function createFloat32MatrixTexture(gl,debug,rows,columns,textureConfig){var _a=getUnpackedMatrixTextureShapeWidthHeight(rows,columns),width,height;return createAndConfigureTexture(gl,debug,_a[0],_a[1],textureConfig.internalFormatFloat,textureConfig.textureFormatFloat,gl.FLOAT)}function createFloat16MatrixTexture(gl,debug,rows,columns,textureConfig){var _a=getUnpackedMatrixTextureShapeWidthHeight(rows,columns),width,height;return createAndConfigureTexture(gl,debug,_a[0],_a[1],textureConfig.internalFormatHalfFloat,textureConfig.textureFormatFloat,textureConfig.textureTypeHalfFloat)}function createUnsignedBytesMatrixTexture(gl,debug,rows,columns,textureConfig){var _a=getUnpackedMatrixTextureShapeWidthHeight(rows,columns),width,height;return createAndConfigureTexture(gl,debug,_a[0],_a[1],gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE)}function createPackedMatrixTexture(gl,debug,rows,columns,textureConfig){var _a=getPackedMatrixTextureShapeWidthHeight(rows,columns),width,height;return createAndConfigureTexture(gl,debug,_a[0],_a[1],textureConfig.internalFormatPackedFloat,gl.RGBA,gl.FLOAT)}function createFloat16PackedMatrixTexture(gl,debug,rows,columns,textureConfig){var _a=getPackedMatrixTextureShapeWidthHeight(rows,columns),width,height;return createAndConfigureTexture(gl,debug,_a[0],_a[1],textureConfig.internalFormatPackedHalfFloat,gl.RGBA,textureConfig.textureTypeHalfFloat)}function bindVertexProgramAttributeStreams(gl,debug,program,vertexBuffer){var posOffset=0,uvOffset=12,stride=20,success;return callAndCheck(gl,debug,function(){return gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer)}),bindVertexBufferToProgramAttribute(gl,debug,program,"clipSpacePos",vertexBuffer,3,20,0)&&bindVertexBufferToProgramAttribute(gl,debug,program,"uv",vertexBuffer,2,20,12)}function uploadDenseMatrixToTexture(gl,debug,texture,width,height,data,textureConfig){var dataForUpload,texelDataType,internalFormat;callAndCheck(gl,debug,function(){return gl.bindTexture(gl.TEXTURE_2D,texture)}),data instanceof Uint8Array?(dataForUpload=new Uint8Array(width*height*4),texelDataType=gl.UNSIGNED_BYTE,internalFormat=gl.RGBA):(dataForUpload=new Float32Array(width*height*4),texelDataType=gl.FLOAT,internalFormat=textureConfig.internalFormatPackedFloat),dataForUpload.set(data),callAndCheck(gl,debug,function(){return gl.texImage2D(gl.TEXTURE_2D,0,internalFormat,width,height,0,gl.RGBA,texelDataType,dataForUpload)}),callAndCheck(gl,debug,function(){return gl.bindTexture(gl.TEXTURE_2D,null)})}function uploadPixelDataToTexture(gl,debug,texture,pixels){callAndCheck(gl,debug,function(){return gl.bindTexture(gl.TEXTURE_2D,texture)}),pixels.data instanceof Uint8Array?callAndCheck(gl,debug,function(){return gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,pixels.width,pixels.height,0,gl.RGBA,gl.UNSIGNED_BYTE,pixels.data)}):callAndCheck(gl,debug,function(){return gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,pixels)}),callAndCheck(gl,debug,function(){return gl.bindTexture(gl.TEXTURE_2D,null)})}function createBufferFromOutputTexture(gl2,debug,rows,columns,textureConfig){var buffer=gl2.createBuffer();callAndCheck(gl2,debug,function(){return gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER,buffer)});var bytesPerFloat=4,valuesPerTexel=4,bufferSizeBytes=16*rows*columns;return callAndCheck(gl2,debug,function(){return gl2.bufferData(gl2.PIXEL_PACK_BUFFER,bufferSizeBytes,gl2.STREAM_READ)}),callAndCheck(gl2,debug,function(){return gl2.readPixels(0,0,columns,rows,gl2.RGBA,gl2.FLOAT,0)}),callAndCheck(gl2,debug,function(){return gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER,null)}),buffer}function downloadFloat32MatrixFromBuffer(gl,buffer,size){var gl2=gl,downloadTarget=new Float32Array(size);return gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER,buffer),gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER,0,downloadTarget),gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER,null),downloadTarget}function downloadByteEncodedFloatMatrixFromOutputTexture(gl,debug,rows,columns,textureConfig){var _a=getUnpackedMatrixTextureShapeWidthHeight(rows,columns),w=_a[0],h=_a[1],numChannels=4,downloadTarget=new Uint8Array(getUnpackedArraySizeFromMatrixSize(rows*columns,4));return callAndCheck(gl,debug,function(){return gl.readPixels(0,0,w,h,textureConfig.downloadTextureFormat,gl.UNSIGNED_BYTE,downloadTarget)}),new Float32Array(downloadTarget.buffer)}function downloadPackedMatrixFromBuffer(gl,buffer,batch,rows,cols,physicalRows,physicalCols,textureConfig){var gl2=gl,downloadTarget=new Float32Array(getPackedRGBAArraySizeFromMatrixShape(physicalRows,physicalCols));return gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER,buffer),gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER,0,downloadTarget),gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER,null),downloadTarget}function downloadMatrixFromPackedOutputTexture(gl,debug,physicalRows,physicalCols){var packedRGBA=new Float32Array(physicalRows*physicalCols*4);return callAndCheck(gl,debug,function(){return gl.readPixels(0,0,physicalCols,physicalRows,gl.RGBA,gl.FLOAT,packedRGBA)}),packedRGBA}var gpgpu_util=Object.freeze({createVertexShader:createVertexShader$1,createVertexBuffer:createVertexBuffer,createIndexBuffer:createIndexBuffer,createFloat32MatrixTexture:createFloat32MatrixTexture,createFloat16MatrixTexture:createFloat16MatrixTexture,createUnsignedBytesMatrixTexture:createUnsignedBytesMatrixTexture,createPackedMatrixTexture:createPackedMatrixTexture,createFloat16PackedMatrixTexture:createFloat16PackedMatrixTexture,bindVertexProgramAttributeStreams:bindVertexProgramAttributeStreams,uploadDenseMatrixToTexture:uploadDenseMatrixToTexture,uploadPixelDataToTexture:uploadPixelDataToTexture,createBufferFromOutputTexture:createBufferFromOutputTexture,downloadFloat32MatrixFromBuffer:downloadFloat32MatrixFromBuffer,downloadByteEncodedFloatMatrixFromOutputTexture:downloadByteEncodedFloatMatrixFromOutputTexture,downloadPackedMatrixFromBuffer:downloadPackedMatrixFromBuffer,downloadMatrixFromPackedOutputTexture:downloadMatrixFromPackedOutputTexture}),GPGPUContext=function(){function GPGPUContext(gl){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];var glVersion=env().getNumber("WEBGL_VERSION");null!=gl?(this.gl=gl,setWebGLContext(glVersion,gl)):this.gl=getWebGLContext(glVersion);var COLOR_BUFFER_FLOAT="WEBGL_color_buffer_float",COLOR_BUFFER_HALF_FLOAT="EXT_color_buffer_half_float";if(1===env().getNumber("WEBGL_VERSION")){var TEXTURE_FLOAT="OES_texture_float",TEXTURE_HALF_FLOAT="OES_texture_half_float";if(this.textureFloatExtension=getExtensionOrThrow(this.gl,this.debug,TEXTURE_FLOAT),hasExtension(this.gl,TEXTURE_HALF_FLOAT))this.textureHalfFloatExtension=getExtensionOrThrow(this.gl,this.debug,TEXTURE_HALF_FLOAT);else if(env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(COLOR_BUFFER_FLOAT),hasExtension(this.gl,COLOR_BUFFER_HALF_FLOAT))this.colorBufferHalfFloatExtension=getExtensionOrThrow(this.gl,this.debug,COLOR_BUFFER_HALF_FLOAT);else if(env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(COLOR_BUFFER_FLOAT="EXT_color_buffer_float",hasExtension(this.gl,COLOR_BUFFER_FLOAT))this.colorBufferFloatExtension=this.gl.getExtension(COLOR_BUFFER_FLOAT);else{if(!hasExtension(this.gl,COLOR_BUFFER_HALF_FLOAT))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT)}this.vertexBuffer=createVertexBuffer(this.gl,this.debug),this.indexBuffer=createIndexBuffer(this.gl,this.debug),this.framebuffer=createFramebuffer(this.gl,this.debug),this.textureConfig=getTextureConfig(this.gl,this.textureHalfFloatExtension)}return Object.defineProperty(GPGPUContext.prototype,"debug",{get:function(){return env().getBool("DEBUG")},enumerable:!0,configurable:!0}),GPGPUContext.prototype.dispose=function(){var _this=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var gl=this.gl;callAndCheck(gl,this.debug,function(){return gl.finish()}),callAndCheck(gl,this.debug,function(){return gl.bindFramebuffer(gl.FRAMEBUFFER,null)}),callAndCheck(gl,this.debug,function(){return gl.deleteFramebuffer(_this.framebuffer)}),callAndCheck(gl,this.debug,function(){return gl.bindBuffer(gl.ARRAY_BUFFER,null)}),callAndCheck(gl,this.debug,function(){return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null)}),callAndCheck(gl,this.debug,function(){return gl.deleteBuffer(_this.indexBuffer)}),this.disposed=!0}},GPGPUContext.prototype.createFloat32MatrixTexture=function(rows,columns){return this.throwIfDisposed(),createFloat32MatrixTexture(this.gl,this.debug,rows,columns,this.textureConfig)},GPGPUContext.prototype.createFloat16MatrixTexture=function(rows,columns){return this.throwIfDisposed(),createFloat16MatrixTexture(this.gl,this.debug,rows,columns,this.textureConfig)},GPGPUContext.prototype.createUnsignedBytesMatrixTexture=function(rows,columns){return this.throwIfDisposed(),createUnsignedBytesMatrixTexture(this.gl,this.debug,rows,columns,this.textureConfig)},GPGPUContext.prototype.uploadPixelDataToTexture=function(texture,pixels){this.throwIfDisposed(),uploadPixelDataToTexture(this.gl,this.debug,texture,pixels)},GPGPUContext.prototype.uploadDenseMatrixToTexture=function(texture,width,height,data){this.throwIfDisposed(),uploadDenseMatrixToTexture(this.gl,this.debug,texture,width,height,data,this.textureConfig)},GPGPUContext.prototype.createFloat16PackedMatrixTexture=function(rows,columns){return this.throwIfDisposed(),createFloat16PackedMatrixTexture(this.gl,this.debug,rows,columns,this.textureConfig)},GPGPUContext.prototype.createPackedMatrixTexture=function(rows,columns){return this.throwIfDisposed(),createPackedMatrixTexture(this.gl,this.debug,rows,columns,this.textureConfig)},GPGPUContext.prototype.deleteMatrixTexture=function(texture){var _this=this;this.throwIfDisposed(),this.outputTexture===texture&&(unbindColorTextureFromFramebuffer(this.gl,this.debug,this.framebuffer),this.outputTexture=null),callAndCheck(this.gl,this.debug,function(){return _this.gl.deleteTexture(texture)})},GPGPUContext.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(texture,rows,columns){var _this=this;return this.downloadMatrixDriver(texture,function(){return downloadByteEncodedFloatMatrixFromOutputTexture(_this.gl,_this.debug,rows,columns,_this.textureConfig)})},GPGPUContext.prototype.downloadPackedMatrixFromBuffer=function(buffer,batch,rows,columns,physicalRows,physicalCols){return downloadPackedMatrixFromBuffer(this.gl,buffer,batch,rows,columns,physicalRows,physicalCols,this.textureConfig)},GPGPUContext.prototype.downloadFloat32MatrixFromBuffer=function(buffer,size){return downloadFloat32MatrixFromBuffer(this.gl,buffer,size)},GPGPUContext.prototype.createBufferFromTexture=function(texture,rows,columns){this.bindTextureToFrameBuffer(texture);var result=createBufferFromOutputTexture(this.gl,this.debug,rows,columns,this.textureConfig);return this.unbindTextureToFrameBuffer(),result},GPGPUContext.prototype.createAndWaitForFence=function(){var fenceContext=this.createFence(this.gl);return this.pollFence(fenceContext)},GPGPUContext.prototype.createFence=function(gl){var _this=this,query,isFencePassed;if(env().getBool("WEBGL_FENCE_API_ENABLED")){var gl2_1=gl,sync_1=gl2_1.fenceSync(gl2_1.SYNC_GPU_COMMANDS_COMPLETE,0);gl.flush(),isFencePassed=function(){var status=gl2_1.clientWaitSync(sync_1,0,0);return status===gl2_1.ALREADY_SIGNALED||status===gl2_1.CONDITION_SATISFIED},query=sync_1}else env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(query=this.beginQuery(),this.endQuery(),isFencePassed=function(){return _this.isQueryAvailable(query,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):isFencePassed=function(){return!0};return{query:query,isFencePassed:isFencePassed}},GPGPUContext.prototype.downloadMatrixFromPackedTexture=function(texture,physicalRows,physicalCols){var _this=this;return this.downloadMatrixDriver(texture,function(){return downloadMatrixFromPackedOutputTexture(_this.gl,_this.debug,physicalRows,physicalCols)})},GPGPUContext.prototype.createProgram=function(fragmentShaderSource){this.throwIfDisposed();var gl=this.gl,fragmentShader=createFragmentShader(gl,this.debug,fragmentShaderSource),vertexShader=createVertexShader$1(gl,this.debug),program=createProgram(gl,this.debug);return callAndCheck(gl,this.debug,function(){return gl.attachShader(program,vertexShader)}),callAndCheck(gl,this.debug,function(){return gl.attachShader(program,fragmentShader)}),linkProgram(gl,this.debug,program),this.debug&&validateProgram(gl,this.debug,program),this.vertexAttrsAreBound||(this.setProgram(program),this.vertexAttrsAreBound=bindVertexProgramAttributeStreams(gl,this.debug,this.program,this.vertexBuffer)),program},GPGPUContext.prototype.deleteProgram=function(program){var _this=this;this.throwIfDisposed(),program===this.program&&(this.program=null),null!=program&&callAndCheck(this.gl,this.debug,function(){return _this.gl.deleteProgram(program)})},GPGPUContext.prototype.setProgram=function(program){var _this=this;this.throwIfDisposed(),this.program=program,null!=this.program&&this.debug&&validateProgram(this.gl,this.debug,this.program),callAndCheck(this.gl,this.debug,function(){return _this.gl.useProgram(program)})},GPGPUContext.prototype.getUniformLocation=function(program,uniformName,shouldThrow){return void 0===shouldThrow&&(shouldThrow=!0),this.throwIfDisposed(),shouldThrow?getProgramUniformLocationOrThrow(this.gl,this.debug,program,uniformName):getProgramUniformLocation(this.gl,program,uniformName)},GPGPUContext.prototype.getAttributeLocation=function(program,attribute){var _this=this;return this.throwIfDisposed(),callAndCheck(this.gl,this.debug,function(){return _this.gl.getAttribLocation(program,attribute)})},GPGPUContext.prototype.getUniformLocationNoThrow=function(program,uniformName){return this.throwIfDisposed(),this.gl.getUniformLocation(program,uniformName)},GPGPUContext.prototype.setInputMatrixTexture=function(inputMatrixTexture,uniformLocation,textureUnit){this.throwIfDisposed(),this.throwIfNoProgram(),bindTextureToProgramUniformSampler(this.gl,this.debug,this.program,inputMatrixTexture,uniformLocation,textureUnit)},GPGPUContext.prototype.setOutputMatrixTexture=function(outputMatrixTexture,rows,columns){this.setOutputMatrixTextureDriver(outputMatrixTexture,columns,rows)},GPGPUContext.prototype.setOutputPackedMatrixTexture=function(outputPackedMatrixTexture,rows,columns){this.throwIfDisposed();var _a=getPackedMatrixTextureShapeWidthHeight(rows,columns),width=_a[0],height=_a[1];this.setOutputMatrixTextureDriver(outputPackedMatrixTexture,width,height)},GPGPUContext.prototype.setOutputMatrixWriteRegion=function(startRow,numRows,startColumn,numColumns){this.setOutputMatrixWriteRegionDriver(startColumn,startRow,numColumns,numRows)},GPGPUContext.prototype.setOutputPackedMatrixWriteRegion=function(startRow,numRows,startColumn,numColumns){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")},GPGPUContext.prototype.debugValidate=function(){null!=this.program&&validateProgram(this.gl,this.debug,this.program),validateFramebuffer(this.gl)},GPGPUContext.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var gl=this.gl;this.debug&&this.debugValidate(),callAndCheck(gl,this.debug,function(){return gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0)})},GPGPUContext.prototype.blockUntilAllProgramsCompleted=function(){var _this=this;this.throwIfDisposed(),callAndCheck(this.gl,this.debug,function(){return _this.gl.finish()})},GPGPUContext.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=getExtensionOrThrow(this.gl,this.debug,2===env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},GPGPUContext.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},GPGPUContext.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},GPGPUContext.prototype.beginQuery=function(){if(2===env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var gl2=this.gl,ext_1=this.getQueryTimerExtensionWebGL2(),query_1=gl2.createQuery();return gl2.beginQuery(ext_1.TIME_ELAPSED_EXT,query_1),query_1}var ext=this.getQueryTimerExtensionWebGL1(),query=ext.createQueryEXT();return ext.beginQueryEXT(ext.TIME_ELAPSED_EXT,query),query},GPGPUContext.prototype.endQuery=function(){if(2!==env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var ext=this.getQueryTimerExtensionWebGL1();ext.endQueryEXT(ext.TIME_ELAPSED_EXT)}else{var gl2=this.gl,ext_2=this.getQueryTimerExtensionWebGL2();gl2.endQuery(ext_2.TIME_ELAPSED_EXT)}},GPGPUContext.prototype.waitForQueryAndGetTime=function(query){return __awaiter(this,void 0,void 0,function(){var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:return[4,repeatedTry(function(){return _this.disposed||_this.isQueryAvailable(query,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})];case 1:return _a.sent(),[2,this.getQueryTime(query,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}})})},GPGPUContext.prototype.getQueryTime=function(query,queryTimerVersion){if(0===queryTimerVersion)return null;if(2===queryTimerVersion){var gl2=this.gl,timeElapsedNanos;return(timeElapsedNanos=gl2.getQueryParameter(query,gl2.QUERY_RESULT))/1e6}var ext=this.getQueryTimerExtensionWebGL1(),timeElapsedNanos;return(timeElapsedNanos=ext.getQueryObjectEXT(query,ext.QUERY_RESULT_EXT))/1e6},GPGPUContext.prototype.isQueryAvailable=function(query,queryTimerVersion){if(0===queryTimerVersion)return!0;if(2===queryTimerVersion){var gl2=this.gl,ext=this.getQueryTimerExtensionWebGL2(),available=gl2.getQueryParameter(query,gl2.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(ext.GPU_DISJOINT_EXT)),available&&!this.disjoint}var ext,available=(ext=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(query,ext.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(ext.GPU_DISJOINT_EXT)),available&&!this.disjoint},GPGPUContext.prototype.pollFence=function(fenceContext){var _this=this;return new Promise(function(resolve){_this.addItemToPoll(function(){return fenceContext.isFencePassed()},function(){return resolve()})})},GPGPUContext.prototype.pollItems=function(){for(var index=linearSearchLastTrue(this.itemsToPoll.map(function(x){return x.isDoneFn})),i=0;i<=index;++i){var resolveFn;(0,this.itemsToPoll[i].resolveFn)()}this.itemsToPoll=this.itemsToPoll.slice(index+1)},GPGPUContext.prototype.addItemToPoll=function(isDoneFn,resolveFn){var _this=this;this.itemsToPoll.push({isDoneFn:isDoneFn,resolveFn:resolveFn}),this.itemsToPoll.length>1||repeatedTry(function(){return _this.pollItems(),0===_this.itemsToPoll.length})},GPGPUContext.prototype.bindTextureToFrameBuffer=function(texture){this.throwIfDisposed(),bindColorTextureToFramebuffer(this.gl,this.debug,texture,this.framebuffer),this.debug&&validateFramebuffer(this.gl)},GPGPUContext.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(bindColorTextureToFramebuffer(this.gl,this.debug,this.outputTexture,this.framebuffer),this.debug&&validateFramebuffer(this.gl)):unbindColorTextureFromFramebuffer(this.gl,this.debug,this.framebuffer)},GPGPUContext.prototype.downloadMatrixDriver=function(texture,downloadAndDecode){this.bindTextureToFrameBuffer(texture);var result=downloadAndDecode();return this.unbindTextureToFrameBuffer(),result},GPGPUContext.prototype.setOutputMatrixTextureDriver=function(outputMatrixTextureMaybePacked,width,height){this.throwIfDisposed();var gl=this.gl;bindColorTextureToFramebuffer(gl,this.debug,outputMatrixTextureMaybePacked,this.framebuffer),this.debug&&validateFramebuffer(gl),this.outputTexture=outputMatrixTextureMaybePacked,callAndCheck(gl,this.debug,function(){return gl.viewport(0,0,width,height)}),callAndCheck(gl,this.debug,function(){return gl.scissor(0,0,width,height)})},GPGPUContext.prototype.setOutputMatrixWriteRegionDriver=function(x,y,width,height){var _this=this;this.throwIfDisposed(),callAndCheck(this.gl,this.debug,function(){return _this.gl.scissor(x,y,width,height)})},GPGPUContext.prototype.throwIfDisposed=function(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")},GPGPUContext.prototype.throwIfNoProgram=function(){if(null==this.program)throw new Error("No GPU program is currently set.")},GPGPUContext}();function linearSearchLastTrue(arr){for(var i=0;i<arr.length;++i){var isDone;if(!arr[i]())break}return i-1}function compileProgram(gpgpu,program,inputs,output){var userCode=program.userCode,inputInfos=inputs.map(function(input,i){var shapeInfo={logicalShape:input.shape,texShape:input.isUniform?null:input.texData.texShape,isUniform:input.isUniform,isPacked:!input.isUniform&&input.texData.isPacked,flatOffset:null};return null!=input.texData&&null!=input.texData.slice&&input.texData.slice.flatOffset>0&&(shapeInfo.flatOffset=input.texData.slice.flatOffset),{name:program.variableNames[i],shapeInfo:shapeInfo}}),inShapeInfos=inputInfos.map(function(x){return x.shapeInfo}),outShapeInfo={logicalShape:output.shape,texShape:output.texData.texShape,isUniform:!1,isPacked:output.texData.isPacked,flatOffset:null},source=makeShader(inputInfos,outShapeInfo,userCode,program.packedInputs),webGLProgram=gpgpu.createProgram(source),infLoc=null,nanLoc=gpgpu.getUniformLocation(webGLProgram,"NAN",!1);1===env().getNumber("WEBGL_VERSION")&&(infLoc=gpgpu.getUniformLocation(webGLProgram,"INFINITY",!1));for(var uniformLocations={},i=0;i<program.variableNames.length;i++){var varName=program.variableNames[i],shouldThrow=!1;uniformLocations[varName]=gpgpu.getUniformLocation(webGLProgram,varName,!1),uniformLocations["offset"+varName]=gpgpu.getUniformLocation(webGLProgram,"offset"+varName,!1)}return{program:program,source:source,webGLProgram:webGLProgram,uniformLocations:uniformLocations,inShapeInfos:inShapeInfos,outShapeInfo:outShapeInfo,infLoc:infLoc,nanLoc:nanLoc}}function validateBinaryAndProgram(shapeInfos,inputs){if(shapeInfos.length!==inputs.length)throw Error("Binary was compiled with "+shapeInfos.length+" inputs, but was executed with "+inputs.length+" inputs");shapeInfos.forEach(function(s,i){var shapeA=s.logicalShape,input=inputs[i],shapeB=input.shape;if(!arraysEqual(shapeA,shapeB))throw Error("Binary was compiled with different shapes than the current args. Shapes "+shapeA+" and "+shapeB+" must match");if(!s.isUniform||!input.isUniform){var texShapeA=s.texShape,texShapeB=input.isUniform?null:input.texData.texShape;if(!arraysEqual(texShapeA,texShapeB))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+texShapeA+" and "+texShapeB+" must match")}})}function runProgram(gpgpu,binary,inputs,output,customSetup){validateBinaryAndProgram(binary.inShapeInfos,inputs),validateBinaryAndProgram([binary.outShapeInfo],[output]);var outTex=output.texData.texture,outTexShape=output.texData.texShape;output.texData.isPacked?gpgpu.setOutputPackedMatrixTexture(outTex,outTexShape[0],outTexShape[1]):gpgpu.setOutputMatrixTexture(outTex,outTexShape[0],outTexShape[1]),gpgpu.setProgram(binary.webGLProgram),1===env().getNumber("WEBGL_VERSION")&&null!==binary.infLoc&&gpgpu.gl.uniform1f(binary.infLoc,1/0),null!==binary.nanLoc&&gpgpu.gl.uniform1f(binary.nanLoc,NaN),inputs.forEach(function(input,i){var varName=binary.program.variableNames[i],varLoc=binary.uniformLocations[varName],varOffsetLoc=binary.uniformLocations["offset"+varName];if(null!=varLoc)if(input.isUniform)if(sizeFromShape(input.shape)<2)gpgpu.gl.uniform1f(varLoc,input.uniformValues[0]);else{var vals=input.uniformValues;vals instanceof Float32Array||(vals=new Float32Array(vals)),gpgpu.gl.uniform1fv(varLoc,vals)}else null!=input.texData.slice&&null!=varOffsetLoc&&gpgpu.gl.uniform1i(varOffsetLoc,input.texData.slice.flatOffset),gpgpu.setInputMatrixTexture(input.texData.texture,varLoc,i)}),null!=customSetup&&customSetup(gpgpu,binary.webGLProgram),gpgpu.executeProgram()}function makeShaderKey(program,inputs,output){var keyInputs="";inputs.concat(output).forEach(function(x){var hasOffset=null!=x.texData&&null!=x.texData.slice&&x.texData.slice.flatOffset>0,texShape=x.isUniform?"uniform":x.texData.texShape;keyInputs+=x.shape+"_"+texShape+"_"+hasOffset});var keyUserCode=program.userCode,key=program.constructor.name;return key+="_"+keyInputs+"_"+keyUserCode}var Im2ColPackedProgram=function(){function Im2ColPackedProgram(outputShape,inputShape,convInfo){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=outputShape;for(var filterWidth=convInfo.filterWidth,inChannels=convInfo.inChannels,strideWidth=convInfo.strideWidth,strideHeight=convInfo.strideHeight,padInfo=convInfo.padInfo,outWidth=convInfo.outWidth,dilationWidth=convInfo.dilationWidth,dilationHeight=convInfo.dilationHeight,dataFormat=convInfo.dataFormat,left=padInfo.left,top=padInfo.top,itemsPerBlockRow=inChannels*filterWidth,glsl=getGlslDifferences(),isChannelsLast="channelsLast"===dataFormat,rowDim=isChannelsLast?0:1,colDim=isChannelsLast?1:2,unrolled="",row=0;row<=1;row++)for(var col=0;col<=1;col++)unrolled+="\n          blockIndex = rc.y + "+col+";\n          pos = rc.x + "+row+";\n\n          if(blockIndex < "+outputShape[1]+" && pos < "+outputShape[0]+") {\n            offsetY = int(blockIndex / ("+outWidth+")) * "+strideHeight+" - "+top+";\n            d0 = offsetY + "+dilationHeight+" * (pos / "+itemsPerBlockRow+");\n\n            if(d0 < "+inputShape[rowDim]+" && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), "+outWidth+".) * "+strideWidth+". - "+left+".);\n              d1 = offsetX + "+dilationWidth+" * (int(mod(float(pos), "+itemsPerBlockRow+".) / "+inChannels+".));\n\n              if(d1 < "+inputShape[colDim]+" && d1 >= 0) {\n\n                ch = int(mod(float(pos), "+inChannels+".));\n\n                if ("+isChannelsLast+") {\n                  innerDims = vec2(d1, ch);\n                  result["+(2*row+col)+"] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result["+(2*row+col)+"] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        "+unrolled+"\n\n        "+glsl.output+" = result;\n      }\n    "}return Im2ColPackedProgram}(),LRNProgram=function(){function LRNProgram(xShape,radius,bias,alpha,beta){this.variableNames=["x"],this.outputShape=[];var rad=radius,maxD=xShape[3]-1,powOperator;this.outputShape=xShape;var basis="float("+bias+") + float("+alpha+") * sum";powOperator=.5===beta?"inversesqrt("+basis+")":1===beta?"1.0/("+basis+")":"exp(log("+basis+") * float(-"+beta+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+rad+"; j <= "+rad+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+maxD+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+powOperator+";\n        setOutput(val);\n      }\n    "}return LRNProgram}(),LRNGradProgram=function(){function LRNGradProgram(inputShape,depthRadius,bias,alpha,beta){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=inputShape,this.depth=inputShape[3],this.depthRadius=depthRadius,this.bias=bias,this.alpha=alpha,this.beta=beta,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+depthRadius+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+depthRadius+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+alpha+") * norm + float("+bias+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+alpha+")\n                * float("+beta+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+beta+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "}return LRNGradProgram}(),LRNPackedProgram=function(){function LRNPackedProgram(xShape,radius,bias,alpha,beta){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;var rad=radius,maxD=xShape[3]-1,powOperator;this.outputShape=xShape;var basis="float("+bias+") + float("+alpha+") * sum";powOperator=.5===beta?"inversesqrt("+basis+")":1===beta?"1.0/("+basis+")":"exp(log("+basis+") * float(-"+beta+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < "+this.outputShape[3]+";\n        bool hasNextRow = c < "+this.outputShape[2]+";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - "+rad+";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - "+rad+"; j <= "+rad+"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2("+maxD+"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * "+powOperator+";\n        setOutput(result);\n      }\n    "}return LRNPackedProgram}(),MaxPool2DBackpropProgram=function(){function MaxPool2DBackpropProgram(convInfo){this.variableNames=["dy","maxPos"],this.outputShape=convInfo.inShape;var strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,lastIndex=effectiveFilterHeight*effectiveFilterWidth-1;this.userCode="\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+effectiveFilterHeight+";\n          wR += "+dilationHeight+") {\n          float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n          if (dyR < 0.0 || dyR >= "+convInfo.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+effectiveFilterWidth+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n            if (dyC < 0.0 || dyC >= "+convInfo.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+lastIndex+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+effectiveFilterWidth+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return MaxPool2DBackpropProgram}(),MaxPool3DBackpropProgram=function(){function MaxPool3DBackpropProgram(convInfo){this.variableNames=["dy","maxPos"],this.outputShape=convInfo.inShape;var strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=effectiveFilterDepth-1-convInfo.padInfo.front,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,lastIndex=effectiveFilterDepth*effectiveFilterHeight*effectiveFilterWidth-1;this.userCode="\n      const ivec3 pads = ivec3("+padFront+", "+padTop+", "+padLeft+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+effectiveFilterDepth+";\n           wD += "+dilationDepth+") {\n          float dyD = float(dyDCorner + wD) / "+strideDepth+".0;\n\n          if (dyD < 0.0 || dyD >= "+convInfo.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+effectiveFilterHeight+";\n              wR += "+dilationHeight+") {\n            float dyR = float(dyRCorner + wR) / "+strideHeight+".0;\n\n            if (dyR < 0.0 || dyR >= "+convInfo.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+effectiveFilterWidth+";\n                wC += "+dilationWidth+") {\n              float dyC = float(dyCCorner + wC) / "+strideWidth+".0;\n\n              if (dyC < 0.0 || dyC >= "+convInfo.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = "+lastIndex+" -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * "+effectiveFilterHeight+" * "+effectiveFilterWidth+" +\n                  wR * "+effectiveFilterWidth+" + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}return MaxPool3DBackpropProgram}(),MatMulPackedProgram=function(){function MatMulPackedProgram(aShape,outputShape,transposeA,transposeB,addBias,activation,hasPreluActivation){void 0===transposeA&&(transposeA=!1),void 0===transposeB&&(transposeB=!1),void 0===addBias&&(addBias=!1),void 0===activation&&(activation=null),void 0===hasPreluActivation&&(hasPreluActivation=!1),this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=outputShape;var sharedDim=transposeA?aShape[1]:aShape[2],sharedDimensionPacked=Math.ceil(sharedDim/2),aSample=transposeA?"i * 2, rc.y":"rc.y, i * 2",bSample=transposeB?"rc.z, i * 2":"i * 2, rc.z",aSwizzle=transposeA?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],bSwizzle=transposeB?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],activationSnippet="",applyActivationSnippet="";activation&&(activationSnippet=hasPreluActivation?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+activation+"\n        }":"vec4 activation(vec4 x) {\n          "+activation+"\n        }",applyActivationSnippet="result = activation(result);");var addBiasSnippet=addBias?"result += getBiasAtOutCoords();":"";addBias&&this.variableNames.push("bias"),hasPreluActivation&&this.variableNames.push("preluActivationWeights"),this.userCode="\n      "+activationSnippet+"\n\n      const float sharedDimension = "+sharedDimensionPacked+".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < "+sharedDimensionPacked+"; i++) {\n          vec4 a = getMatrixA(rc.x, "+aSample+");\n          vec4 b = getMatrixB(rc.x, "+bSample+");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += ("+aSwizzle[0]+" * "+bSwizzle[0]+");\n          result += ("+aSwizzle[1]+" * "+bSwizzle[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        "+addBiasSnippet+"\n\n        "+applyActivationSnippet+"\n\n        setOutput(result);\n      }\n    "}return MatMulPackedProgram}(),MultinomialProgram=function(){function MultinomialProgram(batchSize,numOutcomes,numSamples){this.variableNames=["probs"],this.outputShape=[batchSize,numSamples],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(numOutcomes-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(numOutcomes-1)+"));\n      }\n    "}return MultinomialProgram.prototype.getCustomSetupFunc=function(seed){var _this=this;return function(gpgpu,webGLProgram){null==_this.seedLoc&&(_this.seedLoc=gpgpu.getUniformLocation(webGLProgram,"seed")),gpgpu.gl.uniform1f(_this.seedLoc,seed)}},MultinomialProgram}(),OneHotProgram=function(){function OneHotProgram(numIndices,depth,onValue,offValue){this.variableNames=["indices"],this.outputShape=[numIndices,depth],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+offValue+"), float("+onValue+"),\n                      float(index == coords.y)));\n      }\n    "}return OneHotProgram}(),PackProgram=function(){function PackProgram(outputShape){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=outputShape;var rank=outputShape.length;if(0===rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{var channels=getChannels("rc",rank),dtype=getCoordsDataType(rank),outOfBoundsCondition=getOutOfBoundsCondition(rank,outputShape,channels),setup=getSetup(rank,outputShape[outputShape.length-1],outputShape[outputShape.length-2],channels),output=getOutput(outputShape,channels);this.userCode="\n        void main() {\n          "+dtype+" rc = getOutputCoords();\n\n          if("+outOfBoundsCondition+") {\n            setOutput(vec4(0));\n          } else {\n            "+setup+"\n\n            setOutput(vec4("+output+"));\n          }\n        }\n      "}}return PackProgram}();function getSourceCoordsArr(rank,dims){for(var coords=[],row=0;row<=1;row++)for(var col=0;col<=1;col++){for(var coord=(0===row?"r":"rp1")+", "+(0===col?"c":"cp1"),d=2;d<rank;d++)coord=dims[dims.length-1-d]+","+coord;coords.push(coord)}return coords}function getOutOfBoundsCondition(rank,shape,dims){if(1===rank)return"rc > "+shape[0];for(var cond="",i=rank-2;i<rank;i++)cond+=dims[i]+" >= "+shape[i],i<rank-1&&(cond+="||");return cond}function getSetup(rank,cols,rows,dims){if(1===rank)return"";var innerDims=dims.slice(-2);return"\n    int r = "+innerDims[0]+";\n    int c = "+innerDims[1]+";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= "+cols+";\n    bool rEdge = rp1 >= "+rows+";\n  "}function getOutput(shape,dims){var rank=shape.length,sourceCoords=getSourceCoordsArr(rank,dims);return 1===rank?"getA(rc),\n            rc + 1 >= "+shape[0]+" ? 0. : getA(rc + 1),\n            0, 0":"getA("+sourceCoords[0]+"),\n          cEdge ? 0. : getA("+sourceCoords[1]+"),\n          rEdge ? 0. : getA("+sourceCoords[2]+"),\n          rEdge || cEdge ? 0. : getA("+sourceCoords[3]+")"}var PadProgram=function(){function PadProgram(xShape,paddings,constantValue){this.variableNames=["x"],this.outputShape=paddings.map(function(p,i){return p[0]+xShape[i]+p[1]});var rank=xShape.length,type=getCoordsDataType(rank),start=paddings.map(function(p){return p[0]}).join(","),end=paddings.map(function(p,i){return p[0]+xShape[i]}).join(","),unpackedCoords=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,rank);this.userCode=1!==rank?"\n      "+type+" start = "+type+"("+start+");\n      "+type+" end = "+type+"("+end+");\n\n      void main() {\n        "+type+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+constantValue+"));\n        } else {\n          "+type+" coords = outC - start;\n          setOutput(getX("+unpackedCoords+"));\n        }\n      }\n    ":"\n        int start = "+start+";\n        int end = "+end+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float("+constantValue+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "}return PadProgram}(),PadPackedProgram=function(){function PadPackedProgram(xShape,paddings,constantValue){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=paddings.map(function(p,i){return p[0]+xShape[i]+p[1]});for(var rank=xShape.length,dtype=getCoordsDataType(rank),start=paddings.map(function(p){return p[0]}).join(","),end=paddings.map(function(p,i){return p[0]+xShape[i]}).join(","),coords=getChannels("rc",rank),source=getChannels("source",rank),cLimit=coords[rank-1]+" < "+this.outputShape[rank-1],innerDims=1===rank?"source":"vec2("+source.slice(-2).join()+")",componentSetup=[dtype+" rc = outputLoc;",coords[rank-1]+" += 1;\n       if("+cLimit+") {\n      ",1===rank?"":"}\n       rc = outputLoc;\n       "+coords[rank-2]+" += 1;\n       if("+coords[rank-2]+" < "+this.outputShape[rank-2]+") {",1===rank?"":"  "+coords[rank-1]+" += 1;\n         if("+cLimit+") {"],paddingArea=1===rank?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",mainLoop="",i=0,j=1===rank?2:4;i<j;i++)mainLoop+="\n        "+componentSetup[i]+"\n        if ("+paddingArea+") {\n          result["+i+"] = float("+constantValue+");\n        } else {\n          "+dtype+" source = rc - start;\n          result["+i+"] = getChannel(getX("+source.join()+"), "+innerDims+");\n        }\n      ";mainLoop+=1===rank?"} ":"}}",this.userCode="\n      const "+dtype+" start = "+dtype+"("+start+");\n      const "+dtype+" end = "+dtype+"("+end+");\n\n      void main() {\n        "+dtype+" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        "+mainLoop+"\n        setOutput(result);\n      }\n    "}return PadPackedProgram}(),Pool2DProgram=function(){function Pool2DProgram(convInfo,poolType,computePositions,flattenPositions,includeBatchInIndex){if(void 0===flattenPositions&&(flattenPositions=!1),void 0===includeBatchInIndex&&(includeBatchInIndex=!1),this.variableNames=["x"],"avg"===poolType&&computePositions)throw new Error("Cannot compute positions for average pool.");var filterWidth=convInfo.filterWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left;this.outputShape=convInfo.outShape;var isAvgPool="avg"===poolType,batchFlattenPositionStr="((batch  * "+convInfo.inHeight+" + xR) * "+convInfo.inWidth+" + xC) * "+convInfo.inChannels+" + d",flattenPositionStr="(xR * "+convInfo.inWidth+" + xC) * "+convInfo.inChannels+" + d",initializationValue="0.0";if(isAvgPool||(initializationValue="-1.0 / 1e-20"),computePositions){var compareOp_1=">=";this.userCode="\n        const ivec2 strides = ivec2("+strideHeight+", "+strideWidth+");\n        const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+effectiveFilterHeight+";\n              wR += "+dilationHeight+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+convInfo.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+effectiveFilterWidth+";\n                wC += "+dilationWidth+") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+convInfo.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = "+(flattenPositions?includeBatchInIndex?batchFlattenPositionStr:flattenPositionStr:"wR * "+effectiveFilterWidth+" + wC")+";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "}else{var compareOp="max",returnValue=poolType+"("+poolType+"("+poolType+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===poolType&&(returnValue="avgValue / count");var filterWidthNearestVec4=4*Math.floor(filterWidth/4),filterWidthVec4Remainder=filterWidth%4,updateSnippet="\n      if ("+isAvgPool+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+strideHeight+", "+strideWidth+");\n      const ivec2 pads = ivec2("+padTop+", "+padLeft+");\n      const float initializationValue = "+initializationValue+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+convInfo.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+initializationValue+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+effectiveFilterHeight+";\n            wR += "+dilationHeight+") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+convInfo.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+filterWidthNearestVec4+"; wC += 4) {\n            int xC = xCCorner + wC * "+dilationWidth+";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+dilationWidth+", d),\n              getValue(batch, xR, xC + 2 * "+dilationWidth+", d),\n              getValue(batch, xR, xC + 3 * "+dilationWidth+", d)\n            );\n\n            "+updateSnippet+"\n          }\n\n          int xC = xCCorner + "+filterWidthNearestVec4+";\n          if ("+(1===filterWidthVec4Remainder)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+updateSnippet+"\n          } else if ("+(2===filterWidthVec4Remainder)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+dilationWidth+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+updateSnippet+"\n          } else if ("+(3===filterWidthVec4Remainder)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+dilationWidth+", d),\n              getValue(batch, xR, xC + 2 * "+dilationWidth+", d),\n              initializationValue\n            );\n\n            "+updateSnippet+"\n          }\n        }\n        setOutput("+returnValue+");\n      }\n    "}}return Pool2DProgram}(),Pool3DProgram=function(){function Pool3DProgram(convInfo,poolType,computePositions,flattenPositions,includeBatchInIndex){if(void 0===flattenPositions&&(flattenPositions=!1),void 0===includeBatchInIndex&&(includeBatchInIndex=!1),this.variableNames=["x"],"avg"===poolType&&computePositions)throw new Error("Cannot compute positions for average pool.");var filterWidth=convInfo.filterWidth,strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=convInfo.padInfo.front,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left;this.outputShape=convInfo.outShape;var isAvgPool="avg"===poolType,initializationValue="0.0";if(isAvgPool||(initializationValue="-1.0 / 1e-20"),computePositions){var compareOp_2=">=";this.userCode="\n        const ivec3 strides =\n            ivec3("+strideDepth+", "+strideHeight+", "+strideWidth+");\n        const ivec3 pads = ivec3("+padFront+", "+padTop+", "+padLeft+");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < "+effectiveFilterDepth+";\n              wD += "+dilationDepth+") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= "+convInfo.inDepth+") {\n              continue;\n            }\n\n            for (int wR = 0; wR < "+effectiveFilterHeight+";\n                wR += "+dilationHeight+") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= "+convInfo.inHeight+") {\n                continue;\n              }\n\n              for (int wC = 0; wC < "+effectiveFilterWidth+";\n                  wC += "+dilationWidth+") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= "+convInfo.inWidth+") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = "+(flattenPositions?includeBatchInIndex?"(((batch * "+convInfo.inDepth+" + xD) * "+convInfo.inHeight+" + xR) * "+convInfo.inWidth+" + xC) * "+convInfo.inChannels+" + ch":"((xD * "+convInfo.inHeight+" + xR) * "+convInfo.inWidth+" + xC) * "+convInfo.inChannels+" + ch":"wD * "+effectiveFilterHeight+" * "+effectiveFilterWidth+" +\n                      wR * "+effectiveFilterWidth+" + wC")+";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "}else{var compareOp="max",returnValue=poolType+"("+poolType+"("+poolType+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===poolType&&(returnValue="avgValue / count");var filterWidthNearestVec4=4*Math.floor(filterWidth/4),filterWidthVec4Remainder=filterWidth%4,updateSnippet="\n      if ("+isAvgPool+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec3 strides =\n        ivec3("+strideDepth+", "+strideHeight+", "+strideWidth+");\n      const ivec3 pads = ivec3("+padFront+", "+padTop+", "+padLeft+");\n      const float initializationValue = "+initializationValue+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= "+convInfo.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+initializationValue+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < "+effectiveFilterDepth+";\n            wD += "+dilationDepth+") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= "+convInfo.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+effectiveFilterHeight+";\n            wR += "+dilationHeight+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+convInfo.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+filterWidthNearestVec4+"; wC += 4) {\n              int xC = xCCorner + wC * "+dilationWidth+";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+dilationWidth+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+dilationWidth+", ch),\n                getValue(batch, xD, xR, xC + 3 * "+dilationWidth+", ch)\n              );\n\n              "+updateSnippet+"\n            }\n\n            int xC = xCCorner + "+filterWidthNearestVec4+";\n            if ("+(1===filterWidthVec4Remainder)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              "+updateSnippet+"\n            } else if ("+(2===filterWidthVec4Remainder)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+dilationWidth+", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              "+updateSnippet+"\n            } else if ("+(3===filterWidthVec4Remainder)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+dilationWidth+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+dilationWidth+", ch),\n                initializationValue\n              );\n\n              "+updateSnippet+"\n            }\n          }\n          setOutput("+returnValue+");\n        }\n      }\n    "}}return Pool3DProgram}(),ReduceProgram=function(){function ReduceProgram(reduceInfo,reduceType){this.variableNames=["x"];var windowSize=reduceInfo.windowSize,batchSize=reduceInfo.batchSize,inSize=reduceInfo.inSize,outSize=Math.ceil(inSize/windowSize);this.outputShape=[batchSize,outSize];var initializationValue="0.0",compareOp="";"prod"===reduceType?initializationValue="1.0":"min"===reduceType?(initializationValue="1.0 / 1e-20",compareOp="min"):"max"===reduceType&&(initializationValue="-1.0 / 1e-20",compareOp="max");var returnValue=reduceType+"("+reduceType+"("+reduceType+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===reduceType?returnValue="sumValue":"prod"===reduceType?returnValue="prodValue":"all"===reduceType?returnValue="allValue":"any"===reduceType&&(returnValue="anyValue");var windowSizeNearestVec4=4*Math.floor(windowSize/4),windowSizeVec4Remainder=windowSize%4,updateSnippet="\n      if ("+("sum"===reduceType)+") {\n        sumValue += dot(values, ones);\n      } else if ("+("prod"===reduceType)+") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = "+compareOp+"(values, minMaxValue);\n      }\n    ",vecType="vec4";"all"===reduceType?(initializationValue="1.0",updateSnippet="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",vecType="bvec4"):"any"===reduceType&&(initializationValue="0.0",updateSnippet="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",vecType="bvec4");var checkOutOfBounds="";inSize%windowSize>0&&(checkOutOfBounds="\n        if (inIdx < 0 || inIdx >= "+inSize+") {\n          return initializationValue;\n        }\n      "),this.userCode="\n      const float initializationValue = "+initializationValue+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+checkOutOfBounds+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+windowSize+";\n\n        vec4 minMaxValue = vec4("+initializationValue+");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+windowSizeNearestVec4+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+vecType+" values = "+vecType+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+updateSnippet+"\n        }\n\n        int inIdx = inOffset + "+windowSizeNearestVec4+";\n        if ("+(1===windowSizeVec4Remainder)+") {\n          "+vecType+" values = "+vecType+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+updateSnippet+"\n        } else if ("+(2===windowSizeVec4Remainder)+") {\n          "+vecType+" values = "+vecType+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+updateSnippet+"\n        } else if ("+(3===windowSizeVec4Remainder)+") {\n          "+vecType+" values = "+vecType+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+updateSnippet+"\n        }\n        setOutput("+returnValue+");\n      }\n    "}return ReduceProgram}(),ReshapePackedProgram=function(){function ReshapePackedProgram(outputShape,inputShape){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=outputShape;for(var mainLoop="",i=0;i<4;i++){var thisRC="thisRC = rc;";i%2==1&&(thisRC+="thisRC.z += 1;"),i>1&&(thisRC+="thisRC.y += 1;"),mainLoop+="\n        "+thisRC+"\n        "+(i>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+i+"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(i>0?"}":"")+"\n      "}this.userCode="\n      "+getReshapedInputCoords(inputShape)+"\n      "+getFlatIndexFrom3D(outputShape)+"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = "+outputShape[1]+";\n        int cols = "+outputShape[2]+";\n\n        "+mainLoop+"\n\n        setOutput(result);\n      }\n    "}return ReshapePackedProgram}();function getReshapedInputCoords(shape){var coordsFromIndexSnippet;return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+getLogicalCoordinatesFromFlatIndex(["r","c","d"],shape)+"\n      return ivec3(r, c, d);\n    }\n  "}var ResizeBilinearBackpropProgram=function(){function ResizeBilinearBackpropProgram(dy,x,alignCorners){this.variableNames=["dy"],this.outputShape=[],this.outputShape=x.shape;var _a=x.shape,xHeight=_a[1],xWidth=_a[2],_b=dy.shape,yHeight=_b[1],yWidth=_b[2],effectiveXSize=[alignCorners&&yHeight>1?xHeight-1:xHeight,alignCorners&&yWidth>1?xWidth-1:xWidth],effectiveYSize=[alignCorners&&yHeight>1?yHeight-1:yHeight,alignCorners&&yWidth>1?yWidth-1:yWidth],heightScale=effectiveXSize[0]/effectiveYSize[0],widthScale=effectiveXSize[1]/effectiveYSize[1],invHeightScale=1/heightScale,invWidthScale=1/widthScale,winHeight=2*Math.ceil(invHeightScale)+2,winWidth=2*Math.ceil(invWidthScale)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+heightScale+");\n        const float widthScale = float("+widthScale+");\n\n        const float invHeightScale = float("+invHeightScale+");\n        const float invWidthScale = float("+invWidthScale+");\n\n        const int winHeight = int("+winHeight+");\n        const int winWidth = int("+winWidth+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+yHeight+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+yWidth+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(xHeight-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(xWidth-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}return ResizeBilinearBackpropProgram}(),ResizeBilinearProgram=function(){function ResizeBilinearProgram(inputShape,newHeight,newWidth,alignCorners){this.variableNames=["A"],this.outputShape=[];var batch=inputShape[0],oldHeight=inputShape[1],oldWidth=inputShape[2],depth=inputShape[3];this.outputShape=[batch,newHeight,newWidth,depth];var effectiveInSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth],effectiveOutSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+effectiveInSize[0]/effectiveOutSize[0]+",\n          "+effectiveInSize[1]/effectiveOutSize[1]+");\n      const vec2 inputShapeRC = vec2("+oldHeight+".0, "+oldWidth+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "}return ResizeBilinearProgram}(),ResizeBilinearPackedProgram=function(){function ResizeBilinearPackedProgram(inputShape,newHeight,newWidth,alignCorners){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];var batch=inputShape[0],oldHeight=inputShape[1],oldWidth=inputShape[2],depth=inputShape[3];this.outputShape=[batch,newHeight,newWidth,depth];var effectiveInSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth],effectiveOutSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth];this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          "+effectiveInSize[0]/effectiveOutSize[0]+",\n          "+effectiveInSize[1]/effectiveOutSize[1]+",\n          "+effectiveInSize[1]/effectiveOutSize[1]+");\n      const vec3 inputShapeRC = vec3("+oldHeight+".0, "+oldWidth+".0,\n                                     "+oldWidth+".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < "+(depth-1)+";\n        bool hasNextRow = coords.z < "+(newWidth-1)+";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "}return ResizeBilinearPackedProgram}(),ResizeNearestNeigborBackpropProgram=function(){function ResizeNearestNeigborBackpropProgram(dy,x,alignCorners){this.variableNames=["dy"],this.outputShape=[],this.outputShape=x.shape;var _a=x.shape,xHeight=_a[1],xWidth=_a[2],_b=dy.shape,yHeight=_b[1],yWidth=_b[2],effectiveXSize=[alignCorners&&yHeight>1?xHeight-1:xHeight,alignCorners&&yWidth>1?xWidth-1:xWidth],effectiveYSize=[alignCorners&&yHeight>1?yHeight-1:yHeight,alignCorners&&yWidth>1?yWidth-1:yWidth],heightScale=effectiveXSize[0]/effectiveYSize[0],widthScale=effectiveXSize[1]/effectiveYSize[1],invHeightScale=1/heightScale,invWidthScale=1/widthScale,winHeight=2*Math.ceil(invHeightScale)+2,winWidth=2*Math.ceil(invWidthScale)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+heightScale+");\n        const float widthScale = float("+widthScale+");\n\n        const float invHeightScale = float("+invHeightScale+");\n        const float invWidthScale = float("+invWidthScale+");\n\n        const int winHeight = int("+winHeight+");\n        const int winWidth = int("+winWidth+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+yHeight+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+yWidth+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+effectiveXSize[0]+") *\n                (float(dyR) / float("+effectiveYSize[0]+"));\n\n            float sourceFracCol =\n                float("+effectiveXSize[1]+") *\n                  (float(dyC) / float("+effectiveYSize[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+xHeight+") - 1),\n                "+alignCorners+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+xWidth+") - 1),\n                "+alignCorners+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}return ResizeNearestNeigborBackpropProgram}(),ResizeNearestNeighborProgram=function(){function ResizeNearestNeighborProgram(inputShape,newHeight,newWidth,alignCorners){this.variableNames=["A"],this.outputShape=[];var batch=inputShape[0],oldHeight=inputShape[1],oldWidth=inputShape[2],depth=inputShape[3];this.outputShape=[batch,newHeight,newWidth,depth];var effectiveInSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth],effectiveOutSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth],roundBase=alignCorners?"0.5":"0.0";this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+effectiveInSize[0]/effectiveOutSize[0]+",\n          "+effectiveInSize[1]/effectiveOutSize[1]+");\n      const vec2 inputShapeRC = vec2("+oldHeight+".0, "+oldWidth+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+roundBase+")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "}return ResizeNearestNeighborProgram}(),ReverseProgram=function(){function ReverseProgram(xShape,axis){this.variableNames=["x"];var rank=xShape.length;if(rank>4)throw new Error("WebGL backend: Reverse of rank-"+rank+" tensor is not yet supported");if(this.outputShape=xShape,1!==rank){var getInCoord=function(i){return-1!==axis.indexOf(i)&&1!==xShape[i]?xShape[i]+" - coords["+i+"] - 1":"coords["+i+"]"},inCoords=xShape.map(function(_,i){return getInCoord(i)}).join(","),type=getCoordsDataType(rank);this.userCode="\n      void main() {\n        "+type+" coords = getOutputCoords();\n        setOutput(getX("+inCoords+"));\n      }\n    "}else this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+xShape[0]+" - coord - 1));\n        }\n      "}return ReverseProgram}(),ReversePackedProgram=function(){function ReversePackedProgram(xShape,axis){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;var rank=xShape.length;if(rank>4)throw new Error("WebGL backend: Reverse of rank-"+rank+" tensor is not yet supported");this.outputShape=xShape;var channels=getChannels("rc",rank),nextColumn=channels[rank-1]+" + 1 < "+this.outputShape[rank-1],nextRow=channels[rank-2]+" + 1 < "+this.outputShape[rank-2],type=getCoordsDataType(rank);function getR(channels){return getChannel(channels)}function getG(channels){return channels[rank-1]="("+channels[rank-1]+" + 1)",getChannel(channels)}function getB(channels){return channels[rank-2]="("+channels[rank-2]+" + 1)",getChannel(channels)}function getA(channels){return channels[rank-1]="("+channels[rank-1]+" + 1)",channels[rank-2]="("+channels[rank-2]+" + 1)",getChannel(channels)}function getChannel(channels){var inCoordsArray=xShape.map(function(_,i){return getInCoord(i,channels)}),inCoords,innerDims;return"getChannel(getX("+inCoordsArray.join(",")+"), vec2("+inCoordsArray.slice(-2).join(",")+"))"}function getInCoord(i,channels1){return-1!==axis.indexOf(i)&&1!==xShape[i]?xShape[i]+" - "+channels1[i]+" - 1":""+channels1[i]}this.userCode=1===rank?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX("+xShape[0]+" - rc - 1),\n            "+xShape[0]+" - rc - 1);\n          if("+nextColumn+"){\n              result.g = getChannel(getX("+xShape[0]+" - (rc  + 1) - 1),\n                "+xShape[0]+" - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ":"\n        void main() {\n          "+type+" rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = "+getR(channels.slice())+";\n          if("+nextColumn+"){\n            result.g = "+getG(channels.slice())+";\n          }\n          if("+nextRow+") {\n            result.b = "+getB(channels.slice())+";\n            if("+nextColumn+") {\n              result.a = "+getA(channels.slice())+";\n            }\n          }\n          setOutput(result);\n        }\n    "}return ReversePackedProgram}(),ScatterProgram=function(){function ScatterProgram(updateSize,sliceDim,indicesRank,updatesRank,strides,shape,summingDupeIndex){void 0===summingDupeIndex&&(summingDupeIndex=!0),this.variableNames=["updates","indices","defaultValue"],this.outputShape=shape;var stridesType=getCoordsDataType(strides.length),dtype=getCoordsDataType(shape.length),indicesString="";1===indicesRank?indicesString="i":2===indicesRank&&(indicesString="i, j");var indicesSnippet="getIndices("+indicesString+")",updatesString="";1===updatesRank?updatesString="i":2===updatesRank&&(updatesString="i, coords[1]");var updatesSnippet="getUpdates("+updatesString+")",strideString=sliceDim>1?"strides[j]":"strides";this.userCode="\n        "+stridesType+" strides = "+stridesType+"("+strides+");\n\n        void main() {\n          "+dtype+" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < "+updateSize+"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < "+sliceDim+"; j++) {\n              int index = round("+indicesSnippet+");\n              flattenedIndex += index * "+strideString+";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += "+updatesSnippet+";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "}return ScatterProgram}(),SegmentOpProgram=function(){function SegmentOpProgram(segOpInfo,segOpType){this.variableNames=["x","segmentIds"];var windowSize=segOpInfo.windowSize,batchSize=segOpInfo.batchSize,inSize=segOpInfo.inSize,numSegments=segOpInfo.numSegments,outSize=numSegments*Math.ceil(inSize/windowSize);this.outputShape=[batchSize,outSize];var initializationValue="0.0",returnValue="sumValue",windowSizeNearestVec4=4*Math.floor(windowSize/4),windowSizeVec4Remainder=windowSize%4,updateSnippet="\n        sumValue += dot(values, segFilter);\n    ",checkValueOutOfBounds="";inSize%windowSize>0&&(checkValueOutOfBounds="\n        if (inIdx < 0 || inIdx >= "+inSize+") {\n          return initializationValue;\n        }\n      ");var checkSegmentIdOutOfBounds="";inSize%windowSize>0&&(checkSegmentIdOutOfBounds="\n        if (inIdx < 0 || inIdx >= "+inSize+") {\n          return -1.0;\n        }\n      "),this.userCode="\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+checkValueOutOfBounds+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+checkSegmentIdOutOfBounds+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+numSegments+")) * float("+windowSize+"));\n        int currentSeg = int(mod(float(outIdx), float("+numSegments+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+windowSizeNearestVec4+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+updateSnippet+"\n        }\n\n        int inIdx = inOffset + "+windowSizeNearestVec4+";\n        if ("+(1===windowSizeVec4Remainder)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+updateSnippet+"\n        } else if ("+(2===windowSizeVec4Remainder)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+updateSnippet+"\n        } else if ("+(3===windowSizeVec4Remainder)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+updateSnippet+"\n        }\n        setOutput(sumValue);\n      }\n    "}return SegmentOpProgram}(),SelectProgram=function(){function SelectProgram(cRank,shape,rank){var cCoords,abCoords;if(this.variableNames=["c","a","b"],this.outputShape=shape,rank>4)throw Error("Where for rank "+rank+" is not yet supported");if(1===rank)abCoords="resRC",cCoords="resRC";else{for(var currentCoords=["resRC.x","resRC.y","resRC.z","resRC.w"],cCoordVars=[],abCoordVars=[],i=0;i<shape.length;i++)abCoordVars.push(""+currentCoords[i]),i<cRank&&cCoordVars.push(""+currentCoords[i]);cCoords=cCoordVars.join(),abCoords=abCoordVars.join()}var dtype=getCoordsDataType(rank);this.userCode="\n      void main() {\n        "+dtype+" resRC = getOutputCoords();\n        float cVal = getC("+cCoords+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+abCoords+"));\n        } else {\n          setOutput(getB("+abCoords+"));\n        }\n      }\n    "}return SelectProgram}(),SliceProgram=function(){function SliceProgram(destSize){this.variableNames=["source"],this.outputShape=destSize,this.rank=destSize.length;var dtype=getCoordsDataType(this.rank),uniformPart="uniform int start["+this.rank+"];",sourceCoords=getCoords$1(this.rank),body,coordSum;body="\n        "+dtype+" sourceLoc;\n        "+dtype+" coords = getOutputCoords();\n        "+destSize.map(function(_,i){return"sourceLoc."+coords[i]+" = start["+i+"] + coords."+coords[i]+";"}).join("\n")+"\n      ",this.userCode="\n      "+uniformPart+"\n      void main() {\n        "+body+"\n        setOutput(getSource("+sourceCoords+"));\n      }\n    "}return SliceProgram.prototype.getCustomSetupFunc=function(start){var _this=this;if(start.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+start.length+")");return function(gpgpu,webGLProgram){null==_this.startLoc&&(_this.startLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"start"),null==_this.startLoc)||gpgpu.gl.uniform1iv(_this.startLoc,start)}},SliceProgram}(),coords=["x","y","z","w","u","v"];function getCoords$1(rank){if(1===rank)return"sourceLoc";if(rank<=6)return coords.slice(0,rank).map(function(x){return"sourceLoc."+x}).join(",");throw Error("Slicing for rank "+rank+" is not yet supported")}var SlicePackedProgram=function(){function SlicePackedProgram(destSize){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=destSize,this.rank=destSize.length;var dtype=getCoordsDataType(this.rank),coords=getChannels("coords",this.rank),sourceLoc=getChannels("sourceLoc",this.rank),innerDims=1===this.rank?"sourceLoc":"vec2("+sourceLoc.slice(-2).join()+")",getChannel="getChannel(getSource("+sourceLoc.join()+"), "+innerDims+")",upperRow="\n      result.x = "+getChannel+";\n      if (++"+coords[this.rank-1]+" < "+destSize[this.rank-1]+") {\n        ++"+sourceLoc[this.rank-1]+";\n        result.y = "+getChannel+";\n        --"+sourceLoc[this.rank-1]+";\n      }\n    ",lowerRow=1===this.rank?"":"\n      --"+coords[this.rank-1]+";\n      if (++"+coords[this.rank-2]+" < "+destSize[this.rank-2]+") {\n        ++"+sourceLoc[this.rank-2]+";\n        result.z = "+getChannel+";\n        if (++"+coords[this.rank-1]+" < "+destSize[this.rank-1]+") {\n          ++"+sourceLoc[this.rank-1]+";\n          result.w = "+getChannel+";\n        }\n      }\n    ",sourceLocSetup=this.rank<=4?"sourceLoc = coords +\n            "+dtype+"("+destSize.map(function(_,i){return"start["+i+"]"}).join()+");":destSize.map(function(_,i){return sourceLoc[i]+" = "+coords[i]+" + start["+i+"];"}).join("\n");this.userCode="\n      uniform int start["+this.rank+"];\n      void main() {\n        "+dtype+" coords = getOutputCoords();\n        "+dtype+" sourceLoc;\n        "+sourceLocSetup+"\n        vec4 result = vec4(0.);\n        "+upperRow+"\n        "+lowerRow+"\n        setOutput(result);\n      }\n    "}return SlicePackedProgram.prototype.getCustomSetupFunc=function(start){var _this=this;if(start.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+start.length+")");return function(gpgpu,webGLProgram){null==_this.startLoc&&(_this.startLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"start"),null==_this.startLoc)||gpgpu.gl.uniform1iv(_this.startLoc,start)}},SlicePackedProgram}(),StridedSliceProgram=function(){function StridedSliceProgram(begin,strides,size){this.variableNames=["x"],this.outputShape=size;var rank=size.length,inputDtype=getCoordsDataType(size.length),dtype=getCoordsDataType(size.length),newCoords="";if(1===rank)newCoords="coords * strides + begin";else{var outputAxis_1=0;newCoords=size.map(function(_,i){return outputAxis_1++,1===size.length?"coords * strides["+i+"] + begin["+i+"]":"coords["+(outputAxis_1-1)+"] * strides["+i+"] + begin["+i+"]"}).join(",")}this.userCode="\n      "+inputDtype+" begin = "+inputDtype+"("+begin+");\n      "+inputDtype+" strides = "+inputDtype+"("+strides+");\n\n      void main() {\n        "+dtype+" coords = getOutputCoords();\n        setOutput(getX("+newCoords+"));\n      }\n    "}return StridedSliceProgram}(),TextureManager=function(){function TextureManager(gpgpu){this.gpgpu=gpgpu,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return TextureManager.prototype.acquireTexture=function(shapeRC,usage,isPacked){var physicalTexType=getPhysicalFromLogicalTextureType(usage,isPacked),shapeKey=getKeyFromTextureShape(shapeRC,physicalTexType,isPacked),newTexture;if(shapeKey in this.freeTextures||(this.freeTextures[shapeKey]=[]),shapeKey in this.usedTextures||(this.usedTextures[shapeKey]=[]),this.freeTextures[shapeKey].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();var newTexture_1=this.freeTextures[shapeKey].shift();return this.usedTextures[shapeKey].push(newTexture_1),newTexture_1}return this.numUsedTextures++,this.log(),physicalTexType===PhysicalTextureType.PACKED_2X2_FLOAT32?newTexture=this.gpgpu.createPackedMatrixTexture(shapeRC[0],shapeRC[1]):physicalTexType===PhysicalTextureType.PACKED_2X2_FLOAT16?newTexture=this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0],shapeRC[1]):physicalTexType===PhysicalTextureType.UNPACKED_FLOAT32?newTexture=this.gpgpu.createFloat32MatrixTexture(shapeRC[0],shapeRC[1]):physicalTexType===PhysicalTextureType.UNPACKED_FLOAT16?newTexture=this.gpgpu.createFloat16MatrixTexture(shapeRC[0],shapeRC[1]):physicalTexType===PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE&&(newTexture=this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0],shapeRC[1])),this.usedTextures[shapeKey].push(newTexture),newTexture},TextureManager.prototype.releaseTexture=function(texture,shape,logicalTexType,isPacked){if(null!=this.freeTextures){var physicalTexType,shapeKey=getKeyFromTextureShape(shape,getPhysicalFromLogicalTextureType(logicalTexType,isPacked),isPacked);shapeKey in this.freeTextures||(this.freeTextures[shapeKey]=[]),this.freeTextures[shapeKey].push(texture),this.numFreeTextures++,this.numUsedTextures--;var texList=this.usedTextures[shapeKey],texIndex=texList.indexOf(texture);if(texIndex<0)throw new Error("Cannot release a texture that was never provided by this texture manager");texList.splice(texIndex,1),this.log()}},TextureManager.prototype.log=function(){if(this.logEnabled){var total=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+total+")")}},TextureManager.prototype.getNumUsedTextures=function(){return this.numUsedTextures},TextureManager.prototype.getNumFreeTextures=function(){return this.numFreeTextures},TextureManager.prototype.dispose=function(){var _this=this;if(null!=this.freeTextures){for(var texShape in this.freeTextures)this.freeTextures[texShape].forEach(function(tex){_this.gpgpu.deleteMatrixTexture(tex)});for(var texShape in this.usedTextures)this.usedTextures[texShape].forEach(function(tex){_this.gpgpu.deleteMatrixTexture(tex)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}},TextureManager}();function getPhysicalTextureForRendering(isPacked){return env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?isPacked?PhysicalTextureType.PACKED_2X2_FLOAT32:PhysicalTextureType.UNPACKED_FLOAT32:isPacked?PhysicalTextureType.PACKED_2X2_FLOAT16:PhysicalTextureType.UNPACKED_FLOAT16}function getPhysicalFromLogicalTextureType(logicalTexType,isPacked){if(logicalTexType===TextureUsage.UPLOAD)return PhysicalTextureType.PACKED_2X2_FLOAT32;if(logicalTexType===TextureUsage.RENDER||null==logicalTexType)return getPhysicalTextureForRendering(isPacked);if(logicalTexType===TextureUsage.DOWNLOAD||logicalTexType===TextureUsage.PIXELS)return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+logicalTexType)}function getKeyFromTextureShape(shapeRowsCol,physicalTexType,isPacked){return shapeRowsCol[0]+"_"+shapeRowsCol[1]+"_"+physicalTexType+"_"+isPacked}var TileProgram=function(){function TileProgram(aShape,reps){this.variableNames=["A"];for(var outputShape=new Array(aShape.length),i=0;i<outputShape.length;i++)outputShape[i]=aShape[i]*reps[i];this.outputShape=outputShape,this.rank=outputShape.length;var dtype=getCoordsDataType(this.rank),sourceCoords=getSourceCoords$2(aShape);this.userCode="\n      void main() {\n        "+dtype+" resRC = getOutputCoords();\n        setOutput(getA("+sourceCoords+"));\n      }\n    "}return TileProgram}();function getSourceCoords$2(aShape){var rank=aShape.length;if(rank>5)throw Error("Tile for rank "+rank+" is not yet supported");if(1===rank)return"imod(resRC, "+aShape[0]+")";for(var currentCoords=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],sourceCoords=[],i=0;i<aShape.length;i++)sourceCoords.push("imod("+currentCoords[i]+", "+aShape[i]+")");return sourceCoords.join()}var ERF_P=.3275911,ERF_A1=.254829592,ERF_A2=-.284496736,ERF_A3=1.421413741,ERF_A4=-1.453152027,ERF_A5=1.061405429,SELU_SCALEALPHA=1.7580993408473768,SELU_SCALE=1.0507009873554805,UnaryOpProgram=function(){function UnaryOpProgram(aShape,opSnippet){this.variableNames=["A"],this.outputShape=aShape,this.userCode="\n      float unaryOperation(float x) {\n        "+opSnippet+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}return UnaryOpProgram}(),CHECK_NAN_SNIPPET$2="if (isnan(x)) return x;",LINEAR="return x;",ABS="return abs(x);",RELU=CHECK_NAN_SNIPPET$2+"\n  return (x < 0.0) ? 0.0 : x;\n",RELU6=CHECK_NAN_SNIPPET$2+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",ELU="return (x >= 0.0) ? x : (exp(x) - 1.0);",SELU="\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = "+SELU_SCALEALPHA+";\n  float scale = "+SELU_SCALE+";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";function STEP(alpha){return void 0===alpha&&(alpha=0),CHECK_NAN_SNIPPET$2+"\n    return x > 0.0 ? 1.0 : float("+alpha+");\n  "}var NEG="return -x;",CEIL="return ceil(x);",FLOOR="return floor(x);",SIGN="\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n",IS_NAN="return float(isnan(x));",IS_INF="return float(isinf(x));",IS_FINITE="return float(!isnan(x) && !isinf(x));",ROUND="\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n",EXP="return exp(x);",EXPM1="return exp(x) - 1.0;",LOG="if (x < 0.0) return NAN;\n  return log(x);",LOG1P="return log(1.0 + x);",SQRT="return sqrt(x);",RSQRT="return inversesqrt(x);",SIGMOID="return 1.0 / (1.0 + exp(-1.0 * x));",SOFTPLUS="\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n",SIN=CHECK_NAN_SNIPPET$2+"\n  return sin(x);\n",COS=CHECK_NAN_SNIPPET$2+"\n  return cos(x);\n",TAN="return tan(x);",ASIN=CHECK_NAN_SNIPPET$2+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",ACOS=CHECK_NAN_SNIPPET$2+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",ATAN=CHECK_NAN_SNIPPET$2+"\n  return atan(x);\n",SINH="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n",COSH="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n",TANH="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n",ASINH=CHECK_NAN_SNIPPET$2+"return log(x + sqrt(x * x + 1.0));",ACOSH=CHECK_NAN_SNIPPET$2+"\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",ATANH=CHECK_NAN_SNIPPET$2+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",ERF='\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = '+ERF_A1+";\n  float a2 = "+ERF_A2+";\n  float a3 = "+ERF_A3+";\n  float a4 = "+ERF_A4+";\n  float a5 = "+ERF_A5+";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n",SQUARE="return x * x;",RECIPROCAL="return 1.0 / x;",LOGICAL_NOT="return float(!(x >= 1.0));",TO_INT="return float(int(x));",CLONE="return x;",LINEAR$1="return x;",LOG$1="\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",RELU$1="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",RELU6$1="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",ELU$1="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",UnaryOpPackedProgram=function(){function UnaryOpPackedProgram(aShape,opSnippet){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=aShape,this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        "+opSnippet+"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}return UnaryOpPackedProgram}(),UnpackProgram=function(){function UnpackProgram(outputShape){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=outputShape;var rank=outputShape.length,channels=getChannels("rc",rank),dtype=getCoordsDataType(rank),sourceCoords=getSourceCoords(rank,channels),innerDims=channels.slice(-2),coords=rank<=1?"rc":"vec2("+innerDims.join(",")+")";this.userCode="\n      void main() {\n        "+dtype+" rc = getOutputCoords();\n        vec4 packedInput = getA("+sourceCoords+");\n\n        setOutput(getChannel(packedInput, "+coords+"));\n      }\n    "}return UnpackProgram}(),binaryCaches={};function getBinaryCache(webGLVersion){return webGLVersion in binaryCaches?binaryCaches[webGLVersion]:(binaryCaches[webGLVersion]={},binaryCaches[webGLVersion])}function mapActivationToShaderProgram(activation,packed){if(void 0===packed&&(packed=!1),"linear"===activation)return packed?LINEAR$1:LINEAR;if("relu"===activation)return packed?RELU$1:RELU;if("elu"===activation)return packed?ELU$1:ELU;if("relu6"===activation)return packed?RELU6$1:RELU6;if("prelu"===activation)return packed?PRELU$1:PRELU;throw new Error("Activation "+activation+" has not been implemented for the WebGL backend.")}var CPU_HANDOFF_SIZE_THRESHOLD=128,BEFORE_PAGING_CONSTANT=600;function numMBBeforeWarning(){return null==env().global.screen?1024:env().global.screen.height*env().global.screen.width*window.devicePixelRatio*BEFORE_PAGING_CONSTANT/1024/1024}var MATMUL_SHARED_DIM_THRESHOLD=1e3,MathBackendWebGL=function(_super){function MathBackendWebGL(gpgpu){var _this=_super.call(this)||this;if(_this.pendingRead=new WeakMap,_this.pendingDisposal=new WeakSet,_this.dataRefCount=new WeakMap,_this.numBytesInGPU=0,_this.uploadWaitMs=0,_this.downloadWaitMs=0,_this.warnedAboutMemory=!1,_this.pendingDeletes=0,_this.disposed=!1,!env().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==gpgpu){var gl=getWebGLContext(env().getNumber("WEBGL_VERSION"));_this.binaryCache=getBinaryCache(env().getNumber("WEBGL_VERSION")),_this.gpgpu=new GPGPUContext(gl),_this.canvas=gl.canvas,_this.gpgpuCreatedLocally=!0}else _this.gpgpu=gpgpu,_this.binaryCache={},_this.gpgpuCreatedLocally=!1,_this.canvas=gpgpu.gl.canvas;return _this.textureManager=new TextureManager(_this.gpgpu),_this.numMBBeforeWarning=numMBBeforeWarning(),_this.texData=new DataStorage(_this,ENGINE),_this}return __extends(MathBackendWebGL,_super),MathBackendWebGL.prototype.numDataIds=function(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes},MathBackendWebGL.prototype.write=function(values,shape,dtype){if(env().getBool("DEBUG")&&this.checkNumericalProblems(values),"complex64"===dtype&&null!=values)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var dataId={};return this.texData.set(dataId,{shape:shape,dtype:dtype,values:values,usage:TextureUsage.UPLOAD}),dataId},MathBackendWebGL.prototype.move=function(dataId,values,shape,dtype){if(env().getBool("DEBUG")&&this.checkNumericalProblems(values),"complex64"===dtype)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(dataId,{shape:shape,dtype:dtype,values:values,usage:TextureUsage.UPLOAD})},MathBackendWebGL.prototype.readSync=function(dataId){var texData=this.texData.get(dataId),values=texData.values,dtype=texData.dtype,complexTensors=texData.complexTensors,slice=texData.slice,shape=texData.shape,isPacked=texData.isPacked;if(null!=slice){var program=void 0;program=isPacked?new UnaryOpPackedProgram(shape,CLONE):new UnaryOpProgram(shape,CLONE);var res=this.runWebGLProgram(program,[{dataId:dataId,shape:shape,dtype:dtype}],dtype),data=this.readSync(res.dataId);return this.disposeData(res.dataId),data}if(null!=values)return this.convertAndCacheOnCPU(dataId);if("string"===dtype)return values;var shouldTimeProgram=null!=this.activeTimers,start,result,realValues,imagValues;(shouldTimeProgram&&(start=now()),"complex64"===dtype)?result=mergeRealAndImagArrays(complexTensors.real.dataSync(),complexTensors.imag.dataSync()):result=this.getValuesFromTexture(dataId);return shouldTimeProgram&&(this.downloadWaitMs+=now()-start),this.convertAndCacheOnCPU(dataId,result)},MathBackendWebGL.prototype.read=function(dataId){return __awaiter(this,void 0,void 0,function(){var subscribers_1,texData,values,shape,slice,dtype,complexTensors,isPacked,program,res,data,buffer,tmpDownloadTarget,tmpData,vals,ps,realValues,imagValues,size,dTypeVals,subscribers,_a;return __generator(this,function(_b){switch(_b.label){case 0:if(this.pendingRead.has(dataId))return subscribers_1=this.pendingRead.get(dataId),[2,new Promise(function(resolve){return subscribers_1.push(resolve)})];if(texData=this.texData.get(dataId),values=texData.values,shape=texData.shape,slice=texData.slice,dtype=texData.dtype,complexTensors=texData.complexTensors,isPacked=texData.isPacked,null!=slice)return program=void 0,program=isPacked?new UnaryOpPackedProgram(shape,CLONE):new UnaryOpProgram(shape,CLONE),res=this.runWebGLProgram(program,[{dataId:dataId,shape:shape,dtype:dtype}],dtype),data=this.read(res.dataId),this.disposeData(res.dataId),[2,data];if(null!=values)return[2,this.convertAndCacheOnCPU(dataId)];if(!env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===env().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");return buffer=null,"complex64"!==dtype&&env().get("WEBGL_BUFFER_SUPPORTED")&&(tmpDownloadTarget=this.decode(dataId),tmpData=this.texData.get(tmpDownloadTarget.dataId),buffer=(_a=this.gpgpu).createBufferFromTexture.apply(_a,[tmpData.texture].concat(getDenseTexShape(shape)))),this.pendingRead.set(dataId,[]),"complex64"===dtype?[3,2]:[4,this.gpgpu.createAndWaitForFence()];case 1:_b.sent(),_b.label=2;case 2:return"complex64"!==dtype?[3,4]:[4,Promise.all([complexTensors.real.data(),complexTensors.imag.data()])];case 3:return ps=_b.sent(),realValues=ps[0],imagValues=ps[1],vals=mergeRealAndImagArrays(realValues,imagValues),[3,5];case 4:null==buffer?vals=this.getValuesFromTexture(dataId):(size=sizeFromShape(shape),vals=this.gpgpu.downloadFloat32MatrixFromBuffer(buffer,size)),_b.label=5;case 5:return null!=tmpDownloadTarget&&this.disposeData(tmpDownloadTarget.dataId),dTypeVals=this.convertAndCacheOnCPU(dataId,vals),subscribers=this.pendingRead.get(dataId),this.pendingRead.delete(dataId),subscribers.forEach(function(resolve){return resolve(dTypeVals)}),this.pendingDisposal.has(dataId)&&(this.pendingDisposal.delete(dataId),this.disposeData(dataId),this.pendingDeletes--),[2,dTypeVals]}})})},MathBackendWebGL.prototype.checkNumericalProblems=function(values){if(null!=values)for(var i=0;i<values.length;i++){var num=values[i];if(!canBeRepresented(num)){if(env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value "+num+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value "+num+" cannot be represented on this device.")}}},MathBackendWebGL.prototype.getValuesFromTexture=function(dataId){var _a,_b=this.texData.get(dataId),shape=_b.shape,dtype=_b.dtype,isPacked=_b.isPacked,size=sizeFromShape(shape);if(env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){var tmpTarget=this.decode(dataId),tmpData_1=this.texData.get(tmpTarget.dataId),vals_1=(_a=this.gpgpu).downloadMatrixFromPackedTexture.apply(_a,[tmpData_1.texture].concat(getDenseTexShape(shape))).subarray(0,size);return this.disposeData(tmpTarget.dataId),vals_1}var shouldUsePackedProgram=env().getBool("WEBGL_PACK")&&!0===isPacked,outputShape=shouldUsePackedProgram?getShapeAs3D(shape):shape,program=shouldUsePackedProgram?new EncodeFloatPackedProgram(outputShape):new EncodeFloatProgram(outputShape),output=this.runWebGLProgram(program,[{shape:outputShape,dtype:dtype,dataId:dataId}],"float32"),tmpData=this.texData.get(output.dataId),vals=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture,tmpData.texShape[0],tmpData.texShape[1]).subarray(0,size);return this.disposeData(output.dataId),vals},MathBackendWebGL.prototype.time=function(f){return __awaiter(this,void 0,void 0,function(){var oldActiveTimers,newActiveTimers,outerMostTime,flattenedActiveTimerQueries,flattenedActiveTimerNames,res,kernelMs_1;return __generator(this,function(_a){switch(_a.label){case 0:return oldActiveTimers=this.activeTimers,newActiveTimers=[],outerMostTime=!1,null==this.programTimersStack?(this.programTimersStack=newActiveTimers,outerMostTime=!0):this.activeTimers.push(newActiveTimers),this.activeTimers=newActiveTimers,f(),flattenedActiveTimerQueries=flatten(this.activeTimers.map(function(d){return d.query})).filter(function(d){return null!=d}),flattenedActiveTimerNames=flatten(this.activeTimers.map(function(d){return d.name})).filter(function(d){return null!=d}),this.activeTimers=oldActiveTimers,outerMostTime&&(this.programTimersStack=null),res={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[4,Promise.all(flattenedActiveTimerQueries)]:[3,2];case 1:return kernelMs_1=_a.sent(),res.kernelMs=sum(kernelMs_1),res.getExtraProfileInfo=function(){return kernelMs_1.map(function(d,i){return{name:flattenedActiveTimerNames[i],ms:d}}).map(function(d){return d.name+": "+d.ms}).join(", ")},[3,3];case 2:res.kernelMs={error:"WebGL query timers are not supported in this environment."},_a.label=3;case 3:return this.uploadWaitMs=0,this.downloadWaitMs=0,[2,res]}})})},MathBackendWebGL.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}},MathBackendWebGL.prototype.startTimer=function(){return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:now(),endMs:null}},MathBackendWebGL.prototype.endTimer=function(query){return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),query):(query.endMs=now(),query)},MathBackendWebGL.prototype.getQueryTime=function(query){return __awaiter(this,void 0,void 0,function(){var timerQuery;return __generator(this,function(_a){return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[2,this.gpgpu.waitForQueryAndGetTime(query)]:[2,(timerQuery=query).endMs-timerQuery.startMs]})})},MathBackendWebGL.prototype.disposeData=function(dataId){if(!this.pendingDisposal.has(dataId)){if(this.pendingRead.has(dataId))return this.pendingDisposal.add(dataId),void this.pendingDeletes++;if(this.texData.has(dataId)){this.releaseGPUData(dataId);var complexTensors=this.texData.get(dataId).complexTensors;null!=complexTensors&&(complexTensors.real.dispose(),complexTensors.imag.dispose()),this.texData.delete(dataId)}}},MathBackendWebGL.prototype.releaseGPUData=function(dataId){var _a=this.texData.get(dataId),texture=_a.texture,dtype=_a.dtype,texShape=_a.texShape,usage=_a.usage,isPacked=_a.isPacked,slice=_a.slice,key=slice&&slice.origDataId||dataId,refCount=this.dataRefCount.get(key);refCount>1?this.dataRefCount.set(key,refCount-1):(this.dataRefCount.delete(key),null!=texture&&(this.numBytesInGPU-=this.computeBytes(texShape,dtype),this.textureManager.releaseTexture(texture,texShape,usage,isPacked)));var texData=this.texData.get(dataId);texData.texture=null,texData.texShape=null,texData.isPacked=!1,texData.slice=null},MathBackendWebGL.prototype.getTexture=function(dataId){return this.uploadToGPU(dataId),this.texData.get(dataId).texture},MathBackendWebGL.prototype.getDataInfo=function(dataId){return this.texData.get(dataId)},MathBackendWebGL.prototype.getCPUBackend=function(){return env().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=ENGINE.findBackend("cpu")),this.cpuBackend):null},MathBackendWebGL.prototype.shouldExecuteOnCPU=function(inputs,sizeThreshold){var _this=this;return void 0===sizeThreshold&&(sizeThreshold=128),null!=this.getCPUBackend()&&inputs.every(function(input){return null==_this.texData.get(input.dataId).texture&&sizeFromShape(input.shape)<sizeThreshold})},MathBackendWebGL.prototype.getGPGPUContext=function(){return this.gpgpu},MathBackendWebGL.prototype.complex=function(real,imag){var result=this.makeOutput(real.shape,"complex64"),resultData;return this.texData.get(result.dataId).complexTensors={real:ENGINE.keep(real.clone()),imag:ENGINE.keep(imag.clone())},result},MathBackendWebGL.prototype.real=function(input){var resultData;return this.texData.get(input.dataId).complexTensors.real.clone()},MathBackendWebGL.prototype.imag=function(input){var resultData;return this.texData.get(input.dataId).complexTensors.imag.clone()},MathBackendWebGL.prototype.slice=function(x,begin,size){if(this.shouldExecuteOnCPU([x]))return this.cpuBackend.slice(x,begin,size);if(0===sizeFromShape(size))return tensor([],size,x.dtype);var isPacked=this.texData.get(x.dataId).isPacked,isContinous=isSliceContinous(x.shape,begin,size);if(isPacked||!isContinous){var program=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SlicePackedProgram(size):new SliceProgram(size),customSetup=program.getCustomSetupFunc(begin);return this.compileAndRun(program,[x],null,customSetup)}return this.uploadToGPU(x.dataId),this.shallowSlice(x,begin,size)},MathBackendWebGL.prototype.shallowSlice=function(x,begin,size){var xTexData=this.texData.get(x.dataId),t=this.makeOutput(size,x.dtype),newTexData=this.texData.get(t.dataId);Object.assign(newTexData,xTexData),newTexData.shape=size,newTexData.dtype=x.dtype;var flatOffset=computeFlatOffset(begin,x.strides);xTexData.slice&&(flatOffset+=xTexData.slice.flatOffset),newTexData.slice={flatOffset:flatOffset,origDataId:xTexData.slice&&xTexData.slice.origDataId||x.dataId};var refCount=this.dataRefCount.get(newTexData.slice.origDataId)||1;return this.dataRefCount.set(newTexData.slice.origDataId,refCount+1),t},MathBackendWebGL.prototype.stridedSlice=function(x,begin,end,strides){if(this.shouldExecuteOnCPU([x]))return this.cpuBackend.stridedSlice(x,begin,end,strides);var outShape=computeOutShape$2(begin,end,strides);if(outShape.some(function(axis){return 0===axis}))return tensor([],outShape);var program=new StridedSliceProgram(begin,strides,outShape);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.reverse=function(x,axis){var program=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ReversePackedProgram(x.shape,axis):new ReverseProgram(x.shape,axis);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.concat=function(tensors,axis){if("complex64"===tensors[0].dtype){var reals=tensors.map(function(t){return real(t)}),imags=tensors.map(function(t){return imag(t)});return complex(this.concat(reals,axis),this.concat(imags,axis))}if(this.shouldExecuteOnCPU(tensors))return this.cpuBackend.concat(tensors,axis);if(1===tensors.length)return tensors[0];if(tensors.length>env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){var midIndex=Math.floor(tensors.length/2),leftSide=this.concat(tensors.slice(0,midIndex),axis),rightSide=this.concat(tensors.slice(midIndex),axis);return this.concat([leftSide,rightSide],axis)}if(env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&tensors[0].rank>1){var program_1=new ConcatPackedProgram(tensors.map(function(t){return t.shape}),axis);return this.compileAndRun(program_1,tensors)}var outShape=computeOutShape(tensors.map(function(t){return t.shape}),axis),tensors2D=tensors.map(function(t){return t.as2D(-1,sizeFromShape(t.shape.slice(axis)))}),program=new ConcatProgram(tensors2D.map(function(t){return t.shape})),res;return this.compileAndRun(program,tensors2D).reshape(outShape)},MathBackendWebGL.prototype.neg=function(x){if(this.shouldExecuteOnCPU([x]))return this.cpuBackend.neg(x);if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,NEG,x.dtype);var program=new UnaryOpProgram(x.shape,NEG);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.batchMatMul=function(a,b,transposeA,transposeB){var outerShapeA=transposeA?a.shape[2]:a.shape[1],outerShapeB=transposeB?b.shape[1]:b.shape[2],sharedDim=transposeA?a.shape[1]:a.shape[2],_a,batch=a.shape[0];if((1===outerShapeA||1===outerShapeB)&&sharedDim>1e3){transposeA&&(a=transpose(a,[0,2,1])),transposeB&&(b=transpose(b,[0,2,1]));var a3D=1===outerShapeB?a:a.as3D(batch,sharedDim,1),axis=1===outerShapeB?2:1,b3D=1===outerShapeB?b.as3D(batch,1,sharedDim):b;return this.multiply(a3D,b3D).sum(axis,!0)}var dtype=upcastType(a.dtype,b.dtype),program=new MatMulPackedProgram(a.shape,[batch,outerShapeA,outerShapeB],transposeA,transposeB);return this.compileAndRun(program,[a,b],dtype)},MathBackendWebGL.prototype.fusedBatchMatMul=function(_a){var a=_a.a,b=_a.b,transposeA=_a.transposeA,transposeB=_a.transposeB,bias=_a.bias,activation=_a.activation,preluActivationWeights=_a.preluActivationWeights,outerShapeA=transposeA?a.shape[2]:a.shape[1],outerShapeB=transposeB?b.shape[1]:b.shape[2],_b,batch=a.shape[0],dtype=upcastType(a.dtype,b.dtype),hasBias=null!=bias,hasPreluActivationWeights=null!=preluActivationWeights,fusedActivation=activation?mapActivationToShaderProgram(activation,!0):null,program=new MatMulPackedProgram(a.shape,[batch,outerShapeA,outerShapeB],transposeA,transposeB,hasBias,fusedActivation,hasPreluActivationWeights),inputs=[a,b];return bias&&inputs.push(bias),preluActivationWeights&&inputs.push(preluActivationWeights),this.compileAndRun(program,inputs,dtype)},MathBackendWebGL.prototype.multiply=function(a,b){if("complex64"===a.dtype){var aData=this.texData.get(a.dataId),bData=this.texData.get(b.dataId),realProgram=new BinaryOpComplexProgram(COMPLEX_MULTIPLY_REAL,a.shape,b.shape),imagProgram=new BinaryOpComplexProgram(COMPLEX_MULTIPLY_IMAG,a.shape,b.shape),inputs=[this.makeComplexComponentTensorInfo(a,aData.complexTensors.real),this.makeComplexComponentTensorInfo(a,aData.complexTensors.imag),this.makeComplexComponentTensorInfo(b,bData.complexTensors.real),this.makeComplexComponentTensorInfo(b,bData.complexTensors.imag)],real_1=this.compileAndRun(realProgram,inputs),imag_1=this.compileAndRun(imagProgram,inputs),complex_1=this.complex(real_1,imag_1);return real_1.dispose(),imag_1.dispose(),complex_1}if(this.shouldExecuteOnCPU([a,b]))return this.cpuBackend.multiply(a,b);if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,MUL,a.dtype);var program=new BinaryOpProgram(MUL,a.shape,b.shape);return this.compileAndRun(program,[a,b],a.dtype)},MathBackendWebGL.prototype.batchNormalization=function(x,mean,variance,varianceEpsilon,scale,offset){var inputs=[x,mean,variance],offsetShape=null;null!=offset&&(offsetShape=offset.shape,inputs.push(offset));var scaleShape=null;if(null!=scale&&(scaleShape=scale.shape,inputs.push(scale)),env().getBool("WEBGL_PACK_NORMALIZATION")){var batchNormPackedProgram=new BatchNormPackedProgram(x.shape,mean.shape,variance.shape,offsetShape,scaleShape,varianceEpsilon);return this.compileAndRun(batchNormPackedProgram,inputs)}var batchNormProgram=new BatchNormProgram(x.shape,mean.shape,variance.shape,offsetShape,scaleShape,varianceEpsilon);return this.compileAndRun(batchNormProgram,inputs)},MathBackendWebGL.prototype.localResponseNormalization4D=function(x,radius,bias,alpha,beta){var program=env().getBool("WEBGL_PACK_NORMALIZATION")?new LRNPackedProgram(x.shape,radius,bias,alpha,beta):new LRNProgram(x.shape,radius,bias,alpha,beta);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.LRNGrad=function(dy,inputImage,outputImage,depthRadius,bias,alpha,beta){var program=new LRNGradProgram(inputImage.shape,depthRadius,bias,alpha,beta);return this.compileAndRun(program,[inputImage,outputImage,dy])},MathBackendWebGL.prototype.tile=function(x,reps){if("string"===x.dtype){var data,decodedData=this.readSync(x.dataId).map(function(d){return decodeString(d)}),buf;return tile(buffer(x.shape,x.dtype,decodedData),reps)}var program=new TileProgram(x.shape,reps);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.pad=function(x,paddings,constantValue){var program=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PadPackedProgram(x.shape,paddings,constantValue):new PadProgram(x.shape,paddings,constantValue);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.gather=function(x,indices,axis){if(this.shouldExecuteOnCPU([x,indices]))return this.cpuBackend.gather(x,indices,axis);var program=new GatherProgram(x.shape,indices.size,axis);return this.compileAndRun(program,[x,indices])},MathBackendWebGL.prototype.batchToSpaceND=function(x,blockShape,crops){assert(x.rank<=4,function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"});var prod=blockShape.reduce(function(a,b){return a*b}),reshaped=getReshaped(x.shape,blockShape,prod),permuted=getPermuted(reshaped.length,blockShape.length),reshapedPermuted=getReshapedPermuted(x.shape,blockShape,prod),sliceBeginCoords=getSliceBeginCoords(crops,blockShape.length),sliceSize=getSliceSize(reshapedPermuted,crops,blockShape.length);return transpose(x.reshape(reshaped),permuted).reshape(reshapedPermuted).slice(sliceBeginCoords,sliceSize)},MathBackendWebGL.prototype.spaceToBatchND=function(x,blockShape,paddings){assert(x.rank<=4,function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"});var prod=blockShape.reduce(function(a,b){return a*b}),completePaddings=[[0,0]];completePaddings.push.apply(completePaddings,paddings);for(var i=1+blockShape.length;i<x.shape.length;++i)completePaddings.push([0,0]);var paddedX=x.pad(completePaddings),reshapedPaddedShape=getReshaped(paddedX.shape,blockShape,prod,!1),permutedReshapedPaddedPermutation=getPermuted(reshapedPaddedShape.length,blockShape.length,!1),flattenShape=getReshapedPermuted(paddedX.shape,blockShape,prod,!1);return transpose(paddedX.reshape(reshapedPaddedShape),permutedReshapedPaddedPermutation).reshape(flattenShape)},MathBackendWebGL.prototype.reduce=function(x,reduceType,dtype){var batchSize=x.shape[0],inSize=x.shape[1],windowSize=computeOptimalWindowSize(inSize),reduceInfo,program=new ReduceProgram({windowSize:windowSize,inSize:inSize,batchSize:batchSize},reduceType),output=this.compileAndRun(program,[x],dtype);return 1===output.shape[1]?output:this.reduce(output,reduceType,dtype)},MathBackendWebGL.prototype.argReduce=function(x,reduceType,bestIndicesA){void 0===bestIndicesA&&(bestIndicesA=null);var batchSize=x.shape[0],inSize=x.shape[1];null!=bestIndicesA&&(batchSize=bestIndicesA.shape[0],inSize=bestIndicesA.shape[1]);var windowSize=computeOptimalWindowSize(inSize),reduceInfo,program=new ArgMinMaxProgram({windowSize:windowSize,inSize:inSize,batchSize:batchSize},reduceType,null==bestIndicesA),inputs=[x];null!=bestIndicesA&&inputs.push(bestIndicesA);var output=this.compileAndRun(program,inputs,"int32");return 1===output.shape[1]?output:this.argReduce(x,reduceType,output)},MathBackendWebGL.prototype.argReducePacked=function(x,reduceType,bestIndicesA){void 0===bestIndicesA&&(bestIndicesA=null);var inShape=null!=bestIndicesA?bestIndicesA.shape:x.shape,inSize,windowSize=computeOptimalWindowSize(inShape[inShape.length-1]),program=new ArgMinMaxPackedProgram(inShape,windowSize,reduceType,null==bestIndicesA),inputs=null==bestIndicesA?[x]:[x,bestIndicesA],output=this.compileAndRun(program,inputs,"int32");return output.rank===x.rank?this.argReducePacked(x,reduceType,output):output},MathBackendWebGL.prototype.sum=function(x,axes){assertAxesAreInnerMostDims("sum",axes,x.rank);var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape,inSize=sizeFromShape(_a[1]),a2D=x.as2D(-1,inSize),outputDType=sumOutType(x.dtype);return this.reduce(a2D,"sum",outputDType).reshape(outShape)},MathBackendWebGL.prototype.prod=function(x,axes){if(this.shouldExecuteOnCPU([x]))return this.cpuBackend.prod(x,axes);var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape,inSize=sizeFromShape(_a[1]),a2D=x.as2D(-1,inSize),outputDType=sumOutType(x.dtype);return this.reduce(a2D,"prod",outputDType).reshape(outShape)},MathBackendWebGL.prototype.unsortedSegmentSum=function(x,segmentIds,numSegments){var axis=0,permutation=getAxesPermutation([axis],x.rank),permutedX=x;null!=permutation&&(permutedX=transpose(x,permutation),axis=getInnerMostAxes(1,x.rank)[0]);var outShape=computeOutShape$1(permutedX.shape,axis,numSegments),inSize=sizeFromShape([permutedX.shape[axis]]),a2D=permutedX.as2D(-1,inSize),outputDType=sumOutType(x.dtype),result=this.segOpCompute(a2D,"unsortedSegmentSum",segmentIds,outputDType,numSegments).reshape(outShape);return null!=permutation&&(result=transpose(result,getUndoAxesPermutation(permutation))),result},MathBackendWebGL.prototype.segOpCompute=function(x,segOpType,segmentIds,dtype,numSegments){var batchSize=x.shape[0],inSize=x.shape[1],windowSize=segOpComputeOptimalWindowSize(inSize,numSegments),segOpInfo,program=new SegmentOpProgram({windowSize:windowSize,inSize:inSize,batchSize:batchSize,numSegments:numSegments},segOpType),output=this.compileAndRun(program,[x,segmentIds],dtype);return output.shape[1]===numSegments?output:(segmentIds=range(0,numSegments).tile([inSize/windowSize]),this.segOpCompute(output,segOpType,segmentIds,dtype,numSegments))},MathBackendWebGL.prototype.argMinMaxReduce=function(x,axis,reduceType){var axes=[axis];if(assertAxesAreInnerMostDims("arg"+reduceType.charAt(0).toUpperCase()+reduceType.slice(1),axes,x.rank),!env().getBool("WEBGL_PACK_REDUCE")||x.rank<=2){var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape,inSize=sizeFromShape(_a[1]),a2D=x.as2D(-1,inSize);return this.argReduce(a2D,reduceType).reshape(outShape)}return this.argReducePacked(x,reduceType)},MathBackendWebGL.prototype.argMin=function(x,axis){return this.argMinMaxReduce(x,axis,"min")},MathBackendWebGL.prototype.argMax=function(x,axis){return this.argMinMaxReduce(x,axis,"max")},MathBackendWebGL.prototype.cumsum=function(x,axis,exclusive,reverse){if(axis!==x.rank-1)throw new Error("WebGL cumsum shader expects an inner-most axis="+(x.rank-1)+" but got axis="+axis);var program=new CumSumProgram(x.shape,exclusive,reverse);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.equal=function(a,b){if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,EQUAL$1,"bool");var program=new BinaryOpProgram(EQUAL,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")},MathBackendWebGL.prototype.notEqual=function(a,b){if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,NOT_EQUAL$1,"bool");var program=new BinaryOpProgram(NOT_EQUAL,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")},MathBackendWebGL.prototype.less=function(a,b){if(this.shouldExecuteOnCPU([a,b]))return this.cpuBackend.less(a,b);if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,LESS$1,"bool");var program=new BinaryOpProgram(LESS,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")},MathBackendWebGL.prototype.lessEqual=function(a,b){if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,LESS_EQUAL$1,"bool");var program=new BinaryOpProgram(LESS_EQUAL,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")},MathBackendWebGL.prototype.greater=function(a,b){if(this.shouldExecuteOnCPU([a,b]))return this.cpuBackend.greater(a,b);if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,GREATER$1,"bool");var program=new BinaryOpProgram(GREATER,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")},MathBackendWebGL.prototype.greaterEqual=function(a,b){if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,GREATER_EQUAL$1,"bool");var program=new BinaryOpProgram(GREATER_EQUAL,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")},MathBackendWebGL.prototype.logicalNot=function(x){var program=new UnaryOpProgram(x.shape,LOGICAL_NOT);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.logicalAnd=function(a,b){if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,LOGICAL_AND$1,"bool");var program=new BinaryOpProgram(LOGICAL_AND,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")},MathBackendWebGL.prototype.logicalOr=function(a,b){if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,LOGICAL_OR$1,"bool");var program=new BinaryOpProgram(LOGICAL_OR,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")},MathBackendWebGL.prototype.select=function(condition,a,b){var program=new SelectProgram(condition.rank,a.shape,a.rank);return this.compileAndRun(program,[condition,a,b],upcastType(a.dtype,b.dtype))},MathBackendWebGL.prototype.where=function(condition){warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var condVals=condition.dataSync();return whereImpl(condition.shape,condVals)},MathBackendWebGL.prototype.topk=function(x,k,sorted){var xVals;return topkImpl(x.dataSync(),x.shape,x.dtype,k,sorted)},MathBackendWebGL.prototype.min=function(x,axes){assertAxesAreInnerMostDims("min",axes,x.rank);var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape,inSize=sizeFromShape(_a[1]),a2D=x.as2D(-1,inSize);return this.reduce(a2D,"min",a2D.dtype).reshape(outShape)},MathBackendWebGL.prototype.minimum=function(a,b){if(this.shouldExecuteOnCPU([a,b]))return this.cpuBackend.minimum(a,b);var program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(MIN$1,a.shape,b.shape):new BinaryOpProgram(MIN,a.shape,b.shape);return this.compileAndRun(program,[a,b])},MathBackendWebGL.prototype.mod=function(a,b){var program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(MOD$1,a.shape,b.shape):new BinaryOpProgram(MOD,a.shape,b.shape);return this.compileAndRun(program,[a,b])},MathBackendWebGL.prototype.max=function(x,axes){if(this.shouldExecuteOnCPU([x]))return this.cpuBackend.max(x,axes);assertAxesAreInnerMostDims("max",axes,x.rank);var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape,inSize=sizeFromShape(_a[1]),a2D=x.as2D(-1,inSize);return this.reduce(a2D,"max",a2D.dtype).reshape(outShape)},MathBackendWebGL.prototype.maximum=function(a,b){if(this.shouldExecuteOnCPU([a,b]))return this.cpuBackend.maximum(a,b);var program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(MAX$1,a.shape,b.shape):new BinaryOpProgram(MAX,a.shape,b.shape);return this.compileAndRun(program,[a,b])},MathBackendWebGL.prototype.all=function(x,axes){assertAxesAreInnerMostDims("all",axes,x.rank);var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape,inSize=sizeFromShape(_a[1]),a2D=x.as2D(-1,inSize);return this.reduce(a2D,"all",a2D.dtype).reshape(outShape)},MathBackendWebGL.prototype.any=function(x,axes){assertAxesAreInnerMostDims("any",axes,x.rank);var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape,inSize=sizeFromShape(_a[1]),a2D=x.as2D(-1,inSize);return this.reduce(a2D,"any",a2D.dtype).reshape(outShape)},MathBackendWebGL.prototype.floorDiv=function(a,b){var op=INT_DIV,outputDtype="int32";if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,INT_DIV$1,"int32");var program=new BinaryOpProgram(op,a.shape,b.shape);return this.compileAndRun(program,[a,b],"int32")},MathBackendWebGL.prototype.add=function(a,b){if("complex64"===a.dtype&&"complex64"===b.dtype)return this.complexSeparableBinaryOp(a,b,ADD);if(this.shouldExecuteOnCPU([a,b]))return this.cpuBackend.add(a,b);var dtype=upcastType(a.dtype,b.dtype);if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,ADD,dtype);var program=new BinaryOpProgram(ADD,a.shape,b.shape);return this.compileAndRun(program,[a,b],dtype)},MathBackendWebGL.prototype.packedUnaryOp=function(x,op,dtype){var program=new UnaryOpPackedProgram(x.shape,op);return this.compileAndRun(program,[x],dtype)},MathBackendWebGL.prototype.packedBinaryOp=function(a,b,op,dtype,checkOutOfBounds){void 0===checkOutOfBounds&&(checkOutOfBounds=!1);var program=new BinaryOpPackedProgram(op,a.shape,b.shape,checkOutOfBounds);return this.compileAndRun(program,[a,b],dtype)},MathBackendWebGL.prototype.complexSeparableBinaryOp=function(a,b,op){var _this=this,aData=this.texData.get(a.dataId),bData=this.texData.get(b.dataId),_a=[[aData.complexTensors.real,bData.complexTensors.real],[aData.complexTensors.imag,bData.complexTensors.imag]].map(function(complexParts){var aPart=complexParts[0],bPart=complexParts[1],aHandle=_this.makeComplexComponentTensorInfo(a,aPart),bHandle=_this.makeComplexComponentTensorInfo(b,bPart),program=new BinaryOpProgram(op,a.shape,b.shape);return _this.compileAndRun(program,[aHandle,bHandle],upcastType(aPart.dtype,bPart.dtype))}),real=_a[0],imag=_a[1],complex=this.complex(real,imag);return real.dispose(),imag.dispose(),complex},MathBackendWebGL.prototype.makeComplexComponentTensorInfo=function(complexTensor,complexPart){return{dataId:complexPart.dataId,dtype:complexPart.dtype,shape:complexTensor.shape}},MathBackendWebGL.prototype.addN=function(tensors){if(1===tensors.length)return tensors[0];if(tensors.length>env().get("WEBGL_MAX_TEXTURES_IN_SHADER")){var midIndex=Math.floor(tensors.length/2),leftSide=this.addN(tensors.slice(0,midIndex)),rightSide=this.addN(tensors.slice(midIndex));return this.addN([leftSide,rightSide])}var dtype=tensors.map(function(t){return t.dtype}).reduce(function(d1,d2){return upcastType(d1,d2)}),shapes=tensors.map(function(t){return t.shape}),usePackedOp,program=env().getBool("WEBGL_PACK")?new AddNPackedProgram(tensors[0].shape,shapes):new AddNProgram(tensors[0].shape,shapes);return this.compileAndRun(program,tensors,dtype)},MathBackendWebGL.prototype.subtract=function(a,b){if("complex64"===a.dtype&&"complex64"===b.dtype)return this.complexSeparableBinaryOp(a,b,SUB);if(this.shouldExecuteOnCPU([a,b]))return this.cpuBackend.subtract(a,b);var dtype=upcastType(a.dtype,b.dtype);if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,SUB,a.dtype);var program=new BinaryOpProgram(SUB,a.shape,b.shape);return this.compileAndRun(program,[a,b],dtype)},MathBackendWebGL.prototype.pow=function(a,b){var usePackedOp,program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(POW$1,a.shape,b.shape):new BinaryOpProgram(POW,a.shape,b.shape),dtype=upcastType(a.dtype,b.dtype);return this.compileAndRun(program,[a,b],dtype)},MathBackendWebGL.prototype.ceil=function(x){if(this.shouldExecuteOnCPU([x]))return this.cpuBackend.ceil(x);if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,CEIL,x.dtype);var program=new UnaryOpProgram(x.shape,CEIL);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.floor=function(x){if(this.shouldExecuteOnCPU([x]))return this.cpuBackend.floor(x);if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,FLOOR,x.dtype);var program=new UnaryOpProgram(x.shape,FLOOR);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.sign=function(x){var program=new UnaryOpProgram(x.shape,SIGN);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.isNaN=function(x){var program=new UnaryOpProgram(x.shape,IS_NAN);return this.compileAndRun(program,[x],"bool")},MathBackendWebGL.prototype.isInf=function(x){var program=new UnaryOpProgram(x.shape,IS_INF);return this.compileAndRun(program,[x],"bool")},MathBackendWebGL.prototype.isFinite=function(x){var program=new UnaryOpProgram(x.shape,IS_FINITE);return this.compileAndRun(program,[x],"bool")},MathBackendWebGL.prototype.round=function(x){var program=new UnaryOpProgram(x.shape,ROUND);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.exp=function(x){if(this.shouldExecuteOnCPU([x]))return this.cpuBackend.exp(x);if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,EXP,x.dtype);var program=new UnaryOpProgram(x.shape,EXP);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.expm1=function(x){if(this.shouldExecuteOnCPU([x]))return this.cpuBackend.expm1(x);if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,EXPM1,x.dtype);var program=new UnaryOpProgram(x.shape,EXPM1);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.softmax=function(logits,dim){var axes=parseAxisParam([dim],logits.shape),maxLogit=this.max(logits,axes),expandedShape=expandShapeToKeepDim(maxLogit.shape,axes),a=this.subtract(logits,maxLogit.reshape(expandedShape)),b=this.exp(a),sumExp=this.sum(b,axes).reshape(expandedShape);return div(b,sumExp)},MathBackendWebGL.prototype.log=function(x){if(this.shouldExecuteOnCPU([x]))return this.cpuBackend.log(x);if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,LOG$1,x.dtype);var program=new UnaryOpProgram(x.shape,LOG);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.log1p=function(x){var program=new UnaryOpProgram(x.shape,LOG1P);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.sqrt=function(x){var program=new UnaryOpProgram(x.shape,SQRT);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.rsqrt=function(x){if(this.shouldExecuteOnCPU([x]))return this.cpuBackend.rsqrt(x);var program=new UnaryOpProgram(x.shape,RSQRT);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.reciprocal=function(x){var program=new UnaryOpProgram(x.shape,RECIPROCAL);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.relu=function(x){var program;return program=env().getBool("WEBGL_PACK")?new UnaryOpPackedProgram(x.shape,RELU$1):new UnaryOpProgram(x.shape,RELU),this.compileAndRun(program,[x])},MathBackendWebGL.prototype.relu6=function(x){var program;return program=env().getBool("WEBGL_PACK")?new UnaryOpPackedProgram(x.shape,RELU6$1):new UnaryOpProgram(x.shape,RELU6),this.compileAndRun(program,[x])},MathBackendWebGL.prototype.prelu=function(x,alpha){var program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(PRELU$1,x.shape,alpha.shape):new BinaryOpProgram(PRELU,x.shape,alpha.shape);return this.compileAndRun(program,[x,alpha])},MathBackendWebGL.prototype.elu=function(x){if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,ELU$1,x.dtype);var program=new UnaryOpProgram(x.shape,ELU);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.eluDer=function(dy,y){var program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(ELU_DER$1,dy.shape,y.shape):new BinaryOpProgram(ELU_DER,dy.shape,y.shape);return this.compileAndRun(program,[dy,y])},MathBackendWebGL.prototype.selu=function(x){var program=new UnaryOpProgram(x.shape,SELU);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.int=function(x){var program=new UnaryOpProgram(x.shape,TO_INT);return this.compileAndRun(program,[x],"int32")},MathBackendWebGL.prototype.clip=function(x,min,max){var program,customSetup=(program=env().getBool("WEBGL_PACK_CLIP")?new ClipPackedProgram(x.shape):new ClipProgram(x.shape)).getCustomSetupFunc(min,max);return this.compileAndRun(program,[x],null,customSetup)},MathBackendWebGL.prototype.abs=function(x){if(this.shouldExecuteOnCPU([x]))return this.cpuBackend.abs(x);if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,ABS,x.dtype);var program=new UnaryOpProgram(x.shape,ABS);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.complexAbs=function(x){var xData=this.texData.get(x.dataId),program=new ComplexAbsProgram(x.shape),inputs=[this.makeComplexComponentTensorInfo(x,xData.complexTensors.real),this.makeComplexComponentTensorInfo(x,xData.complexTensors.imag)];return this.compileAndRun(program,inputs)},MathBackendWebGL.prototype.sigmoid=function(x){var program=new UnaryOpProgram(x.shape,SIGMOID);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.softplus=function(x){var program=new UnaryOpProgram(x.shape,SOFTPLUS);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.sin=function(x){var program=new UnaryOpProgram(x.shape,SIN);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.cos=function(x){var program=new UnaryOpProgram(x.shape,COS);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.tan=function(x){var program=new UnaryOpProgram(x.shape,TAN);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.asin=function(x){var program=new UnaryOpProgram(x.shape,ASIN);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.acos=function(x){var program=new UnaryOpProgram(x.shape,ACOS);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.atan=function(x){var program=new UnaryOpProgram(x.shape,ATAN);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.atan2=function(a,b){var program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(ATAN2$1,a.shape,b.shape):new BinaryOpProgram(ATAN2,a.shape,b.shape);return this.compileAndRun(program,[a,b])},MathBackendWebGL.prototype.sinh=function(x){var program=new UnaryOpProgram(x.shape,SINH);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.cosh=function(x){var program=new UnaryOpProgram(x.shape,COSH);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.tanh=function(x){var program=new UnaryOpProgram(x.shape,TANH);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.asinh=function(x){var program=new UnaryOpProgram(x.shape,ASINH);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.acosh=function(x){var program=new UnaryOpProgram(x.shape,ACOSH);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.atanh=function(x){var program=new UnaryOpProgram(x.shape,ATANH);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.erf=function(x){var program=new UnaryOpProgram(x.shape,ERF);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.step=function(x,alpha){var program=new UnaryOpProgram(x.shape,STEP(alpha));return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.conv2dByMatMul=function(x,filter,convInfo,bias,activation,preluActivationWeights){var xShape=x.shape,xTexData=this.texData.get(x.dataId),sharedMatMulDim=convInfo.inChannels,outerShapeX=xShape[0]*xShape[1]*xShape[2],outerShapeFilter=convInfo.outChannels,isChannelsLast="channelsLast"===convInfo.dataFormat,transposeA=!1,transposeB=!1,batchMatMulWillBeUnpacked=(1===outerShapeX||1===outerShapeFilter)&&sharedMatMulDim>1e3,reshapeWillBeExpensive=xShape[2]%2!=0&&!!xTexData.isPacked;if(batchMatMulWillBeUnpacked||!env().getBool("WEBGL_LAZILY_UNPACK")||!env().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!reshapeWillBeExpensive){var targetShape_1=isChannelsLast?xShape[0]*xShape[1]*xShape[2]:xShape[0]*xShape[2]*xShape[3],xReshaped_1=this.reshape(x,[1,targetShape_1,convInfo.inChannels]),filterReshaped_1=this.reshape(filter,[1,convInfo.inChannels,convInfo.outChannels]);return this.reshape(this.fusedBatchMatMul({a:xReshaped_1,b:filterReshaped_1,transposeA:!1,transposeB:!1,bias:bias,activation:activation,preluActivationWeights:preluActivationWeights}),convInfo.outShape)}var targetShape=isChannelsLast?xShape[0]*xShape[1]*(xShape[2]+1):xShape[0]*xShape[2]*(xShape[3]+1),xReshaped={dataId:x.dataId,shape:[1,targetShape,convInfo.inChannels],dtype:x.dtype},originalXTexDataShape=xTexData.shape;xTexData.shape=xTexData.shape.slice(),xTexData.shape[xTexData.shape.length-2]++,assert(isReshapeFree(xTexData.shape,xReshaped.shape),function(){return"packed reshape "+xTexData.shape+" to "+xReshaped.shape+" isn't free"});var filterReshaped=this.reshape(filter,[1,convInfo.inChannels,convInfo.outChannels]),pointwiseConv=this.fusedBatchMatMul({a:xReshaped,b:filterReshaped,transposeA:!1,transposeB:!1,bias:bias,activation:activation,preluActivationWeights:preluActivationWeights}),pointwiseConvTexData=this.texData.get(pointwiseConv.dataId);return assert(pointwiseConvTexData.isPacked,function(){return"batchMatMul result is expected to be packed"}),xTexData.shape=originalXTexDataShape,pointwiseConvTexData.shape=convInfo.outShape,ENGINE.makeTensorFromDataId(pointwiseConv.dataId,convInfo.outShape,pointwiseConv.dtype)},MathBackendWebGL.prototype.conv2dWithIm2Row=function(x,filter,convInfo,bias,activation,preluActivationWeights){var filterWidth=convInfo.filterWidth,filterHeight=convInfo.filterHeight,inChannels=convInfo.inChannels,outWidth=convInfo.outWidth,outHeight=convInfo.outHeight,dataFormat,isChannelsLast="channelsLast"===convInfo.dataFormat,sharedDim=filterWidth*filterHeight*inChannels,numCols=outHeight*outWidth,x2ColShape=[sharedDim,numCols],transposeA=!0,transposeB=!1,xSqueezed=x.squeeze([0]),w2Row=filter.reshape([1,sharedDim,-1]),im2ColProgram=new Im2ColPackedProgram(x2ColShape,xSqueezed.shape,convInfo),im2Col=this.compileAndRun(im2ColProgram,[xSqueezed]).reshape([1,x2ColShape[0],x2ColShape[1]]),hasBias=null!=bias,hasPreluActivationWeights=null!=preluActivationWeights,fusedActivation=activation?mapActivationToShaderProgram(activation,!0):null,matmulProgram=new MatMulPackedProgram(im2Col.shape,[1,numCols,convInfo.outChannels],!0,!1,hasBias,fusedActivation,hasPreluActivationWeights),inputs=[im2Col,w2Row];bias&&inputs.push(bias),hasPreluActivationWeights&&inputs.push(preluActivationWeights);var product=this.compileAndRun(matmulProgram,inputs);return isChannelsLast?product.reshape([1,outHeight,outWidth,convInfo.outChannels]):product.reshape([1,convInfo.outChannels,outHeight,outWidth])},MathBackendWebGL.prototype.fusedConv2d=function(_a){var input=_a.input,filter=_a.filter,convInfo=_a.convInfo,bias=_a.bias,activation=_a.activation,preluActivationWeights=_a.preluActivationWeights;if(1===convInfo.filterHeight&&1===convInfo.filterWidth&&1===convInfo.dilationHeight&&1===convInfo.dilationWidth&&1===convInfo.strideHeight&&1===convInfo.strideWidth&&("SAME"===convInfo.padInfo.type||"VALID"===convInfo.padInfo.type))return this.conv2dByMatMul(input,filter,convInfo,bias,activation,preluActivationWeights);if(env().getBool("WEBGL_CONV_IM2COL")&&1===input.shape[0])return this.conv2dWithIm2Row(input,filter,convInfo,bias,activation,preluActivationWeights);var hasBias=null!=bias,hasPreluActivationWeights=null!=preluActivationWeights,fusedActivation=activation?mapActivationToShaderProgram(activation,!1):null,program=new Conv2DProgram(convInfo,hasBias,fusedActivation,hasPreluActivationWeights),inputs=[input,filter];return bias&&inputs.push(bias),preluActivationWeights&&inputs.push(preluActivationWeights),this.compileAndRun(program,inputs)},MathBackendWebGL.prototype.conv2d=function(x,filter,convInfo){if(1===convInfo.filterHeight&&1===convInfo.filterWidth&&1===convInfo.dilationHeight&&1===convInfo.dilationWidth&&1===convInfo.strideHeight&&1===convInfo.strideWidth&&("SAME"===convInfo.padInfo.type||"VALID"===convInfo.padInfo.type))return this.conv2dByMatMul(x,filter,convInfo);if(env().getBool("WEBGL_CONV_IM2COL")&&1===x.shape[0])return this.conv2dWithIm2Row(x,filter,convInfo);var program=new Conv2DProgram(convInfo);return this.compileAndRun(program,[x,filter])},MathBackendWebGL.prototype.conv2dDerInput=function(dy,filter,convInfo){var program=new Conv2DDerInputProgram(convInfo);return this.compileAndRun(program,[dy,filter])},MathBackendWebGL.prototype.conv2dDerFilter=function(x,dy,convInfo){var program=new Conv2DDerFilterProgram(convInfo);return this.compileAndRun(program,[x,dy])},MathBackendWebGL.prototype.fusedDepthwiseConv2D=function(_a){var input=_a.input,filter=_a.filter,convInfo=_a.convInfo,bias=_a.bias,activation=_a.activation,preluActivationWeights=_a.preluActivationWeights,shouldPackDepthwiseConv=env().getBool("WEBGL_PACK_DEPTHWISECONV")&&convInfo.strideWidth<=2&&convInfo.outChannels/convInfo.inChannels==1,fusedActivation=activation?mapActivationToShaderProgram(activation,shouldPackDepthwiseConv):null,inputs=[input,filter],hasBias=null!=bias,hasPreluActivationWeights=null!=preluActivationWeights,program;return hasBias&&inputs.push(bias),hasPreluActivationWeights&&inputs.push(preluActivationWeights),shouldPackDepthwiseConv?(program=new DepthwiseConvPacked2DProgram(convInfo,hasBias,fusedActivation,hasPreluActivationWeights),this.compileAndRun(program,inputs)):(program=new DepthwiseConv2DProgram(convInfo,hasBias,fusedActivation,hasPreluActivationWeights),this.compileAndRun(program,inputs))},MathBackendWebGL.prototype.depthwiseConv2D=function(x,filter,convInfo){var program;return env().getBool("WEBGL_PACK_DEPTHWISECONV")&&convInfo.strideWidth<=2&&convInfo.outChannels/convInfo.inChannels==1?(program=new DepthwiseConvPacked2DProgram(convInfo),this.compileAndRun(program,[x,filter])):(program=new DepthwiseConv2DProgram(convInfo),this.compileAndRun(program,[x,filter]))},MathBackendWebGL.prototype.depthwiseConv2DDerInput=function(dy,filter,convInfo){var program=new DepthwiseConv2DDerInputProgram(convInfo);return this.compileAndRun(program,[dy,filter])},MathBackendWebGL.prototype.depthwiseConv2DDerFilter=function(x,dy,convInfo){var program=new DepthwiseConv2DDerFilterProgram(convInfo);return this.compileAndRun(program,[x,dy])},MathBackendWebGL.prototype.conv3d=function(x,filter,convInfo){var program=new Conv3DProgram(convInfo);return this.compileAndRun(program,[x,filter])},MathBackendWebGL.prototype.conv3dDerInput=function(dy,filter,convInfo){var program=new Conv3DDerInputProgram(convInfo);return this.compileAndRun(program,[dy,filter])},MathBackendWebGL.prototype.conv3dDerFilter=function(x,dy,convInfo){var program=new Conv3DDerFilterProgram(convInfo);return this.compileAndRun(program,[x,dy])},MathBackendWebGL.prototype.maxPool=function(x,convInfo){var program=new Pool2DProgram(convInfo,"max",!1);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.avgPool=function(x,convInfo){var program=new Pool2DProgram(convInfo,"avg",!1);return this.compileAndRun(program,[x],"float32")},MathBackendWebGL.prototype.maxPoolBackprop=function(dy,x,y,convInfo){var getPositions=!0,maxPoolPositionsProgram=new Pool2DProgram(convInfo,"max",!0),maxPoolPositions=this.compileAndRun(maxPoolPositionsProgram,[x]),maxPoolBackPropProgram=new MaxPool2DBackpropProgram(convInfo),result=this.compileAndRun(maxPoolBackPropProgram,[dy,maxPoolPositions],x.dtype);return maxPoolPositions.dispose(),result},MathBackendWebGL.prototype.avgPoolBackprop=function(dy,x,convInfo){var avgPoolBackpropProgram=new AvgPool2DBackpropProgram(convInfo);return this.compileAndRun(avgPoolBackpropProgram,[dy],x.dtype)},MathBackendWebGL.prototype.cast=function(x,dtype){return castTensor(x,dtype,this)},MathBackendWebGL.prototype.unstack=function(x,axis){for(var num=x.shape[axis],outShape=new Array(x.rank-1),outIndex=0,i=0;i<x.rank;i++)i!==axis&&(outShape[outIndex++]=x.shape[i]);var begin=new Array(x.rank).fill(0),size=x.shape.slice();size[axis]=1;for(var res=new Array(num),i=0;i<res.length;i++)begin[axis]=i,res[i]=this.slice(x,begin,size).reshape(outShape);return res},MathBackendWebGL.prototype.avgPool3d=function(x,convInfo){var program=new Pool3DProgram(convInfo,"avg",!1);return this.compileAndRun(program,[x],"float32")},MathBackendWebGL.prototype.avgPool3dBackprop=function(dy,x,convInfo){var avgPool3dBackpropProgram=new AvgPool3DBackpropProgram(convInfo);return this.compileAndRun(avgPool3dBackpropProgram,[dy],x.dtype)},MathBackendWebGL.prototype.maxPool3d=function(x,convInfo){var program=new Pool3DProgram(convInfo,"max",!1);return this.compileAndRun(program,[x],"float32")},MathBackendWebGL.prototype.maxPool3dBackprop=function(dy,x,y,convInfo){var getPositions=!0,maxPool3dPositionsProgram=new Pool3DProgram(convInfo,"max",!0),maxPool3dPositions=this.compileAndRun(maxPool3dPositionsProgram,[x]),maxPool3dBackPropProgram=new MaxPool3DBackpropProgram(convInfo),result=this.compileAndRun(maxPool3dBackPropProgram,[dy,maxPool3dPositions],x.dtype);return maxPool3dPositions.dispose(),result},MathBackendWebGL.prototype.reshape=function(x,shape){var texData=this.texData.get(x.dataId);if(texData.isPacked&&!isReshapeFree(x.shape,shape)&&(null===texData.texture||!isReshapeFree(texData.shape,shape))){var info=this.packedReshape(x,shape);return ENGINE.makeTensorFromDataId(info.dataId,info.shape,info.dtype)}return reshapeTensor(x,shape)},MathBackendWebGL.prototype.resizeBilinear=function(x,newHeight,newWidth,alignCorners){var program=env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ResizeBilinearPackedProgram(x.shape,newHeight,newWidth,alignCorners):new ResizeBilinearProgram(x.shape,newHeight,newWidth,alignCorners);return this.compileAndRun(program,[x],"float32")},MathBackendWebGL.prototype.resizeBilinearBackprop=function(dy,x,alignCorners){var program=new ResizeBilinearBackpropProgram(dy,x,alignCorners);return this.compileAndRun(program,[dy])},MathBackendWebGL.prototype.resizeNearestNeighbor=function(x,newHeight,newWidth,alignCorners){var program=new ResizeNearestNeighborProgram(x.shape,newHeight,newWidth,alignCorners);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.resizeNearestNeighborBackprop=function(dy,x,alignCorners){var program=new ResizeNearestNeigborBackpropProgram(dy,x,alignCorners);return this.compileAndRun(program,[dy])},MathBackendWebGL.prototype.multinomial=function(logits,normalized,numSamples,seed){var probs=normalized?logits:softmax(logits),batchSize=probs.shape[0],numOutcomes=probs.shape[1],program=new MultinomialProgram(batchSize,numOutcomes,numSamples),customSetup=program.getCustomSetupFunc(seed);return this.compileAndRun(program,[probs],"int32",customSetup)},MathBackendWebGL.prototype.oneHot=function(indices,depth,onValue,offValue){var program=new OneHotProgram(indices.size,depth,onValue,offValue);return this.compileAndRun(program,[indices])},MathBackendWebGL.prototype.diag=function(x){var program=new DiagProgram(x.size);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.nonMaxSuppression=function(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){var boxesVals,scoresVals;return warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"),nonMaxSuppressionV3(boxes.dataSync(),scores.dataSync(),maxOutputSize,iouThreshold,scoreThreshold)},MathBackendWebGL.prototype.cropAndResize=function(image,boxes,boxIndex,cropSize,method,extrapolationValue){var program=new CropAndResizeProgram(image.shape,boxes.shape,cropSize,method,extrapolationValue);return this.compileAndRun(program,[image,boxes,boxIndex],"float32")},MathBackendWebGL.prototype.depthToSpace=function(x,blockSize,dataFormat){assert(blockSize>1,function(){return"blockSize should be > 1 for depthToSpace, but was: "+blockSize});var batchSize=x.shape[0],inputHeight="NHWC"===dataFormat?x.shape[1]:x.shape[2],inputWidth="NHWC"===dataFormat?x.shape[2]:x.shape[3],inputDepth="NHWC"===dataFormat?x.shape[3]:x.shape[1],outputHeight=inputHeight*blockSize,outputWidth=inputWidth*blockSize,outputDepth=inputDepth/(blockSize*blockSize),outputShape,program=new DepthToSpaceProgram("NHWC"===dataFormat?[batchSize,outputHeight,outputWidth,outputDepth]:[batchSize,outputDepth,outputHeight,outputWidth],blockSize,dataFormat);return this.compileAndRun(program,[x])},MathBackendWebGL.prototype.split=function(x,sizeSplits,axis){return split$1(x,sizeSplits,axis)},MathBackendWebGL.prototype.scatterND=function(indices,updates,shape){var _a=calculateShapes(updates,indices,shape),sliceRank=_a.sliceRank,numUpdates=_a.numUpdates,sliceSize=_a.sliceSize,strides=_a.strides,outputSize=_a.outputSize,flattenShape=[outputSize/sliceSize,sliceSize],flattenIndices=indices.reshape([numUpdates,sliceRank]),flattenX=updates.reshape([numUpdates,sliceSize]);if(0===outputSize)return reshapeTensor(tensor([]),shape);var defaultValue=scalar(0),program=new ScatterProgram(numUpdates,sliceRank,flattenIndices.rank,flattenX.rank,strides,flattenShape),res;return this.compileAndRun(program,[flattenX,flattenIndices,defaultValue]).reshape(shape)},MathBackendWebGL.prototype.sparseToDense=function(sparseIndices,sparseValues,outputShape,defaultValue){var _a=calculateShapes(sparseValues,sparseIndices,outputShape),sliceRank=_a.sliceRank,numUpdates=_a.numUpdates,strides=_a.strides,outputSize=_a.outputSize,sumDupeIndices=!1,program=new ScatterProgram(numUpdates,sliceRank,sparseIndices.rank,sparseValues.rank,strides,[outputSize,1],!1),res;return this.compileAndRun(program,[sparseValues,sparseIndices,defaultValue]).reshape(outputShape)},MathBackendWebGL.prototype.fft=function(x){var inverse=!1;return this.fftImpl(x,!1)},MathBackendWebGL.prototype.ifft=function(x){var inverse=!0;return this.fftImpl(x,!0)},MathBackendWebGL.prototype.fftImpl=function(x,inverse){var xData=this.texData.get(x.dataId),realProgram=new FFTProgram(COMPLEX_FFT_REAL,x.shape,inverse),imagProgram=new FFTProgram(COMPLEX_FFT_IMAG,x.shape,inverse),inputs=[this.makeComplexComponentTensorInfo(x,xData.complexTensors.real),this.makeComplexComponentTensorInfo(x,xData.complexTensors.imag)],real=this.compileAndRun(realProgram,inputs),imag=this.compileAndRun(imagProgram,inputs),complex=this.complex(real,imag).as2D(x.shape[0],x.shape[1]);return real.dispose(),imag.dispose(),complex},MathBackendWebGL.prototype.gatherND=function(x,indices){var indicesShape=indices.shape,sliceRank=indicesShape[indicesShape.length-1],_a=prepareAndValidate(x,indices),resultShape=_a[0],numSlices=_a[1],sliceSize=_a[2],strides=_a[3],flattenIndices=indices.reshape([numSlices,sliceRank]),flattenX=x.reshape([x.size/sliceSize,sliceSize]),program=new GatherNDProgram(sliceRank,strides,[numSlices,sliceSize]),res;return this.compileAndRun(program,[flattenX,flattenIndices]).reshape(resultShape)},MathBackendWebGL.prototype.fill=function(shape,value,dtype){if("string"===(dtype=dtype||inferDtype(value))){var values=getArrayFromDType(dtype,sizeFromShape(shape));return values.fill(value),ENGINE.makeTensor(values,shape,dtype,this)}var program=new FillProgram(shape,value),customSetup=program.getCustomSetupFunc(value);return this.compileAndRun(program,[],dtype,customSetup)},MathBackendWebGL.prototype.onesLike=function(x){if("string"===x.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(x.shape,1,x.dtype)},MathBackendWebGL.prototype.zerosLike=function(x){return this.fill(x.shape,"string"===x.dtype?"":0,x.dtype)},MathBackendWebGL.prototype.linspace=function(start,stop,num){return linspaceImpl(start,stop,num)},MathBackendWebGL.prototype.makeTensorInfo=function(shape,dtype){var dataId=this.write(null,shape,dtype);return this.texData.get(dataId).usage=null,{dataId:dataId,shape:shape,dtype:dtype}},MathBackendWebGL.prototype.makeOutput=function(shape,dtype){var dataId=this.makeTensorInfo(shape,dtype).dataId;return ENGINE.makeTensorFromDataId(dataId,shape,dtype,this)},MathBackendWebGL.prototype.unpackTensor=function(input){var program=new UnpackProgram(input.shape);return this.runWebGLProgram(program,[input],input.dtype)},MathBackendWebGL.prototype.packTensor=function(input){var program=new PackProgram(input.shape),preventEagerUnpackingOutput=!0;return this.runWebGLProgram(program,[input],input.dtype,null,!0)},MathBackendWebGL.prototype.packedReshape=function(input,afterShape){var input3DShape=[getBatchDim(input.shape)].concat(getRowsCols(input.shape)),input3D={dtype:input.dtype,shape:input3DShape,dataId:input.dataId},afterShapeAs3D=[getBatchDim(afterShape)].concat(getRowsCols(afterShape)),program=new ReshapePackedProgram(afterShapeAs3D,input3DShape),preventEagerUnpackingOfOutput=!0,output=this.runWebGLProgram(program,[input3D],input.dtype,null,!0);return{dataId:output.dataId,shape:afterShape,dtype:output.dtype}},MathBackendWebGL.prototype.decode=function(dataId){var texData=this.texData.get(dataId),isPacked=texData.isPacked,shape=texData.shape,dtype=texData.dtype,shapeAs3D=getShapeAs3D(shape),program;program=isPacked?new DecodeMatrixPackedProgram(shapeAs3D):new DecodeMatrixProgram(shapeAs3D);var preventEagerUnpackingOfOutput=!0,out;return{dtype:dtype,shape:shape,dataId:this.runWebGLProgram(program,[{shape:shapeAs3D,dtype:dtype,dataId:dataId}],dtype,null,!0).dataId}},MathBackendWebGL.prototype.runWebGLProgram=function(program,inputs,outputDtype,customSetup,preventEagerUnpackingOfOutput){var _this=this;void 0===preventEagerUnpackingOfOutput&&(preventEagerUnpackingOfOutput=!1);var output=this.makeTensorInfo(program.outputShape,outputDtype),outData=this.texData.get(output.dataId);if(program.packedOutput&&(outData.isPacked=!0),program.outPackingScheme===PackingScheme.DENSE){var texelShape=getDenseTexShape(program.outputShape);outData.texShape=texelShape.map(function(d){return 2*d})}if(null!=program.outTexUsage&&(outData.usage=program.outTexUsage),0===sizeFromShape(output.shape))return outData.values=getTypedArrayFromDType(output.dtype,0),output;var dataToDispose=[],inputsData=inputs.map(function(input){if("complex64"===input.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var texData=_this.texData.get(input.dataId);if(null==texData.texture){if(!program.packedInputs&&sizeFromShape(input.shape)<=env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:input.shape,texData:null,isUniform:!0,uniformValues:texData.values};program.packedInputs&&(texData.isPacked=!0,texData.shape=input.shape)}else if(!!texData.isPacked!=!!program.packedInputs)input=texData.isPacked?_this.unpackTensor(input):_this.packTensor(input),dataToDispose.push(input),texData=_this.texData.get(input.dataId);else if(texData.isPacked&&!isReshapeFree(texData.shape,input.shape)){var savedInput=input,targetShape=input.shape;input.shape=texData.shape,input=_this.packedReshape(input,targetShape),dataToDispose.push(input),texData=_this.texData.get(input.dataId),savedInput.shape=targetShape}return _this.uploadToGPU(input.dataId),{shape:input.shape,texData:texData,isUniform:!1}});this.uploadToGPU(output.dataId);var outputData={shape:output.shape,texData:outData,isUniform:!1},key=makeShaderKey(program,inputsData,outputData),binary=this.getAndSaveBinary(key,function(){return compileProgram(_this.gpgpu,program,inputsData,outputData)}),shouldTimeProgram=null!=this.activeTimers,query;if(shouldTimeProgram&&(query=this.startTimer()),runProgram(this.gpgpu,binary,inputsData,outputData,customSetup),dataToDispose.forEach(function(info){return _this.disposeData(info.dataId)}),shouldTimeProgram&&(query=this.endTimer(query),this.activeTimers.push({name:program.constructor.name,query:this.getQueryTime(query)})),!env().getBool("WEBGL_LAZILY_UNPACK")&&outData.isPacked&&!1===preventEagerUnpackingOfOutput){var unpacked=this.unpackTensor(output);return this.disposeData(output.dataId),unpacked}return output},MathBackendWebGL.prototype.compileAndRun=function(program,inputs,outputDtype,customSetup,preventEagerUnpackingOfOutput){void 0===preventEagerUnpackingOfOutput&&(preventEagerUnpackingOfOutput=!1),outputDtype=outputDtype||inputs[0].dtype;var outInfo=this.runWebGLProgram(program,inputs,outputDtype,customSetup,preventEagerUnpackingOfOutput);return ENGINE.makeTensorFromDataId(outInfo.dataId,outInfo.shape,outInfo.dtype)},MathBackendWebGL.prototype.getAndSaveBinary=function(key,getBinary){return key in this.binaryCache||(this.binaryCache[key]=getBinary()),this.binaryCache[key]},MathBackendWebGL.prototype.getTextureManager=function(){return this.textureManager},MathBackendWebGL.prototype.dispose=function(){var _this=this;if(!this.disposed){var allKeys;if(!env().getBool("IS_TEST"))Object.keys(this.binaryCache).forEach(function(key){_this.gpgpu.deleteProgram(_this.binaryCache[key].webGLProgram),delete _this.binaryCache[key]});this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}},MathBackendWebGL.prototype.floatPrecision=function(){var _this=this;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=tidy(function(){if(!env().get("WEBGL_RENDER_FLOAT32_ENABLED")){var debugFlag=env().getBool("DEBUG");env().set("DEBUG",!1);var underflowCheckValue=_this.abs(scalar(1e-8)).dataSync()[0];if(env().set("DEBUG",debugFlag),underflowCheckValue>0)return 32}return 16})),this.floatPrecisionValue},MathBackendWebGL.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},MathBackendWebGL.prototype.uploadToGPU=function(dataId){var _a,texData=this.texData.get(dataId),shape=texData.shape,dtype=texData.dtype,values=texData.values,texture=texData.texture,usage=texData.usage,isPacked=texData.isPacked;if(null==texture){var shouldTimeProgram=null!=this.activeTimers,start;shouldTimeProgram&&(start=now());var texShape=texData.texShape;if(null==texShape&&(texShape=getTextureShapeFromLogicalShape(shape,isPacked),texData.texShape=texShape),null!=values){var shapeAs3D=getShapeAs3D(shape),program=void 0,width=texShape[1],height=texShape[0],isByteArray=values instanceof Uint8Array;isPacked?(width=(_a=getPackedMatrixTextureShapeWidthHeight(texShape[0],texShape[1]))[0],height=_a[1],program=new EncodeMatrixPackedProgram(shapeAs3D,[height,width],isByteArray)):program=new EncodeMatrixProgram(shapeAs3D,[height,width],isByteArray);var tempDenseInputHandle=this.makeTensorInfo([height,width],dtype);this.texData.get(tempDenseInputHandle.dataId).usage=isByteArray?TextureUsage.PIXELS:TextureUsage.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId),width,height,values);var preventEagerUnpacking=!0,encodedOutputTarget=this.runWebGLProgram(program,[tempDenseInputHandle],dtype,null,!0),outputTexData=this.texData.get(encodedOutputTarget.dataId);texData.texture=outputTexData.texture,texData.texShape=outputTexData.texShape,texData.isPacked=outputTexData.isPacked,texData.usage=outputTexData.usage,this.disposeData(tempDenseInputHandle.dataId),this.texData.delete(encodedOutputTarget.dataId),texData.values=null,shouldTimeProgram&&(this.uploadWaitMs+=now()-start)}else{var newTexture=this.acquireTexture(texShape,usage,dtype,isPacked);texData.texture=newTexture}}},MathBackendWebGL.prototype.convertAndCacheOnCPU=function(dataId,float32Values){var texData=this.texData.get(dataId),dtype=texData.dtype;return this.releaseGPUData(dataId),null!=float32Values&&(texData.values=float32ToTypedArray(float32Values,dtype)),texData.values},MathBackendWebGL.prototype.acquireTexture=function(texShape,texType,dtype,isPacked){if(this.numBytesInGPU+=this.computeBytes(texShape,dtype),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){var mb=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+mb+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(texShape,texType,isPacked)},MathBackendWebGL.prototype.computeBytes=function(shape,dtype){return shape[0]*shape[1]*bytesPerElement(dtype)},MathBackendWebGL}(KernelBackend);function float32ToTypedArray(a,dtype){if("float32"===dtype||"complex64"===dtype)return a;if("int32"===dtype||"bool"===dtype){for(var result="int32"===dtype?new Int32Array(a.length):new Uint8Array(a.length),i=0;i<result.length;++i)result[i]=Math.round(a[i]);return result}throw new Error("Unknown dtype "+dtype)}isBrowser()&&ENGINE.registerBackend("webgl",function(){return new MathBackendWebGL},2);var commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function createCommonjsModule(fn,module){return fn(module={exports:{}},module.exports),module.exports}var alea=createCommonjsModule(function(module){!function(global,module,define){function Alea(seed){var me=this,mash=Mash();me.next=function(){var t=2091639*me.s0+2.3283064365386963e-10*me.c;return me.s0=me.s1,me.s1=me.s2,me.s2=t-(me.c=0|t)},me.c=1,me.s0=mash(" "),me.s1=mash(" "),me.s2=mash(" "),me.s0-=mash(seed),me.s0<0&&(me.s0+=1),me.s1-=mash(seed),me.s1<0&&(me.s1+=1),me.s2-=mash(seed),me.s2<0&&(me.s2+=1),mash=null}function copy(f,t){return t.c=f.c,t.s0=f.s0,t.s1=f.s1,t.s2=f.s2,t}function impl(seed,opts){var xg=new Alea(seed),state=opts&&opts.state,prng=xg.next;return prng.int32=function(){return 4294967296*xg.next()|0},prng.double=function(){return prng()+1.1102230246251565e-16*(2097152*prng()|0)},prng.quick=prng,state&&("object"==typeof state&&copy(state,xg),prng.state=function(){return copy(xg,{})}),prng}function Mash(){var n=4022871197,mash;return function(data){data=data.toString();for(var i=0;i<data.length;i++){var h=.02519603282416938*(n+=data.charCodeAt(i));h-=n=h>>>0,n=(h*=n)>>>0,n+=4294967296*(h-=n)}return 2.3283064365386963e-10*(n>>>0)}}module&&module.exports?module.exports=impl:define&&define.amd?define(function(){return impl}):this.alea=impl}(commonjsGlobal,module,!1)}),xor128=createCommonjsModule(function(module){!function(global,module,define){function XorGen(seed){var me=this,strseed="";me.x=0,me.y=0,me.z=0,me.w=0,me.next=function(){var t=me.x^me.x<<11;return me.x=me.y,me.y=me.z,me.z=me.w,me.w^=me.w>>>19^t^t>>>8},seed===(0|seed)?me.x=seed:strseed+=seed;for(var k=0;k<strseed.length+64;k++)me.x^=0|strseed.charCodeAt(k),me.next()}function copy(f,t){return t.x=f.x,t.y=f.y,t.z=f.z,t.w=f.w,t}function impl(seed,opts){var xg=new XorGen(seed),state=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do{var top,bot,result=((xg.next()>>>11)+(xg.next()>>>0)/4294967296)/(1<<21)}while(0===result);return result},prng.int32=xg.next,prng.quick=prng,state&&("object"==typeof state&&copy(state,xg),prng.state=function(){return copy(xg,{})}),prng}module&&module.exports?module.exports=impl:define&&define.amd?define(function(){return impl}):this.xor128=impl}(commonjsGlobal,module,!1)}),xorwow=createCommonjsModule(function(module){!function(global,module,define){function XorGen(seed){var me=this,strseed="";me.next=function(){var t=me.x^me.x>>>2;return me.x=me.y,me.y=me.z,me.z=me.w,me.w=me.v,(me.d=me.d+362437|0)+(me.v=me.v^me.v<<4^t^t<<1)|0},me.x=0,me.y=0,me.z=0,me.w=0,me.v=0,seed===(0|seed)?me.x=seed:strseed+=seed;for(var k=0;k<strseed.length+64;k++)me.x^=0|strseed.charCodeAt(k),k==strseed.length&&(me.d=me.x<<10^me.x>>>4),me.next()}function copy(f,t){return t.x=f.x,t.y=f.y,t.z=f.z,t.w=f.w,t.v=f.v,t.d=f.d,t}function impl(seed,opts){var xg=new XorGen(seed),state=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do{var top,bot,result=((xg.next()>>>11)+(xg.next()>>>0)/4294967296)/(1<<21)}while(0===result);return result},prng.int32=xg.next,prng.quick=prng,state&&("object"==typeof state&&copy(state,xg),prng.state=function(){return copy(xg,{})}),prng}module&&module.exports?module.exports=impl:define&&define.amd?define(function(){return impl}):this.xorwow=impl}(commonjsGlobal,module,!1)}),xorshift7=createCommonjsModule(function(module){!function(global,module,define){function XorGen(seed){var me=this;function init(me,seed){var j,w,X=[];if(seed===(0|seed))w=X[0]=seed;else for(seed=""+seed,j=0;j<seed.length;++j)X[7&j]=X[7&j]<<15^seed.charCodeAt(j)+X[j+1&7]<<13;for(;X.length<8;)X.push(0);for(j=0;j<8&&0===X[j];++j);for(w=8==j?X[7]=-1:X[j],me.x=X,me.i=0,j=256;j>0;--j)me.next()}me.next=function(){var X=me.x,i=me.i,t,v;return t=X[i],v=(t^=t>>>7)^t<<24,v^=(t=X[i+1&7])^t>>>10,v^=(t=X[i+3&7])^t>>>3,v^=(t=X[i+4&7])^t<<7,t=X[i+7&7],v^=(t^=t<<13)^t<<9,X[i]=v,me.i=i+1&7,v},init(me,seed)}function copy(f,t){return t.x=f.x.slice(),t.i=f.i,t}function impl(seed,opts){null==seed&&(seed=+new Date);var xg=new XorGen(seed),state=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do{var top,bot,result=((xg.next()>>>11)+(xg.next()>>>0)/4294967296)/(1<<21)}while(0===result);return result},prng.int32=xg.next,prng.quick=prng,state&&(state.x&&copy(state,xg),prng.state=function(){return copy(xg,{})}),prng}module&&module.exports?module.exports=impl:define&&define.amd?define(function(){return impl}):this.xorshift7=impl}(commonjsGlobal,module,!1)}),xor4096=createCommonjsModule(function(module){!function(global,module,define){function XorGen(seed){var me=this;function init(me,seed){var t,v,i,j,w,X=[],limit=128;for(seed===(0|seed)?(v=seed,seed=null):(seed+="\0",v=0,limit=Math.max(limit,seed.length)),i=0,j=-32;j<limit;++j)seed&&(v^=seed.charCodeAt((j+32)%seed.length)),0===j&&(w=v),v^=v<<10,v^=v>>>15,v^=v<<4,v^=v>>>13,j>=0&&(w=w+1640531527|0,i=0==(t=X[127&j]^=v+w)?i+1:0);for(i>=128&&(X[127&(seed&&seed.length||0)]=-1),i=127,j=512;j>0;--j)v=X[i+34&127],t=X[i=i+1&127],v^=v<<13,t^=t<<17,v^=v>>>15,t^=t>>>12,X[i]=v^t;me.w=w,me.X=X,me.i=i}me.next=function(){var w=me.w,X=me.X,i=me.i,t,v;return me.w=w=w+1640531527|0,v=X[i+34&127],t=X[i=i+1&127],v^=v<<13,t^=t<<17,v^=v>>>15,t^=t>>>12,v=X[i]=v^t,me.i=i,v+(w^w>>>16)|0},init(me,seed)}function copy(f,t){return t.i=f.i,t.w=f.w,t.X=f.X.slice(),t}function impl(seed,opts){null==seed&&(seed=+new Date);var xg=new XorGen(seed),state=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do{var top,bot,result=((xg.next()>>>11)+(xg.next()>>>0)/4294967296)/(1<<21)}while(0===result);return result},prng.int32=xg.next,prng.quick=prng,state&&(state.X&&copy(state,xg),prng.state=function(){return copy(xg,{})}),prng}module&&module.exports?module.exports=impl:define&&define.amd?define(function(){return impl}):this.xor4096=impl}(commonjsGlobal,module,!1)}),tychei=createCommonjsModule(function(module){!function(global,module,define){function XorGen(seed){var me=this,strseed="";me.next=function(){var b=me.b,c=me.c,d=me.d,a=me.a;return b=b<<25^b>>>7^c,c=c-d|0,d=d<<24^d>>>8^a,a=a-b|0,me.b=b=b<<20^b>>>12^c,me.c=c=c-d|0,me.d=d<<16^c>>>16^a,me.a=a-b|0},me.a=0,me.b=0,me.c=-1640531527,me.d=1367130551,seed===Math.floor(seed)?(me.a=seed/4294967296|0,me.b=0|seed):strseed+=seed;for(var k=0;k<strseed.length+20;k++)me.b^=0|strseed.charCodeAt(k),me.next()}function copy(f,t){return t.a=f.a,t.b=f.b,t.c=f.c,t.d=f.d,t}function impl(seed,opts){var xg=new XorGen(seed),state=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do{var top,bot,result=((xg.next()>>>11)+(xg.next()>>>0)/4294967296)/(1<<21)}while(0===result);return result},prng.int32=xg.next,prng.quick=prng,state&&("object"==typeof state&&copy(state,xg),prng.state=function(){return copy(xg,{})}),prng}module&&module.exports?module.exports=impl:define&&define.amd?define(function(){return impl}):this.tychei=impl}(commonjsGlobal,module,!1)}),seedrandom=createCommonjsModule(function(module){!function(pool,math){var global=this,width=256,chunks=6,digits=52,rngname="random",startdenom=math.pow(width,chunks),significance=math.pow(2,52),overflow=2*significance,mask=width-1,nodecrypto;function seedrandom(seed,options,callback){var key=[],shortseed=mixkey(flatten((options=1==options?{entropy:!0}:options||{}).entropy?[seed,tostring(pool)]:null==seed?autoseed():seed,3),key),arc4=new ARC4(key),prng=function(){for(var n=arc4.g(chunks),d=startdenom,x=0;n<significance;)n=(n+x)*width,d*=width,x=arc4.g(1);for(;n>=overflow;)n/=2,d/=2,x>>>=1;return(n+x)/d};return prng.int32=function(){return 0|arc4.g(4)},prng.quick=function(){return arc4.g(4)/4294967296},prng.double=prng,mixkey(tostring(arc4.S),pool),(options.pass||callback||function(prng,seed,is_math_call,state){return state&&(state.S&&copy(state,arc4),prng.state=function(){return copy(arc4,{})}),is_math_call?(math[rngname]=prng,seed):prng})(prng,shortseed,"global"in options?options.global:this==math,options.state)}function ARC4(key){var t,keylen=key.length,me=this,i=0,j=me.i=me.j=0,s=me.S=[];for(keylen||(key=[keylen++]);i<width;)s[i]=i++;for(i=0;i<width;i++)s[i]=s[j=mask&j+key[i%keylen]+(t=s[i])],s[j]=t;(me.g=function(count){for(var t,r=0,i=me.i,j=me.j,s=me.S;count--;)t=s[i=mask&i+1],r=r*width+s[mask&(s[i]=s[j=mask&j+t])+(s[j]=t)];return me.i=i,me.j=j,r})(width)}function copy(f,t){return t.i=f.i,t.j=f.j,t.S=f.S.slice(),t}function flatten(obj,depth){var result=[],typ=typeof obj,prop;if(depth&&"object"==typ)for(prop in obj)try{result.push(flatten(obj[prop],depth-1))}catch(e){}return result.length?result:"string"==typ?obj:obj+"\0"}function mixkey(seed,key){for(var stringseed=seed+"",smear,j=0;j<stringseed.length;)key[mask&j]=mask&(smear^=19*key[mask&j])+stringseed.charCodeAt(j++);return tostring(key)}function autoseed(){try{var out;return nodecrypto&&(out=nodecrypto.randomBytes)?out=out(width):(out=new Uint8Array(width),(global.crypto||global.msCrypto).getRandomValues(out)),tostring(out)}catch(e){var browser=global.navigator,plugins=browser&&browser.plugins;return[+new Date,global,plugins,global.screen,tostring(pool)]}}function tostring(a){return String.fromCharCode.apply(0,a)}if(math["seed"+rngname]=seedrandom,mixkey(math.random(),pool),module.exports){module.exports=seedrandom;try{nodecrypto=require("crypto")}catch(ex){}}}([],Math)});seedrandom.alea=alea,seedrandom.xor128=xor128,seedrandom.xorwow=xorwow,seedrandom.xorshift7=xorshift7,seedrandom.xor4096=xor4096,seedrandom.tychei=tychei;var seedrandom$1,seedrandom_1=seedrandom.alea;function addN_(tensors){assert(Array.isArray(tensors),function(){return"The argument passed to tf.addN() must be a list of tensors"}),assert(tensors.length>=1,function(){return"Must pass at least one tensor to tf.addN(), but got "+tensors.length});var $tensors=tensors.map(function(t,i){return convertToTensor(t,"tensors"+i,"addN")}),firstTensor=$tensors[0];$tensors.forEach(function(t){if(t.dtype!==firstTensor.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),$tensors.forEach(function(t){if(!arraysEqual(t.shape,firstTensor.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});var forward=function(backend,save){return backend.addN($tensors)},inputs=$tensors;return ENGINE.runKernelFunc(forward,inputs,null,"AddN")}var addN=op({addN_:addN_});function warnDeprecation(){deprecationWarn("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon")}function xAs4D(x){var x4D;return x4D=0===x.rank||1===x.rank?x.as4D(1,1,1,x.size):2===x.rank?x.as4D(1,1,x.shape[0],x.shape[1]):3===x.rank?x.as4D(1,x.shape[0],x.shape[1],x.shape[2]):x}function batchNormalization_(x,mean,variance,varianceEpsilon,scale,offset){return void 0===varianceEpsilon&&(varianceEpsilon=.001),warnDeprecation(),batchNorm_(x,mean,variance,offset,scale,varianceEpsilon)}function batchNorm_(x,mean,variance,offset,scale,varianceEpsilon){null==varianceEpsilon&&(varianceEpsilon=.001);var $x=convertToTensor(x,"x","batchNorm"),$mean=convertToTensor(mean,"mean","batchNorm"),$variance=convertToTensor(variance,"variance","batchNorm"),$scale,$offset;null!=scale&&($scale=convertToTensor(scale,"scale","batchNorm")),null!=offset&&($offset=convertToTensor(offset,"offset","batchNorm")),assert($mean.rank===$variance.rank,function(){return"Batch normalization gradient requires mean and variance to have equal ranks."}),assert(null==$offset||$mean.rank===$offset.rank,function(){return"Batch normalization gradient requires mean and offset to have equal ranks."}),assert(null==$scale||$mean.rank===$scale.rank,function(){return"Batch normalization gradient requires mean and scale to have equal ranks."});var forward=function(backend,save){var x4D=xAs4D($x),res=backend.batchNormalization(x4D,as1DOr4D($mean),as1DOr4D($variance),varianceEpsilon,as1DOr4D($scale),as1DOr4D($offset));return save([$x,$mean,$variance,$scale]),res},inputs={x:$x,scale:$scale,offset:$offset,mean:$mean,variance:$variance},attrs={varianceEpsilon:varianceEpsilon},res;return ENGINE.runKernelFunc(forward,inputs,null,"FusedBatchNorm",attrs).reshape($x.shape)}function as1DOr4D(x){return null==x?null:0===x.rank?x.as1D():1===x.rank?x:2===x.rank?x.as4D(1,1,x.shape[0],x.shape[1]):3===x.rank?x.as4D(1,x.shape[0],x.shape[1],x.shape[2]):x}var batchNormalization=op({batchNormalization_:batchNormalization_}),batchNorm=op({batchNorm_:batchNorm_});function batchNorm2d_(x,mean,variance,offset,scale,varianceEpsilon){var $x=convertToTensor(x,"x","batchNorm"),$mean=convertToTensor(mean,"mean","batchNorm"),$variance=convertToTensor(variance,"variance","batchNorm"),$scale,$offset;return null!=scale&&($scale=convertToTensor(scale,"scale","batchNorm")),null!=offset&&($offset=convertToTensor(offset,"offset","batchNorm")),assert(2===$x.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+$x.rank+"."}),assert(2===$mean.rank||1===$mean.rank,function(){return"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank "+$mean.rank+"."}),assert(2===$variance.rank||1===$variance.rank,function(){return"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank "+$variance.rank+"."}),null!=$scale&&assert(2===$scale.rank||1===$scale.rank,function(){return"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank "+$scale.rank+"."}),null!=$offset&&assert(2===$offset.rank||1===$offset.rank,function(){return"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank "+$offset.rank+"."}),batchNorm($x,$mean,$variance,$offset,$scale,varianceEpsilon)}function batchNormalization2d_(x,mean,variance,varianceEpsilon,scale,offset){return void 0===varianceEpsilon&&(varianceEpsilon=.001),warnDeprecation(),batchNorm2d_(x,mean,variance,offset,scale,varianceEpsilon)}var batchNormalization2d=op({batchNormalization2d_:batchNormalization2d_}),batchNorm2d=op({batchNorm2d_:batchNorm2d_});function batchNorm3d_(x,mean,variance,offset,scale,varianceEpsilon){var $x=convertToTensor(x,"x","batchNorm"),$mean=convertToTensor(mean,"mean","batchNorm"),$variance=convertToTensor(variance,"variance","batchNorm"),$scale,$offset;return null!=scale&&($scale=convertToTensor(scale,"scale","batchNorm")),null!=offset&&($offset=convertToTensor(offset,"offset","batchNorm")),assert(3===$x.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+$x.rank+"."}),assert(3===$mean.rank||1===$mean.rank,function(){return"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank "+$mean.rank+"."}),assert(3===$variance.rank||1===$variance.rank,function(){return"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank "+$variance.rank+"."}),null!=$scale&&assert(3===$scale.rank||1===$scale.rank,function(){return"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank "+$scale.rank+"."}),null!=$offset&&assert(3===$offset.rank||1===$offset.rank,function(){return"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank "+$offset.rank+"."}),batchNorm($x,$mean,$variance,$offset,$scale,varianceEpsilon)}function batchNormalization3d_(x,mean,variance,varianceEpsilon,scale,offset){return void 0===varianceEpsilon&&(varianceEpsilon=.001),warnDeprecation(),batchNorm3d_(x,mean,variance,offset,scale,varianceEpsilon)}var batchNormalization3d=op({batchNormalization3d_:batchNormalization3d_}),batchNorm3d=op({batchNorm3d_:batchNorm3d_});function batchNorm4d_(x,mean,variance,offset,scale,varianceEpsilon){var $x=convertToTensor(x,"x","batchNorm"),$mean=convertToTensor(mean,"mean","batchNorm"),$variance=convertToTensor(variance,"variance","batchNorm"),$scale,$offset;return null!=scale&&($scale=convertToTensor(scale,"scale","batchNorm")),null!=offset&&($offset=convertToTensor(offset,"offset","batchNorm")),assert(4===$x.rank,function(){return"Error in batchNorm4D: x must be rank 4 but got rank "+$x.rank+"."}),assert(4===$mean.rank||1===$mean.rank,function(){return"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank "+$mean.rank+"."}),assert(4===$variance.rank||1===$variance.rank,function(){return"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank "+$variance.rank+"."}),null!=$scale&&assert(4===$scale.rank||1===$scale.rank,function(){return"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank "+$scale.rank+"."}),null!=$offset&&assert(4===$offset.rank||1===$offset.rank,function(){return"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank "+$offset.rank+"."}),batchNorm($x,$mean,$variance,$offset,$scale,varianceEpsilon)}function batchNormalization4d_(x,mean,variance,varianceEpsilon,scale,offset){return void 0===varianceEpsilon&&(varianceEpsilon=.001),warnDeprecation(),batchNorm4d_(x,mean,variance,offset,scale,varianceEpsilon)}var batchNormalization4d=op({batchNormalization4d_:batchNormalization4d_}),batchNorm4d=op({batchNorm4d_:batchNorm4d_});function broadcastTo_(x,shape){var input=convertToTensor(x,"broadcastTo","x"),xShape=input.shape;if(shape.some(function(d){return!(d>0)||d%1!=0}))throw new Error("broadcastTo(): Invalid broadcast shape ["+shape+"].");if(shape.length<input.rank)throw new Error("broadcastTo(): shape.length="+shape.length+" < input.rank="+input.rank+".");if(shape.length>input.rank){for(var newShape=input.shape.slice();newShape.length<shape.length;)newShape.unshift(1);input=input.reshape(newShape)}for(var inputShape=input.shape,reps=Array.from(shape),i=shape.length-1;i>=0;i--)if(inputShape[i]===shape[i])reps[i]=1;else if(1!==input.shape[i])throw new Error("broadcastTo(): ["+xShape+"] cannot be broadcast to ["+shape+"].");var axes=reps.map(function(n,i){return n>1?i:-1}).filter(function(i){return i>=0});if(0===axes.length)return input.clone();var forward=function(backend){return backend.tile(input,reps)},keepDims=!0,backward=function(dy){return{x:function(){return dy.sum(axes,!0)}}},inputs={x:input},attrs={shape:shape,inputShape:inputShape};return ENGINE.runKernelFunc(forward,inputs,backward,BroadcastTo,attrs)}var broadcastTo=op({broadcastTo_:broadcastTo_});function clone_(x){var $x=convertToTensor(x,"x","clone",null),forward=function(){return ENGINE.makeTensorFromDataId($x.dataId,$x.shape,$x.dtype)};return ENGINE.runKernelFunc(forward,{x:$x},null,Identity)}var clone=op({clone_:clone_});function logicalNot_(x){var $x=convertToTensor(x,"x","logicalNot","bool");return ENGINE.runKernelFunc(function(backend){return backend.logicalNot($x)},{$x:$x})}function logicalAnd_(a,b){var $a=convertToTensor(a,"a","logicalAnd","bool"),$b=convertToTensor(b,"b","logicalAnd","bool");return assertAndGetBroadcastShape($a.shape,$b.shape),ENGINE.runKernelFunc(function(backend){return backend.logicalAnd($a,$b)},{a:$a,b:$b},null,"LogicalAnd")}function logicalOr_(a,b){var $a=convertToTensor(a,"a","logicalOr","bool"),$b=convertToTensor(b,"b","logicalOr","bool");return assertAndGetBroadcastShape($a.shape,$b.shape),ENGINE.runKernelFunc(function(backend){return backend.logicalOr($a,$b)},{$a:$a,$b:$b})}function logicalXor_(a,b){var $a=convertToTensor(a,"a","logicalXor","bool"),$b=convertToTensor(b,"b","logicalXor","bool");return assertAndGetBroadcastShape($a.shape,$b.shape),logicalOr(a,b).logicalAnd(logicalAnd(a,b).logicalNot())}function where_(condition,a,b){var $a=convertToTensor(a,"a","where"),$b=convertToTensor(b,"b","where"),$condition=convertToTensor(condition,"condition","where","bool");assertShapesMatch($a.shape,$b.shape,"Error in where: "),1===$condition.rank?assert($condition.shape[0]===$a.shape[0],function(){return"The first dimension of `a` must match the size of `condition`."}):assertShapesMatch($condition.shape,$b.shape,"Error in where: ");var grad=function(dy,saved){var $condition=saved[0];return{$condition:function(){return zerosLike($condition).toFloat()},$a:function(){return dy.mul($condition.cast(dy.dtype))},$b:function(){return dy.mul($condition.logicalNot().cast(dy.dtype))}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.select($condition,$a,$b);return save([$condition]),res},{$condition:$condition,$a:$a,$b:$b},grad)}function whereAsync_(condition){return __awaiter(this,void 0,void 0,function(){var $condition,vals,res;return __generator(this,function(_a){switch(_a.label){case 0:return[4,($condition=convertToTensor(condition,"condition","whereAsync","bool")).data()];case 1:return vals=_a.sent(),res=whereImpl($condition.shape,vals),condition!==$condition&&$condition.dispose(),[2,res]}})})}var logicalAnd=op({logicalAnd_:logicalAnd_}),logicalNot=op({logicalNot_:logicalNot_}),logicalOr=op({logicalOr_:logicalOr_}),logicalXor=op({logicalXor_:logicalXor_}),where=op({where_:where_}),whereAsync=whereAsync_;function divNoNan_(a,b){var _a,$a=convertToTensor(a,"a","div"),$b=convertToTensor(b,"b","div");$a=(_a=makeTypesMatch($a,$b))[0],$b=_a[1];var divResult=div($a,$b),zeros=zerosLike(divResult),bEqualsZero=$b.equal(zeros);return where(bEqualsZero,zeros,divResult)}var divNoNan=op({divNoNan_:divNoNan_});function tile_(x,reps){var parseAs=null,$x=convertToTensor(x,"x","tile",null);assert($x.rank===reps.length,function(){return"Error in transpose: rank of input "+$x.rank+" must match length of reps "+reps+"."});var forward=function(backend,save){var res=backend.tile($x,reps);return save([$x]),res},inputsToSave=[$x],inputs={x:$x},attrs={reps:reps};return ENGINE.runKernelFunc(forward,inputs,null,Tile,attrs,inputsToSave)}var tile$1=op({tile_:tile_});function eye_(numRows,numColumns,batchShape,dtype){void 0===dtype&&(dtype="float32"),null==numColumns&&(numColumns=numRows);for(var buff=buffer([numRows,numColumns],dtype),n=numRows<=numColumns?numRows:numColumns,i=0;i<n;++i)buff.set(1,i,i);var out=buff.toTensor().as2D(numRows,numColumns);if(null==batchShape)return out;if(1===batchShape.length)return tile$1(expandDims(out,0),[batchShape[0],1,1]);if(2===batchShape.length)return tile$1(expandDims(expandDims(out,0),0),[batchShape[0],batchShape[1],1,1]);if(3===batchShape.length)return tile$1(expandDims(expandDims(expandDims(out,0),0),0),[batchShape[0],batchShape[1],batchShape[2],1,1]);throw new Error("eye() currently supports only 1D and 2D batchShapes, but received "+batchShape.length+"D.")}var eye=op({eye_:eye_});function multinomial_(logits,numSamples,seed,normalized){void 0===normalized&&(normalized=!1);var $logits=convertToTensor(logits,"logits","multinomial"),numOutcomes=$logits.size,origRank=$logits.rank;if(numOutcomes<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+numOutcomes+".");if(origRank>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+origRank);seed=seed||Math.random();var logits2D=1===origRank?$logits.as2D(1,-1):$logits,res=ENGINE.runKernelFunc(function(backend){return backend.multinomial(logits2D,normalized,numSamples,seed)},{logits2D:logits2D});return 1===origRank?res.as1D():res}var multinomial=op({multinomial_:multinomial_});function oneHot_(indices,depth,onValue,offValue){if(void 0===onValue&&(onValue=1),void 0===offValue&&(offValue=0),depth<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+depth);var $indices=convertToTensor(indices,"indices","oneHot","int32"),outShape=$indices.shape.concat([depth]),forward=function(backend,save){return save([$indices]),backend.oneHot($indices,depth,onValue,offValue)},inputs={indices:$indices=$indices.flatten()},attrs={depth:depth,onValue:onValue,offValue:offValue},result;return ENGINE.runKernelFunc(forward,inputs,null,OneHot,attrs).reshape(outShape)}var oneHot=op({oneHot_:oneHot_});function pad_(x,paddings,constantValue){void 0===constantValue&&(constantValue=0);var $x=convertToTensor(x,"x","pad");if(0===$x.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");var forward=function(backend,save){return save([$x]),backend.pad($x,paddings,constantValue)},attrs={paddings:paddings,constantValue:constantValue},inputs={x:$x};return ENGINE.runKernelFunc(forward,inputs,null,PadV2,attrs)}var pad=op({pad_:pad_});function pad1d_(x,paddings,constantValue){return void 0===constantValue&&(constantValue=0),assert(2===paddings.length,function(){return"Invalid number of paddings. Must be length of 2."}),pad(x,[paddings],constantValue)}var pad1d=op({pad1d_:pad1d_});function pad2d_(x,paddings,constantValue){return void 0===constantValue&&(constantValue=0),assert(2===paddings.length&&2===paddings[0].length&&2===paddings[1].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),pad(x,paddings,constantValue)}var pad2d=op({pad2d_:pad2d_});function pad3d_(x,paddings,constantValue){return void 0===constantValue&&(constantValue=0),assert(3===paddings.length&&2===paddings[0].length&&2===paddings[1].length&&2===paddings[2].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),pad(x,paddings,constantValue)}var pad3d=op({pad3d_:pad3d_});function pad4d_(x,paddings,constantValue){return void 0===constantValue&&(constantValue=0),assert(4===paddings.length&&2===paddings[0].length&&2===paddings[1].length&&2===paddings[2].length&&2===paddings[3].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),pad(x,paddings,constantValue)}var pad4d=op({pad4d_:pad4d_});function rand_(shape,randFunction,dtype){var size=sizeFromShape(shape),values=null;if(null==dtype||"float32"===dtype)values=new Float32Array(size);else if("int32"===dtype)values=new Int32Array(size);else{if("bool"!==dtype)throw new Error("Unknown data type "+dtype);values=new Uint8Array(size)}for(var i=0;i<size;i++)values[i]=randFunction();return ENGINE.makeTensor(values,shape,dtype)}var rand=op({rand_:rand_}),TEST_EPSILON_FLOAT32=.001,TEST_EPSILON_FLOAT16=.1;function expectArraysClose(actual,expected,epsilon){return null==epsilon&&(epsilon=testEpsilon()),expectArraysPredicate(actual,expected,function(a,b){return areClose(a,b,epsilon)})}function testEpsilon(){return 32===ENGINE.backend.floatPrecision()?TEST_EPSILON_FLOAT32:TEST_EPSILON_FLOAT16}function expectArraysPredicate(actual,expected,predicate){var checkClassType=!0;if((isTypedArray(actual)||isTypedArray(expected))&&(checkClassType=!1),isTypedArray(actual)&&isTypedArray(expected)&&(checkClassType=!0),checkClassType){var aType=actual.constructor.name,bType=expected.constructor.name;if(aType!==bType)throw new Error("Arrays are of different type. Actual: "+aType+". Expected: "+bType)}if(Array.isArray(actual)&&Array.isArray(expected)){var actualShape=inferShape(actual),expectedShape=inferShape(expected);if(!arraysEqual(actualShape,expectedShape))throw new Error("Arrays have different shapes. Actual: ["+actualShape+"]. Expected: ["+expectedShape+"]")}var actualFlat=isTypedArray(actual)?actual:flatten(actual),expectedFlat=isTypedArray(expected)?expected:flatten(expected);if(actualFlat.length!==expectedFlat.length)throw new Error("Arrays have different lengths actual: "+actualFlat.length+" vs expected: "+expectedFlat.length+".\nActual:   "+actualFlat+".\nExpected: "+expectedFlat+".");for(var i=0;i<expectedFlat.length;++i){var a=actualFlat[i],e=expectedFlat[i];if(!predicate(a,e))throw new Error("Arrays differ: actual["+i+"] = "+a+", expected["+i+"] = "+e+".\nActual:   "+actualFlat+".\nExpected: "+expectedFlat+".")}}function expectPromiseToFail(fn,done){fn().then(function(){return done.fail()},function(){return done()})}function expectArraysEqual(actual,expected){var exp="string"==typeof expected||"number"==typeof expected||"boolean"==typeof expected?[expected]:expected;return isString(actual)||isString(actual[0])||isString(expected)||isString(expected[0])?expectArraysPredicate(actual,exp,function(a,b){return a==b}):expectArraysPredicate(actual,expected,function(a,b){return areClose(a,b,0)})}function expectNumbersClose(a,e,epsilon){if(null==epsilon&&(epsilon=testEpsilon()),!areClose(a,e,epsilon))throw new Error("Numbers differ: actual === "+a+", expected === "+e)}function areClose(a,e,epsilon){return!isFinite(a)&&!isFinite(e)||!(isNaN(a)||isNaN(e)||Math.abs(a-e)>epsilon)}function expectValuesInRange(actual,low,high){for(var i=0;i<actual.length;i++)if(actual[i]<low||actual[i]>high)throw new Error("Value out of range:"+actual[i]+" low: "+low+", high: "+high)}function expectArrayBuffersEqual(actual,expected){expect(new Float32Array(actual)).toEqual(new Float32Array(expected))}var test_util=Object.freeze({TEST_EPSILON_FLOAT16:TEST_EPSILON_FLOAT16,expectArraysClose:expectArraysClose,testEpsilon:testEpsilon,expectPromiseToFail:expectPromiseToFail,expectArraysEqual:expectArraysEqual,expectNumbersClose:expectNumbersClose,expectValuesInRange:expectValuesInRange,expectArrayBuffersEqual:expectArrayBuffersEqual}),MPRandGauss=function(){function MPRandGauss(mean,stdDeviation,dtype,truncated,seed){this.mean=mean,this.stdDev=stdDeviation,this.dtype=dtype,this.nextVal=NaN,this.truncated=truncated,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);var seedValue=seed||Math.random();this.random=seedrandom_1(seedValue.toString())}return MPRandGauss.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var value=this.nextVal;return this.nextVal=NaN,value}for(var resultX,resultY,isValid=!1;!isValid;){var v1=void 0,v2=void 0,s=void 0;do{s=(v1=2*this.random()-1)*v1+(v2=2*this.random()-1)*v2}while(s>=1||0===s);var mul=Math.sqrt(-2*Math.log(s)/s);resultX=this.mean+this.stdDev*v1*mul,resultY=this.mean+this.stdDev*v2*mul,this.truncated&&!this.isValidTruncated(resultX)||(isValid=!0)}return this.truncated&&!this.isValidTruncated(resultY)||(this.nextVal=this.convertValue(resultY)),this.convertValue(resultX)},MPRandGauss.prototype.convertValue=function(value){return null==this.dtype||"float32"===this.dtype?value:Math.round(value)},MPRandGauss.prototype.isValidTruncated=function(value){return value<=this.upper&&value>=this.lower},MPRandGauss}(),RandGamma=function(){function RandGamma(alpha,beta,dtype,seed){this.alpha=alpha,this.beta=1/beta,this.dtype=dtype;var seedValue=seed||Math.random();this.randu=seedrandom_1(seedValue.toString()),this.randn=new MPRandGauss(0,1,dtype,!1,this.randu()),this.d=alpha<1?alpha+2/3:alpha-1/3,this.c=1/Math.sqrt(9*this.d)}return RandGamma.prototype.nextValue=function(){for(var x2,v0,v1,x,u,v;;){do{x=this.randn.nextValue(),v=1+this.c*x}while(v<=0);if(v*=v*v,v0=1-.331*(x2=x*x)*x2,v1=.5*x2+this.d*(1-v+Math.log(v)),(u=this.randu())<v0||Math.log(u)<v1)break}return v=1/this.beta*this.d*v,this.alpha<1&&(v*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(v)},RandGamma.prototype.convertValue=function(value){return"float32"===this.dtype?value:Math.round(value)},RandGamma}(),UniformRandom=function(){function UniformRandom(min,max,dtype,seed){var _this=this;if(void 0===min&&(min=0),void 0===max&&(max=1),this.canReturnFloat=function(){return null==_this.dtype||"float32"===_this.dtype},this.min=min,this.range=max-min,this.dtype=dtype,null==seed&&(seed=Math.random()),"number"==typeof seed&&(seed=seed.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between "+min+" - "+max+" <= 1 and dtype is not float");this.random=seedrandom_1(seed)}return UniformRandom.prototype.convertValue=function(value){return this.canReturnFloat()?value:Math.round(value)},UniformRandom.prototype.nextValue=function(){return this.convertValue(this.min+this.range*this.random())},UniformRandom}();function randomGamma_(shape,alpha,beta,dtype,seed){if(void 0===beta&&(beta=1),void 0===dtype&&(dtype="float32"),null==beta&&(beta=1),null==dtype&&(dtype="float32"),"float32"!==dtype&&"int32"!==dtype)throw new Error("Unsupported data type "+dtype);for(var rgamma=new RandGamma(alpha,beta,dtype,seed),res=buffer(shape,dtype),i=0;i<res.values.length;i++)res.values[i]=rgamma.nextValue();return res.toTensor()}var randomGamma=op({randomGamma_:randomGamma_});function randomNormal_(shape,mean,stdDev,dtype,seed){if(void 0===mean&&(mean=0),void 0===stdDev&&(stdDev=1),null!=dtype&&"bool"===dtype)throw new Error("Unsupported data type "+dtype);for(var randGauss=new MPRandGauss(mean,stdDev,dtype,!1,seed),res=buffer(shape,dtype),i=0;i<res.values.length;i++)res.values[i]=randGauss.nextValue();return res.toTensor()}var randomNormal=op({randomNormal_:randomNormal_});function randomUniform_(shape,minval,maxval,dtype,seed){void 0===minval&&(minval=0),void 0===maxval&&(maxval=1),void 0===dtype&&(dtype="float32");for(var res=buffer(shape,dtype),random=new UniformRandom(minval,maxval,null,seed),i=0;i<res.values.length;i++)res.values[i]=random.nextValue();return res.toTensor()}var randomUniform=op({randomUniform_:randomUniform_});function square_(x){var $x=convertToTensor(x,"x","square"),attrs={},inputsToSave=[$x],outputsToSave=[];return ENGINE.runKernelFunc(function(backend,save){return save([$x]),backend.square($x)},{x:$x},null,"Square",attrs,inputsToSave,outputsToSave)}var square=op({square_:square_});function squaredDifference_(a,b){var _a,$a=convertToTensor(a,"a","squaredDifference"),$b=convertToTensor(b,"b","squaredDifference");_a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1],assertAndGetBroadcastShape($a.shape,$b.shape);var der=function(dy,saved){var $a=saved[0],$b=saved[1],two=scalar(2),derA,derB;return{a:function(){return dy.mul($a.sub($b).mul(two))},b:function(){return dy.mul($b.sub($a).mul(two))}}},forward=function(backend,save){var res=backend.squaredDifference($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b},attrs={},inputsToSave=[$a,$b],outputToSave=[];return ENGINE.runKernelFunc(forward,inputs,der,SquaredDifference,attrs,inputsToSave,outputToSave)}var squaredDifference=op({squaredDifference_:squaredDifference_});function truncatedNormal_(shape,mean,stdDev,dtype,seed){if(void 0===mean&&(mean=0),void 0===stdDev&&(stdDev=1),null!=dtype&&"bool"===dtype)throw new Error("Unsupported data type $ { dtype }");for(var randGauss=new MPRandGauss(mean,stdDev,dtype,!0,seed),res=buffer(shape,dtype),i=0;i<res.values.length;i++)res.values[i]=randGauss.nextValue();return res.toTensor()}var truncatedNormal=op({truncatedNormal_:truncatedNormal_});function notEqual_(a,b){var _a,$a=convertToTensor(a,"a","notEqual"),$b=convertToTensor(b,"b","notEqual");return _a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1],assertAndGetBroadcastShape($a.shape,$b.shape),ENGINE.runKernelFunc(function(backend){return backend.notEqual($a,$b)},{a:$a,b:$b},null,"NotEqual")}function notEqualStrict_(a,b){var $a=convertToTensor(a,"a","notEqualStrict"),$b=convertToTensor(b,"b","notEqualStrict");return assertShapesMatch($a.shape,$b.shape,"Error in notEqualStrict: "),$a.notEqual($b)}function less_(a,b){var _a,$a=convertToTensor(a,"a","less"),$b=convertToTensor(b,"b","less");return _a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1],assertAndGetBroadcastShape($a.shape,$b.shape),ENGINE.runKernelFunc(function(backend){return backend.less($a,$b)},{a:$a,b:$b},null,"Less")}function lessStrict_(a,b){var $a=convertToTensor(a,"a","lessStrict"),$b=convertToTensor(b,"b","lessStrict");return assertShapesMatch($a.shape,$b.shape,"Error in lessStrict: "),$a.less($b)}function equal_(a,b){var _a,$a=convertToTensor(a,"a","equal"),$b=convertToTensor(b,"b","equal");return _a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1],assertAndGetBroadcastShape($a.shape,$b.shape),ENGINE.runKernelFunc(function(backend){return backend.equal($a,$b)},{$a:$a,$b:$b})}function equalStrict_(a,b){var $a=convertToTensor(a,"a","equalStrict"),$b=convertToTensor(b,"b","equalStrict");return assertShapesMatch($a.shape,$b.shape,"Error in equalStrict: "),$a.equal($b)}function lessEqual_(a,b){var _a,$a=convertToTensor(a,"a","lessEqual"),$b=convertToTensor(b,"b","lessEqual");return _a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1],assertAndGetBroadcastShape($a.shape,$b.shape),ENGINE.runKernelFunc(function(backend,save){var res=backend.lessEqual($a,$b);return save([$a,$b]),res},{a:$a,b:$b},null,"LessEqual")}function lessEqualStrict_(a,b){var $a=convertToTensor(a,"a","lessEqualStrict"),$b=convertToTensor(b,"b","lessEqualStrict");return assertShapesMatch($a.shape,$b.shape,"Error in lessEqualStrict: "),$a.lessEqual($b)}function greater_(a,b){var _a,$a=convertToTensor(a,"a","greater"),$b=convertToTensor(b,"b","greater");return _a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1],assertAndGetBroadcastShape($a.shape,$b.shape),ENGINE.runKernelFunc(function(backend){return backend.greater($a,$b)},{a:$a,b:$b},null,"Greater")}function greaterStrict_(a,b){var $a=convertToTensor(a,"a","greaterStrict"),$b=convertToTensor(b,"b","greaterStrict");return assertShapesMatch($a.shape,$b.shape,"Error in greaterStrict: "),$a.greater($b)}function greaterEqual_(a,b){var _a,$a=convertToTensor(a,"a","greaterEqual"),$b=convertToTensor(b,"b","greaterEqual");_a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1],assertAndGetBroadcastShape($a.shape,$b.shape);var grad=function(dy,saved){var $a=saved[0],$b=saved[1];return{a:function(){return zerosLike($a)},b:function(){return zerosLike($b)}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.greaterEqual($a,$b);return save([$a,$b]),res},{a:$a,b:$b},grad,"GreaterEqual")}function greaterEqualStrict_(a,b){var $a=convertToTensor(a,"a","greaterEqualStrict"),$b=convertToTensor(b,"b","greaterEqualStrict");return assertShapesMatch($a.shape,$b.shape,"Error in greaterEqualStrict: "),$a.greaterEqual($b)}var equal=op({equal_:equal_}),equalStrict=op({equalStrict_:equalStrict_}),greater=op({greater_:greater_}),greaterEqual=op({greaterEqual_:greaterEqual_}),greaterEqualStrict=op({greaterEqualStrict_:greaterEqualStrict_}),greaterStrict=op({greaterStrict_:greaterStrict_}),less=op({less_:less_}),lessEqual=op({lessEqual_:lessEqual_}),lessEqualStrict=op({lessEqualStrict_:lessEqualStrict_}),lessStrict=op({lessStrict_:lessStrict_}),notEqual=op({notEqual_:notEqual_}),notEqualStrict=op({notEqualStrict_:notEqualStrict_});function unsortedSegmentSum_(x,segmentIds,numSegments){var $x=convertToTensor(x,"x","unsortedSegmentSum"),$segmentIds=convertToTensor(segmentIds,"segmentIds","unsortedSegmentSum","int32");assert(isInt(numSegments),function(){return"numSegments must be of dtype int"});var gradFunc=function(dy,saved){var $segmentIds=saved[0],derX;return{$x:function(){return gatherDropNegatives(dy,$segmentIds)}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.unsortedSegmentSum($x,$segmentIds,numSegments);return save([$segmentIds]),res},{$x:$x},gradFunc)}function gather_(x,indices,axis){void 0===axis&&(axis=0);var $x=convertToTensor(x,"x","gather"),$indices=convertToTensor(indices,"indices","gather","int32");axis=parseAxisParam(axis,$x.shape)[0];var shapeInfo=collectGatherOpShapeInfo($x,$indices,axis),grad=function(dy,saved){var $indices=saved[0],derX;return{x:function(){var paramsShape=$x.shape,indicesSize=$indices.size,outerShape=paramsShape.slice(0,axis),outerDims=outerShape.length,innerShape=paramsShape.slice(axis,paramsShape.length).slice(1),innerDims=innerShape.length,outerAxesIndices=arrayRange(0,outerDims),innerAxesIndices=arrayRange(outerDims+1,outerDims+1+innerDims),valuesShape=arrayConcat([outerShape,[indicesSize],innerShape]),values=dy.reshape(valuesShape),reshapedIndices=$indices.reshape([indicesSize]),transposeDims=arrayConcat([[outerDims],outerAxesIndices,innerAxesIndices]),valuesTranspose=values.transpose(transposeDims),paramsGrad=unsortedSegmentSum(valuesTranspose,reshapedIndices,$x.shape[axis]),invertTransposeDims=getUndoAxesPermutation(transposeDims);return paramsGrad=paramsGrad.transpose(invertTransposeDims)},indices:function(){return $indices}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.gather($x,$indices.flatten(),axis);return save([$indices]),res},{x:$x,indices:$indices},grad,"Gather",{axis:axis}).reshape(shapeInfo.outputShape)}function arrayRange(start,stop){for(var result=[],i=start;i<stop;++i)result.push(i);return result}function arrayConcat(arrays){for(var result=[],i=0;i<arrays.length;++i)for(var j=0;j<arrays[i].length;++j)result.push(arrays[i][j]);return result}function gatherDropNegatives(x,indices){for(var zeroClippedIndices=maximum(indices,zerosLike(indices)),gathered=gather(x,zeroClippedIndices),isPositive=greaterEqual(indices,scalar(0,"int32")),numIters=gathered.rank-isPositive.rank,i=0;i<numIters;++i)isPositive=expandDims(isPositive,i+1);isPositive=logicalAnd(isPositive,ones$1(gathered.shape,"bool"));var zeroSlice=zerosLike(gathered);return where(isPositive,gathered,zeroSlice)}var gather=op({gather_:gather_}),unsortedSegmentSum=op({unsortedSegmentSum_:unsortedSegmentSum_});function booleanMaskAsync_(tensor,mask,axis){return __awaiter(this,void 0,void 0,function(){var $tensor,$mask,axisFrom,maskDim,tensorShape,leadingSize,i,targetTensorShape,reshapedTensor,reshapedMask,positivePositions,indices,res;return __generator(this,function(_a){switch(_a.label){case 0:for($tensor=convertToTensor(tensor,"tensor","boolMask"),$mask=convertToTensor(mask,"mask","boolMask","bool"),axisFrom=null==axis?0:axis,maskDim=$mask.rank,tensorShape=$tensor.shape,assert(maskDim>0,function(){return"mask cannot be scalar"}),assertShapesMatch(tensorShape.slice(axisFrom,axisFrom+maskDim),$mask.shape,"mask's shape must match the first K dimensions of tensor's shape,"),leadingSize=1,i=axisFrom;i<axisFrom+maskDim;i++)leadingSize*=tensorShape[i];return targetTensorShape=tensorShape.slice(0,axisFrom).concat([leadingSize],tensorShape.slice(axisFrom+maskDim)),reshapedTensor=$tensor.reshape(targetTensorShape),reshapedMask=$mask.reshape([-1]),[4,whereAsync(reshapedMask)];case 1:return positivePositions=_a.sent(),indices=positivePositions.squeeze([1]),res=gather(reshapedTensor,indices,axisFrom),tensor!==$tensor&&$tensor.dispose(),mask!==$mask&&$mask.dispose(),indices.dispose(),reshapedTensor.dispose(),reshapedMask.dispose(),positivePositions.dispose(),[2,res]}})})}var booleanMaskAsync=booleanMaskAsync_;function conv1d_(x,filter,stride,pad,dataFormat,dilation,dimRoundingMode){void 0===dataFormat&&(dataFormat="NWC"),void 0===dilation&&(dilation=1);var $x=convertToTensor(x,"x","conv1d"),$filter=convertToTensor(filter,"filter","conv1d"),x3D=$x,reshapedTo3D=!1;2===$x.rank&&(reshapedTo3D=!0,x3D=$x.as3D(1,$x.shape[0],$x.shape[1])),assert(3===x3D.rank,function(){return"Error in conv1d: input must be rank 3, but got rank "+x3D.rank+"."}),assert(3===$filter.rank,function(){return"Error in conv1d: filter must be rank 3, but got rank "+$filter.rank+"."}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in conv1d: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."}),assert(x3D.shape[2]===$filter.shape[1],function(){return"Error in conv1d: depth of input ("+x3D.shape[2]+") must match input depth for filter "+$filter.shape[1]+"."}),assert(eitherStridesOrDilationsAreOne(stride,dilation),function(){return"Error in conv1D: Either stride or dilation must be 1. Got stride "+stride+" and dilation '"+dilation+"'"}),assert("NWC"===dataFormat,function(){return"Error in conv1d: got dataFormat of "+dataFormat+" but only NWC is currently supported."});var filter4D=$filter.as4D(1,$filter.shape[0],$filter.shape[1],$filter.shape[2]),input4D=x3D.as4D(x3D.shape[0],1,x3D.shape[1],x3D.shape[2]),strides,dilations,conv2dDataFormat="NHWC",res=conv2d(input4D,filter4D,[1,stride],pad,"NHWC",[1,dilation],dimRoundingMode);return reshapedTo3D?res.as2D(res.shape[2],res.shape[3]):res.as3D(res.shape[0],res.shape[2],res.shape[3])}function conv2d_(x,filter,strides,pad,dataFormat,dilations,dimRoundingMode){void 0===dataFormat&&(dataFormat="NHWC"),void 0===dilations&&(dilations=[1,1]);var $x=convertToTensor(x,"x","conv2d"),$filter=convertToTensor(filter,"filter","conv2d"),x4D=$x,reshapedTo4D=!1;3===$x.rank&&(reshapedTo4D=!0,x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])),assert(4===x4D.rank,function(){return"Error in conv2d: input must be rank 4, but got rank "+x4D.rank+"."}),assert(4===$filter.rank,function(){return"Error in conv2d: filter must be rank 4, but got rank "+$filter.rank+"."}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in conv2d: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."});var inDepth="NHWC"===dataFormat?x4D.shape[3]:x4D.shape[1];assert(inDepth===$filter.shape[2],function(){return"Error in conv2d: depth of input ("+inDepth+") must match input depth for filter "+$filter.shape[2]+"."}),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"});var $dataFormat=convertConv2DDataFormat(dataFormat),convInfo=computeConv2DInfo(x4D.shape,$filter.shape,strides,dilations,pad,dimRoundingMode,!1,$dataFormat),grad=function(dy,saved){var _a=saved,$filter=_a[0],x4D=_a[1];return assert(tupleValuesAreOne(dilations),function(){return"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+dilations+"'"}),{x:function(){return conv2dDerInput(x4D.shape,dy,$filter,strides,pad,dataFormat)},filter:function(){return conv2dDerFilter(x4D,dy,$filter.shape,strides,pad,dataFormat)}}},inputsToSave=[$filter,x4D],res=ENGINE.runKernelFunc(function(backend,save){var res=backend.conv2d(x4D,$filter,convInfo);return save([$filter,x4D]),res},{x:x4D,filter:$filter},grad,"Conv2D",convInfo,inputsToSave);return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}function conv2dDerInput_(xShape,dy,filter,strides,pad,dataFormat,dimRoundingMode){void 0===dataFormat&&(dataFormat="NHWC"),assert(xShape.length===dy.rank,function(){return"Length of inShape ("+xShape.length+") and rank of dy ("+dy.rank+") must match"});var xShape4D=xShape,dy4D=dy,reshapedTo4D=!1;3===dy.rank&&(reshapedTo4D=!0,dy4D=dy.as4D(1,dy.shape[0],dy.shape[1],dy.shape[2]),xShape4D=[1,xShape[0],xShape[1],xShape[2]]),assert(4===xShape4D.length,function(){return"Error in conv2dDerInput: inShape must be length 4, but got length "+xShape4D.length+"."}),assert(4===dy4D.rank,function(){return"Error in conv2dDerInput: dy must be rank 4, but got rank "+dy4D.rank}),assert(4===filter.rank,function(){return"Error in conv2dDerInput: filter must be rank 4, but got rank "+filter.rank});var inDepth="NHWC"===dataFormat?xShape4D[3]:xShape4D[1],outDepth="NHWC"===dataFormat?dy4D.shape[3]:dy4D.shape[1];assert(inDepth===filter.shape[2],function(){return"Error in conv2dDerInput: depth of input ("+inDepth+") must match input depth for filter "+filter.shape[2]+"."}),assert(outDepth===filter.shape[3],function(){return"Error in conv2dDerInput: depth of output ("+outDepth+") must match output depth for filter "+filter.shape[3]+"."}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."});var dilations=1,grad=function(ddx,saved){var filter=saved[0],dy4D=saved[1];return{dy4D:function(){return conv2d(ddx,filter,strides,pad,dataFormat,1,dimRoundingMode)},filter:function(){return conv2dDerFilter(ddx,dy4D,filter.shape,strides,pad,dataFormat,dimRoundingMode)}}},$dataFormat=convertConv2DDataFormat(dataFormat),convInfo=computeConv2DInfo(xShape4D,filter.shape,strides,1,pad,dimRoundingMode,!1,$dataFormat),res=ENGINE.runKernelFunc(function(backend,save){var res=backend.conv2dDerInput(dy4D,filter,convInfo);return save([filter,dy4D]),res},{dy4D:dy4D,filter:filter},grad);return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}function conv2dDerFilter_(x,dy,filterShape,strides,pad,dataFormat,dimRoundingMode){void 0===dataFormat&&(dataFormat="NHWC");var x4D=x;3===x.rank&&(x4D=x.as4D(1,x.shape[0],x.shape[1],x.shape[2]));var dy4D=dy;3===dy4D.rank&&(dy4D=dy.as4D(1,dy.shape[0],dy.shape[1],dy.shape[2])),assert(4===x4D.rank,function(){return"Error in conv2dDerFilter: input must be rank 4, but got shape "+x4D.shape+"."}),assert(4===dy4D.rank,function(){return"Error in conv2dDerFilter: dy must be rank 4, but got shape "+dy4D.shape+"."}),assert(4===filterShape.length,function(){return"Error in conv2dDerFilter: filterShape must be length 4, but got "+filterShape+"."});var inDepth="NHWC"===dataFormat?x4D.shape[3]:x4D.shape[1],outDepth="NHWC"===dataFormat?dy4D.shape[3]:dy4D.shape[1];assert(inDepth===filterShape[2],function(){return"Error in conv2dDerFilter: depth of input "+inDepth+") must match input depth in filter ("+filterShape[2]+"."}),assert(outDepth===filterShape[3],function(){return"Error in conv2dDerFilter: depth of dy ("+outDepth+") must match output depth for filter ("+filterShape[3]+")."}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."});var dilations=1,$dataFormat=convertConv2DDataFormat(dataFormat),convInfo=computeConv2DInfo(x4D.shape,filterShape,strides,1,pad,dimRoundingMode,!1,$dataFormat);return ENGINE.runKernelFunc(function(backend){return backend.conv2dDerFilter(x4D,dy4D,convInfo)},{x4D:x4D,dy4D:dy4D})}function conv2dTranspose_(x,filter,outputShape,strides,pad,dimRoundingMode){var $x,$filter;return conv2dDerInput_(outputShape,convertToTensor(x,"x","conv2dTranspose"),convertToTensor(filter,"filter","conv2dTranspose"),strides,pad,"NHWC",dimRoundingMode)}function depthwiseConv2d_(x,filter,strides,pad,dataFormat,dilations,dimRoundingMode){void 0===dataFormat&&(dataFormat="NHWC"),void 0===dilations&&(dilations=[1,1]);var $x=convertToTensor(x,"x","depthwiseConv2d"),$filter=convertToTensor(filter,"filter","depthwiseConv2d"),x4D=$x,reshapedTo4D=!1;3===$x.rank&&(reshapedTo4D=!0,x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])),assert(4===x4D.rank,function(){return"Error in depthwiseConv2d: input must be rank 4, but got rank "+x4D.rank+"."}),assert(4===$filter.rank,function(){return"Error in depthwiseConv2d: filter must be rank 4, but got rank "+$filter.rank+"."}),assert(x4D.shape[3]===$filter.shape[2],function(){return"Error in depthwiseConv2d: number of input channels ("+x4D.shape[3]+") must match the inChannels dimension in filter "+$filter.shape[2]+"."}),null==dilations&&(dilations=[1,1]),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."});var convInfo=computeConv2DInfo(x4D.shape,$filter.shape,strides,dilations,pad,dimRoundingMode,!0),grad=function(dy,saved){assert(tupleValuesAreOne(dilations),function(){return"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+dilations+"'"});var x4D=saved[0],$filter=saved[1];return{x:function(){return depthwiseConv2dDerInput(x4D.shape,dy,$filter,convInfo)},filter:function(){return depthwiseConv2dDerFilter(x4D,dy,$filter.shape,convInfo)}}},inputsToSave=[x4D,$filter],res=ENGINE.runKernelFunc(function(backend,save){var res=backend.depthwiseConv2D(x4D,$filter,convInfo);return save([x4D,$filter]),res},{x:x4D,filter:$filter},grad,"DepthwiseConv2dNative",convInfo,inputsToSave);return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}function separableConv2d_(x,depthwiseFilter,pointwiseFilter,strides,pad,dilation,dataFormat){void 0===dilation&&(dilation=[1,1]),void 0===dataFormat&&(dataFormat="NHWC");var $x=convertToTensor(x,"x","separableConv2d"),$depthwiseFilter=convertToTensor(depthwiseFilter,"depthwiseFilter","separableConv2d"),$pointwiseFilter=convertToTensor(pointwiseFilter,"pointwiseFilter","separableConv2d"),x4D=$x,reshapedTo4D=!1;if(3===$x.rank&&(reshapedTo4D=!0,x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])),"NCHW"===dataFormat)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");assert(4===x4D.rank,function(){return"Error in separableConv2d: input must be rank 4, but got rank "+x4D.rank+"."}),assert(4===$depthwiseFilter.rank,function(){return"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+$depthwiseFilter.rank+"."}),assert(4===$pointwiseFilter.rank,function(){return"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+$depthwiseFilter.rank+"."}),assert(1===$pointwiseFilter.shape[0],function(){return"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+$pointwiseFilter.shape[0]+"."}),assert(1===$pointwiseFilter.shape[1],function(){return"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got "+$pointwiseFilter.shape[1]+"."});var inChannels=$depthwiseFilter.shape[2],channelMultiplier=$depthwiseFilter.shape[3];assert($pointwiseFilter.shape[2]===inChannels*channelMultiplier,function(){return"Error in separableConv2d: the third dimension of pointwise filter must be "+inChannels*channelMultiplier+", but got "+$pointwiseFilter.shape[2]+"."});var depthwise=depthwiseConv2d(x4D,$depthwiseFilter,strides,pad,dataFormat,dilation),pointwiseStride=1,res=conv2d(depthwise,$pointwiseFilter,1,"valid",dataFormat);return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}function parseTupleParam$1(param){return"number"==typeof param?[param,param,param]:2===param.length?[param[0],param[1],1]:param}function tupleValuesAreOne$1(param){var _a=parseTupleParam$1(param),dimA=_a[0],dimB=_a[1],dimC=_a[2];return 1===dimA&&1===dimB&&1===dimC}function eitherStridesOrDilationsAreOne$1(strides,dilations){return tupleValuesAreOne$1(strides)||tupleValuesAreOne$1(dilations)}function depthwiseConv2dDerInput_(xShape,dy,filter,convInfo){var dy4D=dy,reshapedTo4D=!1;3===dy.rank&&(reshapedTo4D=!0,dy4D=dy.as4D(1,dy.shape[0],dy.shape[1],dy.shape[2]));var res=ENGINE.runKernelFunc(function(backend){return backend.depthwiseConv2DDerInput(dy4D,filter,convInfo)},{dy4D:dy4D});return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}function depthwiseConv2dDerFilter_(x,dy,filterShape,convInfo){var x4D=x;3===x.rank&&(x4D=x.as4D(1,x.shape[0],x.shape[1],x.shape[2]));var dy4D=dy;return 3===dy4D.rank&&(dy4D=dy.as4D(1,dy.shape[0],dy.shape[1],dy.shape[2])),ENGINE.runKernelFunc(function(backend){return backend.depthwiseConv2DDerFilter(x4D,dy4D,convInfo)},{x4D:x4D,dy4D:dy4D})}function conv3d_(x,filter,strides,pad,dataFormat,dilations){void 0===dataFormat&&(dataFormat="NDHWC"),void 0===dilations&&(dilations=[1,1,1]);var $x=convertToTensor(x,"x","conv3d"),$filter=convertToTensor(filter,"filter","conv3d"),x5D=$x,reshapedTo5D=!1;4===$x.rank&&(reshapedTo5D=!0,x5D=$x.as5D(1,$x.shape[0],$x.shape[1],$x.shape[2],$x.shape[3])),assert(5===x5D.rank,function(){return"Error in conv3d: input must be rank 5, but got rank "+x5D.rank+"."}),assert(5===$filter.rank,function(){return"Error in conv3d: filter must be rank 5, but got rank "+$filter.rank+"."}),assert(x5D.shape[4]===$filter.shape[3],function(){return"Error in conv3d: depth of input ("+x5D.shape[4]+") must match input depth for filter "+$filter.shape[3]+"."}),assert(eitherStridesOrDilationsAreOne$1(strides,dilations),function(){return"Error in conv3D: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"}),assert("NDHWC"===dataFormat,function(){return"Error in conv3d: got dataFormat of "+dataFormat+" but only NDHWC is currently supported."});var convInfo=computeConv3DInfo(x5D.shape,$filter.shape,strides,dilations,pad),grad=function(dy,saved){assert(tupleValuesAreOne$1(dilations),function(){return"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+dilations+"'"});var x5D=saved[0],$filter=saved[1];return{x:function(){return conv3dDerInput_(x5D.shape,dy,$filter,strides,pad)},$filter:function(){return conv3dDerFilter_(x5D,dy,$filter.shape,strides,pad)}}},res=ENGINE.runKernelFunc(function(backend,save){var res=backend.conv3d(x5D,$filter,convInfo);return save([x5D,$filter]),res},{x:x5D,$filter:$filter},grad);return reshapedTo5D?res.as4D(res.shape[1],res.shape[2],res.shape[3],res.shape[4]):res}function conv3dDerInput_(xShape,dy,filter,strides,pad){assert(xShape.length===dy.rank,function(){return"Length of inShape ("+xShape.length+") and rank of dy ("+dy.rank+") must match"});var xShape5D=xShape,dy5D=dy,reshapedTo5D=!1;4===dy.rank&&(reshapedTo5D=!0,dy5D=dy.as5D(1,dy.shape[0],dy.shape[1],dy.shape[2],dy.shape[3]),xShape5D=[1,xShape[0],xShape[1],xShape[2],xShape[3]]);var inDepth=xShape5D[4],outDepth=dy5D.shape[4];assert(5===xShape5D.length,function(){return"Error in conv3dDerInput: inShape must be length 5, but got length "+xShape5D.length+"."}),assert(5===dy5D.rank,function(){return"Error in conv3dDerInput: dy must be rank 5, but got rank "+dy5D.rank}),assert(5===filter.rank,function(){return"Error in conv3dDerInput: filter must be rank 5, but got rank "+filter.rank}),assert(inDepth===filter.shape[3],function(){return"Error in conv3dDerInput: depth of input ("+inDepth+") must match input depth for filter "+filter.shape[3]+"."}),assert(outDepth===filter.shape[4],function(){return"Error in conv3dDerInput: depth of output ("+outDepth+") must match output depth for filter "+filter.shape[4]+"."});var dilations=1,convInfo=computeConv3DInfo(xShape5D,filter.shape,strides,1,pad),res=ENGINE.runKernelFunc(function(backend){return backend.conv3dDerInput(dy5D,filter,convInfo)},{dy5D:dy5D});return reshapedTo5D?res.as4D(res.shape[1],res.shape[2],res.shape[3],res.shape[4]):res}function conv3dDerFilter_(x,dy,filterShape,strides,pad){var x5D=x;4===x.rank&&(x5D=x.as5D(1,x.shape[0],x.shape[1],x.shape[2],x.shape[3]));var dy5D=dy;4===dy5D.rank&&(dy5D=dy.as5D(1,dy.shape[0],dy.shape[1],dy.shape[2],dy.shape[3])),assert(5===x5D.rank,function(){return"Error in conv3dDerFilter: input must be rank 5, but got shape "+x5D.shape+"."}),assert(5===dy5D.rank,function(){return"Error in conv3dDerFilter: dy must be rank 5, but got shape "+dy5D.shape+"."}),assert(5===filterShape.length,function(){return"Error in conv3dDerFilter: filterShape must be length 5, but got "+filterShape+"."}),assert(x5D.shape[4]===filterShape[3],function(){return"Error in conv3dDerFilter: depth of input "+x5D.shape[4]+") must match input depth in filter ("+filterShape[3]+"."}),assert(dy5D.shape[4]===filterShape[4],function(){return"Error in conv3dDerFilter: depth of dy ("+dy5D.shape[4]+") must match output depth for filter ("+filterShape[4]+")."});var dilations=1,convInfo=computeConv3DInfo(x5D.shape,filterShape,strides,1,pad);return ENGINE.runKernelFunc(function(backend){return backend.conv3dDerFilter(x5D,dy5D,convInfo)},{x5D:x5D,dy5D:dy5D})}function conv3dTranspose_(x,filter,outputShape,strides,pad){var $x,$filter;return conv3dDerInput_(outputShape,convertToTensor(x,"x","conv3dTranspose"),convertToTensor(filter,"filter","conv3dTranspose"),strides,pad)}var conv1d=op({conv1d_:conv1d_}),conv2d=op({conv2d_:conv2d_}),conv3d=op({conv3d_:conv3d_}),conv2dDerFilter=op({conv2dDerFilter_:conv2dDerFilter_}),conv2dDerInput=op({conv2dDerInput_:conv2dDerInput_}),depthwiseConv2d=op({depthwiseConv2d_:depthwiseConv2d_}),depthwiseConv2dDerInput=op({depthwiseConv2dDerInput_:depthwiseConv2dDerInput_}),depthwiseConv2dDerFilter=op({depthwiseConv2dDerFilter_:depthwiseConv2dDerFilter_}),separableConv2d=op({separableConv2d_:separableConv2d_}),conv2dTranspose=op({conv2dTranspose_:conv2dTranspose_}),conv3dTranspose=op({conv3dTranspose_:conv3dTranspose_});function matMul_(a,b,transposeA,transposeB){var _a;void 0===transposeA&&(transposeA=!1),void 0===transposeB&&(transposeB=!1);var $a=convertToTensor(a,"a","matMul"),$b=convertToTensor(b,"b","matMul");_a=makeTypesMatch($a,$b),$a=_a[0],$b=_a[1];var innerShapeA=transposeA?$a.shape[$a.rank-2]:$a.shape[$a.rank-1],innerShapeB=transposeB?$b.shape[$b.rank-1]:$b.shape[$b.rank-2],outerShapeA=transposeA?$a.shape[$a.rank-1]:$a.shape[$a.rank-2],outerShapeB=transposeB?$b.shape[$b.rank-2]:$b.shape[$b.rank-1],outerDimsA=$a.shape.slice(0,-2),outerDimsB=$b.shape.slice(0,-2),batchDimA=sizeFromShape(outerDimsA),batchDimB=sizeFromShape(outerDimsB);assert($a.rank>=2&&$b.rank>=2&&$a.rank===$b.rank,function(){return"Error in matMul: inputs must have the same rank of at least 2, got ranks "+$a.rank+" and "+$b.rank+"."}),assert(arraysEqual(outerDimsA,outerDimsB),function(){return"Error in matMul: outer dimensions ("+outerDimsA+") and ("+outerDimsB+") of Tensors with shapes "+$a.shape+" and "+$b.shape+" must match."}),assert(innerShapeA===innerShapeB,function(){return"Error in matMul: inner shapes ("+innerShapeA+") and ("+innerShapeB+") of Tensors with shapes "+$a.shape+" and "+$b.shape+" and transposeA="+transposeA+" and transposeB="+transposeB+" must match."});var outShape=$a.shape.slice(0,-2).concat([outerShapeA,outerShapeB]),a3D=transposeA?$a.as3D(batchDimA,innerShapeA,outerShapeA):$a.as3D(batchDimA,outerShapeA,innerShapeA),b3D=transposeB?$b.as3D(batchDimB,outerShapeB,innerShapeB):$b.as3D(batchDimB,innerShapeB,outerShapeB),grad=function(dy,saved){var _a=saved,a3D=_a[0],b3D=_a[1];return transposeA||transposeB?!transposeA&&transposeB?{a:function(){return dy.matMul(b3D,!1,!1)},b:function(){return dy.matMul(a3D,!0,!1)}}:transposeA&&!transposeB?{a:function(){return b3D.matMul(dy,!1,!0)},b:function(){return a3D.matMul(dy,!1,!1)}}:{a:function(){return b3D.matMul(dy,!0,!0)},b:function(){return dy.matMul(a3D,!0,!0)}}:{a:function(){return dy.matMul(b3D,!1,!0)},b:function(){return a3D.matMul(dy,!0,!1)}}},attrs={transposeA:transposeA,transposeB:transposeB},res;return ENGINE.runKernelFunc(function(backend,save){var res=backend.batchMatMul(a3D,b3D,transposeA,transposeB);return save([a3D,b3D]),res},{a:a3D,b:b3D},grad,"BatchMatMul",attrs).reshape(outShape)}function outerProduct_(v1,v2){var $v1=convertToTensor(v1,"v1","outerProduct"),$v2=convertToTensor(v2,"v2","outerProduct");return assert(1===$v1.rank&&1===$v2.rank,function(){return"Error in outerProduct: inputs must be rank 1, but got ranks "+$v1.rank+" and "+$v2.rank+"."}),$v1.as2D(-1,1).matMul($v2.as2D(1,-1))}function dot_(t1,t2){var $t1=convertToTensor(t1,"t1","dot"),$t2=convertToTensor(t2,"t2","dot");assert(!(1!==$t1.rank&&2!==$t1.rank||1!==$t2.rank&&2!==$t2.rank),function(){return"Error in dot: inputs must all be rank 1 or 2, but got ranks "+$t1.rank+" and "+$t2.rank+"."});var t1Inner=1===$t1.rank?$t1.size:$t1.shape[1],t2Inner=1===$t2.rank?$t2.size:$t2.shape[0];return assert(t1Inner===t2Inner,function(){return"Error in dot: inner dimensions of inputs must match, but got "+t1Inner+" and "+t2Inner+"."}),1===$t1.rank&&1===$t2.rank?$t1.as2D(1,-1).matMul($t2.as2D(-1,1)).asScalar():1===$t1.rank&&2===$t2.rank?$t1.as2D(1,-1).matMul($t2.as2D($t2.shape[0],$t2.shape[1])).as1D():2===$t1.rank&&1===$t2.rank?$t1.matMul($t2.as2D(-1,1)).as1D():$t1.matMul($t2.as2D($t2.shape[0],$t2.shape[1]))}var matMul=op({matMul_:matMul_}),dot=op({dot_:dot_}),outerProduct=op({outerProduct_:outerProduct_});function reverse1d_(x){var $x=convertToTensor(x,"x","reverse");return assert(1===$x.rank,function(){return"Error in reverse1D: x must be rank 1 but got rank "+$x.rank+"."}),reverse($x,0)}function reverse2d_(x,axis){var $x=convertToTensor(x,"x","reverse");return assert(2===$x.rank,function(){return"Error in reverse2D: x must be rank 2 but got rank "+$x.rank+"."}),reverse($x,axis)}function reverse3d_(x,axis){var $x=convertToTensor(x,"x","reverse");return assert(3===$x.rank,function(){return"Error in reverse3D: x must be rank 3 but got rank "+$x.rank+"."}),reverse($x,axis)}function reverse4d_(x,axis){var $x=convertToTensor(x,"x","reverse");return assert(4===$x.rank,function(){return"Error in reverse4D: x must be rank 4 but got rank "+$x.rank+"."}),reverse($x,axis)}function reverse_(x,axis){var $x=convertToTensor(x,"x","reverse");if(0===$x.rank)return $x.clone();var axes=parseAxisParam(axis,$x.shape),grad=function(dy){return{$x:function(){return dy.reverse(axes)}}},res;return ENGINE.runKernelFunc(function(backend){return backend.reverse($x,axes)},{$x:$x},grad).reshapeAs($x)}var reverse=op({reverse_:reverse_}),reverse1d=op({reverse1d_:reverse1d_}),reverse2d=op({reverse2d_:reverse2d_}),reverse3d=op({reverse3d_:reverse3d_}),reverse4d=op({reverse4d_:reverse4d_});function maxPoolImpl_(x,filterSize,strides,dilations,pad,dimRoundingMode){var $x=convertToTensor(x,"x","maxPool"),x4D=$x,reshapedTo4D=!1;3===$x.rank&&(reshapedTo4D=!0,x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])),null==dilations&&(dilations=[1,1]),assert(4===x4D.rank,function(){return"Error in maxPool: input must be rank 4 but got rank "+x4D.rank+"."}),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in maxPool: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."});var convInfo=computePool2DInfo(x4D.shape,filterSize,strides,dilations,pad,dimRoundingMode);if(1===convInfo.filterWidth&&1===convInfo.filterHeight&&arraysEqual(convInfo.inShape,convInfo.outShape))return $x.clone();var grad=function(dy,saved){var x4D=saved[0],y=saved[1];return{x:function(){return maxPoolBackprop(dy,x4D,y,filterSize,strides,dilations,pad)}}},inputsToSave=[x4D],res=ENGINE.runKernelFunc(function(backend,save){var y=backend.maxPool(x4D,convInfo);return save([x4D,y]),y},{x:x4D},grad,"MaxPool",convInfo,inputsToSave);return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}function maxPool_(x,filterSize,strides,pad,dimRoundingMode){return maxPoolImpl_(x,filterSize,strides,1,pad,dimRoundingMode)}function avgPoolImpl_(x,filterSize,strides,dilations,pad,dimRoundingMode){var $x=convertToTensor(x,"x","avgPool","float32");null==dilations&&(dilations=[1,1]),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"});var x4D=$x,reshapedTo4D=!1;3===$x.rank&&(reshapedTo4D=!0,x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])),assert(4===x4D.rank,function(){return"Error in avgPool: x must be rank 4 but got rank "+x4D.rank+"."}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in avgPool: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."});var convInfo=computePool2DInfo(x4D.shape,filterSize,strides,dilations,pad,dimRoundingMode);if(1===convInfo.filterWidth&&1===convInfo.filterHeight&&arraysEqual(convInfo.inShape,convInfo.outShape))return $x.clone();var grad=function(dy){return{x:function(){return avgPoolBackprop(dy,x4D,filterSize,strides,dilations,pad)}}},res=ENGINE.runKernelFunc(function(backend){return backend.avgPool(x4D,convInfo)},{x:x4D},grad,"AvgPool",convInfo);return res=res.cast($x.dtype),reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}function avgPool_(x,filterSize,strides,pad,dimRoundingMode){return avgPoolImpl_(x,filterSize,strides,1,pad,dimRoundingMode)}function pool_(input,windowShape,poolingType,pad,dilations,strides){null==dilations&&(dilations=[1,1]),null==strides&&(strides=1),0===pad&&(pad="valid");var $x=convertToTensor(input,"x","maxPool"),x4D=$x,reshapedTo4D=!1;3===$x.rank&&(reshapedTo4D=!0,x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in pool: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"});var convInfo=computePool2DInfo(x4D.shape,windowShape,strides,dilations,pad),dilation=[convInfo.dilationHeight,convInfo.dilationWidth],basePadding;basePadding="same"===pad?withSpaceToBatchBasePaddings([convInfo.filterHeight,convInfo.filterWidth],dilation):[[0,0],[0,0]];var isDilationOne=1===dilation[0]&&1===dilation[1],_a=requiredSpaceToBatchPaddings([convInfo.inHeight,convInfo.inWidth],dilation,basePadding),adjustedPadding=_a[0],adjustedCrops=_a[1],convertedPad=isDilationOne?pad:"valid",convertedX=isDilationOne?x4D:spaceToBatchND(x4D,dilation,adjustedPadding),forwardOp,y=("avg"===poolingType?function(){return avgPoolImpl_(convertedX,windowShape,strides,1,convertedPad)}:function(){return maxPoolImpl_(convertedX,windowShape,strides,1,convertedPad)})(),res=isDilationOne?y:batchToSpaceND(y,dilation,adjustedCrops);return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}function maxPoolBackprop(dy,input,output,filterSize,strides,dilations,pad,dimRoundingMode){var $dy=convertToTensor(dy,"dy","maxPoolBackprop"),$input=convertToTensor(input,"input","maxPoolBackprop"),$output=convertToTensor(output,"output","maxPoolBackprop");assert($input.rank===$dy.rank,function(){return"Rank of input ("+$input.rank+") does not match rank of dy ("+$dy.rank+")"}),null==dilations&&(dilations=[1,1]),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"}),assert(4===$dy.rank,function(){return"Error in maxPoolBackprop: dy must be rank 4 but got rank "+$dy.rank+"."}),assert(4===$input.rank,function(){return"Error in maxPoolBackprop: input must be rank 4 but got rank "+$input.rank+"."}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."});var convInfo=computePool2DInfo($input.shape,filterSize,strides,dilations,pad,dimRoundingMode),res;return ENGINE.runKernelFunc(function(backend){return backend.maxPoolBackprop($dy,$input,$output,convInfo)},{$dy:$dy,$input:$input})}function avgPoolBackprop(dy,input,filterSize,strides,dilations,pad){var $dy=convertToTensor(dy,"dy","avgPoolBackprop"),$input=convertToTensor(input,"input","avgPoolBackprop");assert($input.rank===$dy.rank,function(){return"Rank of input ("+$input.rank+") does not match rank of dy ("+$dy.rank+")"}),null==dilations&&(dilations=[1,1]),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"});var input4D=$input,dy4D=$dy,reshapedTo4D=!1;3===$input.rank&&(reshapedTo4D=!0,input4D=$input.as4D(1,$input.shape[0],$input.shape[1],$input.shape[2]),dy4D=$dy.as4D(1,$dy.shape[0],$dy.shape[1],$dy.shape[2])),assert(4===dy4D.rank,function(){return"Error in avgPoolBackprop: dy must be rank 4 but got rank "+dy4D.rank+"."}),assert(4===input4D.rank,function(){return"Error in avgPoolBackprop: input must be rank 4 but got rank "+input4D.rank+"."});var convInfo=computePool2DInfo(input4D.shape,filterSize,strides,dilations,pad),res=ENGINE.runKernelFunc(function(backend){return backend.avgPoolBackprop(dy4D,input4D,convInfo)},{dy4D:dy4D,input4D:input4D});return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}function requiredSpaceToBatchPaddings(inputShape,blockShape,basePadding){var padStart=basePadding.map(function(b){return b[0]}),origPadEnd=basePadding.map(function(b){return b[1]}),fullInputShape=inputShape.concat(padStart,origPadEnd),padEndExtra=blockShape.map(function(b,i){return(b-fullInputShape[i]%b)%b}),padEnd=origPadEnd.map(function(s,i){return s+padEndExtra[i]}),paddings,crops;return[blockShape.map(function(_,i){return[padStart[i],padEnd[i]]}),blockShape.map(function(_,i){return[0,padEndExtra[i]]})]}function withSpaceToBatchBasePaddings(filterShape,dilation){var dilatedFilterShape,padExtraShape=filterShape.map(function(s,i){return s+(s-1)*(dilation[i]-1)}).map(function(s){return s-1}),padExtraStart=padExtraShape.map(function(s){return Math.floor(s/2)}),padExtraEnd=padExtraShape.map(function(s,i){return s-padExtraStart[i]});return padExtraShape.map(function(_,i){return[padExtraStart[i],padExtraEnd[i]]})}function avgPool3d_(x,filterSize,strides,pad,dimRoundingMode,dataFormat,dilations){void 0===dataFormat&&(dataFormat="NDHWC");var $x=convertToTensor(x,"x","avgPool3d","float32"),x5D=$x,reshapedTo5D=!1;4===$x.rank&&(reshapedTo5D=!0,x5D=$x.as5D(1,$x.shape[0],$x.shape[1],$x.shape[2],$x.shape[3])),null==dilations&&(dilations=[1,1,1]),assert(5===x5D.rank,function(){return"Error in avgPool3d: x must be rank 5 but got rank "+x5D.rank+"."}),assert("NDHWC"===dataFormat,function(){return"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of "+dataFormat}),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in avgPool3d: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in avgPool3d: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."});var convInfo=computePool3DInfo(x5D.shape,filterSize,strides,dilations,pad,dimRoundingMode,dataFormat),grad=function(dy){return{x:function(){return avgPool3dBackprop(dy,x5D,filterSize,strides,dilations,pad,dimRoundingMode)}}},res=ENGINE.runKernelFunc(function(backend){return backend.avgPool3d(x5D,convInfo)},{x:x5D},grad);return res=res.cast(x5D.dtype),reshapedTo5D?res.as4D(res.shape[1],res.shape[2],res.shape[3],res.shape[4]):res}function avgPool3dBackprop(dy,input,filterSize,strides,dilations,pad,dimRoundingMode){var $dy=convertToTensor(dy,"dy","avgPool3dBackprop"),$input=convertToTensor(input,"input","avgPool3dBackprop"),dy5D=$dy,input5D=$input,reshapedTo5D=!1;4===$input.rank&&(reshapedTo5D=!0,dy5D=$dy.as5D(1,$dy.shape[0],$dy.shape[1],$dy.shape[2],$dy.shape[3]),input5D=$input.as5D(1,$input.shape[0],$input.shape[1],$input.shape[2],$input.shape[3])),assert(5===dy5D.rank,function(){return"Error in avgPool3dBackprop: dy must be rank 5 but got rank "+dy5D.rank+"."}),assert(5===input5D.rank,function(){return"Error in avgPool3dBackprop: input must be rank 5 but got rank "+input5D.rank+"."}),null==dilations&&(dilations=[1,1,1]),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."});var convInfo=computePool3DInfo(input5D.shape,filterSize,strides,dilations,pad,dimRoundingMode),res=ENGINE.runKernelFunc(function(backend){return backend.avgPool3dBackprop(dy5D,input5D,convInfo)},{dy5D:dy5D,input5D:input5D});return reshapedTo5D?res.as4D(res.shape[1],res.shape[2],res.shape[3],res.shape[4]):res}function maxPool3d_(x,filterSize,strides,pad,dimRoundingMode,dataFormat,dilations){void 0===dataFormat&&(dataFormat="NDHWC");var $x=convertToTensor(x,"x","maxPool3d"),x5D=$x,reshapedTo5D=!1;4===$x.rank&&(reshapedTo5D=!0,x5D=$x.as5D(1,$x.shape[0],$x.shape[1],$x.shape[2],$x.shape[3])),null==dilations&&(dilations=[1,1,1]),assert(5===x5D.rank,function(){return"Error in maxPool3d: x must be rank 5 but got rank "+x5D.rank+"."}),assert("NDHWC"===dataFormat,function(){return"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of "+dataFormat}),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in maxPool3d: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in maxPool3d: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."});var convInfo=computePool3DInfo(x5D.shape,filterSize,strides,dilations,pad,dimRoundingMode,dataFormat),grad=function(dy,saved){var x5D=saved[0],y=saved[1];return{x:function(){return maxPool3dBackprop(dy,x5D,y,filterSize,strides,dilations,pad,dimRoundingMode)}}},res=ENGINE.runKernelFunc(function(backend,save){var y=backend.maxPool3d(x5D,convInfo);return save([x5D,y]),y},{x:x5D},grad);return reshapedTo5D?res.as4D(res.shape[1],res.shape[2],res.shape[3],res.shape[4]):res}function maxPool3dBackprop(dy,input,output,filterSize,strides,dilations,pad,dimRoundingMode){var $dy=convertToTensor(dy,"dy","maxPool3dBackprop"),$input=convertToTensor(input,"input","maxPool3dBackprop"),$output=convertToTensor(output,"output","maxPool3dBackprop"),dy5D=$dy,input5D=$input,output5D=$output,reshapedTo5D=!1;4===$input.rank&&(reshapedTo5D=!0,dy5D=$dy.as5D(1,$dy.shape[0],$dy.shape[1],$dy.shape[2],$dy.shape[3]),input5D=$input.as5D(1,$input.shape[0],$input.shape[1],$input.shape[2],$input.shape[3]),output5D=$output.as5D(1,$output.shape[0],$output.shape[1],$output.shape[2],$output.shape[3])),assert(5===dy5D.rank,function(){return"Error in maxPool3dBackprop: dy must be rank 5 but got rank "+dy5D.rank+"."}),assert(5===input5D.rank,function(){return"Error in maxPool3dBackprop: input must be rank 5 but got rank "+input5D.rank+"."}),assert(5===output5D.rank,function(){return"Error in maxPool3dBackprop: output must be rank 5 but got rank "+output5D.rank+"."}),null==dilations&&(dilations=[1,1,1]),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."});var convInfo=computePool3DInfo(input5D.shape,filterSize,strides,dilations,pad,dimRoundingMode),res=ENGINE.runKernelFunc(function(backend){return backend.maxPool3dBackprop(dy5D,input5D,output5D,convInfo)},{dy5D:dy5D,input5D:input5D});return reshapedTo5D?res.as4D(res.shape[1],res.shape[2],res.shape[3],res.shape[4]):res}function maxPoolWithArgmax_(x,filterSize,strides,pad,includeBatchInIndex){void 0===includeBatchInIndex&&(includeBatchInIndex=!1);var $x=convertToTensor(x,"x","maxPoolWithArgmax"),attrs={filterSize:filterSize,strides:strides,pad:pad,includeBatchInIndex:includeBatchInIndex},result=ENGINE.runKernel("MaxPoolWithArgmax",{x:$x},attrs);return{result:result[0],indexes:result[1]}}var maxPool=op({maxPool_:maxPool_}),avgPool=op({avgPool_:avgPool_}),pool=op({pool_:pool_}),maxPool3d=op({maxPool3d_:maxPool3d_}),avgPool3d=op({avgPool3d_:avgPool3d_}),maxPoolWithArgmax=op({maxPoolWithArgmax_:maxPoolWithArgmax_});function slice1d_(x,begin,size){var $x=convertToTensor(x,"x","slice1d");return assert(1===$x.rank,function(){return"slice1d expects a rank-1 tensor, but got a rank-"+$x.rank+" tensor"}),slice($x,[begin],[size])}function slice2d_(x,begin,size){var $x=convertToTensor(x,"x","slice2d");return assert(2===$x.rank,function(){return"slice2d expects a rank-2 tensor, but got a rank-"+$x.rank+" tensor"}),slice($x,begin,size)}function slice3d_(x,begin,size){var $x=convertToTensor(x,"x","slice3d");return assert(3===$x.rank,function(){return"slice3d expects a rank-3 tensor, but got a rank-"+$x.rank+" tensor"}),slice($x,begin,size)}function slice4d_(x,begin,size){var $x=convertToTensor(x,"x","slice4d");return assert(4===$x.rank,function(){return"slice4d expects a rank-4 tensor, but got a rank-"+$x.rank+" tensor"}),slice($x,begin,size)}function slice_(x,begin,size){var $x=convertToTensor(x,"x","slice"),begin_,size_;if(0===$x.rank)throw new Error("Slicing scalar is not possible");(begin_="number"==typeof begin?[begin].concat(new Array($x.rank-1).fill(0)):begin.length<$x.rank?begin.concat(new Array($x.rank-begin.length).fill(0)):begin.slice()).forEach(function(d){assert(-1!==d,function(){return"slice() does not support negative begin indexing."})}),size_=(size_=null==size?new Array($x.rank).fill(-1):"number"==typeof size?[size].concat(new Array($x.rank-1).fill(-1)):size.length<$x.rank?size.concat(new Array($x.rank-size.length).fill(-1)):size).map(function(d,i){return d>=0?d:(assert(-1===d,function(){return"Negative size values should be exactly -1 but got "+d+" for the slice() size at index "+i+"."}),$x.shape[i]-begin_[i])}),assertParamsValid($x,begin_,size_);var inputShape=$x.shape,grad=function(dy){for(var paddings=[],i=0;i<dy.rank;i++)paddings.push([begin_[i],inputShape[i]-begin_[i]-size_[i]]);return{x:function(){return pad(dy,paddings)}}},attrs={begin:begin_,size:size_};return ENGINE.runKernelFunc(function(backend){return backend.slice($x,begin_,size_)},{x:$x},grad,"Slice",attrs)}var slice=op({slice_:slice_}),slice1d=op({slice1d_:slice1d_}),slice2d=op({slice2d_:slice2d_}),slice3d=op({slice3d_:slice3d_}),slice4d=op({slice4d_:slice4d_});function logSumExp_(x,axis,keepDims){void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1);var $x=convertToTensor(x,"x","logSumExp"),axes=parseAxisParam(axis,$x.shape),xMax=$x.max(axes,!0),a,b,c,d=$x.sub(xMax).exp().sum(axes).log(),res=xMax.reshape(d.shape).add(d);if(keepDims){var newShape=expandShapeToKeepDim(res.shape,axes);return res.reshape(newShape)}return res}function sum_(x,axis,keepDims){void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1);var $x=convertToTensor(x,"x","sum");"bool"===$x.dtype&&($x=$x.toInt());var axes=parseAxisParam(axis,$x.shape),customOp;return customGrad(function(x){var permutation=getAxesPermutation(axes,x.rank),reductionAxes=axes,permutedX=x;null!=permutation&&(permutedX=x.transpose(permutation),reductionAxes=getInnerMostAxes(reductionAxes.length,x.rank));var gradFunc=function(dy){var expandedDyShape=x.shape.slice(),expandedDy,derX;return axes.forEach(function(axis){expandedDyShape[axis]=1}),dy.reshape(expandedDyShape).mul(ones$1(x.shape,"float32"))},gradInputs=function(dy){return{x:function(){return gradFunc(dy)}}},attrs={axes:reductionAxes},value=ENGINE.runKernelFunc(function(backend){return backend.sum(permutedX,reductionAxes)},{x:permutedX},gradInputs,"Sum",attrs);if(keepDims){var newShape=expandShapeToKeepDim(value.shape,axes);value=value.reshape(newShape)}return{value:value,gradFunc:gradFunc}})($x)}function prod_(x,axis,keepDims){void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1);var $x=convertToTensor(x,"x","prod");"bool"===$x.dtype&&($x=$x.toInt());var axes=parseAxisParam(axis,$x.shape),permutation=getAxesPermutation(axes,$x.rank),reductionAxes=axes,permutedX=$x;null!=permutation&&(permutedX=$x.transpose(permutation),reductionAxes=getInnerMostAxes(reductionAxes.length,$x.rank));var value=ENGINE.runKernelFunc(function(backend){return backend.prod(permutedX,reductionAxes)},{permutedX:permutedX});if(keepDims){var newShape=expandShapeToKeepDim(value.shape,axes);value=value.reshape(newShape)}return value}function mean_(x,axis,keepDims){void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1);var $x=convertToTensor(x,"x","mean"),axes=parseAxisParam(axis,$x.shape),shapes,reduceShape,reduceSize=sizeFromShape(computeOutAndReduceShapes($x.shape,axes)[1]),customOp;return customGrad(function(x){var reduceSizeScalar=scalar(reduceSize),xReduce,res,value,gradFunc;return{value:(reduceSizeScalar.dtype===x.dtype?x:x.cast(reduceSizeScalar.dtype)).div(reduceSizeScalar).sum(axis,keepDims),gradFunc:function(dy){var expandedDyShape=x.shape.slice(),expandedDy,derX;return axes.forEach(function(axis){expandedDyShape[axis]=1}),dy.reshape(expandedDyShape).mul(ones$1(x.shape,"float32")).div(reduceSize)}}})($x)}function gradForMinAndMax(dy,y,xOrig,origAxes,permutedAxes){return y.rank<xOrig.rank&&(y=y.reshape(expandShapeToKeepDim(y.shape,origAxes))),dy.rank<xOrig.rank&&(dy=dy.reshape(expandShapeToKeepDim(dy.shape,origAxes))),{x:function(){var dx=dy.mul(xOrig.equal(y).cast(dy.dtype));return null==permutedAxes?dx:dx.transpose(permutedAxes)}}}function min_(x,axis,keepDims){void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1);var $x=convertToTensor(x,"x","min"),xOrig=$x,origAxes=parseAxisParam(axis,$x.shape),axes=origAxes,permutedAxes=getAxesPermutation(axes,$x.rank);null!=permutedAxes&&($x=$x.transpose(permutedAxes),axes=getInnerMostAxes(axes.length,$x.rank));var grad=function(dy,saved){return gradForMinAndMax(dy,saved[1],saved[0],origAxes,permutedAxes)},inputsToSave=[$x],outputsToSave=[!0],res=ENGINE.runKernelFunc(function(backend,save){var y=backend.min($x,axes);return save([xOrig,y]),y},{x:$x},grad,"Min",{axes:axes},inputsToSave,outputsToSave);if(keepDims){var newShape=expandShapeToKeepDim(res.shape,origAxes);res=res.reshape(newShape)}return res}function max_(x,axis,keepDims){void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1);var $x=convertToTensor(x,"x","max"),xOrig=$x,origAxes=parseAxisParam(axis,$x.shape),axes=origAxes,permutedAxes=getAxesPermutation(axes,$x.rank);null!=permutedAxes&&($x=$x.transpose(permutedAxes),axes=getInnerMostAxes(axes.length,$x.rank));var grad=function(dy,saved){return gradForMinAndMax(dy,saved[1],saved[0],origAxes,permutedAxes)},inputsToSave=[$x],outputsToSave=[!0],res=ENGINE.runKernelFunc(function(backend,save){var y=backend.max($x,axes);return save([xOrig,y]),y},{x:$x},grad,"Max",{axes:axes},inputsToSave,outputsToSave);if(keepDims){var newShape=expandShapeToKeepDim(res.shape,origAxes);res=res.reshape(newShape)}return res}function argMin_(x,axis){void 0===axis&&(axis=0);var $x=convertToTensor(x,"x","argMin");null==axis&&(axis=0);var axes=parseAxisParam(axis,$x.shape),permutedAxes=getAxesPermutation(axes,$x.rank);null!=permutedAxes&&($x=$x.transpose(permutedAxes),axes=getInnerMostAxes(axes.length,$x.rank));var grad=function(dy,saved){var $x=saved[0];return{$x:function(){return zerosLike($x)}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.argMin($x,axes[0]);return save([$x]),res},{$x:$x},grad)}function argMax_(x,axis){void 0===axis&&(axis=0);var $x=convertToTensor(x,"x","argMax");null==axis&&(axis=0);var axes=parseAxisParam(axis,$x.shape),permutedAxes=getAxesPermutation(axes,$x.rank);null!=permutedAxes&&($x=$x.transpose(permutedAxes),axes=getInnerMostAxes(axes.length,$x.rank));var grad=function(dy,saved){var $x=saved[0];return{x:function(){return zerosLike($x)}}},attrs={axis:axes[0]},inputsToSave=[$x];return ENGINE.runKernelFunc(function(backend,save){var res=backend.argMax($x,axes[0]);return save([$x]),res},{x:$x},grad,"ArgMax",attrs,inputsToSave)}function all_(x,axis,keepDims){void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1);var $x=convertToTensor(x,"x","all","bool"),origAxes=parseAxisParam(axis,$x.shape),axes=origAxes,permutedAxes=getAxesPermutation(axes,$x.rank);null!=permutedAxes&&($x=$x.transpose(permutedAxes),axes=getInnerMostAxes(axes.length,$x.rank));var res=ENGINE.runKernelFunc(function(backend){return backend.all($x,axes)},{$x:$x});if(keepDims){var newShape=expandShapeToKeepDim(res.shape,origAxes);return res.reshape(newShape)}return res}function any_(x,axis,keepDims){void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1);var $x=convertToTensor(x,"x","any","bool"),origAxes=parseAxisParam(axis,$x.shape),axes=origAxes,permutedAxes=getAxesPermutation(axes,$x.rank);null!=permutedAxes&&($x=$x.transpose(permutedAxes),axes=getInnerMostAxes(axes.length,$x.rank));var res=ENGINE.runKernelFunc(function(backend){return backend.any($x,axes)},{$x:$x});if(keepDims){var newShape=expandShapeToKeepDim(res.shape,origAxes);return res.reshape(newShape)}return res}function moments_(x,axis,keepDims){void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1);var axes=parseAxisParam(axis,(x=convertToTensor(x,"x","moments")).shape),mean=x.mean(axes,keepDims),keepDimsShape=mean.shape,devSquared,variance;return keepDims||(keepDimsShape=expandShapeToKeepDim(mean.shape,axes)),{mean:mean,variance:x.toFloat().sub(mean.reshape(keepDimsShape)).square().mean(axes,keepDims)}}var all=op({all_:all_}),any=op({any_:any_}),argMax=op({argMax_:argMax_}),argMin=op({argMin_:argMin_}),logSumExp=op({logSumExp_:logSumExp_}),max=op({max_:max_}),mean=op({mean_:mean_}),min=op({min_:min_}),moments=op({moments_:moments_}),sum$1=op({sum_:sum_}),prod=op({prod_:prod_});function relu_(x){var $x=convertToTensor(x,"x","relu");if("bool"===$x.dtype)return $x.toInt();var grad=function(dy,saved){var $x=saved[0];return{x:function(){return dy.mulStrict($x.step().toFloat())}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.relu($x);return save([$x]),res},{x:$x},grad,"Relu")}function relu6_(x){var $x=convertToTensor(x,"x","relu6");if("bool"===$x.dtype)return $x.toInt();var grad=function(dy,saved){var $x=saved[0],mask=$x.lessEqual(6).mul($x.step());return{x:function(){return dy.mulStrict(mask.toFloat())}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.relu6($x);return save([$x]),res},{x:$x},grad,"Relu6")}function elu_(x){var $x=convertToTensor(x,"x","elu"),grad=function(dy,saved){var y=saved[0];return{$x:function(){return ENGINE.runKernelFunc(function(backend){return backend.eluDer(dy,y)},{dy:dy,y:y})}}};return ENGINE.runKernelFunc(function(backend,save){var y=backend.elu($x);return save([y]),y},{$x:$x},grad)}function selu_(x){var $x=convertToTensor(x,"x","selu"),grad=function(dy,saved){var $x=saved[0];return{$x:function(){var mask=$x.greater(scalar(0)),scaleAlpha=scalar(SELU_SCALEALPHA),scale=scalar(SELU_SCALE),greaterThanZeroDer=dy.mul(scale),lessEqualZeroDer=dy.mul(scaleAlpha).mul($x.toFloat().exp());return where(mask,greaterThanZeroDer,lessEqualZeroDer)}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.selu($x);return save([$x]),res},{$x:$x},grad)}function leakyRelu_(x,alpha){void 0===alpha&&(alpha=.2);var $x=convertToTensor(x,"x","leakyRelu");return maximum(scalar(alpha).mul($x),$x)}function prelu_(x,alpha){var $x=convertToTensor(x,"x","prelu"),$alpha=convertToTensor(alpha,"alpha","prelu"),grad=function(dy,saved){var $x=saved[0],$alpha=saved[1],mask=$x.greater(0);return{x:function(){return where(mask,dy,dy.mul($alpha))},alpha:function(){var res=where(mask,zerosLike(dy),dy.mul($x)),reduceAxes=getReductionAxes($alpha.shape,dy.shape);return reduceAxes.length>0&&(res=res.sum(reduceAxes)),res.reshape($alpha.shape)}}};return ENGINE.runKernelFunc(function(backend,save){var res=backend.prelu($x,$alpha);return save([$x,$alpha]),res},{x:$x,alpha:$alpha},grad,"Prelu")}var elu=op({elu_:elu_}),leakyRelu=op({leakyRelu_:leakyRelu_}),prelu=op({prelu_:prelu_}),relu=op({relu_:relu_}),relu6=op({relu6_:relu6_}),selu=op({selu_:selu_});function localResponseNormalization_(x,depthRadius,bias,alpha,beta){void 0===depthRadius&&(depthRadius=5),void 0===bias&&(bias=1),void 0===alpha&&(alpha=1),void 0===beta&&(beta=.5);var $x=convertToTensor(x,"x","localResponseNormalization");assert(4===$x.rank||3===$x.rank,function(){return"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank "+$x.rank+"."}),assert(isInt(depthRadius),function(){return"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius "+depthRadius+"."});var x4D=$x,reshapedTo4D=!1;3===$x.rank&&(reshapedTo4D=!0,x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2]));var backward=function(dy,saved){var x4D=saved[0],y=saved[1];return{x4D:function(){return ENGINE.runKernelFunc(function(backend){return backend.LRNGrad(dy,x4D,y,depthRadius,bias,alpha,beta)},{})}}},res=ENGINE.runKernelFunc(function(backend,save){var y=backend.localResponseNormalization4D(x4D,depthRadius,bias,alpha,beta);return save([x4D,y]),y},{x4D:x4D},backward);return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}var localResponseNormalization=op({localResponseNormalization_:localResponseNormalization_});function norm_(x,ord,axis,keepDims){void 0===ord&&(ord="euclidean"),void 0===axis&&(axis=null),void 0===keepDims&&(keepDims=!1);var norm=normImpl(x=convertToTensor(x,"x","norm"),ord,axis),keepDimsShape=norm.shape;if(keepDims){var axes=parseAxisParam(axis,x.shape);keepDimsShape=expandShapeToKeepDim(norm.shape,axes)}return norm.reshape(keepDimsShape)}function normImpl(x,p,axis){if(void 0===axis&&(axis=null),0===x.rank)return x.abs();if(1!==x.rank&&null===axis)return normImpl(x.reshape([-1]),p,axis);if(1===x.rank||"number"==typeof axis||Array.isArray(axis)&&1===axis.length){if(1===p)return x.abs().sum(axis);if(p===1/0)return x.abs().max(axis);if(p===-1/0)return x.abs().min(axis);if("euclidean"===p||2===p)return x.abs().pow(scalar(2,"int32")).sum(axis).sqrt();throw new Error("Error in norm: invalid ord value: "+p)}if(Array.isArray(axis)&&2===axis.length){if(1===p)return x.abs().sum(axis[0]).max(axis[1]-1);if(p===1/0)return x.abs().sum(axis[1]).max(axis[0]);if(p===-1/0)return x.abs().sum(axis[1]).min(axis[0]);if("fro"===p||"euclidean"===p)return x.square().sum(axis).sqrt();throw new Error("Error in norm: invalid ord value: "+p)}throw new Error("Error in norm: invalid axis: "+axis)}var norm=op({norm_:norm_});function multiRNNCell_(lstmCells,data,c,h){for(var $data=convertToTensor(data,"data","multiRNNCell"),$c=convertToTensorArray(c,"c","multiRNNCell"),$h=convertToTensorArray(h,"h","multiRNNCell"),input=$data,newStates=[],i=0;i<lstmCells.length;i++){var output=lstmCells[i](input,$c[i],$h[i]);newStates.push(output[0]),newStates.push(output[1]),input=output[1]}for(var newC=[],newH=[],i=0;i<newStates.length;i+=2)newC.push(newStates[i]),newH.push(newStates[i+1]);return[newC,newH]}function basicLSTMCell_(forgetBias,lstmKernel,lstmBias,data,c,h){var $forgetBias=convertToTensor(forgetBias,"forgetBias","basicLSTMCell"),$lstmKernel=convertToTensor(lstmKernel,"lstmKernel","basicLSTMCell"),$lstmBias=convertToTensor(lstmBias,"lstmBias","basicLSTMCell"),$data=convertToTensor(data,"data","basicLSTMCell"),$c=convertToTensor(c,"c","basicLSTMCell"),$h=convertToTensor(h,"h","basicLSTMCell"),combined,weighted,res=$data.concat($h,1).matMul($lstmKernel).add($lstmBias),batchSize=res.shape[0],sliceCols=res.shape[1]/4,sliceSize=[batchSize,sliceCols],i=res.slice([0,0],sliceSize),j=res.slice([0,sliceCols],sliceSize),f=res.slice([0,2*sliceCols],sliceSize),o=res.slice([0,3*sliceCols],sliceSize),newC=i.sigmoid().mulStrict(j.tanh()).addStrict($c.mulStrict($forgetBias.add(f).sigmoid())),newH;return[newC,newC.tanh().mulStrict(o.sigmoid())]}var basicLSTMCell=op({basicLSTMCell_:basicLSTMCell_}),multiRNNCell=op({multiRNNCell_:multiRNNCell_});function movingAverage_(v,x,decay,step,zeroDebias){void 0===zeroDebias&&(zeroDebias=!0);var $v=convertToTensor(v,"v","movingAverage"),$x=convertToTensor(x,"x","movingAverage"),$decay=convertToTensor(decay,"decay","movingAverage");assertTypesMatch($v,$x),assert(arraysEqual($v.shape,$x.shape),function(){return"Shape mismatch in v and x"});var one=scalar(1),oneMinusDecay=one.sub($decay),update=$x.sub($v).mul(oneMinusDecay);if(zeroDebias){assert(null!=step,function(){return"When using zeroDebias: true, step is required."});var $step=convertToTensor(step,"step","movingAverage");update=update.div(one.sub(pow($decay,$step)))}return $v.add(update)}var movingAverage=op({movingAverage_:movingAverage_});function stridedSlice_(x,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask){if(void 0===beginMask&&(beginMask=0),void 0===endMask&&(endMask=0),void 0===ellipsisMask&&(ellipsisMask=0),void 0===newAxisMask&&(newAxisMask=0),void 0===shrinkAxisMask&&(shrinkAxisMask=0),null==strides&&(strides=new Array(begin.length)),0!==ellipsisMask)throw new Error("ellipsis mask is not yet supported");var $x=convertToTensor(x,"x","stridedSlice"),expandAxes=maskToAxes(newAxisMask),newShape=$x.shape.slice();expandAxes.forEach(function(axis){begin[axis]=0,end[axis]=1,newShape.splice(axis,0,1)}),$x=$x.reshape(newShape);for(var axis=0;axis<$x.rank;axis++)begin[axis]=startForAxis(beginMask,begin,strides,$x.shape,axis),end[axis]=stopForAxis(endMask,end,strides,$x.shape,axis),strides[axis]=strides[axis]||1;var shrinkAxes=maskToAxes(shrinkAxisMask);shrinkAxes.forEach(function(axis){end[axis]=begin[axis]+1,strides[axis]=1});var size=computeOutShape$2(begin,end,strides),outShape=size.filter(function(_,axis){return-1===shrinkAxes.indexOf(axis)}),nonStrided,res;return strides.every(function(v){return 1===v})?slice($x,begin,size).reshape(outShape):ENGINE.runKernelFunc(function(backend){return backend.stridedSlice($x,begin,end,strides)},{$x:$x}).reshape(outShape)}var stridedSlice=op({stridedSlice_:stridedSlice_});function topk_(x,k,sorted){void 0===k&&(k=1),void 0===sorted&&(sorted=!0);var $x=convertToTensor(x,"x","topk");if(0===$x.rank)throw new Error("topk() expects the input to be of rank 1 or higher");var lastDim=$x.shape[$x.shape.length-1];if(k>lastDim)throw new Error("'k' passed to topk() must be <= the last dimension ("+lastDim+") but got "+k);var _a=ENGINE.runKernelFunc(function(b){return b.topk($x,k,sorted)},{$x:$x}),values,indices;return{values:_a[0],indices:_a[1]}}var topk=op({topk_:topk_});function scatterND_(indices,updates,shape){var $indices=convertToTensor(indices,"indices","scatterND","int32"),$updates=convertToTensor(updates,"updates","scatterND");return validateInput($updates,$indices,shape),ENGINE.runKernelFunc(function(backend){return backend.scatterND($indices,$updates,shape)},{indices:$indices,updates:$updates},null,"ScatterNd",{shape:shape})}var scatterND=op({scatterND_:scatterND_});function fft_(input){assert("complex64"===input.dtype,function(){return"The dtype for tf.spectral.fft() must be complex64 but got "+input.dtype+"."});var innerDimensionSize=input.shape[input.shape.length-1],batch=input.size/innerDimensionSize,input2D=input.as2D(batch,innerDimensionSize),ret;return ENGINE.runKernelFunc(function(backend){return backend.fft(input2D)},{input:input}).reshape(input.shape)}function ifft_(input){assert("complex64"===input.dtype,function(){return"The dtype for tf.spectral.ifft() must be complex64 but got "+input.dtype+"."});var innerDimensionSize=input.shape[input.shape.length-1],batch=input.size/innerDimensionSize,input2D=input.as2D(batch,innerDimensionSize),ret;return ENGINE.runKernelFunc(function(backend){return backend.ifft(input2D)},{input:input}).reshape(input.shape)}function rfft_(input,fftLength){assert("float32"===input.dtype,function(){return"The dtype for rfft() must be real value but got "+input.dtype});var innerDimensionSize=input.shape[input.shape.length-1],batch=input.size/innerDimensionSize,adjustedInput;if(null!=fftLength&&fftLength<innerDimensionSize){var begin=input.shape.map(function(v){return 0}),size=input.shape.map(function(v){return v});size[input.shape.length-1]=fftLength,adjustedInput=input.slice(begin,size),innerDimensionSize=fftLength}else if(null!=fftLength&&fftLength>innerDimensionSize){var zerosShape=input.shape.map(function(v){return v});zerosShape[input.shape.length-1]=fftLength-innerDimensionSize,adjustedInput=input.concat(zeros(zerosShape),input.shape.length-1),innerDimensionSize=fftLength}else adjustedInput=input;var zerosInput=adjustedInput.zerosLike(),complexInput=complex(adjustedInput,zerosInput).as2D(batch,innerDimensionSize),ret=fft(complexInput),half=Math.floor(innerDimensionSize/2)+1,realValues=real(ret),imagValues=imag(ret),realComplexConjugate=realValues.split([half,innerDimensionSize-half],realValues.shape.length-1),imagComplexConjugate=imagValues.split([half,innerDimensionSize-half],imagValues.shape.length-1),outputShape=adjustedInput.shape.slice();return outputShape[adjustedInput.shape.length-1]=half,complex(realComplexConjugate[0],imagComplexConjugate[0]).reshape(outputShape)}function irfft_(input){var innerDimensionSize=input.shape[input.shape.length-1],batch=input.size/innerDimensionSize;if(innerDimensionSize<=2){var complexInput=input.as2D(batch,innerDimensionSize),ret=ifft(complexInput);return real(ret)}var outputShape=[batch,2*(innerDimensionSize-1)],realInput=real(input).as2D(batch,innerDimensionSize),imagInput=imag(input).as2D(batch,innerDimensionSize),realConjugate=realInput.slice([0,1],[batch,innerDimensionSize-2]).reverse(1),imagConjugate=imagInput.slice([0,1],[batch,innerDimensionSize-2]).reverse(1).mul(scalar(-1)),r=realInput.concat(realConjugate,1),i=imagInput.concat(imagConjugate,1),complexInput=complex(r,i).as2D(outputShape[0],outputShape[1]),ret=ifft(complexInput);return real(ret)}var fft=op({fft_:fft_}),ifft=op({ifft_:ifft_}),rfft=op({rfft_:rfft_}),irfft=op({irfft_:irfft_}),spectral_ops=Object.freeze({fft:fft,ifft:ifft,rfft:rfft,irfft:irfft});function validateInput$1(sparseIndices,sparseValues,outputShape,defaultValues){if("int32"!==sparseIndices.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+sparseIndices.dtype+".");if(sparseIndices.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+sparseIndices.shape+".");var numElems=sparseIndices.rank>0?sparseIndices.shape[0]:1,numDims=sparseIndices.rank>1?sparseIndices.shape[1]:1;if(outputShape.length!==numDims)throw new Error("outputShape has incorrect number of elements:, "+outputShape.length+", should be: "+numDims+".");var numValues=sparseValues.size;if(0!==sparseValues.rank&&(1!==sparseValues.rank||numValues!==numElems))throw new Error("sparseValues has incorrect shape "+sparseValues.shape+", should be [] or ["+numElems+"]");if(sparseValues.dtype!==defaultValues.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function sparseToDense_(sparseIndices,sparseValues,outputShape,defaultValue){void 0===defaultValue&&(defaultValue=0);var $sparseIndices=convertToTensor(sparseIndices,"sparseIndices","sparseToDense","int32"),$sparseValues=convertToTensor(sparseValues,"sparseValues","sparseToDense"),$defaultValue=convertToTensor(defaultValue,"defaultValue","sparseToDense",$sparseValues.dtype);return validateInput$1($sparseIndices,$sparseValues,outputShape,$defaultValue),ENGINE.runKernelFunc(function(backend){return backend.sparseToDense($sparseIndices,$sparseValues,outputShape,$defaultValue)},{$sparseIndices:$sparseIndices,$sparseValues:$sparseValues,$defaultValue:$defaultValue})}var sparseToDense=op({sparseToDense_:sparseToDense_});function gatherND_(x,indices){var $indices=convertToTensor(indices,"indices","gatherND","int32"),$x=convertToTensor(x,"x","gatherND");return ENGINE.runKernelFunc(function(backend){return backend.gatherND($x,$indices)},{x:$x,indices:$indices},null,"GatherNd")}var gatherND=op({gatherND_:gatherND_});function diag_(x){var $x=convertToTensor(x,"x","diag").flatten(),outShape=x.shape.concat(x.shape);return ENGINE.runKernelFunc(function(backend){return backend.diag($x)},{$x:$x}).reshape(outShape)}var diag=op({diag_:diag_});function getNoiseShape(x,noiseShape){if(null==noiseShape)return x.shape.slice();if(arraysEqual(x.shape,noiseShape))return noiseShape;if(x.shape.length===noiseShape.length){for(var newDimension=[],i=0;i<x.shape.length;i++)null==noiseShape[i]&&null!=x.shape[i]?newDimension.push(x.shape[i]):newDimension.push(noiseShape[i]);return newDimension}return noiseShape}function dropout_(x,rate,noiseShape,seed){var $x=convertToTensor(x,"x","dropout");if(assert("float32"===$x.dtype,function(){return"x has to be a floating point tensor since it's going to be scaled, but got a "+$x.dtype+" tensor instead."}),assert(rate>=0&&rate<1,function(){return"rate must be a float in the range [0, 1), but got "+rate+"."}),0===rate)return x instanceof Tensor?$x.clone():$x;var $noiseShape=getNoiseShape($x,noiseShape),keepProb=1-rate,multiplier=randomUniform($noiseShape,0,1,"float32",seed).add(keepProb).floor().div(keepProb);return $x.mul(multiplier)}var dropout=op({dropout_:dropout_});function hannWindow_(windowLength){return cosineWindow(windowLength,.5,.5)}function hammingWindow_(windowLength){return cosineWindow(windowLength,.54,.46)}function frame_(signal,frameLength,frameStep,padEnd,padValue){void 0===padEnd&&(padEnd=!1),void 0===padValue&&(padValue=0);for(var start=0,output=[];start+frameLength<=signal.size;)output.push(slice(signal,start,frameLength)),start+=frameStep;if(padEnd)for(;start<signal.size;){var padLen=start+frameLength-signal.size,pad=concat([slice(signal,start,frameLength-padLen),fill([padLen],padValue)]);output.push(pad),start+=frameStep}return 0===output.length?tensor2d([],[0,frameLength]):concat(output).as2D(output.length,frameLength)}function stft_(signal,frameLength,frameStep,fftLength,windowFn){void 0===windowFn&&(windowFn=hannWindow),null==fftLength&&(fftLength=enclosingPowerOfTwo(frameLength));for(var framedSignal=frame(signal,frameLength,frameStep),windowedSignal=mul(framedSignal,windowFn(frameLength)),output=[],i=0;i<framedSignal.shape[0];i++)output.push(rfft(windowedSignal.slice([i,0],[1,frameLength]),fftLength));return concat(output)}function enclosingPowerOfTwo(value){return Math.floor(Math.pow(2,Math.ceil(Math.log(value)/Math.log(2))))}function cosineWindow(windowLength,a,b){for(var even=1-windowLength%2,newValues=new Float32Array(windowLength),i=0;i<windowLength;++i){var cosArg=2*Math.PI*i/(windowLength+even-1);newValues[i]=a-b*Math.cos(cosArg)}return tensor1d(newValues,"float32")}var hannWindow=op({hannWindow_:hannWindow_}),hammingWindow=op({hammingWindow_:hammingWindow_}),frame=op({frame_:frame_}),stft=op({stft_:stft_}),signal_ops=Object.freeze({hannWindow:hannWindow,hammingWindow:hammingWindow,frame:frame,stft:stft});function inTopKAsync_(predictions,targets,k){return void 0===k&&(k=1),__awaiter(this,void 0,void 0,function(){var $predictions,$targets,lastDim,predictionsVals,targetsVals,_a,batch,size,precision,b,offset,vals,valAndInd,i,i;return __generator(this,function(_b){switch(_b.label){case 0:return $predictions=convertToTensor(predictions,"predictions","inTopK"),$targets=convertToTensor(targets,"targets","inTopK"),assert($predictions.rank>1,function(){return"inTopK() expects the predictions to be of rank 2 or higher, but got "+$predictions.rank}),assert($predictions.rank-1===$targets.rank,function(){return"predictions rank should be 1 larger than targets rank, but got predictions rank "+$predictions.rank+" and targets rank "+$targets.rank}),assertShapesMatch($predictions.shape.slice(0,$predictions.shape.length-1),$targets.shape,"predictions's shape should be align with the targets' shape, except the last dimension."),lastDim=$predictions.shape[$predictions.shape.length-1],assert(k>0&&k<=lastDim,function(){return"'k' passed to inTopK() must be > 0 && <= the predictions last dimension ("+lastDim+"), but got "+k}),[4,$predictions.data()];case 1:return predictionsVals=_b.sent(),[4,$targets.data()];case 2:for(targetsVals=_b.sent(),_a=[predictionsVals.length/lastDim,lastDim],batch=_a[0],size=_a[1],precision=getTypedArrayFromDType("bool",batch),b=0;b<batch;b++){for(offset=b*size,vals=predictionsVals.subarray(offset,offset+size),valAndInd=[],i=0;i<vals.length;i++)valAndInd.push({value:vals[i],index:i});for(valAndInd.sort(function(a,b){return b.value-a.value}),precision[b]=0,i=0;i<k;i++)if(valAndInd[i].index===targetsVals[b]){precision[b]=1;break}}return predictions!==$predictions&&$predictions.dispose(),targets!==$targets&&$targets.dispose(),[2,tensor(precision,$targets.shape,"bool")]}})})}var inTopKAsync=inTopKAsync_,Reduction;function computeWeightedLoss_(losses,weights,reduction){void 0===reduction&&(reduction=exports.Reduction.SUM_BY_NONZERO_WEIGHTS);var $losses=convertToTensor(losses,"losses","computeWeightedLoss"),$weights=null;null!=weights&&($weights=convertToTensor(weights,"weights","computeWeightedLoss"));var weightedLoss=null==$weights?$losses:$losses.mul($weights);if(reduction===exports.Reduction.NONE)return weightedLoss;if(reduction===exports.Reduction.SUM)return weightedLoss.sum();if(reduction===exports.Reduction.MEAN){if(null==$weights)return weightedLoss.mean();var broadcastFactor=$losses.size/$weights.size,result=weightedLoss.sum().div($weights.sum());return broadcastFactor>1?result.div(scalar(broadcastFactor)):result}if(reduction===exports.Reduction.SUM_BY_NONZERO_WEIGHTS){if(null==$weights)return weightedLoss.sum().div(scalar($losses.size));var broadcastedWeights,numNonZeros=$weights.mul(ones$1($losses.shape)).notEqual(scalar(0)).sum().toFloat();return weightedLoss.sum().div(numNonZeros)}throw Error("Unknown reduction: "+reduction)}function absoluteDifference_(labels,predictions,weights,reduction){void 0===reduction&&(reduction=exports.Reduction.SUM_BY_NONZERO_WEIGHTS);var $labels=convertToTensor(labels,"labels","absoluteDifference"),$predictions=convertToTensor(predictions,"predictions","absoluteDifference"),$weights=null;null!=weights&&($weights=convertToTensor(weights,"weights","absoluteDifference")),assertShapesMatch($labels.shape,$predictions.shape,"Error in absoluteDifference: ");var losses=$labels.sub($predictions).abs();return computeWeightedLoss(losses,$weights,reduction)}function meanSquaredError_(labels,predictions,weights,reduction){void 0===reduction&&(reduction=exports.Reduction.SUM_BY_NONZERO_WEIGHTS);var $labels=convertToTensor(labels,"labels","meanSquaredError"),$predictions=convertToTensor(predictions,"predictions","meanSquaredError"),$weights=null;null!=weights&&($weights=convertToTensor(weights,"weights","meanSquaredError")),assertShapesMatch($labels.shape,$predictions.shape,"Error in meanSquaredError: ");var losses=$labels.squaredDifference($predictions);return computeWeightedLoss(losses,$weights,reduction)}function cosineDistance_(labels,predictions,axis,weights,reduction){void 0===reduction&&(reduction=exports.Reduction.SUM_BY_NONZERO_WEIGHTS);var $labels=convertToTensor(labels,"labels","cosineDistance"),$predictions=convertToTensor(predictions,"predictions","cosineDistance"),$weights=null;null!=weights&&($weights=convertToTensor(weights,"weights","cosineDistance")),assertShapesMatch($labels.shape,$predictions.shape,"Error in cosineDistance: ");var one,losses=scalar(1).sub($labels.mul($predictions).sum(axis,!0));return computeWeightedLoss(losses,$weights,reduction)}function hingeLoss_(labels,predictions,weights,reduction){void 0===reduction&&(reduction=exports.Reduction.SUM_BY_NONZERO_WEIGHTS);var $labels=convertToTensor(labels,"labels","hingeLoss"),$predictions=convertToTensor(predictions,"predictions","hingeLoss"),$weights=null;null!=weights&&($weights=convertToTensor(weights,"weights","hingeLoss")),assertShapesMatch($labels.shape,$predictions.shape,"Error in hingeLoss: ");var one=scalar(1);$labels=scalar(2).mul($labels).sub(one);var losses=one.sub($labels.mul($predictions)).relu();return computeWeightedLoss(losses,$weights,reduction)}function logLoss_(labels,predictions,weights,epsilon,reduction){void 0===epsilon&&(epsilon=1e-7),void 0===reduction&&(reduction=exports.Reduction.SUM_BY_NONZERO_WEIGHTS);var $labels=convertToTensor(labels,"labels","logLoss"),$predictions=convertToTensor(predictions,"predictions","logLoss"),$weights=null;null!=weights&&($weights=convertToTensor(weights,"weights","logLoss")),assertShapesMatch($labels.shape,$predictions.shape,"Error in logLoss: ");var one=scalar(1),epsilonScalar=scalar(epsilon),losses=$labels.mul($predictions.add(epsilonScalar).log()).neg().sub(one.sub($labels).mul(one.sub($predictions).add(epsilonScalar).log()));return computeWeightedLoss(losses,$weights,reduction)}function sigmoidCrossEntropyWithLogits_(labels,logits){var $labels=convertToTensor(labels,"labels","sigmoidCrossEntropyWithLogits"),$logits=convertToTensor(logits,"logits","sigmoidCrossEntropyWithLogits");assertShapesMatch($labels.shape,$logits.shape,"Error in sigmoidCrossEntropyWithLogits: ");var maxOutput=$logits.relu(),outputXTarget=$logits.mul($labels),sigmoidOutput=$logits.abs().neg().exp().log1p();return maxOutput.sub(outputXTarget).add(sigmoidOutput)}function sigmoidCrossEntropy_(multiClassLabels,logits,weights,labelSmoothing,reduction){void 0===labelSmoothing&&(labelSmoothing=0),void 0===reduction&&(reduction=exports.Reduction.SUM_BY_NONZERO_WEIGHTS);var $multiClassLabels=convertToTensor(multiClassLabels,"multiClassLabels","sigmoidCrossEntropy"),$logits=convertToTensor(logits,"logits","sigmoidCrossEntropy"),$weights=null;if(null!=weights&&($weights=convertToTensor(weights,"weights","sigmoidCrossEntropy")),assertShapesMatch($multiClassLabels.shape,$logits.shape,"Error in sigmoidCrossEntropy: "),labelSmoothing>0){var labelSmoothingScalar=scalar(labelSmoothing),one=scalar(1),half=scalar(.5);$multiClassLabels=$multiClassLabels.mul(one.sub(labelSmoothingScalar)).add(half.mul(labelSmoothingScalar))}var losses=sigmoidCrossEntropyWithLogits_($multiClassLabels,$logits);return computeWeightedLoss(losses,$weights,reduction)}function huberLoss_(labels,predictions,weights,delta,reduction){void 0===delta&&(delta=1),void 0===reduction&&(reduction=exports.Reduction.SUM_BY_NONZERO_WEIGHTS);var $labels=convertToTensor(labels,"labels","huberLoss"),$predictions=convertToTensor(predictions,"predictions","huberLoss"),$weights=null;null!=weights&&($weights=convertToTensor(weights,"weights","huberLoss")),assertShapesMatch($labels.shape,$predictions.shape,"Error in huberLoss: ");var deltaScalar=scalar(delta),error=$predictions.sub($labels).abs(),quadratic=minimum(error,deltaScalar),linear=error.sub(quadratic),losses=scalar(.5).mul(quadratic.square()).add(deltaScalar.mul(linear));return computeWeightedLoss(losses,$weights,reduction)}function softmaxCrossEntropyWithLogits_(labels,logits,dim){if(void 0===dim&&(dim=-1),-1===dim&&(dim=logits.rank-1),dim!==logits.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+logits.rank+" and dim was "+dim);var customOp;return customGrad(function(labels,logits,save){var keepDims=!0,lse=logits.logSumExp([dim],!0),logResult=logits.toFloat().sub(lse),costVector,value,gradFunc;return save([labels,logResult]),{value:logResult.mul(labels).neg().sum([dim]),gradFunc:function(dy,saved){var labels=saved[0],logResult=saved[1],dyShape=expandShapeToKeepDim(dy.shape,[dim]);return[dy.reshape(dyShape).mul(labels.toFloat().sub(logResult.exp())),dy.reshape(dyShape).mul(logResult.exp().sub(labels.toFloat()))]}}})(labels,logits)}function softmaxCrossEntropy_(onehotLabels,logits,weights,labelSmoothing,reduction){void 0===labelSmoothing&&(labelSmoothing=0),void 0===reduction&&(reduction=exports.Reduction.SUM_BY_NONZERO_WEIGHTS);var $onehotLabels=convertToTensor(onehotLabels,"onehotLabels","softmaxCrossEntropy"),$logits=convertToTensor(logits,"logits","softmaxCrossEntropy"),$weights=null;if(null!=weights&&($weights=convertToTensor(weights,"weights","softmaxCrossEntropy")),assertShapesMatch($onehotLabels.shape,$logits.shape,"Error in softmaxCrossEntropy: "),labelSmoothing>0){var labelSmoothingScalar=scalar(labelSmoothing),one=scalar(1),numClasses=scalar($onehotLabels.shape[1]);$onehotLabels=$onehotLabels.mul(one.sub(labelSmoothingScalar)).add(labelSmoothingScalar.div(numClasses))}var losses=softmaxCrossEntropyWithLogits_($onehotLabels,$logits);return computeWeightedLoss(losses,$weights,reduction)}(Reduction=exports.Reduction||(exports.Reduction={}))[Reduction.NONE=0]="NONE",Reduction[Reduction.MEAN=1]="MEAN",Reduction[Reduction.SUM=2]="SUM",Reduction[Reduction.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS";var absoluteDifference=op({absoluteDifference_:absoluteDifference_}),computeWeightedLoss=op({computeWeightedLoss_:computeWeightedLoss_}),cosineDistance=op({cosineDistance_:cosineDistance_}),hingeLoss=op({hingeLoss_:hingeLoss_}),huberLoss=op({huberLoss_:huberLoss_}),logLoss=op({logLoss_:logLoss_}),meanSquaredError=op({meanSquaredError_:meanSquaredError_}),sigmoidCrossEntropy=op({sigmoidCrossEntropy_:sigmoidCrossEntropy_}),softmaxCrossEntropy=op({softmaxCrossEntropy_:softmaxCrossEntropy_}),loss_ops=Object.freeze({get Reduction(){return exports.Reduction},absoluteDifference:absoluteDifference,computeWeightedLoss:computeWeightedLoss,cosineDistance:cosineDistance,hingeLoss:hingeLoss,huberLoss:huberLoss,logLoss:logLoss,meanSquaredError:meanSquaredError,sigmoidCrossEntropy:sigmoidCrossEntropy,softmaxCrossEntropy:softmaxCrossEntropy});function bandPart_(a,numLower,numUpper){if(numLower%1!=0)throw new Error("bandPart(): numLower must be an integer, got "+numLower+".");if(numUpper%1!=0)throw new Error("bandPart(): numUpper must be an integer, got "+numUpper+".");var $a=convertToTensor(a,"a","bandPart");if($a.rank<2)throw new Error("bandPart(): Rank must be at least 2, got "+$a.rank+".");var shape=$a.shape,_a=$a.shape.slice(-2),M=_a[0],N=_a[1];if(!(numLower<=M))throw new Error("bandPart(): numLower ("+numLower+") must not be greater than the number of rows ("+M+").");if(!(numUpper<=N))throw new Error("bandPart(): numUpper ("+numUpper+") must not be greater than the number of columns ("+N+").");numLower<0&&(numLower=M),numUpper<0&&(numUpper=N);var i=range(0,M,1,"int32").reshape([-1,1]),j=range(0,N,1,"int32"),ij=sub(i,j),inBand=logicalAnd(ij.lessEqual(scalar(+numLower,"int32")),ij.greaterEqual(scalar(-numUpper,"int32"))),zero=zeros([M,N],$a.dtype);return stack(unstack($a.reshape([-1,M,N])).map(function(mat){return where(inBand,mat,zero)})).reshape(shape)}function gramSchmidt_(xs){var inputIsTensor2D;if(Array.isArray(xs)){inputIsTensor2D=!1,assert(null!=xs&&xs.length>0,function(){return"Gram-Schmidt process: input must not be null, undefined, or empty"});for(var dim_1=xs[0].shape[0],_loop_1=function(i){assert(xs[i].shape[0]===dim_1,function(){return"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+xs[i].shape[0]+" vs. "+dim_1+")"})},i=1;i<xs.length;++i)_loop_1(i)}else inputIsTensor2D=!0,xs=split(xs,xs.shape[0],0).map(function(x){return squeeze(x,[0])});assert(xs.length<=xs[0].shape[0],function(){return"Gram-Schmidt: Number of vectors ("+xs.length+") exceeds number of dimensions ("+xs[0].shape[0]+")."});for(var ys=[],xs1d=xs,_loop_2=function(i){ys.push(ENGINE.tidy(function(){var x=xs1d[i];if(i>0)for(var j=0;j<i;++j){var proj=sum$1(ys[j].mulStrict(x)).mul(ys[j]);x=x.sub(proj)}return x.div(norm(x,"euclidean"))}))},i=0;i<xs.length;++i)_loop_2(i);return inputIsTensor2D?stack(ys,0):ys}function qr_(x,fullMatrices){if(void 0===fullMatrices&&(fullMatrices=!1),x.rank<2)throw new Error("qr() requires input tensor to have a rank >= 2, but got rank "+x.rank);if(2===x.rank)return qr2d(x,fullMatrices);var outerDimsProd=x.shape.slice(0,x.shape.length-2).reduce(function(value,prev){return value*prev}),x2ds,q2ds_1=[],r2ds_1=[],q,r;return unstack(x.reshape([outerDimsProd,x.shape[x.shape.length-2],x.shape[x.shape.length-1]]),0).forEach(function(x2d){var _a=qr2d(x2d,fullMatrices),q2d=_a[0],r2d=_a[1];q2ds_1.push(q2d),r2ds_1.push(r2d)}),[stack(q2ds_1,0).reshape(x.shape),stack(r2ds_1,0).reshape(x.shape)]}function qr2d(x,fullMatrices){return void 0===fullMatrices&&(fullMatrices=!1),ENGINE.tidy(function(){if(2!==x.shape.length)throw new Error("qr2d() requires a 2D Tensor, but got a "+x.shape.length+"D Tensor.");for(var m=x.shape[0],n=x.shape[1],q=eye(m),r=x.clone(),one2D=tensor2d([[1]],[1,1]),w=one2D.clone(),iters=m>=n?n:m,_loop_3=function(j){var _a,rTemp=r,wTemp=w,qTemp=q;_a=ENGINE.tidy(function(){var rjEnd1=r.slice([j,j],[m-j,1]),normX=rjEnd1.norm(),rjj=r.slice([j,j],[1,1]),s=tensor2d([[-1]]).where(rjj.greater(0),tensor2d([[1]])),u1=rjj.sub(s.mul(normX)),wPre=rjEnd1.div(u1);w=1===wPre.shape[0]?one2D.clone():one2D.concat(wPre.slice([1,0],[wPre.shape[0]-1,wPre.shape[1]]),0);var tau=s.matMul(u1).div(normX).neg(),rjEndAll=r.slice([j,0],[m-j,n]),tauTimesW=tau.mul(w),wT=w.transpose();if(0===j)r=rjEndAll.sub(tauTimesW.matMul(wT.matMul(rjEndAll)));else{var rTimesTau=rjEndAll.sub(tauTimesW.matMul(wT.matMul(rjEndAll)));r=r.slice([0,0],[j,n]).concat(rTimesTau,0)}var tawTimesWT=tauTimesW.transpose(),qAllJEnd=q.slice([0,j],[m,q.shape[1]-j]);if(0===j)q=qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tawTimesWT));else{var qTimesTau=qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tawTimesWT));q=q.slice([0,0],[m,j]).concat(qTimesTau,1)}return[w,r,q]}),w=_a[0],r=_a[1],q=_a[2],dispose([rTemp,wTemp,qTemp])},j=0;j<iters;++j)_loop_3(j);return!fullMatrices&&m>n&&(q=q.slice([0,0],[m,n]),r=r.slice([0,0],[n,n])),[q,r]})}var bandPart=op({bandPart_:bandPart_}),gramSchmidt=op({gramSchmidt_:gramSchmidt_}),qr=op({qr_:qr_}),linalg_ops=Object.freeze({bandPart:bandPart,gramSchmidt:gramSchmidt,qr:qr});function resizeBilinear_(images,size,alignCorners){void 0===alignCorners&&(alignCorners=!1);var $images=convertToTensor(images,"images","resizeBilinear");assert(3===$images.rank||4===$images.rank,function(){return"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+$images.rank+"."}),assert(2===size.length,function(){return"Error in resizeBilinear: new shape must 2D, but got shape "+size+"."});var batchImages=$images,reshapedTo4D=!1;3===$images.rank&&(reshapedTo4D=!0,batchImages=$images.as4D(1,$images.shape[0],$images.shape[1],$images.shape[2]));var newHeight=size[0],newWidth=size[1],forward=function(backend,save){return save([batchImages]),backend.resizeBilinear(batchImages,newHeight,newWidth,alignCorners)},backward=function(dy,saved){return{x:function(){return ENGINE.runKernelFunc(function(backend){return backend.resizeBilinearBackprop(dy,saved[0],alignCorners)},{})}}},res=ENGINE.runKernelFunc(forward,{x:batchImages},backward,"ResizeBilinear",{alignCorners:alignCorners,newHeight:newHeight,newWidth:newWidth});return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}function resizeNearestNeighbor_(images,size,alignCorners){void 0===alignCorners&&(alignCorners=!1);var $images=convertToTensor(images,"images","resizeNearestNeighbor");assert(3===$images.rank||4===$images.rank,function(){return"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+$images.rank+"."}),assert(2===size.length,function(){return"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+size+"."}),assert("float32"===$images.dtype||"int32"===$images.dtype,function(){return"`images` must have `int32` or `float32` as dtype"});var batchImages=$images,reshapedTo4D=!1;3===$images.rank&&(reshapedTo4D=!0,batchImages=$images.as4D(1,$images.shape[0],$images.shape[1],$images.shape[2]));var newHeight=size[0],newWidth=size[1],forward=function(backend,save){return save([batchImages]),backend.resizeNearestNeighbor(batchImages,newHeight,newWidth,alignCorners)},backward=function(dy,saved){return{batchImages:function(){return ENGINE.runKernelFunc(function(backend){return backend.resizeNearestNeighborBackprop(dy,saved[0],alignCorners)},{})}}},res=ENGINE.runKernelFunc(forward,{batchImages:batchImages},backward);return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}function nonMaxSuppression_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){void 0===iouThreshold&&(iouThreshold=.5),void 0===scoreThreshold&&(scoreThreshold=Number.NEGATIVE_INFINITY);var $boxes=convertToTensor(boxes,"boxes","nonMaxSuppression"),$scores=convertToTensor(scores,"scores","nonMaxSuppression"),inputs=nonMaxSuppSanityCheck($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold);maxOutputSize=inputs.maxOutputSize,iouThreshold=inputs.iouThreshold,scoreThreshold=inputs.scoreThreshold;var attrs={maxOutputSize:maxOutputSize,iouThreshold:iouThreshold,scoreThreshold:scoreThreshold};return ENGINE.runKernelFunc(function(b){return b.nonMaxSuppression($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold)},{boxes:$boxes,scores:$scores},null,"NonMaxSuppressionV3",attrs)}function nonMaxSuppressionAsync_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){return void 0===iouThreshold&&(iouThreshold=.5),void 0===scoreThreshold&&(scoreThreshold=Number.NEGATIVE_INFINITY),__awaiter(this,void 0,void 0,function(){var $boxes,$scores,inputs,boxesAndScores,boxesVals,scoresVals,res;return __generator(this,function(_a){switch(_a.label){case 0:return $boxes=convertToTensor(boxes,"boxes","nonMaxSuppressionAsync"),$scores=convertToTensor(scores,"scores","nonMaxSuppressionAsync"),inputs=nonMaxSuppSanityCheck($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold),maxOutputSize=inputs.maxOutputSize,iouThreshold=inputs.iouThreshold,scoreThreshold=inputs.scoreThreshold,[4,Promise.all([$boxes.data(),$scores.data()])];case 1:return boxesAndScores=_a.sent(),boxesVals=boxesAndScores[0],scoresVals=boxesAndScores[1],res=nonMaxSuppressionV3(boxesVals,scoresVals,maxOutputSize,iouThreshold,scoreThreshold),$boxes!==boxes&&$boxes.dispose(),$scores!==scores&&$scores.dispose(),[2,res]}})})}function nonMaxSuppressionWithScore_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma){void 0===iouThreshold&&(iouThreshold=.5),void 0===scoreThreshold&&(scoreThreshold=Number.NEGATIVE_INFINITY),void 0===softNmsSigma&&(softNmsSigma=0);var $boxes=convertToTensor(boxes,"boxes","nonMaxSuppression"),$scores=convertToTensor(scores,"scores","nonMaxSuppression"),inputs=nonMaxSuppSanityCheck($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma),attrs={maxOutputSize:maxOutputSize=inputs.maxOutputSize,iouThreshold:iouThreshold=inputs.iouThreshold,scoreThreshold:scoreThreshold=inputs.scoreThreshold,softNmsSigma:softNmsSigma=inputs.softNmsSigma},result=ENGINE.runKernel("NonMaxSuppressionV5",{boxes:$boxes,scores:$scores},attrs);return{selectedIndices:result[0],selectedScores:result[1]}}function nonMaxSuppressionWithScoreAsync_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma){return void 0===iouThreshold&&(iouThreshold=.5),void 0===scoreThreshold&&(scoreThreshold=Number.NEGATIVE_INFINITY),void 0===softNmsSigma&&(softNmsSigma=0),__awaiter(this,void 0,void 0,function(){var $boxes,$scores,inputs,boxesAndScores,boxesVals,scoresVals,res;return __generator(this,function(_a){switch(_a.label){case 0:return $boxes=convertToTensor(boxes,"boxes","nonMaxSuppressionAsync"),$scores=convertToTensor(scores,"scores","nonMaxSuppressionAsync"),inputs=nonMaxSuppSanityCheck($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma),maxOutputSize=inputs.maxOutputSize,iouThreshold=inputs.iouThreshold,scoreThreshold=inputs.scoreThreshold,softNmsSigma=inputs.softNmsSigma,[4,Promise.all([$boxes.data(),$scores.data()])];case 1:return boxesAndScores=_a.sent(),boxesVals=boxesAndScores[0],scoresVals=boxesAndScores[1],res=nonMaxSuppressionV5(boxesVals,scoresVals,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma),$boxes!==boxes&&$boxes.dispose(),$scores!==scores&&$scores.dispose(),[2,res]}})})}function nonMaxSuppSanityCheck(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma){null==iouThreshold&&(iouThreshold=.5),null==scoreThreshold&&(scoreThreshold=Number.NEGATIVE_INFINITY),null==softNmsSigma&&(softNmsSigma=0);var numBoxes=boxes.shape[0];return maxOutputSize=Math.min(maxOutputSize,numBoxes),assert(0<=iouThreshold&&iouThreshold<=1,function(){return"iouThreshold must be in [0, 1], but was '"+iouThreshold+"'"}),assert(2===boxes.rank,function(){return"boxes must be a 2D tensor, but was of rank '"+boxes.rank+"'"}),assert(4===boxes.shape[1],function(){return"boxes must have 4 columns, but 2nd dimension was "+boxes.shape[1]}),assert(1===scores.rank,function(){return"scores must be a 1D tensor"}),assert(scores.shape[0]===numBoxes,function(){return"scores has incompatible shape with boxes. Expected "+numBoxes+", but was "+scores.shape[0]}),assert(0<=softNmsSigma&&softNmsSigma<=1,function(){return"softNmsSigma must be in [0, 1], but was '"+softNmsSigma+"'"}),{maxOutputSize:maxOutputSize,iouThreshold:iouThreshold,scoreThreshold:scoreThreshold,softNmsSigma:softNmsSigma}}function cropAndResize_(image,boxes,boxInd,cropSize,method,extrapolationValue){var $image=convertToTensor(image,"image","cropAndResize"),$boxes=convertToTensor(boxes,"boxes","cropAndResize","float32"),$boxInd=convertToTensor(boxInd,"boxInd","cropAndResize","int32");method=method||"bilinear",extrapolationValue=extrapolationValue||0;var numBoxes=$boxes.shape[0];assert(4===$image.rank,function(){return"Error in cropAndResize: image must be rank 4,but got rank "+$image.rank+"."}),assert(2===$boxes.rank&&4===$boxes.shape[1],function(){return"Error in cropAndResize: boxes must be have size ["+numBoxes+",4] but had shape "+$boxes.shape+"."}),assert(1===$boxInd.rank&&$boxInd.shape[0]===numBoxes,function(){return"Error in cropAndResize: boxInd must be have size ["+numBoxes+"] but had shape "+$boxes.shape+"."}),assert(2===cropSize.length,function(){return"Error in cropAndResize: cropSize must be of length 2, but got length "+cropSize.length+"."}),assert(cropSize[0]>=1&&cropSize[1]>=1,function(){return"cropSize must be atleast [1,1], but was "+cropSize}),assert("bilinear"===method||"nearest"===method,function(){return"method must be bilinear or nearest, but was "+method});var forward=function(backend,save){return backend.cropAndResize($image,$boxes,$boxInd,cropSize,method,extrapolationValue)},res;return ENGINE.runKernelFunc(forward,{images:$image,boxes:$boxes,boxInd:$boxInd},null,"CropAndResize",{method:method,extrapolationValue:extrapolationValue,cropSize:cropSize})}var resizeBilinear=op({resizeBilinear_:resizeBilinear_}),resizeNearestNeighbor=op({resizeNearestNeighbor_:resizeNearestNeighbor_}),nonMaxSuppression=op({nonMaxSuppression_:nonMaxSuppression_}),nonMaxSuppressionAsync=nonMaxSuppressionAsync_,nonMaxSuppressionWithScore=op({nonMaxSuppressionWithScore_:nonMaxSuppressionWithScore_}),nonMaxSuppressionWithScoreAsync=nonMaxSuppressionWithScoreAsync_,cropAndResize=op({cropAndResize_:cropAndResize_}),image_ops=Object.freeze({resizeBilinear:resizeBilinear,resizeNearestNeighbor:resizeNearestNeighbor,nonMaxSuppression:nonMaxSuppression,nonMaxSuppressionAsync:nonMaxSuppressionAsync,nonMaxSuppressionWithScore:nonMaxSuppressionWithScore,nonMaxSuppressionWithScoreAsync:nonMaxSuppressionWithScoreAsync,cropAndResize:cropAndResize}),shouldFuse=function(gradientDepth,activation){var gradientMode;return!(gradientDepth>0)||"linear"===activation},getFusedDyActivation=function(dy,y,activation){if(null==activation||"linear"===activation)return dy;if("relu"===activation)return dy.mul(y.step());throw new Error("Gradient for activation "+activation+" has not been implemented yet.")},getFusedBiasGradient=function(bias,dyActivation){var res=dyActivation,reduceAxes=getReductionAxes(bias.shape,dyActivation.shape);return reduceAxes.length>0&&(res=res.sum(reduceAxes)),res.reshape(bias.shape)},applyActivation=function(x,activation,preluActivationWeights){if("linear"===activation)return x;if("relu"===activation)return relu(x);if("elu"===activation)return elu(x);if("relu6"===activation)return relu6(x);if("prelu"===activation)return prelu(x,preluActivationWeights);throw new Error("Unknown fused activation "+activation+".")};function fusedMatMul_(_a){var _b,a=_a.a,b=_a.b,_c=_a.transposeA,transposeA=void 0!==_c&&_c,_d=_a.transposeB,transposeB=void 0!==_d&&_d,bias=_a.bias,_e=_a.activation,activation=void 0===_e?"linear":_e,preluActivationWeights=_a.preluActivationWeights;if(!1===shouldFuse(ENGINE.state.gradientDepth,activation)){var result=matMul(a,b,transposeA,transposeB);return null!=bias&&(result=add(result,bias)),applyActivation(result,activation,preluActivationWeights)}var $a=convertToTensor(a,"a","fused matMul"),$b=convertToTensor(b,"b","fused matMul");_b=makeTypesMatch($a,$b),$a=_b[0],$b=_b[1];var innerShapeA=transposeA?$a.shape[$a.rank-2]:$a.shape[$a.rank-1],innerShapeB=transposeB?$b.shape[$b.rank-1]:$b.shape[$b.rank-2],outerShapeA=transposeA?$a.shape[$a.rank-1]:$a.shape[$a.rank-2],outerShapeB=transposeB?$b.shape[$b.rank-2]:$b.shape[$b.rank-1],outerDimsA=$a.shape.slice(0,-2),outerDimsB=$b.shape.slice(0,-2),batchDimA=sizeFromShape(outerDimsA),batchDimB=sizeFromShape(outerDimsB);assert($a.rank>=2&&$b.rank>=2&&$a.rank===$b.rank,function(){return"Error in fused matMul: inputs must have the same rank of at least 2, got ranks "+$a.rank+" and "+$b.rank+"."}),assert(arraysEqual(outerDimsA,outerDimsB),function(){return"Error in fused matMul: outer dimensions ("+outerDimsA+") and ("+outerDimsB+") of Tensors with shapes "+$a.shape+" and "+$b.shape+" must match."}),assert(innerShapeA===innerShapeB,function(){return"Error in fused matMul: inner shapes ("+innerShapeA+") and ("+innerShapeB+") of Tensors with shapes "+$a.shape+" and "+$b.shape+" and transposeA="+transposeA+" and transposeB="+transposeB+" must match."});var outShape=$a.shape.slice(0,-2).concat([outerShapeA,outerShapeB]),a3D=transposeA?$a.as3D(batchDimA,innerShapeA,outerShapeA):$a.as3D(batchDimA,outerShapeA,innerShapeA),b3D=transposeB?$b.as3D(batchDimB,outerShapeB,innerShapeB):$b.as3D(batchDimB,innerShapeB,outerShapeB),$bias,$preluActivationWeights;null!=bias&&assertAndGetBroadcastShape(outShape,($bias=makeTypesMatch($bias=convertToTensor(bias,"bias","fused matMul"),$a)[0]).shape),null!=preluActivationWeights&&($preluActivationWeights=convertToTensor(preluActivationWeights,"prelu weights","fused matMul"));var grad=function(dy,saved){var a3D=saved[0],b3D=saved[1],y=saved[2],dyActivation=getFusedDyActivation(dy,y,activation),biasGradient={};return null!=bias&&(biasGradient={bias:function(){return getFusedBiasGradient($bias,dyActivation)}}),transposeA||transposeB?!transposeA&&transposeB?Object.assign({a:function(){return dyActivation.matMul(b3D,!1,!1)},b:function(){return dyActivation.matMul(a3D,!0,!1)}},biasGradient):transposeA&&!transposeB?Object.assign({a:function(){return b3D.matMul(dyActivation,!1,!0)},b:function(){return a3D.matMul(dyActivation,!1,!1)}},biasGradient):Object.assign({a:function(){return b3D.matMul(dyActivation,!0,!0)},b:function(){return dyActivation.matMul(a3D,!0,!0)}},biasGradient):Object.assign({a:function(){return dyActivation.matMul(b3D,!1,!0)},b:function(){return a3D.matMul(dyActivation,!0,!1)}},biasGradient)},inputs={a:a3D,b:b3D};null!=bias&&(inputs.bias=$bias),null!=preluActivationWeights&&(inputs.preluActivationWeights=$preluActivationWeights);var inputsToSave=[a3D,b3D],outputsToSave=[!0],res;return ENGINE.runKernelFunc(function(backend,save){var y=backend.fusedBatchMatMul({a:a3D,b:b3D,transposeA:transposeA,transposeB:transposeB,bias:$bias,activation:activation,preluActivationWeights:$preluActivationWeights});return save([a3D,b3D,y]),y},inputs,grad,"_FusedMatMul",{transposeA:transposeA,transposeB:transposeB,activation:activation},inputsToSave,outputsToSave).reshape(outShape)}function fusedConv2d_(_a){var x=_a.x,filter=_a.filter,strides=_a.strides,pad=_a.pad,_b=_a.dataFormat,dataFormat=void 0===_b?"NHWC":_b,_c=_a.dilations,dilations=void 0===_c?[1,1]:_c,dimRoundingMode=_a.dimRoundingMode,bias=_a.bias,_d=_a.activation,activation=void 0===_d?"linear":_d,preluActivationWeights=_a.preluActivationWeights;if(activation=activation||"linear",!1===shouldFuse(ENGINE.state.gradientDepth,activation)){var result=conv2d(x,filter,strides,pad,dataFormat,dilations,dimRoundingMode);return null!=bias&&(result=add(result,bias)),applyActivation(result,activation,preluActivationWeights)}var $x=convertToTensor(x,"x","conv2d"),$filter=convertToTensor(filter,"filter","conv2d"),x4D=$x,reshapedTo4D=!1;3===$x.rank&&(reshapedTo4D=!0,x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])),assert(4===x4D.rank,function(){return"Error in fused conv2d: input must be rank 4, but got rank "+x4D.rank+"."}),assert(4===$filter.rank,function(){return"Error in fused conv2d: filter must be rank 4, but got rank "+$filter.rank+"."}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in fused conv2d: pad must be an integer when using, dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."}),assert(x4D.shape[3]===$filter.shape[2],function(){return"Error in conv2d: depth of input ("+x4D.shape[3]+") must match input depth for filter "+$filter.shape[2]+"."}),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"}),assert("NHWC"===dataFormat,function(){return"Error in conv2d: got dataFormat of "+dataFormat+" but only NHWC is currently supported."});var convInfo=computeConv2DInfo(x4D.shape,$filter.shape,strides,dilations,pad,dimRoundingMode),$bias,$preluActivationWeights;null!=bias&&($bias=makeTypesMatch($bias=convertToTensor(bias,"bias","fused conv2d"),$x)[0],assertAndGetBroadcastShape(convInfo.outShape,$bias.shape)),null!=preluActivationWeights&&($preluActivationWeights=convertToTensor(preluActivationWeights,"prelu weights","fused conv2d"));var grad=function(dy,saved){var _a=saved,$filter=_a[0],x4D=_a[1],y=_a[2],dyActivation=getFusedDyActivation(dy,y,activation);assert(tupleValuesAreOne(dilations),function(){return"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+dilations+"'"});var biasGradient={};return null!=bias&&(biasGradient={bias:function(){return getFusedBiasGradient($bias,dyActivation)}}),Object.assign({x:function(){return conv2dDerInput(x4D.shape,dyActivation,$filter,strides,pad)},filter:function(){return conv2dDerFilter(x4D,dyActivation,$filter.shape,strides,pad)}},biasGradient)},inputs={x:x4D,filter:$filter};null!=bias&&(inputs.bias=$bias),null!=preluActivationWeights&&(inputs.preluActivationWeights=$preluActivationWeights);var inputsToSave=[$filter,x4D],outputsToSave=[!0],res=ENGINE.runKernelFunc(function(backend,save){var res=backend.fusedConv2d({input:x4D,filter:$filter,convInfo:convInfo,bias:$bias,activation:activation,preluActivationWeights:$preluActivationWeights});return save([$filter,x4D,res]),res},inputs,grad,"FusedConv2D",{convInfo:convInfo,activation:activation},inputsToSave,outputsToSave);return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}function fusedDepthwiseConv2d_(_a){var x=_a.x,filter=_a.filter,strides=_a.strides,pad=_a.pad,_b=_a.dataFormat,dataFormat=void 0===_b?"NHWC":_b,_c=_a.dilations,dilations=void 0===_c?[1,1]:_c,dimRoundingMode=_a.dimRoundingMode,bias=_a.bias,_d=_a.activation,activation=void 0===_d?"linear":_d,preluActivationWeights=_a.preluActivationWeights;if(!1===shouldFuse(ENGINE.state.gradientDepth,activation)){var result=depthwiseConv2d(x,filter,strides,pad,dataFormat,dilations,dimRoundingMode);return null!=bias&&(result=add(result,bias)),applyActivation(result,activation,preluActivationWeights)}var $x=convertToTensor(x,"x","depthwiseConv2d"),$filter=convertToTensor(filter,"filter","depthwiseConv2d"),x4D=$x,reshapedTo4D=!1;3===$x.rank&&(reshapedTo4D=!0,x4D=$x.as4D(1,$x.shape[0],$x.shape[1],$x.shape[2])),assert(4===x4D.rank,function(){return"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+x4D.rank+"."}),assert(4===$filter.rank,function(){return"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+$filter.rank+"."}),assert(x4D.shape[3]===$filter.shape[2],function(){return"Error in fused depthwiseConv2d: number of input channels ("+x4D.shape[3]+") must match the inChannels dimension in filter "+$filter.shape[2]+"."}),null==dilations&&(dilations=[1,1]),assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"}),null!=dimRoundingMode&&assert(isInt(pad),function(){return"Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode "+dimRoundingMode+" but got pad "+pad+"."});var convInfo=computeConv2DInfo(x4D.shape,$filter.shape,strides,dilations,pad,dimRoundingMode,!0),$bias,$preluActivationWeights;null!=bias&&($bias=makeTypesMatch($bias=convertToTensor(bias,"bias","fused conv2d"),$x)[0],assertAndGetBroadcastShape(convInfo.outShape,$bias.shape)),null!=preluActivationWeights&&($preluActivationWeights=convertToTensor(preluActivationWeights,"prelu weights","fused depthwiseConv2d"));var grad=function(dy,saved){assert(tupleValuesAreOne(dilations),function(){return"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+dilations+"'"});var $filter=saved[0],x4D=saved[1],y=saved[2],dyActivation=getFusedDyActivation(dy,y,activation),biasGradient={};return null!=bias&&(biasGradient={bias:function(){return getFusedBiasGradient($bias,dyActivation)}}),Object.assign({x:function(){return depthwiseConv2dDerInput(x4D.shape,dyActivation,$filter,convInfo)},filter:function(){return depthwiseConv2dDerFilter(x4D,dyActivation,$filter.shape,convInfo)}},biasGradient)},inputs={x:x4D,filter:$filter};null!=bias&&(inputs.bias=$bias),null!=preluActivationWeights&&(inputs.preluActivationWeights=$preluActivationWeights);var inputsToSave=[$filter,x4D],outputsToSave=[!0],res=ENGINE.runKernelFunc(function(backend,save){var res=backend.fusedDepthwiseConv2D({input:x4D,filter:$filter,convInfo:convInfo,bias:$bias,activation:activation,preluActivationWeights:$preluActivationWeights});return save([$filter,x4D,res]),res},inputs,grad,"FusedDepthwiseConv2D",{convInfo:convInfo,activation:activation},inputsToSave,outputsToSave);return reshapedTo4D?res.as3D(res.shape[1],res.shape[2],res.shape[3]):res}var matMul$1=op({fusedMatMul_:fusedMatMul_}),conv2d$1=op({fusedConv2d_:fusedConv2d_}),depthwiseConv2d$1=op({fusedDepthwiseConv2d_:fusedDepthwiseConv2d_}),fused_ops=Object.freeze({matMul:matMul$1,conv2d:conv2d$1,depthwiseConv2d:depthwiseConv2d$1}),ops=Object.freeze({image:image_ops,linalg:linalg_ops,losses:loss_ops,spectral:spectral_ops,fused:fused_ops,signal:signal_ops,add:add,addN:addN,batchNorm:batchNorm,batchNormalization:batchNormalization,batchNorm2d:batchNorm2d,batchNormalization2d:batchNormalization2d,batchNorm3d:batchNorm3d,batchNormalization3d:batchNormalization3d,batchNorm4d:batchNorm4d,batchNormalization4d:batchNormalization4d,broadcastTo:broadcastTo,clone:clone,div:div,divNoNan:divNoNan,eye:eye,multinomial:multinomial,oneHot:oneHot,pad:pad,pad1d:pad1d,pad2d:pad2d,pad3d:pad3d,pad4d:pad4d,rand:rand,randomGamma:randomGamma,randomNormal:randomNormal,randomUniform:randomUniform,square:square,squaredDifference:squaredDifference,tile:tile$1,truncatedNormal:truncatedNormal,conv1d:conv1d,conv2d:conv2d,conv3d:conv3d,depthwiseConv2d:depthwiseConv2d,separableConv2d:separableConv2d,conv2dTranspose:conv2dTranspose,conv3dTranspose:conv3dTranspose,op:op,booleanMaskAsync:booleanMaskAsync,complex:complex,real:real,imag:imag,concat:concat,concat1d:concat1d,concat2d:concat2d,concat3d:concat3d,concat4d:concat4d,split:split,matMul:matMul,dot:dot,outerProduct:outerProduct,reverse:reverse,reverse1d:reverse1d,reverse2d:reverse2d,reverse3d:reverse3d,reverse4d:reverse4d,maxPool:maxPool,avgPool:avgPool,pool:pool,maxPool3d:maxPool3d,avgPool3d:avgPool3d,maxPoolWithArgmax:maxPoolWithArgmax,slice:slice,slice1d:slice1d,slice2d:slice2d,slice3d:slice3d,slice4d:slice4d,abs:abs,acos:acos,acosh:acosh,asin:asin,asinh:asinh,atan:atan,atanh:atanh,ceil:ceil,clipByValue:clipByValue,cos:cos,cosh:cosh,erf:erf,exp:exp,expm1:expm1,floor:floor,log:log,log1p:log1p,logSigmoid:logSigmoid,neg:neg,reciprocal:reciprocal,round:round,rsqrt:rsqrt,sigmoid:sigmoid,sign:sign,isNaN:isNaN$1,isInf:isInf,isFinite:isFinite$1,sin:sin,sinh:sinh,softplus:softplus,sqrt:sqrt,step:step,tan:tan,tanh:tanh$1,all:all,any:any,argMax:argMax,argMin:argMin,logSumExp:logSumExp,max:max,mean:mean,min:min,moments:moments,sum:sum$1,prod:prod,equal:equal,equalStrict:equalStrict,greater:greater,greaterEqual:greaterEqual,greaterEqualStrict:greaterEqualStrict,greaterStrict:greaterStrict,less:less,lessEqual:lessEqual,lessEqualStrict:lessEqualStrict,lessStrict:lessStrict,notEqual:notEqual,notEqualStrict:notEqualStrict,addStrict:addStrict,atan2:atan2,divStrict:divStrict,floorDiv:floorDiv,maximum:maximum,maximumStrict:maximumStrict,minimum:minimum,minimumStrict:minimumStrict,mod:mod,modStrict:modStrict,mul:mul,mulStrict:mulStrict,pow:pow,powStrict:powStrict,squaredDifferenceStrict:squaredDifferenceStrict,sub:sub,subStrict:subStrict,elu:elu,leakyRelu:leakyRelu,prelu:prelu,relu:relu,relu6:relu6,selu:selu,logicalAnd:logicalAnd,logicalNot:logicalNot,logicalOr:logicalOr,logicalXor:logicalXor,where:where,whereAsync:whereAsync,buffer:buffer,print:print,batchToSpaceND:batchToSpaceND,cast:cast,cumsum:cumsum,depthToSpace:depthToSpace,expandDims:expandDims,reshape:reshape,spaceToBatchND:spaceToBatchND,squeeze:squeeze,stack:stack,unstack:unstack,setdiff1dAsync:setdiff1dAsync,fill:fill,linspace:linspace,ones:ones$1,range:range,scalar:scalar,tensor:tensor,tensor1d:tensor1d,tensor2d:tensor2d,tensor3d:tensor3d,tensor4d:tensor4d,tensor5d:tensor5d,tensor6d:tensor6d,variable:variable,zeros:zeros,onesLike:onesLike,zerosLike:zerosLike,transpose:transpose,softmax:softmax,logSoftmax:logSoftmax,localResponseNormalization:localResponseNormalization,norm:norm,gather:gather,unsortedSegmentSum:unsortedSegmentSum,basicLSTMCell:basicLSTMCell,multiRNNCell:multiRNNCell,movingAverage:movingAverage,stridedSlice:stridedSlice,topk:topk,scatterND:scatterND,fft:fft,ifft:ifft,rfft:rfft,irfft:irfft,sparseToDense:sparseToDense,gatherND:gatherND,diag:diag,dropout:dropout,hannWindow:hannWindow,hammingWindow:hammingWindow,frame:frame,stft:stft,inTopKAsync:inTopKAsync});function assertNotComplex(tensor,opName){Array.isArray(tensor)||(tensor=[tensor]),tensor.forEach(function(t){null!=t&&assert("complex64"!==t.dtype,function(){return opName+" does not support complex64 tensors."})})}function pool$1(xValues,xShape,dtype,strides,convInfo,poolType){for(var strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,initialValue="max"===poolType?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,output=buffer(convInfo.outShape,dtype),outputVals=output.values,outputBatchStrides=convInfo.outShape[1]*convInfo.outShape[2]*convInfo.outShape[3],outputRowStrides=convInfo.outShape[2]*convInfo.outShape[3],outputColStrides=convInfo.outShape[3],b=0;b<convInfo.batchSize;++b)for(var outputBatchOffset=b*outputBatchStrides,inputBatchOffset=b*strides[0],d=0;d<convInfo.inChannels;++d)for(var yR=0;yR<convInfo.outHeight;++yR)for(var xRCorner=yR*strideHeight-padTop,xRMin=Math.max(0,xRCorner),xRMax=Math.min(convInfo.inHeight,effectiveFilterHeight+xRCorner),outputRowOffset=outputBatchOffset+yR*outputRowStrides,yC=0;yC<convInfo.outWidth;++yC){for(var xCCorner=yC*strideWidth-padLeft,xCMin=Math.max(0,xCCorner),xCMax=Math.min(convInfo.inWidth,effectiveFilterWidth+xCCorner),minMaxValue=initialValue,avgValue=0,count=0,xR=xRMin;xR<xRMax;xR+=dilationHeight){for(var xROffset=inputBatchOffset+xR*strides[1],xC=xCMin;xC<xCMax;xC+=dilationWidth){var xCOffset,pixel=xValues[xROffset+xC*strides[2]+d];"max"===poolType&&pixel>minMaxValue?minMaxValue=pixel:"avg"===poolType&&(avgValue+=pixel,count++)}if(isNaN(minMaxValue))break}var outputOffset;outputVals[outputRowOffset+yC*outputColStrides+d]="avg"===poolType?avgValue/count:minMaxValue}return output}function maxPoolPositions(xValues,xShape,dtype,convInfo,flattenPositions,includeBatchInIndex){void 0===flattenPositions&&(flattenPositions=!1),void 0===includeBatchInIndex&&(includeBatchInIndex=!1);for(var maxPositions=buffer(convInfo.outShape,"int32"),strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,xBuf=buffer(xShape,dtype,xValues),b=0;b<convInfo.batchSize;++b)for(var d=0;d<convInfo.inChannels;++d)for(var yR=0;yR<convInfo.outHeight;++yR){for(var xRCorner=yR*strideHeight-padTop,xRMin=xRCorner;xRMin<0;)xRMin+=dilationHeight;for(var xRMax=Math.min(convInfo.inHeight,effectiveFilterHeight+xRCorner),yC=0;yC<convInfo.outWidth;++yC){for(var xCCorner=yC*strideWidth-padLeft,xCMin=xCCorner;xCMin<0;)xCMin+=dilationWidth;for(var xCMax=Math.min(convInfo.inWidth,effectiveFilterWidth+xCCorner),maxValue=Number.NEGATIVE_INFINITY,maxPosition=-1,xR=xRMin;xR<xRMax;xR+=dilationHeight)for(var wR=xR-xRCorner,xC=xCMin;xC<xCMax;xC+=dilationWidth){var wC=xC-xCCorner,pixel=xBuf.get(b,xR,xC,d);pixel>maxValue&&(maxValue=pixel,maxPosition=flattenPositions?includeBatchInIndex?((b*convInfo.inHeight+xR)*convInfo.inWidth+xC)*convInfo.inChannels+d:(xR*convInfo.inWidth+xC)*convInfo.inChannels+d:wR*effectiveFilterWidth+wC)}maxPositions.set(maxPosition,b,yR,yC,d)}}return maxPositions}function mapActivation(backend,x,activation,preluActivationWeights){if("linear"===activation)return backend.linear(x);if("relu"===activation)return backend.relu(x);if("elu"===activation)return backend.elu(x);if("relu6"===activation)return backend.relu6(x);if("prelu"===activation)return backend.prelu(x,preluActivationWeights);throw new Error("Activation "+activation+" has not been implemented for the CPU backend.")}var MathBackendCPU=function(_super){function MathBackendCPU(){var _this=_super.call(this)||this;return _this.blockSize=48,_this.firstUse=!0,_this.data=new DataStorage(_this,ENGINE),_this}return __extends(MathBackendCPU,_super),MathBackendCPU.prototype.write=function(values,shape,dtype){this.firstUse&&(this.firstUse=!1,env().get("IS_NODE")&&warn("\n============================\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));var dataId={};return this.data.set(dataId,{values:values,dtype:dtype}),dataId},MathBackendCPU.prototype.move=function(dataId,values,shape,dtype){this.data.set(dataId,{values:values,dtype:dtype})},MathBackendCPU.prototype.numDataIds=function(){return this.data.numDataIds()},MathBackendCPU.prototype.read=function(dataId){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2,this.readSync(dataId)]})})},MathBackendCPU.prototype.readSync=function(dataId){var _a=this.data.get(dataId),dtype=_a.dtype,complexTensors=_a.complexTensors,realValues,imagValues;return"complex64"===dtype?mergeRealAndImagArrays(this.readSync(complexTensors.real.dataId),this.readSync(complexTensors.imag.dataId)):this.data.get(dataId).values},MathBackendCPU.prototype.bufferSync=function(t){var data=this.readSync(t.dataId),decodedData=data;if("string"===t.dtype)try{decodedData=data.map(function(d){return decodeString(d)})}catch(_a){throw new Error("Failed to decode encoded string bytes into utf-8")}return buffer(t.shape,t.dtype,decodedData)},MathBackendCPU.prototype.makeOutput=function(values,shape,dtype){var dataId=this.write(values,shape,dtype);return ENGINE.makeTensorFromDataId(dataId,shape,dtype,this)},MathBackendCPU.prototype.disposeData=function(dataId){if(this.data.has(dataId)){var complexTensors=this.data.get(dataId).complexTensors;null!=complexTensors&&(complexTensors.real.dispose(),complexTensors.imag.dispose()),this.data.delete(dataId)}},MathBackendCPU.prototype.time=function(f){return __awaiter(this,void 0,void 0,function(){var start,kernelMs;return __generator(this,function(_a){return start=now(),f(),[2,{kernelMs:kernelMs=now()-start}]})})},MathBackendCPU.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}},MathBackendCPU.prototype.complex=function(real,imag){var result=this.makeOutput(null,real.shape,"complex64"),resultData;return this.data.get(result.dataId).complexTensors={real:ENGINE.keep(real.clone()),imag:ENGINE.keep(imag.clone())},result},MathBackendCPU.prototype.real=function(input){var resultData;return this.data.get(input.dataId).complexTensors.real.clone()},MathBackendCPU.prototype.imag=function(input){var resultData;return this.data.get(input.dataId).complexTensors.imag.clone()},MathBackendCPU.prototype.slice=function(x,begin,size){var isContinous;if(assertNotComplex(x,"slice"),isSliceContinous(x.shape,begin,size)){var flatOffset=computeFlatOffset(begin,x.strides),length_1=sizeFromShape(size),vals;return tensor(this.readSync(x.dataId).subarray(flatOffset,flatOffset+length_1),size,x.dtype)}for(var buffer$1=buffer(size,x.dtype),xBuf=this.bufferSync(x),i=0;i<buffer$1.size;++i){var loc,xLoc=buffer$1.indexToLoc(i).map(function(idx,j){return idx+begin[j]});buffer$1.values[i]=xBuf.get.apply(xBuf,xLoc)}return buffer$1.toTensor()},MathBackendCPU.prototype.stridedSlice=function(x,begin,end,strides){assertNotComplex(x,"stridedSlice");var outShape=computeOutShape$2(begin,end,strides);if(outShape.some(function(axis){return 0===axis}))return tensor([],outShape);for(var buffer$1=buffer(outShape,x.dtype),xBuf=this.bufferSync(x),i=0;i<buffer$1.size;i++){for(var loc=buffer$1.indexToLoc(i),newLoc=new Array(loc.length),j=0;j<newLoc.length;j++)newLoc[j]=loc[j]*strides[j]+begin[j];buffer$1.set.apply(buffer$1,[xBuf.get.apply(xBuf,newLoc)].concat(loc))}return buffer$1.toTensor()},MathBackendCPU.prototype.diag=function(x){for(var xVals=this.readSync(x.dataId),buffer$1=buffer([x.size,x.size],x.dtype),vals=buffer$1.values,i=0;i<xVals.length;i++)vals[i*x.size+i]=xVals[i];return buffer$1.toTensor()},MathBackendCPU.prototype.unstack=function(x,axis){for(var num=x.shape[axis],outShape=new Array(x.rank-1),outIndex=0,i=0;i<x.rank;i++)i!==axis&&(outShape[outIndex++]=x.shape[i]);var begin=new Array(x.rank).fill(0),size=x.shape.slice();size[axis]=1;for(var res=new Array(num),i=0;i<res.length;i++)begin[axis]=i,res[i]=this.slice(x,begin,size).reshape(outShape);return res},MathBackendCPU.prototype.reverse=function(x,axis){assertNotComplex(x,"reverse");for(var buffer$1=buffer(x.shape,x.dtype),xBuf=this.bufferSync(x),_loop_1=function(i){var outLoc=buffer$1.indexToLoc(i),inLoc=outLoc.slice();axis.forEach(function(ax){return inLoc[ax]=x.shape[ax]-1-inLoc[ax]}),buffer$1.set.apply(buffer$1,[xBuf.get.apply(xBuf,inLoc)].concat(outLoc))},i=0;i<buffer$1.size;i++)_loop_1(i);return buffer$1.toTensor()},MathBackendCPU.prototype.concat=function(tensors,axis){var _this=this;if("complex64"===tensors[0].dtype){var reals=tensors.map(function(t){return real(t)}),imags=tensors.map(function(t){return imag(t)});return complex(this.concat(reals,axis),this.concat(imags,axis))}var tensors2D=tensors.map(function(t){var innerSize=sizeFromShape(t.shape.slice(axis));return t.as2D(-1,innerSize)}),outShape=computeOutShape(tensors2D.map(function(t){return t.shape}),1),values=buffer(outShape,tensors[0].dtype).values;if(1===tensors2D[0].shape[0]){var offset_1=0;tensors2D.forEach(function(t){values.set(_this.readSync(t.dataId),offset_1),offset_1+=t.size})}else{var colOffset_1=0;tensors2D.forEach(function(t){for(var tVals=_this.readSync(t.dataId),tIdx=0,row=0;row<t.shape[0];++row)for(var resIdx=row*outShape[1]+colOffset_1,col=0;col<t.shape[1];++col)values[resIdx+col]=tVals[tIdx++];colOffset_1+=t.shape[1]})}var finalOutShape=computeOutShape(tensors.map(function(t){return t.shape}),axis);return tensor(values,finalOutShape,tensors[0].dtype)},MathBackendCPU.prototype.neg=function(x){return assertNotComplex(x,"neg"),this.multiply(scalar(-1),x)},MathBackendCPU.prototype.add=function(a,b){return"complex64"===a.dtype||"complex64"===b.dtype?this.broadcastedBinaryComplexOp(a.cast("complex64"),b.cast("complex64"),function(aReal,aImag,bReal,bImag){return{real:aReal+bReal,imag:aImag+bImag}}):this.broadcastedBinaryOp(a,b,upcastType(a.dtype,b.dtype),function(aValue,bValue){return aValue+bValue})},MathBackendCPU.prototype.addN=function(tensors){var _this=this;assertNotComplex(tensors,"addN");for(var vals=tensors.map(function(t){return _this.readSync(t.dataId)}),result=buffer(tensors[0].shape,tensors[0].dtype),resultVals=result.values,i=0;i<tensors.length;i++)for(var currVals=vals[i],j=0;j<resultVals.length;j++)resultVals[j]+=currVals[j];return result.toTensor()},MathBackendCPU.prototype.softmax=function(logits,dim){var axes=parseAxisParam([dim],logits.shape),maxLogit=this.max(logits,axes),expandedShape=expandShapeToKeepDim(maxLogit.shape,axes),a=this.subtract(logits,maxLogit.reshape(expandedShape)),b=this.exp(a),sumExp=this.sum(b,axes).reshape(expandedShape);return div(b,sumExp)},MathBackendCPU.prototype.subtract=function(a,b){return"complex64"===a.dtype||"complex64"===b.dtype?this.broadcastedBinaryComplexOp(a.cast("complex64"),b.cast("complex64"),function(aReal,aImag,bReal,bImag){return{real:aReal-bReal,imag:aImag-bImag}}):this.broadcastedBinaryOp(a,b,upcastType(a.dtype,b.dtype),function(aValue,bValue){return aValue-bValue})},MathBackendCPU.prototype.pow=function(a,b){return assertNotComplex([a,b],"pow"),this.broadcastedBinaryOp(a,b,a.dtype,function(aValue,bValue){return Math.pow(aValue,bValue)})},MathBackendCPU.prototype.batchMatMul=function(a,b,transposeA,transposeB){assertNotComplex([a,b],"matMul");for(var sharedDim=transposeA?a.shape[1]:a.shape[2],leftDim=transposeA?a.shape[2]:a.shape[1],rightDim=transposeB?b.shape[1]:b.shape[2],batchDim=a.shape[0],aValues=this.readSync(a.dataId),bValues=this.readSync(b.dataId),_a=transposeA?[a.strides[0],1,a.strides[1]]:[a.strides[0],a.strides[1],1],aBatch=_a[0],aOuterStep=_a[1],aInnerStep=_a[2],_b=transposeB?[1,b.strides[1],b.strides[0]]:[b.strides[1],1,b.strides[0]],bInnerStep=_b[0],bOuterStep=_b[1],bBatch=_b[2],size=leftDim*rightDim,result=buffer([batchDim,leftDim,rightDim],a.dtype),resVals=result.values,blockSize=this.blockSize,b_1=0;b_1<batchDim;b_1++)for(var i0=0;i0<leftDim;i0+=blockSize)for(var j0=0;j0<rightDim;j0+=blockSize)for(var k0=0;k0<sharedDim;k0+=blockSize)for(var iBlock=Math.min(i0+blockSize,leftDim),jBlock=Math.min(j0+blockSize,rightDim),kBlock=Math.min(k0+blockSize,sharedDim),i=i0;i<iBlock;i++)for(var j=j0;j<jBlock;j++){for(var sum=0,k=k0;k<kBlock;k++)sum+=aValues[b_1*aBatch+i*aOuterStep+k*aInnerStep]*bValues[k*bInnerStep+j*bOuterStep+b_1*bBatch];resVals[b_1*size+(i*rightDim+j)]+=sum}return result.toTensor()},MathBackendCPU.prototype.fusedBatchMatMul=function(_a){var a=_a.a,b=_a.b,transposeA=_a.transposeA,transposeB=_a.transposeB,bias=_a.bias,activation=_a.activation,preluActivationWeights=_a.preluActivationWeights,result=this.batchMatMul(a,b,transposeA,transposeB);return bias&&(result=this.add(result,bias)),activation&&(result=mapActivation(this,result,activation,preluActivationWeights)),result},MathBackendCPU.prototype.multiply=function(a,b){return"complex64"===a.dtype||"complex64"===b.dtype?this.broadcastedBinaryComplexOp(a.cast("complex64"),b.cast("complex64"),function(aReal,aImag,bReal,bImag){return{real:aReal*bReal-aImag*bImag,imag:aReal*bImag+aImag*bReal}}):this.broadcastedBinaryOp(a,b,upcastType(a.dtype,b.dtype),function(aValue,bValue){return aValue*bValue})},MathBackendCPU.prototype.floorDiv=function(a,b){assertNotComplex([a,b],"floorDiv");var op=function(a,b){return Math.floor(a/b)},outputDtype="int32";return this.broadcastedBinaryOp(a,b,"int32",op)},MathBackendCPU.prototype.sum=function(x,axes){assertNotComplex(x,"sum"),assertAxesAreInnerMostDims("sum",axes,x.rank);for(var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1],resultDtype,result=zeros(outShape,upcastType(x.dtype,"int32")),reduceSize=sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId),i=0;i<vals.length;++i){for(var offset=i*reduceSize,sum=0,j=0;j<reduceSize;++j)sum+=aVals[offset+j];vals[i]=sum}return result},MathBackendCPU.prototype.prod=function(x,axes){assertNotComplex(x,"sum");for(var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1],resultDtype,result=zeros(outShape,upcastType(x.dtype,"int32")),reduceSize=sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId),i=0;i<vals.length;++i){for(var offset=i*reduceSize,prod=1,j=0;j<reduceSize;++j)prod*=aVals[offset+j];vals[i]=prod}return result},MathBackendCPU.prototype.unsortedSegmentSum=function(x,segmentIds,numSegments){assertNotComplex(x,"unsortedSegmentSum");for(var res=[],numIters=x.rank-segmentIds.rank,i=0;i<numIters;++i)segmentIds=segmentIds.expandDims(i+1);for(var i=0;i<numSegments;++i){var segmentId=scalar(i,"int32"),mask,sum=equal(segmentId,segmentIds).asType("float32").mul(x).sum(0);res.push(sum)}return stack(res)},MathBackendCPU.prototype.argMin=function(x,axis){assertNotComplex(x,"argMin");var axes=[axis];assertAxesAreInnerMostDims("argMin",axes,x.rank);for(var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1],result=zeros(outShape,"int32"),reduceSize=sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId),i=0;i<vals.length;++i){for(var offset=i*reduceSize,min=aVals[offset],minIndex=0,j=0;j<reduceSize;++j){var value=aVals[offset+j];value<min&&(min=value,minIndex=j)}vals[i]=minIndex}return result},MathBackendCPU.prototype.argMax=function(x,axis){assertNotComplex(x,"argMax");var axes=[axis];assertAxesAreInnerMostDims("argMax",axes,x.rank);for(var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1],result=zeros(outShape,"int32"),reduceSize=sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId),i=0;i<vals.length;++i){for(var offset=i*reduceSize,max=aVals[offset],maxIndex=0,j=0;j<reduceSize;++j){var value=aVals[offset+j];value>max&&(max=value,maxIndex=j)}vals[i]=maxIndex}return result},MathBackendCPU.prototype.cumsum=function(x,axis,exclusive,reverse){if(assertNotComplex(x,"cumsum"),axis!==x.rank-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(x.rank-1)+" but got axis="+axis);for(var resultDtype=upcastType(x.dtype,"int32"),result=zeros(x.shape,resultDtype),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId),finalDim=x.shape[x.rank-1],indexAdjuster=reverse?function(i,j){return i+finalDim-j-1}:function(i,j){return i+j},i=0;i<aVals.length;i+=finalDim)for(var j=0;j<finalDim;j++){var idx=indexAdjuster(i,j);if(0===j)vals[idx]=exclusive?0:aVals[idx];else{var prevIdx=indexAdjuster(i,j-1);vals[idx]=exclusive?aVals[prevIdx]+vals[prevIdx]:aVals[idx]+vals[prevIdx]}}return result},MathBackendCPU.prototype.equal=function(a,b){return assertNotComplex([a,b],"equal"),this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal===bVal?1:0})},MathBackendCPU.prototype.notEqual=function(a,b){return assertNotComplex([a,b],"notEqual"),this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal!==bVal?1:0})},MathBackendCPU.prototype.less=function(a,b){return assertNotComplex([a,b],"less"),this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal<bVal?1:0})},MathBackendCPU.prototype.lessEqual=function(a,b){return assertNotComplex([a,b],"lessEqual"),this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal<=bVal?1:0})},MathBackendCPU.prototype.greater=function(a,b){return assertNotComplex([a,b],"greater"),this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal>bVal?1:0})},MathBackendCPU.prototype.greaterEqual=function(a,b){return assertNotComplex([a,b],"greaterEqual"),this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal>=bVal?1:0})},MathBackendCPU.prototype.logicalNot=function(x){assertNotComplex(x,"logicalNot");for(var values=this.readSync(x.dataId),newValues=new Uint8Array(values.length),i=0;i<values.length;++i)newValues[i]=values[i]?0:1;return this.makeOutput(newValues,x.shape,"bool")},MathBackendCPU.prototype.logicalAnd=function(a,b){return assertNotComplex([a,b],"logicalAnd"),this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal&&bVal})},MathBackendCPU.prototype.logicalOr=function(a,b){return assertNotComplex([a,b],"logicalOr"),this.broadcastedBinaryOp(a,b,"bool",function(aVal,bVal){return aVal||bVal})},MathBackendCPU.prototype.select=function(condition,a,b){assertNotComplex([condition,a,b],"select");for(var values=this.readSync(condition.dataId),aValues=this.readSync(a.dataId),bValues=this.readSync(b.dataId),result=zeros(a.shape,upcastType(a.dtype,b.dtype)),newValues=this.readSync(result.dataId),index=0,offset=0===condition.rank||condition.rank>1||1===a.rank?1:sizeFromShape(a.shape.slice(1)),i=0;i<values.length;i++)for(var j=0;j<offset;j++)1===values[i]?newValues[index++]=aValues[i]:newValues[index++]=bValues[i];return result},MathBackendCPU.prototype.where=function(condition){assertNotComplex([condition],"where");var condVals=this.readSync(condition.dataId);return whereImpl(condition.shape,condVals)},MathBackendCPU.prototype.topk=function(x,k,sorted){var xVals;return assertNotComplex(x,"topk"),topkImpl(this.readSync(x.dataId),x.shape,x.dtype,k,sorted)},MathBackendCPU.prototype.min=function(x,axes){assertNotComplex(x,"min"),assertAxesAreInnerMostDims("min",axes,x.rank);for(var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1],result=zeros(outShape,x.dtype),reduceSize=sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId),i=0;i<vals.length;++i){for(var offset=i*reduceSize,min=aVals[offset],j=0;j<reduceSize;++j){var value=aVals[offset+j];value<min&&(min=value)}vals[i]=min}return result},MathBackendCPU.prototype.minimum=function(a,b){return assertNotComplex([a,b],"minimum"),this.broadcastedBinaryOp(a,b,a.dtype,function(aVal,bVal){return Math.min(aVal,bVal)})},MathBackendCPU.prototype.mod=function(a,b){return assertNotComplex([a,b],"mod"),this.broadcastedBinaryOp(a,b,a.dtype,function(aVal,bVal){var rem=aVal%bVal;return aVal<0&&bVal<0||aVal>=0&&bVal>=0?rem:(rem+bVal)%bVal})},MathBackendCPU.prototype.max=function(x,axes){assertNotComplex(x,"max"),assertAxesAreInnerMostDims("max",axes,x.rank);for(var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1],result=zeros(outShape,x.dtype),reduceSize=sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId),i=0;i<vals.length;++i){for(var offset=i*reduceSize,max=aVals[offset],j=0;j<reduceSize;++j){var value=aVals[offset+j];value>max&&(max=value)}vals[i]=max}return result},MathBackendCPU.prototype.maximum=function(a,b){return assertNotComplex([a,b],"maximum"),this.broadcastedBinaryOp(a,b,a.dtype,function(aVal,bVal){return Math.max(aVal,bVal)})},MathBackendCPU.prototype.all=function(x,axes){assertNotComplex(x,"all"),assertAxesAreInnerMostDims("all",axes,x.rank);for(var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1],result=zeros(outShape,x.dtype),reduceSize=sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId),i=0;i<vals.length;++i){for(var offset=i*reduceSize,all=aVals[offset],j=0;j<reduceSize;++j){var value=aVals[offset+j];all=all&&value}vals[i]=all}return result},MathBackendCPU.prototype.any=function(x,axes){assertNotComplex(x,"any"),assertAxesAreInnerMostDims("any",axes,x.rank);for(var _a=computeOutAndReduceShapes(x.shape,axes),outShape=_a[0],reduceShape=_a[1],result=zeros(outShape,x.dtype),reduceSize=sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId),i=0;i<vals.length;++i){for(var offset=i*reduceSize,anyVal=aVals[offset],j=0;j<reduceSize;++j){var value=aVals[offset+j];anyVal=anyVal||value}vals[i]=anyVal}return result},MathBackendCPU.prototype.squaredDifference=function(a,b){return assertNotComplex([a,b],"squaredDifference"),this.broadcastedBinaryOp(a,b,a.dtype,function(aVal,bVal){var diff=aVal-bVal;return diff*diff})},MathBackendCPU.prototype.ceil=function(x){assertNotComplex(x,"ceil");for(var values=this.readSync(x.dataId),newValues=new Float32Array(values.length),i=0;i<values.length;++i)newValues[i]=Math.ceil(values[i]);return this.makeOutput(newValues,x.shape,"float32")},MathBackendCPU.prototype.floor=function(x){assertNotComplex(x,"floor");for(var values=this.readSync(x.dataId),newValues=new Float32Array(values.length),i=0;i<values.length;++i)newValues[i]=Math.floor(values[i]);return this.makeOutput(newValues,x.shape,"float32")},MathBackendCPU.prototype.sign=function(x){assertNotComplex(x,"x");for(var values=this.readSync(x.dataId),newValues=new Float32Array(values.length),i=0;i<values.length;++i)values[i]<0?newValues[i]=-1:values[i]>0?newValues[i]=1:newValues[i]=0;return this.makeOutput(newValues,x.shape,"float32")},MathBackendCPU.prototype.isNaN=function(x){assertNotComplex(x,"x");for(var values=this.readSync(x.dataId),newValues=new Uint8Array(values.length),i=0;i<values.length;++i)Number.isNaN(values[i])&&(newValues[i]=1);return this.makeOutput(newValues,x.shape,"bool")},MathBackendCPU.prototype.isInf=function(x){assertNotComplex(x,"x");for(var values=this.readSync(x.dataId),newValues=new Uint8Array(values.length),i=0;i<values.length;++i)Math.abs(values[i])===1/0&&(newValues[i]=1);return this.makeOutput(newValues,x.shape,"bool")},MathBackendCPU.prototype.isFinite=function(x){assertNotComplex(x,"x");for(var values=this.readSync(x.dataId),newValues=new Uint8Array(values.length),i=0;i<values.length;++i)Number.isFinite(values[i])&&(newValues[i]=1);return this.makeOutput(newValues,x.shape,"bool")},MathBackendCPU.prototype.round=function(x){assertNotComplex(x,"round");for(var values=this.readSync(x.dataId),newValues=new Float32Array(values.length),i=0;i<values.length;++i){var base=Math.floor(values[i]);values[i]-base<.5?newValues[i]=Math.floor(values[i]):values[i]-base>.5?newValues[i]=Math.ceil(values[i]):newValues[i]=base%2==0?base:base+1}return this.makeOutput(newValues,x.shape,"float32")},MathBackendCPU.prototype.exp=function(x){assertNotComplex(x,"exp");for(var values=this.readSync(x.dataId),newValues=new Float32Array(values.length),i=0;i<values.length;++i)newValues[i]=Math.exp(values[i]);return this.makeOutput(newValues,x.shape,"float32")},MathBackendCPU.prototype.expm1=function(x){assertNotComplex(x,"expm1");for(var values=this.readSync(x.dataId),newValues=new Float32Array(values.length),i=0;i<values.length;++i)newValues[i]=Math.expm1(values[i]);return this.makeOutput(newValues,x.shape,"float32")},MathBackendCPU.prototype.log=function(x){assertNotComplex(x,"log");for(var values=this.readSync(x.dataId),newValues=new Float32Array(values.length),i=0;i<values.length;++i){var value=values[i];newValues[i]=Math.log(value)}return this.makeOutput(newValues,x.shape,"float32")},MathBackendCPU.prototype.log1p=function(x){assertNotComplex(x,"log1p");for(var values=this.readSync(x.dataId),newValues=new Float32Array(values.length),i=0;i<values.length;++i){var value=values[i];newValues[i]=Math.log1p(value)}return this.makeOutput(newValues,x.shape,"float32")},MathBackendCPU.prototype.sqrt=function(x){assertNotComplex(x,"sqrt");for(var values=this.readSync(x.dataId),newValues=new Float32Array(values.length),i=0;i<values.length;++i){var value=values[i];newValues[i]=Math.sqrt(value)}return this.makeOutput(newValues,x.shape,"float32")},MathBackendCPU.prototype.rsqrt=function(x){assertNotComplex(x,"rsqrt");for(var values=this.readSync(x.dataId),newValues=new Float32Array(values.length),i=0;i<values.length;++i){var value=values[i];newValues[i]=1/Math.sqrt(value)}return this.makeOutput(newValues,x.shape,"float32")},MathBackendCPU.prototype.reciprocal=function(x){assertNotComplex(x,"reciprocal");for(var values=this.readSync(x.dataId),newValues=new Float32Array(values.length),i=0;i<values.length;++i)newValues[i]=1/values[i];return this.makeOutput(newValues,x.shape,"float32")},MathBackendCPU.prototype.linear=function(x){return x},MathBackendCPU.prototype.relu=function(x){assertNotComplex(x,"relu");for(var res=zeros(x.shape,x.dtype),resVals=this.readSync(res.dataId),inVals=this.readSync(x.dataId),i=0;i<inVals.length;++i)resVals[i]=Math.max(0,inVals[i]);return res},MathBackendCPU.prototype.relu6=function(x){assertNotComplex(x,"relu");for(var res=zeros(x.shape,x.dtype),resVals=this.readSync(res.dataId),inVals=this.readSync(x.dataId),i=0;i<inVals.length;++i)resVals[i]=Math.min(Math.max(0,inVals[i]),6);return res},MathBackendCPU.prototype.prelu=function(x,a){return assertNotComplex([x,a],"prelu"),this.broadcastedBinaryOp(x,a,x.dtype,function(xValue,aValue){return xValue<0?aValue*xValue:xValue})},MathBackendCPU.prototype.elu=function(x){assertNotComplex(x,"elu");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i){var v=values[i];resultValues[i]=v>=0?v:Math.exp(v)-1}return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.eluDer=function(dy,y){assertNotComplex([dy,y],"eluDer");for(var resultValues=new Float32Array(y.size),values=this.readSync(y.dataId),dyValues=this.readSync(dy.dataId),i=0;i<values.length;++i){var v=values[i];resultValues[i]=v>=1?dyValues[i]:dyValues[i]*(v+1)}return this.makeOutput(resultValues,y.shape,"float32")},MathBackendCPU.prototype.selu=function(x){assertNotComplex(x,"selu");for(var scaleAlpha=SELU_SCALEALPHA,scale=SELU_SCALE,resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i){var v=values[i];resultValues[i]=v>=0?scale*v:scaleAlpha*(Math.exp(v)-1)}return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.clip=function(x,min,max){assertNotComplex(x,"clip");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i){var v=values[i];resultValues[i]=v>max?max:v<min?min:v}return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.abs=function(x){for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=Math.abs(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.complexAbs=function(x){for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<x.size;++i){var real_1=values[2*i],imag_1=values[2*i+1];resultValues[i]=Math.hypot(real_1,imag_1)}return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.int=function(x){assertNotComplex(x,"int");for(var resultValues=new Int32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=values[i];return this.makeOutput(resultValues,x.shape,"int32")},MathBackendCPU.prototype.sigmoid=function(x){assertNotComplex(x,"sigmoid");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=1/(1+Math.exp(-values[i]));return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.softplus=function(x){assertNotComplex(x,"softplus");for(var epsilon=1.1920928955078125e-7,threshold=Math.log(epsilon)+2,resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i){var tooLarge=values[i]>-threshold,tooSmall=values[i]<threshold,expX=Math.exp(values[i]),result=void 0;result=tooSmall?expX:tooLarge?values[i]:Math.log(1+expX),resultValues[i]=result}return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.sin=function(x){assertNotComplex(x,"sin");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=Math.sin(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.cos=function(x){assertNotComplex(x,"cos");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=Math.cos(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.tan=function(x){assertNotComplex(x,"tan");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=Math.tan(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.asin=function(x){assertNotComplex(x,"asin");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=Math.asin(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.acos=function(x){assertNotComplex(x,"acos");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=Math.acos(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.atan=function(x){assertNotComplex(x,"atan");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=Math.atan(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.atan2=function(a,b){return assertNotComplex([a,b],"atan2"),this.broadcastedBinaryOp(a,b,a.dtype,function(aValue,bValue){return Math.atan2(aValue,bValue)})},MathBackendCPU.prototype.sinh=function(x){assertNotComplex(x,"sinh");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=Math.sinh(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.cosh=function(x){assertNotComplex(x,"cosh");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=Math.cosh(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.tanh=function(x){assertNotComplex(x,"tanh");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=tanh(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.asinh=function(x){assertNotComplex(x,"asinh");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=Math.asinh(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.acosh=function(x){assertNotComplex(x,"acosh");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=Math.acosh(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.atanh=function(x){assertNotComplex(x,"atanh");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i)resultValues[i]=Math.atanh(values[i]);return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.erf=function(x){assertNotComplex(x,"erf");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),p=ERF_P,a1=ERF_A1,a2=ERF_A2,a3=ERF_A3,a4=ERF_A4,a5=ERF_A5,i=0;i<values.length;++i){var sign=Math.sign(values[i]),v=Math.abs(values[i]),t=1/(1+p*v);resultValues[i]=sign*(1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-v*v))}return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.step=function(x,alpha){void 0===alpha&&(alpha=0),assertNotComplex(x,"step");for(var resultValues=new Float32Array(x.size),values=this.readSync(x.dataId),i=0;i<values.length;++i){var value=values[i];isNaN(value)?resultValues[i]=NaN:resultValues[i]=value>0?1:alpha}return this.makeOutput(resultValues,x.shape,"float32")},MathBackendCPU.prototype.fusedConv2d=function(_a){var input=_a.input,filter=_a.filter,convInfo=_a.convInfo,bias=_a.bias,activation=_a.activation,preluActivationWeights=_a.preluActivationWeights,result=this.conv2d(input,filter,convInfo);return bias&&(result=this.add(result,bias)),activation&&(result=mapActivation(this,result,activation,preluActivationWeights)),result},MathBackendCPU.prototype.conv2d=function(x,filter,convInfo){assertNotComplex([x,filter],"conv2d");for(var filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,padLeft=convInfo.padInfo.left,padTop=convInfo.padInfo.top,isChannelsLast="channelsLast"===convInfo.dataFormat,y=buffer(convInfo.outShape,x.dtype),xBatchStride=x.strides[0],xRowStride=isChannelsLast?x.strides[1]:x.strides[2],xColStride=isChannelsLast?x.strides[2]:1,xChannelStride=isChannelsLast?1:x.strides[1],yBatchStride=y.strides[0],yRowStride=isChannelsLast?y.strides[1]:y.strides[2],yColStride=isChannelsLast?y.strides[2]:1,yChannelStride=isChannelsLast?1:y.strides[1],xVals=this.readSync(x.dataId),wVals=this.readSync(filter.dataId),yVals=y.values,b=0;b<convInfo.batchSize;++b)for(var xOffset1=b*xBatchStride,yOffset1=b*yBatchStride,yR=0;yR<convInfo.outHeight;++yR)for(var yOffset2=yOffset1+yR*yRowStride,xRCorner=yR*convInfo.strideHeight-padTop,wR=0;wR<filterHeight;wR++){var xR=xRCorner+wR*dilationHeight;if(!(xR<0||xR>=convInfo.inHeight))for(var wOffset1=wR*filter.strides[0],xOffset2=xOffset1+xR*xRowStride,yC=0;yC<convInfo.outWidth;++yC)for(var yOffset3=yOffset2+yC*yColStride,xCCorner=yC*convInfo.strideWidth-padLeft,wC=0;wC<filterWidth;wC++){var xC=xCCorner+wC*dilationWidth;if(!(xC<0||xC>=convInfo.inWidth))for(var wOffset2,xOffset3=xOffset2+xC*xColStride,wOffset3=wOffset1+wC*filter.strides[1],d1=0;d1<convInfo.inChannels;++d1){for(var xVal=xVals[xOffset3+d1*xChannelStride],d2=0;d2<convInfo.outChannels;++d2)yVals[yOffset3+d2*yChannelStride]+=xVal*wVals[wOffset3+d2];wOffset3+=convInfo.outChannels}}}return y.toTensor()},MathBackendCPU.prototype.conv3d=function(x,filter,convInfo){for(var filterDepth=convInfo.filterDepth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,padFront=convInfo.padInfo.front,padLeft=convInfo.padInfo.left,padTop=convInfo.padInfo.top,y=buffer(convInfo.outShape,x.dtype),xVals=this.readSync(x.dataId),wVals=this.readSync(filter.dataId),yVals=y.values,b=0;b<convInfo.batchSize;++b)for(var xOffset1=b*x.strides[0],yOffset1=b*y.strides[0],yF=0;yF<convInfo.outDepth;++yF)for(var yOffset2=yOffset1+yF*y.strides[1],xFCorner=yF*convInfo.strideDepth-padFront,wF=0;wF<filterDepth;wF++){var xF=xFCorner+wF*dilationDepth;if(!(xF<0||xF>=convInfo.inDepth))for(var wOffset1=wF*filter.strides[0],xOffset2=xOffset1+xF*x.strides[1],yR=0;yR<convInfo.outHeight;++yR)for(var yOffset3=yOffset2+yR*y.strides[2],xRCorner=yR*convInfo.strideHeight-padTop,wR=0;wR<filterHeight;wR++){var xR=xRCorner+wR*dilationHeight;if(!(xR<0||xR>=convInfo.inHeight))for(var wOffset2=wOffset1+wR*filter.strides[1],xOffset3=xOffset2+xR*x.strides[2],yC=0;yC<convInfo.outWidth;++yC)for(var yOffset4=yOffset3+yC*convInfo.outChannels,xCCorner=yC*convInfo.strideWidth-padLeft,wC=0;wC<filterWidth;wC++){var xC=xCCorner+wC*dilationWidth;if(!(xC<0||xC>=convInfo.inWidth))for(var wOffset3=wOffset2+wC*filter.strides[2],xOffset4=xOffset3+xC*convInfo.inChannels,wOffset4=wOffset3,d1=0;d1<convInfo.inChannels;++d1){for(var xVal=xVals[xOffset4+d1],d2=0;d2<convInfo.outChannels;++d2)yVals[yOffset4+d2]+=xVal*wVals[wOffset4+d2];wOffset4+=convInfo.outChannels}}}}return y.toTensor()},MathBackendCPU.prototype.conv2dDerInput=function(dy,filter,convInfo){assertNotComplex([dy,filter],"conv2dDerInput");for(var dx=buffer(convInfo.inShape,"float32"),dxValues=dx.values,dyValues=this.readSync(dy.dataId),fltValues=this.readSync(filter.dataId),_a=filter.strides,fltS0=_a[0],fltS1=_a[1],fltS2=_a[2],batchSize=convInfo.batchSize,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,inChannels=convInfo.inChannels,inHeight=convInfo.inHeight,inWidth=convInfo.inWidth,outChannels=convInfo.outChannels,outHeight=convInfo.outHeight,outWidth=convInfo.outWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dataFormat=convInfo.dataFormat,topPad=filterHeight-1-convInfo.padInfo.top,leftPad=filterWidth-1-convInfo.padInfo.left,isChannelsLast="channelsLast"===dataFormat,xBatchStride=dx.strides[0],xRowStride=isChannelsLast?dx.strides[1]:dx.strides[2],xColStride=isChannelsLast?dx.strides[2]:1,xChannelStride=isChannelsLast?1:dx.strides[1],yBatchStride=dy.strides[0],yRowStride=isChannelsLast?dy.strides[1]:dy.strides[2],yColStride=isChannelsLast?dy.strides[2]:1,yChannelStride=isChannelsLast?1:dy.strides[1],b=0;b<batchSize;++b)for(var d1=0;d1<inChannels;++d1)for(var xR=0;xR<inHeight;++xR)for(var xRCorner=xR-topPad,xRMin=Math.max(0,Math.ceil(xRCorner/strideHeight)),yRMax=Math.min(outHeight,(filterHeight+xRCorner)/strideHeight),xC=0;xC<inWidth;++xC){for(var xCCorner=xC-leftPad,xCMin=Math.max(0,Math.ceil(xCCorner/strideWidth)),yCMax=Math.min(outWidth,(filterWidth+xCCorner)/strideWidth),dotProd=0,yR=xRMin;yR<yRMax;++yR)for(var wR=yR*strideHeight-xRCorner,yC=xCMin;yC<yCMax;++yC)for(var wC,dyOffset=yBatchStride*b+yRowStride*yR+yColStride*yC,fltOffset=fltS0*(filterHeight-1-wR)+fltS1*(filterWidth-1-(yC*strideWidth-xCCorner))+fltS2*d1,d2=0;d2<outChannels;++d2){var pixel,weight;dotProd+=dyValues[dyOffset+yChannelStride*d2]*fltValues[fltOffset+d2]}var dxOffset;dxValues[xBatchStride*b+xRowStride*xR+xColStride*xC+xChannelStride*d1]=dotProd}return dx.toTensor()},MathBackendCPU.prototype.conv3dDerInput=function(dy,filter,convInfo){for(var dx=buffer(convInfo.inShape,"float32"),dxValues=dx.values,_a=dx.strides,dxS0=_a[0],dxS1=_a[1],dxS2=_a[2],dxS3=_a[3],dyValues=this.readSync(dy.dataId),_b=dy.strides,dyS0=_b[0],dyS1=_b[1],dyS2=_b[2],dyS3=_b[3],fltValues=this.readSync(filter.dataId),_c=filter.strides,fltS0=_c[0],fltS1=_c[1],fltS2=_c[2],fltS3=_c[3],batchSize=convInfo.batchSize,filterDepth=convInfo.filterDepth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,inChannels=convInfo.inChannels,inDepth=convInfo.inDepth,inHeight=convInfo.inHeight,inWidth=convInfo.inWidth,outChannels=convInfo.outChannels,outDepth=convInfo.outDepth,outHeight=convInfo.outHeight,outWidth=convInfo.outWidth,strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,frontPad=filterDepth-1-convInfo.padInfo.front,topPad=filterHeight-1-convInfo.padInfo.top,leftPad=filterWidth-1-convInfo.padInfo.left,b=0;b<batchSize;++b)for(var d1=0;d1<inChannels;++d1)for(var xF=0;xF<inDepth;++xF)for(var xFCorner=xF-frontPad,xFMin=Math.max(0,Math.ceil(xFCorner/strideDepth)),yFMax=Math.min(outDepth,(filterDepth+xFCorner)/strideDepth),xR=0;xR<inHeight;++xR)for(var xRCorner=xR-topPad,xRMin=Math.max(0,Math.ceil(xRCorner/strideHeight)),yRMax=Math.min(outHeight,(filterHeight+xRCorner)/strideHeight),xC=0;xC<inWidth;++xC){for(var xCCorner=xC-leftPad,xCMin=Math.max(0,Math.ceil(xCCorner/strideWidth)),yCMax=Math.min(outWidth,(filterWidth+xCCorner)/strideWidth),dotProd=0,yF=xFMin;yF<yFMax;++yF)for(var wF=yF*strideDepth-xFCorner,yR=xRMin;yR<yRMax;++yR)for(var wR=yR*strideHeight-xRCorner,yC=xCMin;yC<yCMax;++yC)for(var wC,dyOffset=dyS0*b+dyS1*yF+dyS2*yR+dyS3*yC,fltOffset=fltS0*(filterDepth-1-wF)+fltS1*(filterHeight-1-wR)+fltS2*(filterWidth-1-(yC*strideWidth-xCCorner))+fltS3*d1,d2=0;d2<outChannels;++d2){var pixel,weight;dotProd+=dyValues[dyOffset+d2]*fltValues[fltOffset+d2]}dxValues[dxS0*b+dxS1*xF+dxS2*xR+dxS3*xC+d1]=dotProd}return dx.toTensor()},MathBackendCPU.prototype.conv2dDerFilter=function(x,dy,convInfo){assertNotComplex([x,dy],"conv2dDerFilter");for(var strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,isChannelsLast="channelsLast"===convInfo.dataFormat,dW=buffer(convInfo.filterShape,"float32"),leftPad=convInfo.padInfo.left,topPad=convInfo.padInfo.top,xBuf=this.bufferSync(x),dyBuf=this.bufferSync(dy),wR=0;wR<filterHeight;++wR)for(var yRMin=Math.max(0,Math.ceil((topPad-wR)/strideHeight)),yRMax=Math.min(convInfo.outHeight,(convInfo.inHeight+topPad-wR)/strideHeight),wC=0;wC<filterWidth;++wC)for(var yCMin=Math.max(0,Math.ceil((leftPad-wC)/strideWidth)),yCMax=Math.min(convInfo.outWidth,(convInfo.inWidth+leftPad-wC)/strideWidth),d1=0;d1<convInfo.inChannels;++d1)for(var d2=0;d2<convInfo.outChannels;++d2){for(var dotProd=0,b=0;b<convInfo.batchSize;++b)for(var yR=yRMin;yR<yRMax;++yR)for(var xR=wR+yR*strideHeight-topPad,yC=yCMin;yC<yCMax;++yC){var xC=wC+yC*strideWidth-leftPad;dotProd+=isChannelsLast?xBuf.get(b,xR,xC,d1)*dyBuf.get(b,yR,yC,d2):xBuf.get(b,d1,xR,xC)*dyBuf.get(b,d2,yR,yC)}dW.set(dotProd,wR,wC,d1,d2)}return dW.toTensor()},MathBackendCPU.prototype.conv3dDerFilter=function(x,dy,convInfo){for(var strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,filterDepth=convInfo.filterDepth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,dw=buffer(convInfo.filterShape,"float32"),dwValues=dw.values,_a=dw.strides,dwS0=_a[0],dwS1=_a[1],dwS2=_a[2],dwS3=_a[3],dyValues=this.readSync(dy.dataId),_b=dy.strides,dyS0=_b[0],dyS1=_b[1],dyS2=_b[2],dyS3=_b[3],xValues=this.readSync(x.dataId),_c=x.strides,xS0=_c[0],xS1=_c[1],xS2=_c[2],xS3=_c[3],frontPad=convInfo.padInfo.front,leftPad=convInfo.padInfo.left,topPad=convInfo.padInfo.top,wF=0;wF<filterDepth;++wF)for(var yFMin=Math.max(0,Math.ceil((frontPad-wF)/strideDepth)),yFMax=Math.min(convInfo.outDepth,(convInfo.inDepth+frontPad-wF)/strideDepth),wOffset1=wF*dwS0,wR=0;wR<filterHeight;++wR)for(var yRMin=Math.max(0,Math.ceil((topPad-wR)/strideHeight)),yRMax=Math.min(convInfo.outHeight,(convInfo.inHeight+topPad-wR)/strideHeight),wOffset2=wR*dwS1+wOffset1,wC=0;wC<filterWidth;++wC)for(var yCMin=Math.max(0,Math.ceil((leftPad-wC)/strideWidth)),yCMax=Math.min(convInfo.outWidth,(convInfo.inWidth+leftPad-wC)/strideWidth),wOffset3=wC*dwS2+wOffset2,d1=0;d1<convInfo.inChannels;++d1)for(var wOffset4=d1*dwS3+wOffset3,d2=0;d2<convInfo.outChannels;++d2){for(var dotProd=0,b=0;b<convInfo.batchSize;++b)for(var xOffset1=b*xS0,yOffset1=b*dyS0,yF=yFMin;yF<yFMax;++yF)for(var xF,xOffset2=(wF+yF*strideDepth-frontPad)*xS1+xOffset1,yOffset2=yF*dyS1+yOffset1,yR=yRMin;yR<yRMax;++yR)for(var xR,xOffset3=(wR+yR*strideHeight-topPad)*xS2+xOffset2,yOffset3=yR*dyS2+yOffset2,yC=yCMin;yC<yCMax;++yC){var xC,xOffset4,yOffset4=yC*dyS3+yOffset3;dotProd+=xValues[(wC+yC*strideWidth-leftPad)*xS3+xOffset3+d1]*dyValues[yOffset4+d2]}dwValues[wOffset4+d2]=dotProd}return dw.toTensor()},MathBackendCPU.prototype.fusedDepthwiseConv2D=function(_a){var input=_a.input,filter=_a.filter,convInfo=_a.convInfo,bias=_a.bias,activation=_a.activation,preluActivationWeights=_a.preluActivationWeights,result=this.depthwiseConv2D(input,filter,convInfo);return bias&&(result=this.add(result,bias)),activation&&(result=mapActivation(this,result,activation,preluActivationWeights)),result},MathBackendCPU.prototype.depthwiseConv2D=function(x,filter,convInfo){assertNotComplex([x,filter],"depthwiseConv2D");for(var filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,padLeft=convInfo.padInfo.left,padTop=convInfo.padInfo.top,chMul=convInfo.outChannels/convInfo.inChannels,y=buffer(convInfo.outShape,x.dtype),xVals=this.readSync(x.dataId),wVals=this.readSync(filter.dataId),yVals=y.values,b=0;b<convInfo.batchSize;++b)for(var xOffset1=b*x.strides[0],yOffset1=b*y.strides[0],yR=0;yR<convInfo.outHeight;++yR)for(var yOffset2=yOffset1+yR*y.strides[1],xRCorner=yR*convInfo.strideHeight-padLeft,wR=0;wR<filterHeight;++wR){var xR=xRCorner+wR*dilationHeight;if(!(xR<0||xR>=convInfo.inHeight))for(var wOffset1=wR*filter.strides[0],xOffset2=xOffset1+xR*x.strides[1],yC=0;yC<convInfo.outWidth;++yC)for(var yOffset3=yOffset2+yC*y.strides[2],xCCorner=yC*convInfo.strideWidth-padTop,wC=0;wC<filterWidth;++wC){var xC=xCCorner+wC*dilationWidth;if(!(xC<0||xC>=convInfo.inWidth))for(var wOffset2=wOffset1+wC*filter.strides[1],xOffset3=xOffset2+xC*convInfo.inChannels,yOffset4=yOffset3,wOffset3=wOffset2,d1=0;d1<convInfo.inChannels;++d1){for(var xVal=xVals[xOffset3+d1],q=0;q<chMul;++q)yVals[yOffset4+q]+=xVal*wVals[wOffset3+q];yOffset4+=chMul,wOffset3+=chMul}}}return y.toTensor()},MathBackendCPU.prototype.depthwiseConv2DDerInput=function(dy,filter,convInfo){assertNotComplex([dy,filter],"depthwiseConv2DDerInput");for(var dx=buffer(convInfo.inShape,"float32"),dxValues=dx.values,_a=dx.strides,dxS0=_a[0],dxS1=_a[1],dxS2=_a[2],dyValues=this.readSync(dy.dataId),_b=dy.strides,dyS0=_b[0],dyS1=_b[1],dyS2=_b[2],fltValues=this.readSync(filter.dataId),_c=filter.strides,fltS0=_c[0],fltS1=_c[1],fltS2=_c[2],batchSize=convInfo.batchSize,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,inChannels=convInfo.inChannels,inHeight=convInfo.inHeight,inWidth=convInfo.inWidth,outChannels=convInfo.outChannels,outHeight=convInfo.outHeight,outWidth=convInfo.outWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,topPad=filterHeight-1-convInfo.padInfo.top,leftPad=filterWidth-1-convInfo.padInfo.left,chMul=outChannels/inChannels,b=0;b<batchSize;++b)for(var d1=0;d1<inChannels;++d1)for(var xR=0;xR<inHeight;++xR)for(var xRCorner=xR-topPad,xRMin=Math.max(0,Math.ceil(xRCorner/strideHeight)),yRMax=Math.min(outHeight,(filterHeight+xRCorner)/strideHeight),xC=0;xC<inWidth;++xC){for(var xCCorner=xC-leftPad,xCMin=Math.max(0,Math.ceil(xCCorner/strideWidth)),yCMax=Math.min(outWidth,(filterWidth+xCCorner)/strideWidth),dotProd=0,yR=xRMin;yR<yRMax;++yR)for(var wR=yR*strideHeight-xRCorner,yC=xCMin;yC<yCMax;++yC)for(var wC,dyOffset=dyS0*b+dyS1*yR+dyS2*yC,fltOffset=fltS0*(filterHeight-1-wR)+fltS1*(filterWidth-1-(yC*strideWidth-xCCorner))+fltS2*d1,dm=0;dm<chMul;++dm){var d2,pixel,weight;dotProd+=dyValues[dyOffset+(d1*chMul+dm)]*fltValues[fltOffset+dm]}dxValues[dxS0*b+dxS1*xR+dxS2*xC+d1]=dotProd}return dx.toTensor()},MathBackendCPU.prototype.depthwiseConv2DDerFilter=function(x,dy,convInfo){assertNotComplex([x,dy],"depthwiseConv2DDerFilter");for(var strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,dW=buffer(convInfo.filterShape,"float32"),leftPad=convInfo.padInfo.left,topPad=convInfo.padInfo.top,chMul=convInfo.outChannels/convInfo.inChannels,xBuf=this.bufferSync(x),dyBuf=this.bufferSync(dy),wR=0;wR<filterHeight;++wR)for(var yRMin=Math.max(0,Math.ceil((topPad-wR)/strideHeight)),yRMax=Math.min(convInfo.outHeight,(convInfo.inHeight+topPad-wR)/strideHeight),wC=0;wC<filterWidth;++wC)for(var yCMin=Math.max(0,Math.ceil((leftPad-wC)/strideWidth)),yCMax=Math.min(convInfo.outWidth,(convInfo.inWidth+leftPad-wC)/strideWidth),d2=0;d2<convInfo.outChannels;++d2){for(var d1=Math.trunc(d2/chMul),dm=d2%chMul,dotProd=0,b=0;b<convInfo.batchSize;++b)for(var yR=yRMin;yR<yRMax;++yR)for(var xR=wR+yR*strideHeight-topPad,yC=yCMin;yC<yCMax;++yC){var xC=wC+yC*strideWidth-leftPad;dotProd+=xBuf.get(b,xR,xC,d1)*dyBuf.get(b,yR,yC,d2)}dW.set(dotProd,wR,wC,d1,dm)}return dW.toTensor()},MathBackendCPU.prototype.tile=function(x,reps){return assertNotComplex(x,"tile"),tile(this.bufferSync(x),reps)},MathBackendCPU.prototype.pad=function(x,paddings,constantValue){assertNotComplex(x,"pad");var outShape=paddings.map(function(p,i){return p[0]+x.shape[i]+p[1]}),start=paddings.map(function(p){return p[0]}),xBuffer=this.bufferSync(x),buffer$1=buffer(outShape,x.dtype);0!==constantValue&&buffer$1.values.fill(constantValue);for(var i=0;i<x.size;i++){var coords=xBuffer.indexToLoc(i),outCoords=coords.map(function(c,i){return c+start[i]});buffer$1.set.apply(buffer$1,[xBuffer.get.apply(xBuffer,coords)].concat(outCoords))}return buffer$1.toTensor()},MathBackendCPU.prototype.gather=function(x,indices,axis){assertNotComplex([x,indices],"gather");var newShape=x.shape.slice(),indicesValues=this.readSync(indices.dataId);newShape[axis]=indicesValues.length;for(var result=buffer(newShape,x.dtype),xBuf=this.bufferSync(x),i=0;i<result.size;++i){var newLoc=result.indexToLoc(i),originalLoc=newLoc.slice();originalLoc[axis]=indicesValues[newLoc[axis]];var originalIndex=xBuf.locToIndex(originalLoc);result.values[i]=xBuf.values[originalIndex]}return result.toTensor()},MathBackendCPU.prototype.batchToSpaceND=function(x,blockShape,crops){assertNotComplex([x],"batchToSpaceND");var prod=blockShape.reduce(function(a,b){return a*b}),reshaped=getReshaped(x.shape,blockShape,prod),permuted=getPermuted(reshaped.length,blockShape.length),reshapedPermuted=getReshapedPermuted(x.shape,blockShape,prod),sliceBeginCoords=getSliceBeginCoords(crops,blockShape.length),sliceSize=getSliceSize(reshapedPermuted,crops,blockShape.length);return transpose(x.reshape(reshaped),permuted).reshape(reshapedPermuted).slice(sliceBeginCoords,sliceSize)},MathBackendCPU.prototype.spaceToBatchND=function(x,blockShape,paddings){assertNotComplex([x],"spaceToBatchND");var prod=blockShape.reduce(function(a,b){return a*b}),completePaddings=[[0,0]];completePaddings.push.apply(completePaddings,paddings);for(var i=1+blockShape.length;i<x.shape.length;++i)completePaddings.push([0,0]);var paddedX=x.pad(completePaddings),reshapedPaddedShape=getReshaped(paddedX.shape,blockShape,prod,!1),permutedReshapedPaddedPermutation=getPermuted(reshapedPaddedShape.length,blockShape.length,!1),flattenShape=getReshapedPermuted(paddedX.shape,blockShape,prod,!1);return transpose(paddedX.reshape(reshapedPaddedShape),permutedReshapedPaddedPermutation).reshape(flattenShape)},MathBackendCPU.prototype.maxPool=function(x,convInfo){var xValues;return assertNotComplex(x,"maxPool"),pool$1(this.readSync(x.dataId),x.shape,x.dtype,x.strides,convInfo,"max").toTensor()},MathBackendCPU.prototype.maxPoolBackprop=function(dy,x,y,convInfo){assertNotComplex([x,y],"maxPoolBackprop");for(var xValues=this.readSync(x.dataId),maxPosBuf=buffer(convInfo.outShape,x.dtype,maxPoolPositions(xValues,x.shape,x.dtype,convInfo).values),strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,dx=buffer(x.shape,"float32"),dyBuf=this.bufferSync(dy),b=0;b<convInfo.batchSize;++b)for(var d=0;d<convInfo.inChannels;++d)for(var dxR=0;dxR<convInfo.inHeight;++dxR)for(var dxC=0;dxC<convInfo.inWidth;++dxC){for(var dyRCorner=dxR-padTop,dyCCorner=dxC-padLeft,dotProd=0,wR=0;wR<effectiveFilterHeight;wR+=dilationHeight){var dyR=(dyRCorner+wR)/strideHeight;if(!(dyR<0||dyR>=convInfo.outHeight||Math.floor(dyR)!==dyR))for(var wC=0;wC<effectiveFilterWidth;wC+=dilationWidth){var dyC=(dyCCorner+wC)/strideWidth;if(!(dyC<0||dyC>=convInfo.outWidth||Math.floor(dyC)!==dyC)){var maxPos,curPos,mask=effectiveFilterHeight*effectiveFilterWidth-1-maxPosBuf.get(b,dyR,dyC,d)===wR*effectiveFilterWidth+wC?1:0,pixel;if(0!==mask)dotProd+=dyBuf.get(b,dyR,dyC,d)*mask}}}dx.set(dotProd,b,dxR,dxC,d)}return dx.toTensor()},MathBackendCPU.prototype.avgPoolBackprop=function(dy,x,convInfo){assertNotComplex([dy,x],"avgPoolBackprop");for(var strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,dx=buffer(x.shape,"float32"),avgMultiplier=1/(filterHeight*filterWidth),dyBuf=this.bufferSync(dy),b=0;b<convInfo.batchSize;++b)for(var d=0;d<convInfo.inChannels;++d)for(var dxR=0;dxR<convInfo.inHeight;++dxR)for(var dxC=0;dxC<convInfo.inWidth;++dxC){for(var dyRCorner=dxR-padTop,dyCCorner=dxC-padLeft,dotProd=0,wR=0;wR<effectiveFilterHeight;wR+=dilationHeight){var dyR=(dyRCorner+wR)/strideHeight;if(!(dyR<0||dyR>=convInfo.outHeight||Math.floor(dyR)!==dyR))for(var wC=0;wC<effectiveFilterWidth;wC+=dilationWidth){var dyC=(dyCCorner+wC)/strideWidth,pixel;if(!(dyC<0||dyC>=convInfo.outWidth||Math.floor(dyC)!==dyC))dotProd+=dyBuf.get(b,dyR,dyC,d)}}dx.set(dotProd*avgMultiplier,b,dxR,dxC,d)}return dx.toTensor()},MathBackendCPU.prototype.pool3d=function(x,convInfo,poolType){assertNotComplex(x,"pool3d");for(var strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=convInfo.padInfo.front,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,initialValue="max"===poolType?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,xValues=this.readSync(x.dataId),output=buffer(convInfo.outShape,x.dtype),outputVals=output.values,outputBatchStrides=convInfo.outShape[1]*convInfo.outShape[2]*convInfo.outShape[3]*convInfo.outShape[4],outputDepthStrides=convInfo.outShape[2]*convInfo.outShape[3]*convInfo.outShape[4],outputRowStrides=convInfo.outShape[3]*convInfo.outShape[4],outputColStrides=convInfo.outShape[4],batch=0;batch<convInfo.batchSize;++batch)for(var outputBatchOffset=batch*outputBatchStrides,inputBatchOffset=batch*x.strides[0],channel=0;channel<convInfo.inChannels;++channel)for(var yDepth=0;yDepth<convInfo.outDepth;++yDepth){for(var xDepthCorner=yDepth*strideDepth-padFront,xDepthMin=xDepthCorner;xDepthMin<0;)xDepthMin+=dilationDepth;for(var xDepthMax=Math.min(convInfo.inDepth,effectiveFilterDepth+xDepthCorner),outputDepthOffset=outputBatchOffset+yDepth*outputDepthStrides,yRow=0;yRow<convInfo.outHeight;++yRow){for(var xRowCorner=yRow*strideHeight-padTop,xRowMin=xRowCorner;xRowMin<0;)xRowMin+=dilationHeight;for(var xRowMax=Math.min(convInfo.inHeight,effectiveFilterHeight+xRowCorner),outputRowOffset=outputDepthOffset+yRow*outputRowStrides,yCol=0;yCol<convInfo.outWidth;++yCol){for(var xColCorner=yCol*strideWidth-padLeft,xColMin=xColCorner;xColMin<0;)xColMin+=dilationWidth;for(var xColMax=Math.min(convInfo.inWidth,effectiveFilterWidth+xColCorner),outputColOffset=outputRowOffset+yCol*outputColStrides,minMaxValue=initialValue,avgValue=0,count=0,xDepth=xDepthMin;xDepth<xDepthMax;xDepth+=dilationDepth){for(var xDepthOffset=inputBatchOffset+xDepth*x.strides[1],xRow=xRowMin;xRow<xRowMax;xRow+=dilationHeight){for(var xRowOffset=xDepthOffset+xRow*x.strides[2],xCol=xColMin;xCol<xColMax;xCol+=dilationWidth){var xColOffset,pixel=xValues[xRowOffset+xCol*x.strides[3]+channel];if("max"===poolType&&pixel>minMaxValue?minMaxValue=pixel:"avg"===poolType&&(avgValue+=pixel,count++),isNaN(minMaxValue))break}if(isNaN(minMaxValue))break}if(isNaN(minMaxValue))break}var outputOffset;outputVals[outputColOffset+channel]="avg"===poolType?avgValue/count:minMaxValue}}}return output.toTensor()},MathBackendCPU.prototype.avgPool3d=function(x,convInfo){return assertNotComplex(x,"avgPool3d"),this.pool3d(x,convInfo,"avg").toFloat()},MathBackendCPU.prototype.avgPool3dBackprop=function(dy,x,convInfo){assertNotComplex([dy,x],"avgPool3dBackprop");for(var strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,filterDepth=convInfo.filterDepth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=effectiveFilterDepth-1-convInfo.padInfo.front,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,dx=buffer(x.shape,"float32"),avgMultiplier=1/(filterDepth*filterHeight*filterWidth),dyBuf=this.bufferSync(dy),batch=0;batch<convInfo.batchSize;++batch)for(var channel=0;channel<convInfo.inChannels;++channel)for(var dxDepth=0;dxDepth<convInfo.inDepth;++dxDepth)for(var dxRow=0;dxRow<convInfo.inHeight;++dxRow)for(var dxCol=0;dxCol<convInfo.inWidth;++dxCol){for(var dyDepthCorner=dxDepth-padFront,dyRowCorner=dxRow-padTop,dyColCorner=dxCol-padLeft,dotProd=0,wDepth=0;wDepth<effectiveFilterDepth;wDepth+=dilationDepth){var dyDepth=(dyDepthCorner+wDepth)/strideDepth;if(!(dyDepth<0||dyDepth>=convInfo.outDepth||Math.floor(dyDepth)!==dyDepth))for(var wRow=0;wRow<effectiveFilterHeight;wRow+=dilationHeight){var dyRow=(dyRowCorner+wRow)/strideHeight;if(!(dyRow<0||dyRow>=convInfo.outHeight||Math.floor(dyRow)!==dyRow))for(var wCol=0;wCol<effectiveFilterWidth;wCol+=dilationWidth){var dyCol=(dyColCorner+wCol)/strideWidth,pixel;if(!(dyCol<0||dyCol>=convInfo.outWidth||Math.floor(dyCol)!==dyCol))dotProd+=dyBuf.get(batch,dyDepth,dyRow,dyCol,channel)}}}dx.set(dotProd*avgMultiplier,batch,dxDepth,dxRow,dxCol,channel)}return dx.toTensor()},MathBackendCPU.prototype.maxPool3d=function(x,convInfo){return assertNotComplex(x,"maxPool3d"),this.pool3d(x,convInfo,"max").toFloat()},MathBackendCPU.prototype.maxPool3dPositions=function(x,convInfo){for(var maxPositions=buffer(convInfo.outShape,"int32"),strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=convInfo.padInfo.front,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,xBuf=this.bufferSync(x),batch=0;batch<convInfo.batchSize;++batch)for(var channel=0;channel<convInfo.inChannels;++channel)for(var yDepth=0;yDepth<convInfo.outDepth;++yDepth){for(var xDepthCorner=yDepth*strideDepth-padFront,xDepthMin=xDepthCorner;xDepthMin<0;)xDepthMin+=dilationDepth;for(var xDepthMax=Math.min(convInfo.inDepth,effectiveFilterDepth+xDepthCorner),yRow=0;yRow<convInfo.outHeight;++yRow){for(var xRowCorner=yRow*strideHeight-padTop,xRowMin=xRowCorner;xRowMin<0;)xRowMin+=dilationHeight;for(var xRowMax=Math.min(convInfo.inHeight,effectiveFilterHeight+xRowCorner),yCol=0;yCol<convInfo.outWidth;++yCol){for(var xColCorner=yCol*strideWidth-padLeft,xColMin=xColCorner;xColMin<0;)xColMin+=dilationWidth;for(var xColMax=Math.min(convInfo.inWidth,effectiveFilterWidth+xColCorner),maxValue=Number.NEGATIVE_INFINITY,maxPosition=-1,xDepth=xDepthMin;xDepth<xDepthMax;xDepth+=dilationDepth)for(var wDepth=xDepth-xDepthCorner,xRow=xRowMin;xRow<xRowMax;xRow+=dilationHeight)for(var wRow=xRow-xRowCorner,xCol=xColMin;xCol<xColMax;xCol+=dilationWidth){var wCol=xCol-xColCorner,pixel=xBuf.get(batch,xDepth,xRow,xCol,channel);pixel>=maxValue&&(maxValue=pixel,maxPosition=wDepth*effectiveFilterHeight*effectiveFilterWidth+wRow*effectiveFilterHeight+wCol)}maxPositions.set(maxPosition,batch,yDepth,yRow,yCol,channel)}}}return maxPositions.toTensor()},MathBackendCPU.prototype.maxPool3dBackprop=function(dy,x,y,convInfo){assertNotComplex([x,y],"maxPool3dBackprop");for(var maxPositions=this.maxPool3dPositions(x,convInfo),strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=effectiveFilterDepth-1-convInfo.padInfo.front,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,dx=buffer(x.shape,"float32"),maxPosBuf=this.bufferSync(maxPositions),dyBuf=this.bufferSync(dy),batch=0;batch<convInfo.batchSize;++batch)for(var channel=0;channel<convInfo.inChannels;++channel)for(var dxDepth=0;dxDepth<convInfo.inDepth;++dxDepth)for(var dxRow=0;dxRow<convInfo.inHeight;++dxRow)for(var dxCol=0;dxCol<convInfo.inWidth;++dxCol){for(var dyDepthCorner=dxDepth-padFront,dyRowCorner=dxRow-padTop,dyColCorner=dxCol-padLeft,dotProd=0,wDepth=0;wDepth<effectiveFilterDepth;wDepth+=dilationDepth){var dyDepth=(dyDepthCorner+wDepth)/strideDepth;if(!(dyDepth<0||dyDepth>=convInfo.outDepth||Math.floor(dyDepth)!==dyDepth))for(var wRow=0;wRow<effectiveFilterHeight;wRow+=dilationHeight){var dyRow=(dyRowCorner+wRow)/strideHeight;if(!(dyRow<0||dyRow>=convInfo.outHeight||Math.floor(dyRow)!==dyRow))for(var wCol=0;wCol<effectiveFilterWidth;wCol+=dilationWidth){var dyCol=(dyColCorner+wCol)/strideWidth;if(!(dyCol<0||dyCol>=convInfo.outWidth||Math.floor(dyCol)!==dyCol)){var maxPos,curPos,mask=effectiveFilterDepth*effectiveFilterHeight*effectiveFilterWidth-1-maxPosBuf.get(batch,dyDepth,dyRow,dyCol,channel)===wDepth*effectiveFilterHeight*effectiveFilterWidth+wRow*effectiveFilterWidth+wCol?1:0,pixel;if(0!==mask)dotProd+=dyBuf.get(batch,dyDepth,dyRow,dyCol,channel)*mask}}}}dx.set(dotProd,batch,dxDepth,dxRow,dxCol,channel)}return dx.toTensor()},MathBackendCPU.prototype.cast=function(x,dtype){return castTensor(x,dtype,this)},MathBackendCPU.prototype.reshape=function(x,shape){return reshapeTensor(x,shape)},MathBackendCPU.prototype.avgPool=function(x,convInfo){var xValues;return assertNotComplex(x,"avgPool"),assertNotComplex(x,"maxPool"),pool$1(this.readSync(x.dataId),x.shape,x.dtype,x.strides,convInfo,"avg").toTensor().toFloat()},MathBackendCPU.prototype.resizeBilinear=function(x,newHeight,newWidth,alignCorners){assertNotComplex(x,"resizeBilinear");for(var _a=x.shape,batch=_a[0],oldHeight=_a[1],oldWidth=_a[2],numChannels=_a[3],xValues=this.readSync(x.dataId),result=new Float32Array(sizeFromShape([batch,newHeight,newWidth,numChannels])),effectiveInputSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth],effectiveOutputSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth],outputIdx=0,effectiveRowSizeRatio=effectiveInputSize[0]/effectiveOutputSize[0],effectiveColSizeRatio=effectiveInputSize[1]/effectiveOutputSize[1],b=0;b<batch;b++)for(var r=0;r<newHeight;r++)for(var sourceFracRow=effectiveRowSizeRatio*r,sourceRowFloor=Math.floor(sourceFracRow),rowFrac=sourceFracRow-sourceRowFloor,sourceRowCeil=Math.min(oldHeight-1,Math.ceil(sourceFracRow)),topRowOffset=b*x.strides[0]+sourceRowFloor*x.strides[1],botRowOffset=b*x.strides[0]+sourceRowCeil*x.strides[1],c=0;c<newWidth;c++)for(var sourceFracCol=effectiveColSizeRatio*c,sourceColFloor=Math.floor(sourceFracCol),colFrac=sourceFracCol-sourceColFloor,sourceColCeil=Math.min(oldWidth-1,Math.ceil(sourceFracCol)),topLeftOffest=topRowOffset+sourceColFloor*x.strides[2],botLeftOffset=botRowOffset+sourceColFloor*x.strides[2],topRightOffset=topRowOffset+sourceColCeil*x.strides[2],botRightOffest=botRowOffset+sourceColCeil*x.strides[2],d=0;d<numChannels;d++){var topLeft=xValues[topLeftOffest+d],bottomLeft=xValues[botLeftOffset+d],topRight,bottomRight,top_1=topLeft+(xValues[topRightOffset+d]-topLeft)*colFrac,bottom,newValue=top_1+(bottomLeft+(xValues[botRightOffest+d]-bottomLeft)*colFrac-top_1)*rowFrac;result[outputIdx++]=newValue}return tensor(result,[batch,newHeight,newWidth,numChannels])},MathBackendCPU.prototype.resizeBilinearBackprop=function(dy,x,alignCorners){assertNotComplex([dy,x],"resizeBilinearBackprop");for(var _a=x.shape,batch=_a[0],xHeight=_a[1],xWidth=_a[2],depth=_a[3],_b=dy.shape,yHeight=_b[1],yWidth=_b[2],output=new Float32Array(batch*xHeight*xWidth*depth),effectiveXSize=[alignCorners&&yHeight>1?xHeight-1:xHeight,alignCorners&&yWidth>1?xWidth-1:xWidth],effectiveYSize=[alignCorners&&yHeight>1?yHeight-1:yHeight,alignCorners&&yWidth>1?yWidth-1:yWidth],heightScale=effectiveXSize[0]/effectiveYSize[0],widthScale=effectiveXSize[1]/effectiveYSize[1],dyValues=this.readSync(dy.dataId),offset=0,b=0;b<batch;b++)for(var bOffset=b*x.strides[0],r=0;r<yHeight;r++)for(var dxR=r*heightScale,topDxRIndex=Math.floor(dxR),bottomDxRIndex=Math.min(Math.ceil(dxR),xHeight-1),topDxROffset=bOffset+topDxRIndex*x.strides[1],bottomDxROffset=bOffset+bottomDxRIndex*x.strides[1],dxRLerp=dxR-topDxRIndex,inverseDxRLerp=1-dxRLerp,c=0;c<yWidth;c++)for(var dxC=c*widthScale,leftDxCIndex=Math.floor(dxC),rightDxCIndex=Math.min(Math.ceil(dxC),xWidth-1),dxCLerp=dxC-leftDxCIndex,inverseDxCLerp=1-dxCLerp,topLeftRCOffset=topDxROffset+leftDxCIndex*x.strides[2],topRightRCOffset=topDxROffset+rightDxCIndex*x.strides[2],bottomLeftRCOffset=bottomDxROffset+leftDxCIndex*x.strides[2],bottomRightRCOffset=bottomDxROffset+rightDxCIndex*x.strides[2],inverseDxRLerpTimesInverseDxCLerp=inverseDxRLerp*inverseDxCLerp,inverseDxRLerpTimesDxCLerp=inverseDxRLerp*dxCLerp,dxRLerpTimesInverseDxCLerp=dxRLerp*inverseDxCLerp,dxRLerpTimesDxCLerp=dxRLerp*dxCLerp,d=0;d<depth;d++){var dyVal=dyValues[offset++];output[topLeftRCOffset+d]+=dyVal*inverseDxRLerpTimesInverseDxCLerp,output[topRightRCOffset+d]+=dyVal*inverseDxRLerpTimesDxCLerp,output[bottomLeftRCOffset+d]+=dyVal*dxRLerpTimesInverseDxCLerp,output[bottomRightRCOffset+d]+=dyVal*dxRLerpTimesDxCLerp}return tensor4d(output,[batch,xWidth,xHeight,depth],x.dtype)},MathBackendCPU.prototype.resizeNearestNeighbor=function(x,newHeight,newWidth,alignCorners){assertNotComplex(x,"resizeNearestNeighbor");for(var _a=x.shape,batch=_a[0],oldHeight=_a[1],oldWidth=_a[2],numChannels=_a[3],xValues=this.readSync(x.dataId),output=new Float32Array(batch*newHeight*newWidth*numChannels),effectiveInputSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth],effectiveOutputSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth],effectiveRowSizeRatio=effectiveInputSize[0]/effectiveOutputSize[0],effectiveColSizeRatio=effectiveInputSize[1]/effectiveOutputSize[1],outputOffset=0,b=0;b<batch;b++)for(var batchOffset=b*x.strides[0],r=0;r<newHeight;r++)for(var sourceFracRow=effectiveRowSizeRatio*r,sourceNearestRow,rowOffset=batchOffset+Math.min(oldHeight-1,alignCorners?Math.round(sourceFracRow):Math.floor(sourceFracRow))*x.strides[1],c=0;c<newWidth;c++)for(var sourceFracCol=effectiveColSizeRatio*c,sourceNearestCol,colOffset=rowOffset+Math.min(oldWidth-1,alignCorners?Math.round(sourceFracCol):Math.floor(sourceFracCol))*x.strides[2],d=0;d<numChannels;d++){var newVal=xValues[colOffset+d];output[outputOffset++]=newVal}return tensor(output,[batch,newHeight,newWidth,numChannels],x.dtype)},MathBackendCPU.prototype.resizeNearestNeighborBackprop=function(dy,x,alignCorners){assertNotComplex([dy,x],"resizeNearestNeighborBackprop");for(var _a=x.shape,batch=_a[0],xHeight=_a[1],xWidth=_a[2],depth=_a[3],_b=dy.shape,yHeight=_b[1],yWidth=_b[2],output=new Float32Array(batch*xHeight*xWidth*depth),dyValues=this.readSync(dy.dataId),effectiveXSize=[alignCorners&&yHeight>1?xHeight-1:xHeight,alignCorners&&yWidth>1?xWidth-1:xWidth],effectiveYSize=[alignCorners&&yHeight>1?yHeight-1:yHeight,alignCorners&&yWidth>1?yWidth-1:yWidth],heightScale=effectiveXSize[0]/effectiveYSize[0],widthScale=effectiveXSize[1]/effectiveYSize[1],invHeightScale=1/heightScale,invWidthScale=1/widthScale,winHeight=2*Math.ceil(invHeightScale)+2,winWidth=2*Math.ceil(invWidthScale)+2,b=0;b<batch;b++)for(var batchOffset=b*x.strides[0],r=0;r<xHeight;r++)for(var rowOffset=batchOffset+r*x.strides[1],startRLerp=Math.floor(r*invHeightScale),startDyR=Math.floor(startRLerp-winHeight/2),c=0;c<xWidth;c++)for(var colOffset=rowOffset+c*x.strides[2],startCLerp=Math.floor(c*invWidthScale),startDyC=Math.floor(startCLerp-winWidth/2),d=0;d<depth;d++){for(var accum=0,dyRIndex=0;dyRIndex<winHeight;dyRIndex++){var dyR=dyRIndex+startDyR;if(!(dyR<0||dyR>=yHeight)){var dyROffset=batchOffset+dyR*dy.strides[1],sourceFracRow=dyR*heightScale,sourceNearestRow;if(r===Math.min(xHeight-1,alignCorners?Math.round(sourceFracRow):Math.floor(sourceFracRow)))for(var dyCIndex=0;dyCIndex<winWidth;dyCIndex++){var dyC=dyCIndex+startDyC;if(!(dyC<0||dyC>=yWidth)){var dyCOffset=dyROffset+dyC*dy.strides[2],sourceFracCol=dyC*widthScale,sourceNearestCol;c===Math.min(xWidth-1,alignCorners?Math.round(sourceFracCol):Math.floor(sourceFracCol))&&(accum+=dyValues[dyCOffset+d])}}}}output[colOffset+d]=accum}return tensor4d(output,x.shape,x.dtype)},MathBackendCPU.prototype.batchNormalization=function(x,mean,variance,varianceEpsilon,scale,offset){assertNotComplex([x,mean,variance,scale,offset],"batchNorm");for(var xVals=this.readSync(x.dataId),mVals=this.readSync(mean.dataId),varVals=this.readSync(variance.dataId),sVals=scale?this.readSync(scale.dataId):new Float32Array([1]),offVals=offset?this.readSync(offset.dataId):new Float32Array([0]),outVals=new Float32Array(xVals.length),offValsLength=offVals.length,sValsLength=sVals.length,varValsLength=varVals.length,mValsLength=mVals.length,offi=0,mi=0,si=0,vi=0,i=0;i<xVals.length;++i)outVals[i]=offVals[offi++]+(xVals[i]-mVals[mi++])*sVals[si++]/Math.sqrt(varVals[vi++]+varianceEpsilon),offi>=offValsLength&&(offi=0),mi>=mValsLength&&(mi=0),si>=sValsLength&&(si=0),vi>=varValsLength&&(vi=0);return tensor4d(outVals,x.shape)},MathBackendCPU.prototype.localResponseNormalization4D=function(x,depthRadius,bias,alpha,beta){assertNotComplex(x,"localResponseNormalization4D");var channels=x.shape[3],maxD=channels-1,xValues=this.readSync(x.dataId),size=x.size,result=new Float32Array(size);function sumAcrossChannels(offset){for(var currentChannel=offset%channels,beginSumOffset=offset-currentChannel+Math.max(0,currentChannel-depthRadius),endSumOffset=offset-currentChannel+Math.min(currentChannel+depthRadius,maxD),sum=0;beginSumOffset<=endSumOffset;beginSumOffset++){var z=xValues[beginSumOffset];sum+=z*z}return sum}for(var offset=0;offset<size;offset++){var sum=sumAcrossChannels(offset),val=xValues[offset]*Math.pow(bias+alpha*sum,-beta);result[offset]=val}return tensor4d(result,x.shape)},MathBackendCPU.prototype.LRNGrad=function(dy,inputImage,outputImage,depthRadius,bias,alpha,beta){assertNotComplex(dy,"LRNGrad");for(var channels=dy.shape[3],dyValues=this.readSync(dy.dataId),inputImageValues=this.readSync(inputImage.dataId),outputImageValues=this.readSync(outputImage.dataId),result=new Float32Array(dy.size),size=dy.size,offset=0;offset<size;offset++){for(var currentChannel=offset%channels,depthBegin=offset-currentChannel+Math.max(0,currentChannel-depthRadius),depthEnd=offset-currentChannel+Math.min(channels,currentChannel+depthRadius+1),norm=0,k=depthBegin;k<depthEnd;k++)norm+=Math.pow(inputImageValues[k],2);norm=alpha*norm+bias;for(var k=depthBegin;k<depthEnd;k++){var dyi=-2*alpha*beta*inputImageValues[k]*outputImageValues[offset]/norm;offset===k&&(dyi+=Math.pow(norm,-beta)),dyi*=dyValues[offset],result[k]+=dyi}}return tensor4d(result,dy.shape)},MathBackendCPU.prototype.multinomial=function(logits,normalized,numSamples,seed){assertNotComplex(logits,"multinomial");for(var probabilities=normalized?logits:softmax(logits),batchSize=probabilities.shape[0],numEvents=probabilities.shape[1],res=zeros([batchSize,numSamples],"int32"),resVals=this.readSync(res.dataId),probVals=this.readSync(probabilities.dataId),b=0;b<batchSize;++b){var offset=b*numEvents,cdf=new Float32Array(numEvents-1);cdf[0]=probVals[offset];for(var event_1=1;event_1<cdf.length;++event_1)cdf[event_1]=cdf[event_1-1]+probVals[offset+event_1];for(var random=seedrandom_1(seed.toString()),outOffset=b*numSamples,sampleId=0;sampleId<numSamples;++sampleId){var r=random();resVals[outOffset+sampleId]=cdf.length;for(var event_2=0;event_2<cdf.length;event_2++)if(r<cdf[event_2]){resVals[outOffset+sampleId]=event_2;break}}}return res},MathBackendCPU.prototype.oneHot=function(indices,depth,onValue,offValue){assertNotComplex(indices,"oneHot");var res=new Float32Array(indices.size*depth);res.fill(offValue);for(var indicesVal=this.readSync(indices.dataId),event_3=0;event_3<indices.size;++event_3)indicesVal[event_3]>=0&&indicesVal[event_3]<depth&&(res[event_3*depth+indicesVal[event_3]]=onValue);return tensor2d(res,[indices.size,depth],"int32")},MathBackendCPU.prototype.nonMaxSuppression=function(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){var boxesVals,scoresVals;return assertNotComplex(boxes,"nonMaxSuppression"),nonMaxSuppressionV3(this.readSync(boxes.dataId),this.readSync(scores.dataId),maxOutputSize,iouThreshold,scoreThreshold)},MathBackendCPU.prototype.fft=function(x){return this.fftBatch(x,!1)},MathBackendCPU.prototype.ifft=function(x){return this.fftBatch(x,!0)},MathBackendCPU.prototype.fftBatch=function(x,inverse){for(var batch=x.shape[0],innerDim=x.shape[1],realResult=buffer(x.shape,"float32"),imagResult=buffer(x.shape,"float32"),real$1=real(x).as2D(batch,innerDim),imag$1=imag(x).as2D(batch,innerDim),b=0;b<batch;b++)for(var r=real$1.slice([b,0],[1,innerDim]),i=imag$1.slice([b,0],[1,innerDim]),input=complex(r,i),res=this.readSync(this.fftImpl(input,inverse).dataId),d=0;d<innerDim;d++){var c=getComplexWithIndex(res,d);realResult.values[b*innerDim+d]=c.real,imagResult.values[b*innerDim+d]=c.imag}var t;return complex(realResult.toTensor(),imagResult.toTensor()).as2D(batch,innerDim)},MathBackendCPU.prototype.fftImpl=function(x,inverse){var x1D=x.as1D(),n=x1D.size;if(this.isExponentOf2(n)){var result=this.fftRadix2(x1D,n,inverse).as2D(x.shape[0],x.shape[1]);return inverse&&(result=complex(real(result).div(scalar(n)),imag(result).div(scalar(n)))),result}var data=this.readSync(x.dataId),rawOutput,output=splitRealAndImagArrays(this.fourierTransformByMatmul(data,n,inverse));return complex(output.real,output.imag).as2D(x.shape[0],x.shape[1])},MathBackendCPU.prototype.isExponentOf2=function(size){return 0==(size&size-1)},MathBackendCPU.prototype.fftRadix2=function(input,size,inverse){if(1===size)return input;var data=this.readSync(input.dataId),half=size/2,evenComplex=complexWithEvenIndex(data),evenTensor=complex(evenComplex.real,evenComplex.imag).as1D(),oddComplex=complexWithOddIndex(data),oddTensor=complex(oddComplex.real,oddComplex.imag).as1D();evenTensor=this.fftRadix2(evenTensor,half,inverse),oddTensor=this.fftRadix2(oddTensor,half,inverse);var e=exponents(size,inverse),exponent=complex(e.real,e.imag).mul(oddTensor),addPart=evenTensor.add(exponent),subPart=evenTensor.sub(exponent),realTensor=real(addPart).concat(real(subPart)),imagTensor=imag(addPart).concat(imag(subPart));return complex(realTensor,imagTensor).as1D()},MathBackendCPU.prototype.fourierTransformByMatmul=function(data,size,inverse){for(var ret=new Float32Array(2*size),r=0;r<size;r++){for(var real_2=0,imag_2=0,c=0;c<size;c++){var e=exponent(r*c,size,inverse),term=getComplexWithIndex(data,c);real_2+=term.real*e.real-term.imag*e.imag,imag_2+=term.real*e.imag+term.imag*e.real}inverse&&(real_2/=size,imag_2/=size),assignToTypedArray(ret,real_2,imag_2,r)}return ret},MathBackendCPU.prototype.depthToSpace=function(x,blockSize,dataFormat){assert("NHWC"===dataFormat,function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+dataFormat}),assert(blockSize>1,function(){return"blockSize should be > 1 for depthToSpace, but was: "+blockSize});for(var batchSize=x.shape[0],inputHeight=x.shape[1],inputWidth=x.shape[2],inputDepth=x.shape[3],outputHeight=inputHeight*blockSize,outputWidth=inputWidth*blockSize,outputDepth=inputDepth/(blockSize*blockSize),xValues=this.readSync(x.dataId),result=new Float32Array(batchSize*outputHeight*outputWidth*outputDepth),outputIdx=0,b=0;b<batchSize;++b)for(var h=0;h<outputHeight;++h)for(var inH=Math.floor(h/blockSize),offsetH=h%blockSize,w=0;w<outputWidth;++w)for(var inW=Math.floor(w/blockSize),offsetW,offsetD=(offsetH*blockSize+w%blockSize)*outputDepth,d=0;d<outputDepth;++d){var inD,inputIdx=d+offsetD+inputDepth*(inW+inputWidth*(inH+inputHeight*b));result[outputIdx++]=xValues[inputIdx]}return tensor4d(result,[batchSize,outputHeight,outputWidth,outputDepth])},MathBackendCPU.prototype.broadcastedBinaryOp=function(a,b,dtype,op){var newShape=assertAndGetBroadcastShape(a.shape,b.shape),result=buffer(newShape,dtype),aVals=this.readSync(a.dataId),bVals=this.readSync(b.dataId),aBroadcastDims=getBroadcastDims(a.shape,newShape),bBroadcastDims=getBroadcastDims(b.shape,newShape),resVals=result.values;if(aBroadcastDims.length+bBroadcastDims.length===0)for(var i=0;i<resVals.length;++i)resVals[i]=op(aVals[i%aVals.length],bVals[i%bVals.length]);else for(var aBuf=this.bufferSync(a),bBuf=this.bufferSync(b),_loop_2=function(i){var loc=result.indexToLoc(i),aLoc=loc.slice(-a.rank);aBroadcastDims.forEach(function(d){return aLoc[d]=0});var aIndex=aBuf.locToIndex(aLoc),bLoc=loc.slice(-b.rank);bBroadcastDims.forEach(function(d){return bLoc[d]=0});var bIndex=bBuf.locToIndex(bLoc);resVals[i]=op(aVals[aIndex],bVals[bIndex])},i=0;i<resVals.length;++i)_loop_2(i);return result.toTensor()},MathBackendCPU.prototype.broadcastedBinaryComplexOp=function(a,b,op){var newShape=assertAndGetBroadcastShape(a.shape,b.shape),realResult=buffer(newShape,"float32"),imagResult=buffer(newShape,"float32"),aVals=this.readSync(a.dataId),bVals=this.readSync(b.dataId),aBroadcastDims=getBroadcastDims(a.shape,newShape),bBroadcastDims=getBroadcastDims(b.shape,newShape),realVals=realResult.values,imagVals=imagResult.values;if(aBroadcastDims.length+bBroadcastDims.length===0)for(var i=0;i<realVals.length;i++){var aIdx=i%aVals.length,bIdx=i%bVals.length,result=op(aVals[2*aIdx],aVals[2*aIdx+1],bVals[2*bIdx],bVals[2*bIdx+1]);realVals[i]=result.real,imagVals[i]=result.imag}else for(var aRealBuf=this.bufferSync(this.data.get(a.dataId).complexTensors.real),bRealBuf=this.bufferSync(this.data.get(b.dataId).complexTensors.real),_loop_3=function(i){var loc=realResult.indexToLoc(i),aLoc=loc.slice(-a.rank);aBroadcastDims.forEach(function(d){return aLoc[d]=0});var aIndex=aRealBuf.locToIndex(aLoc),bLoc=loc.slice(-b.rank);bBroadcastDims.forEach(function(d){return bLoc[d]=0});var bIndex=bRealBuf.locToIndex(bLoc),opResult=op(aVals[2*aIndex],aVals[2*aIndex+1],bVals[2*bIndex],bVals[2*bIndex+1]);realVals[i]=opResult.real,imagVals[i]=opResult.imag},i=0;i<realVals.length;i++)_loop_3(i);return this.complex(realResult.toTensor(),imagResult.toTensor())},MathBackendCPU.prototype.split=function(x,sizeSplits,axis){return split$1(x,sizeSplits,axis)},MathBackendCPU.prototype.dispose=function(){},MathBackendCPU.prototype.floatPrecision=function(){return 32},MathBackendCPU.prototype.epsilon=function(){return 1e-7},MathBackendCPU.prototype.cropAndResize=function(images,boxes,boxIndex,cropSize,method,extrapolationValue){for(var _a=images.shape,batch=_a[0],imageHeight=_a[1],imageWidth=_a[2],numChannels=_a[3],numBoxes=boxes.shape[0],cropHeight=cropSize[0],cropWidth=cropSize[1],output=buffer([numBoxes,cropHeight,cropWidth,numChannels],"float32"),boxVals=this.readSync(boxes.dataId),boxIndVals=this.readSync(boxIndex.dataId),imageVals=this.readSync(images.dataId),inStride=images.strides,outStride=output.strides,b=0;b<numBoxes;b++){var startInd=4*b,y1=boxVals[startInd],x1=boxVals[startInd+1],y2=boxVals[startInd+2],x2=boxVals[startInd+3],bInd=boxIndVals[b];if(!(bInd>=batch))for(var heightScale=cropHeight>1?(y2-y1)*(imageHeight-1)/(cropHeight-1):0,widthScale=cropWidth>1?(x2-x1)*(imageWidth-1)/(cropWidth-1):0,y=0;y<cropHeight;y++){var yInd=cropHeight>1?y1*(imageHeight-1)+y*heightScale:.5*(y1+y2)*(imageHeight-1);if(yInd<0||yInd>imageHeight-1)for(var x=0;x<cropWidth;x++)for(var c=0;c<numChannels;c++){var ind=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[ind]=extrapolationValue}else if("bilinear"===method)for(var topInd=Math.floor(yInd),bottomInd=Math.ceil(yInd),yLerp=yInd-topInd,x=0;x<cropWidth;x++){var xInd;if((xInd=cropWidth>1?x1*(imageWidth-1)+x*widthScale:.5*(x1+x2)*(imageWidth-1))<0||xInd>imageWidth-1)for(var c=0;c<numChannels;c++){var ind=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[ind]=extrapolationValue}else for(var leftInd=Math.floor(xInd),rightInd=Math.ceil(xInd),xLerp=xInd-leftInd,c=0;c<numChannels;c++){var ind,topLeft=imageVals[ind=c+leftInd*inStride[2]+topInd*inStride[1]+bInd*inStride[0]],topRight=imageVals[ind=c+rightInd*inStride[2]+topInd*inStride[1]+bInd*inStride[0]],bottomLeft=imageVals[ind=c+leftInd*inStride[2]+bottomInd*inStride[1]+bInd*inStride[0]],bottomRight,top_2=topLeft+(topRight-topLeft)*xLerp,bottom=bottomLeft+(imageVals[ind=c+rightInd*inStride[2]+bottomInd*inStride[1]+bInd*inStride[0]]-bottomLeft)*xLerp;ind=c+x*outStride[2]+y*outStride[1]+b*outStride[0],output.values[ind]=top_2+(bottom-top_2)*yLerp}}else for(var x=0;x<cropWidth;++x){var xInd;if((xInd=cropWidth>1?x1*(imageWidth-1)+x*widthScale:.5*(x1+x2)*(imageWidth-1))<0||xInd>imageWidth-1)for(var c=0;c<numChannels;c++){var ind=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[ind]=extrapolationValue}else for(var closestX=Math.round(xInd),closestY=Math.round(yInd),c=0;c<numChannels;c++){var inInd=c+closestX*inStride[2]+closestY*inStride[1]+bInd*inStride[0],outInd=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[outInd]=imageVals[inInd]}}}}return output.toTensor()},MathBackendCPU.prototype.sparseToDense=function(sparseIndices,sparseValues,outputShape,defaultValue){var _a=calculateShapes(sparseValues,sparseIndices,outputShape),sliceRank=_a.sliceRank,numUpdates=_a.numUpdates,sliceSize=_a.sliceSize,strides=_a.strides,outputSize=_a.outputSize,sumDupeIndices=!1;return this.scatter(sparseIndices,sparseValues,outputShape,outputSize,sliceSize,numUpdates,sliceRank,strides,defaultValue,!1)},MathBackendCPU.prototype.gatherND=function(x,indices){var indicesShape=indices.shape,sliceRank=indicesShape[indicesShape.length-1],_a=prepareAndValidate(x,indices),resultShape=_a[0],numSlices=_a[1],sliceSize=_a[2],strides=_a[3];if(0===numSlices)return tensor([],resultShape,x.dtype);for(var buffer=new TensorBuffer([numSlices,sliceSize],x.dtype),indicesData=this.readSync(indices.dataId),xData=this.readSync(x.dataId),i=0;i<numSlices;i++){for(var index=[],flattenIndex=0,j=0;j<sliceRank;j++){var dim=indicesData[i*sliceRank+j];flattenIndex+=dim*strides[j],index.push(dim)}if(flattenIndex<0||flattenIndex>=x.size/sliceSize)throw new Error("Invalid indices: "+index+" does not index into "+x.shape);for(var k=0;k<sliceSize;k++)buffer.values[i*sliceSize+k]=xData[flattenIndex*sliceSize+k]}return buffer.toTensor().reshape(resultShape)},MathBackendCPU.prototype.scatterND=function(indices,updates,shape){var _a=calculateShapes(updates,indices,shape),sliceRank=_a.sliceRank,numUpdates=_a.numUpdates,sliceSize=_a.sliceSize,strides=_a.strides,outputSize=_a.outputSize,defaultValue=scalar(0),sumDupeIndices=!0;return this.scatter(indices,updates,shape,outputSize,sliceSize,numUpdates,sliceRank,strides,defaultValue,!0)},MathBackendCPU.prototype.fill=function(shape,value,dtype){var values=getArrayFromDType(dtype=dtype||inferDtype(value),sizeFromShape(shape));return values.fill(value),ENGINE.makeTensor(values,shape,dtype,this)},MathBackendCPU.prototype.onesLike=function(x){if("string"===x.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(x.shape,1,x.dtype)},MathBackendCPU.prototype.zerosLike=function(x){var values=getArrayFromDType(x.dtype,sizeFromShape(x.shape));return this.makeOutput(values,x.shape,x.dtype)},MathBackendCPU.prototype.linspace=function(start,stop,num){return linspaceImpl(start,stop,num)},MathBackendCPU.prototype.scatter=function(indices,updates,shape,outputSize,sliceSize,numUpdates,sliceRank,strides,defaultValue,sumDupeIndices){var flattenShape=[outputSize/sliceSize,sliceSize],indicesData=this.readSync(indices.dataId),updatesData=this.readSync(updates.dataId);if(0===outputSize)return tensor([],shape,updates.dtype);var buffer=new TensorBuffer(flattenShape,updates.dtype);buffer.values.fill(this.readSync(defaultValue.dataId)[0]);for(var i=0;i<numUpdates;i++){for(var index=[],flattenIndex=0,j=0;j<sliceRank;j++){var dim=indicesData[i*sliceRank+j];index.push(dim),flattenIndex+=dim*strides[j]}if(flattenIndex<0||flattenIndex>=outputSize/sliceSize)throw new Error("Invalid indices: "+index+" does not index into "+shape);for(var k=0;k<sliceSize;k++)sumDupeIndices?buffer.values[flattenIndex*sliceSize+k]+=updatesData[i*sliceSize+k]:buffer.values[flattenIndex*sliceSize+k]=0===updates.rank?updatesData[0]:updatesData[i*sliceSize+k]}return buffer.toTensor().reshape(shape)},MathBackendCPU}(KernelBackend);function createBinaryKernelConfig(name,op){return{kernelName:name,backendName:"cpu",kernelFunc:function(_a){var inputs=_a.inputs,backend=_a.backend,_b=inputs,a=_b.a,b=_b.b,cpuBackend=backend;assertNotComplex([a,b],name);var aVals=cpuBackend.data.get(a.dataId).values,bVals=cpuBackend.data.get(b.dataId).values,_c=op(a.shape,b.shape,aVals,bVals,a.dtype),resultData=_c[0],resultShape=_c[1],dataId;return{dataId:cpuBackend.write(resultData,resultShape,a.dtype),shape:resultShape,dtype:a.dtype}}}}function createBinaryKernelImpl(op){return function(aShape,bShape,aVals,bVals,dtype){var newShape=assertAndGetBroadcastShape(aShape,bShape),resultRank=newShape.length,resultStrides=computeStrides(newShape),resultSize,result=getTypedArrayFromDType(dtype,sizeFromShape(newShape)),aRank=aShape.length,bRank=bShape.length,aStrides=computeStrides(aShape),bStrides=computeStrides(bShape),aBroadcastDims=getBroadcastDims(aShape,newShape),bBroadcastDims=getBroadcastDims(bShape,newShape);if(aBroadcastDims.length+bBroadcastDims.length===0)for(var i=0;i<result.length;++i)result[i]=op(aVals[i%aVals.length],bVals[i%bVals.length]);else for(var _loop_1=function(i){var loc=indexToLoc(i,resultRank,resultStrides),aLoc=loc.slice(-aRank);aBroadcastDims.forEach(function(d){return aLoc[d]=0});var aIndex=locToIndex(aLoc,aRank,aStrides),bLoc=loc.slice(-bRank);bBroadcastDims.forEach(function(d){return bLoc[d]=0});var bIndex=locToIndex(bLoc,bRank,bStrides);result[i]=op(aVals[aIndex],bVals[bIndex])},i=0;i<result.length;++i)_loop_1(i);return[result,newShape]}}ENGINE.registerBackend("cpu",function(){return new MathBackendCPU},1);var divImpl=createBinaryKernelImpl(function(a,b){return a/b}),divConfig=createBinaryKernelConfig(Div,divImpl);function maxPoolWithArgmaxImpl(xValues,xShape,dtype,includeBatchInIndex,convInfo){var strides,maxPools=pool$1(xValues,xShape,dtype,computeStrides(xShape),convInfo,"max"),maxPositions=maxPoolPositions(xValues,xShape,dtype,convInfo,!0,includeBatchInIndex);return[maxPools.values,maxPositions.values]}var maxPoolWithArgmaxConfig={kernelName:MaxPoolWithArgmax,backendName:"cpu",kernelFunc:function(_a){var inputs=_a.inputs,attrs=_a.attrs,backend=_a.backend,x=inputs.x,_b=attrs,filterSize=_b.filterSize,strides=_b.strides,pad=_b.pad,includeBatchInIndex=_b.includeBatchInIndex,cpuBackend=backend;assertNotComplex(x,"MaxPoolWithArgmax");var values=cpuBackend.data.get(x.dataId).values,convInfo=computePool2DInfo(x.shape,filterSize,strides,[1,1],pad),_c=maxPoolWithArgmaxImpl(values,x.shape,x.dtype,includeBatchInIndex,convInfo),pooled=_c[0],indexes=_c[1],pooledDataId=cpuBackend.write(pooled,convInfo.outShape,x.dtype),indexesDataId=cpuBackend.write(indexes,convInfo.outShape,x.dtype);return[{dataId:pooledDataId,shape:convInfo.outShape,dtype:x.dtype},{dataId:indexesDataId,shape:convInfo.outShape,dtype:"int32"}]}},nonMaxSuppressionV5Config={kernelName:NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(_a){var inputs=_a.inputs,backend=_a.backend,attrs=_a.attrs,_b=inputs,boxes=_b.boxes,scores=_b.scores,_c=attrs,maxOutputSize=_c.maxOutputSize,iouThreshold=_c.iouThreshold,scoreThreshold=_c.scoreThreshold,softNmsSigma=_c.softNmsSigma,cpuBackend=backend;assertNotComplex(boxes,"NonMaxSuppressionWithScore");var boxesVals,scoresVals,maxOutputSizeVal,iouThresholdVal,scoreThresholdVal,softNmsSigmaVal,_d=nonMaxSuppressionV5(cpuBackend.data.get(boxes.dataId).values,cpuBackend.data.get(scores.dataId).values,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma),selectedIndices,selectedScores;return[_d.selectedIndices,_d.selectedScores]}},squareConfig={kernelName:Square,backendName:"cpu",kernelFunc:function(_a){var inputs=_a.inputs,backend=_a.backend,x=inputs.x,cpuBackend=backend,dataId;assertNotComplex(x,"square");for(var values=cpuBackend.data.get(x.dataId).values,newValues=new Float32Array(values.length),i=0;i<values.length;++i){var value=values[i];newValues[i]=value*value}return{dataId:cpuBackend.write(newValues,x.shape,x.dtype),shape:x.shape,dtype:x.dtype}}},squaredDifferenceImpl=createBinaryKernelImpl(function(aVal,bVal){var diff=aVal-bVal;return diff*diff}),squaredDifferenceConfig;function transposeImpl(xVals,xShape,dtype,perm,newShape){for(var xSize=sizeFromShape(xShape),xRank=xShape.length,xStrides=computeStrides(xShape),newStrides=computeStrides(newShape),result=getTypedArrayFromDType(dtype,sizeFromShape(newShape)),i=0;i<xSize;++i){for(var loc=indexToLoc(i,xRank,xStrides),newLoc=new Array(loc.length),i_1=0;i_1<newLoc.length;i_1++)newLoc[i_1]=loc[perm[i_1]];var newIndex;result[locToIndex(newLoc,xRank,newStrides)]=xVals[i]}return result}for(var transposeConfig,kernelConfigs,_i=0,kernelConfigs_1=[nonMaxSuppressionV5Config,squareConfig,createBinaryKernelConfig(SquaredDifference,squaredDifferenceImpl),divConfig,{kernelName:Transpose,backendName:"cpu",kernelFunc:function(_a){var inputs=_a.inputs,attrs=_a.attrs,backend=_a.backend,x=inputs.x,perm=attrs.perm,cpuBackend=backend;assertNotComplex(x,"transpose");for(var xRank=x.shape.length,newShape=new Array(xRank),i=0;i<newShape.length;i++)newShape[i]=x.shape[perm[i]];var values,result=transposeImpl(cpuBackend.data.get(x.dataId).values,x.shape,x.dtype,perm,newShape),dataId;return{dataId:cpuBackend.write(result,newShape,x.dtype),shape:newShape,dtype:x.dtype}}},maxPoolWithArgmaxConfig];_i<kernelConfigs_1.length;_i++){var kernelConfig;registerKernel(kernelConfigs_1[_i])}function divImpl$1(a,b,backend){var program=new BinaryOpProgram(DIV,a.shape,b.shape),output;return env().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&(program=new BinaryOpPackedProgram(DIV$1,a.shape,b.shape,!0)),backend.runWebGLProgram(program,[a,b],"float32")}var divConfig$1={kernelName:Div,backendName:"webgl",kernelFunc:function(_a){var inputs=_a.inputs,backend=_a.backend,_b=inputs,a,b,webglBackend;return divImpl$1(_b.a,_b.b,backend)}},FromPixelsProgram=function(){function FromPixelsProgram(outputShape){this.variableNames=["A"];var glsl=getGlslDifferences(),height=outputShape[0],width=outputShape[1];this.outputShape=outputShape,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+width+".0, "+height+".0);\n\n        vec4 values = "+glsl.texture2D+"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "}return FromPixelsProgram}(),FromPixelsPackedProgram=function(){function FromPixelsPackedProgram(outputShape){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var glsl=getGlslDifferences(),height=outputShape[0],width=outputShape[1];this.outputShape=outputShape,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2("+width+".0, "+height+".0);\n            vec4 values = "+glsl.texture2D+"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        "+glsl.output+" = result;\n      }\n    "}return FromPixelsPackedProgram}(),fromPixelsConfig={kernelName:FromPixels,backendName:"webgl",kernelFunc:fromPixels},fromPixels2DContext;function fromPixels(args){var inputs=args.inputs,backend=args.backend,attrs=args.attrs,pixels=inputs.pixels,numChannels=attrs.numChannels,isVideo="undefined"!=typeof HTMLVideoElement&&pixels instanceof HTMLVideoElement,isImage="undefined"!=typeof HTMLImageElement&&pixels instanceof HTMLImageElement,_a=isVideo?[pixels.videoWidth,pixels.videoHeight]:[pixels.width,pixels.height],width=_a[0],height=_a[1],texShape=[height,width],outShape=[height,width,numChannels];(isImage||isVideo)&&(null==fromPixels2DContext&&(fromPixels2DContext=document.createElement("canvas").getContext("2d")),fromPixels2DContext.canvas.width=width,fromPixels2DContext.canvas.height=height,fromPixels2DContext.drawImage(pixels,0,0,width,height),pixels=fromPixels2DContext.canvas);var tempPixelHandle=backend.makeTensorInfo(texShape,"int32");backend.texData.get(tempPixelHandle.dataId).usage=TextureUsage.PIXELS,backend.gpgpu.uploadPixelDataToTexture(backend.getTexture(tempPixelHandle.dataId),pixels);var program=env().getBool("WEBGL_PACK")?new FromPixelsPackedProgram(outShape):new FromPixelsProgram(outShape),res=backend.runWebGLProgram(program,[tempPixelHandle],"int32");return backend.disposeData(tempPixelHandle.dataId),res}function maxPoolWithArgmaxImpl$1(x,includeBatchInIndex,convInfo,backend){var program=new Pool2DProgram(convInfo,"max",!1),poolOutput=backend.runWebGLProgram(program,[x],"float32"),indexOutput;return program=new Pool2DProgram(convInfo,"max",!0,!0,includeBatchInIndex),[poolOutput,backend.runWebGLProgram(program,[x],"float32")]}var maxPoolWithArgmaxConfig$1={kernelName:MaxPoolWithArgmax,backendName:"webgl",kernelFunc:function(_a){var inputs=_a.inputs,attrs=_a.attrs,backend=_a.backend,x=inputs.x,_b=attrs,filterSize=_b.filterSize,strides=_b.strides,pad=_b.pad,includeBatchInIndex=_b.includeBatchInIndex,webglBackend=backend;assert(4===x.shape.length,function(){return"Error in maxPool: input must be rank 4 but got rank "+x.shape.length+"."});var dilations=[1,1];assert(eitherStridesOrDilationsAreOne(strides,dilations),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+strides+" and dilations '"+dilations+"'"});var convInfo=computePool2DInfo(x.shape,filterSize,strides,dilations,pad),_c=maxPoolWithArgmaxImpl$1(x,includeBatchInIndex,convInfo,webglBackend),result,indexes;return[_c[0],_c[1]]}},nonMaxSuppressionV5Config$1={kernelName:NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function(_a){var inputs=_a.inputs,backend=_a.backend,attrs=_a.attrs;warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var _b=inputs,boxes=_b.boxes,scores=_b.scores,_c=attrs,maxOutputSize=_c.maxOutputSize,iouThreshold=_c.iouThreshold,scoreThreshold=_c.scoreThreshold,softNmsSigma=_c.softNmsSigma,gpuBackend=backend,boxesVals,scoresVals,maxOutputSizeVal,iouThresholdVal,scoreThresholdVal,softNmsSigmaVal,_d=nonMaxSuppressionV5(gpuBackend.readSync(boxes.dataId),gpuBackend.readSync(scores.dataId),maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma),selectedIndices,selectedScores;return[_d.selectedIndices,_d.selectedScores]}},squareConfig$1={kernelName:Square,backendName:"webgl",kernelFunc:function(_a){var inputs=_a.inputs,backend=_a.backend,x=inputs.x,webglBackend=backend,program=new UnaryOpProgram(x.shape,SQUARE);return webglBackend.runWebGLProgram(program,[x],x.dtype)}},squaredDifferenceConfig$1={kernelName:SquaredDifference,backendName:"webgl",kernelFunc:function(_a){var inputs=_a.inputs,backend=_a.backend,_b=inputs,a=_b.a,b=_b.b,SQUARED_DIFFERENCE="return (a - b) * (a - b);",webGLBackend=backend,program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(SQUARED_DIFFERENCE,a.shape,b.shape):new BinaryOpProgram(SQUARED_DIFFERENCE,a.shape,b.shape);return webGLBackend.compileAndRun(program,[a,b])}},TransposeProgram=function(){function TransposeProgram(aShape,newDim){this.variableNames=["A"];for(var outputShape=new Array(aShape.length),i=0;i<outputShape.length;i++)outputShape[i]=aShape[newDim[i]];this.outputShape=outputShape,this.rank=outputShape.length;var dtype=getCoordsDataType(this.rank),switched=getSwitchedCoords(newDim);this.userCode="\n    void main() {\n      "+dtype+" resRC = getOutputCoords();\n      setOutput(getA("+switched+"));\n    }\n    "}return TransposeProgram}();function getSwitchedCoords(newDim){var rank=newDim.length;if(rank>6)throw Error("Transpose for rank "+rank+" is not yet supported");for(var originalOrder=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],switchedCoords=new Array(rank),i=0;i<newDim.length;i++)switchedCoords[newDim[i]]=originalOrder[i];return switchedCoords.join()}var TransposePackedProgram=function(){function TransposePackedProgram(aShape,newDim){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;for(var outputShape=new Array(aShape.length),i=0;i<outputShape.length;i++)outputShape[i]=aShape[newDim[i]];if(this.outputShape=outputShape,this.rank=outputShape.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");for(var dtype=getCoordsDataType(this.rank),outputOrder=getVecChannels("rc",this.rank),switchedOrder=new Array(this.rank),i=0;i<newDim.length;i++)switchedOrder[newDim[i]]=outputOrder[i];var innerDims="vec2("+switchedOrder.slice(-2).join()+")",nextColumn="++"+outputOrder[this.rank-1]+" < "+outputShape[this.rank-1],getc="getChannel(getA("+switchedOrder.join()+"), "+innerDims+")";this.userCode="\n    void main() {\n      "+dtype+" rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = "+getc+";\n      if("+nextColumn+") {\n        result[1] = "+getc+";\n      }\n      --"+outputOrder[this.rank-1]+";\n      if(++"+outputOrder[this.rank-2]+" < "+outputShape[this.rank-2]+") {\n        result[2] = "+getc+";\n        if("+nextColumn+") {\n          result[3] = "+getc+";\n        }\n      }\n      setOutput(result);\n    }\n    "}return TransposePackedProgram}();function transposeImpl$1(x,perm,backend){var program=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TransposePackedProgram(x.shape,perm):new TransposeProgram(x.shape,perm);return backend.runWebGLProgram(program,[x],x.dtype)}for(var transposeConfig$1,kernelConfigs$1,_i$1=0,kernelConfigs_1$1=[fromPixelsConfig,divConfig$1,nonMaxSuppressionV5Config$1,squareConfig$1,squaredDifferenceConfig$1,{kernelName:Transpose,backendName:"webgl",kernelFunc:function(_a){for(var inputs=_a.inputs,attrs=_a.attrs,backend=_a.backend,x=inputs.x,perm=attrs.perm,webglBackend=backend,xRank=x.shape.length,newShape=new Array(xRank),i=0,out;i<newShape.length;i++)newShape[i]=x.shape[perm[i]];if(webglBackend.shouldExecuteOnCPU([x])){var xTexData,values,outValues=transposeImpl(webglBackend.texData.get(x.dataId).values,x.shape,x.dtype,perm,newShape),outData;out=webglBackend.makeTensorInfo(newShape,x.dtype),webglBackend.texData.get(out.dataId).values=outValues}else out=transposeImpl$1(x,perm,webglBackend);return out}},maxPoolWithArgmaxConfig$1];_i$1<kernelConfigs_1$1.length;_i$1++){var kernelConfig$1;registerKernel(kernelConfigs_1$1[_i$1])}for(var addGradConfig,addNGradConfig,broadcastToGradConfig,divGradConfig,fusedBatchNormGradConfig,identityGradConfig,oneHotGradConfig,padV2GradConfig,squareGradConfig,squaredDifferenceGradConfig,tileGradConfig,transposeGradConfig,gradConfigs,_i$2=0,gradConfigs_1=[{kernelName:Add,inputsToSave:["a","b"],gradFunc:function(dy,saved){var a=saved[0],b=saved[1],outShape=assertAndGetBroadcastShape(a.shape,b.shape),derA,derB;return{a:function(){var res=dy,reduceAxes=getReductionAxes(a.shape,outShape);return reduceAxes.length>0&&(res=res.sum(reduceAxes)),res.reshape(a.shape)},b:function(){var res=dy,reduceAxes=getReductionAxes(b.shape,outShape);return reduceAxes.length>0&&(res=res.sum(reduceAxes)),res.reshape(b.shape)}}}},{kernelName:AddN,saveAllInputs:!0,gradFunc:function(dy,saved){var ders={};return saved.forEach(function(_,i){ders[i]=function(){return dy.clone()}}),ders}},{kernelName:BroadcastTo,gradFunc:function(dy,saved,attrs){for(var broadCastToAttrs=attrs,inputShape=broadCastToAttrs.inputShape,outputShape=broadCastToAttrs.shape,reps=Array.from(outputShape),i=inputShape.length-1;i>=0;i--)if(inputShape[i]===outputShape[i])reps[i]=1;else if(1!==inputShape[i])throw new Error("broadcastTo(): ["+inputShape+"] cannot be broadcast to ["+outputShape+"].");for(var axes=[],i=0;i<reps.length;i++)reps[i]>1&&axes.push(i);var keepDims=!0;return{x:function(){return dy.sum(axes,!0)}}}},{kernelName:Div,inputsToSave:["a","b"],gradFunc:function(dy,saved){var a=saved[0],b=saved[1],outShape=assertAndGetBroadcastShape(a.shape,b.shape),derA,derB;return{a:function(){var res=div(dy,b.toFloat()),reduceAxes=getReductionAxes(a.shape,outShape);return reduceAxes.length>0?sum$1(res,reduceAxes).reshape(a.shape):res},b:function(){var res=dy.mul(a.toFloat()),reduceAxes=getReductionAxes(b.shape,outShape);reduceAxes.length>0&&(res=sum$1(res,reduceAxes).reshape(b.shape));var tmp=square(b);return neg(div(res,tmp.toFloat()))}}}},{kernelName:FusedBatchNorm,inputsToSave:["x","mean","variance","scale"],gradFunc:function(dy,saved,attrs){var batchNormalizationAttrs,varianceEpsilon=attrs.varianceEpsilon,x=saved[0],mean=saved[1],variance=saved[2],scale=saved[3],x4D=xAs4D(x),scaleValue=null==scale?scalar(1):scale,reductionAxes=getReductionAxes(mean.shape,x4D.shape),tileShape=[];if(1===mean.rank){for(var i=0;i<x4D.shape.length-1;++i)tileShape.push(x4D.shape[i]);tileShape.push(1)}var xMinusMean=sub(x,mean),dyTimesScaleValue=mul(dy,scaleValue),oneOverSqrtVariance=rsqrt(add(variance,scalar(varianceEpsilon))),minusHalfRCube=mul(mul(mul(oneOverSqrtVariance,oneOverSqrtVariance),oneOverSqrtVariance),scalar(-.5)),derX,derMean,derVariance,derScale,derOffset;return{x:function(){return 1===mean.rank?reshape(mul(mul(dy,tile$1(oneOverSqrtVariance.as4D(1,1,1,mean.shape[0]),tileShape)),scaleValue),x.shape):reshape(mul(mul(dy,oneOverSqrtVariance),scaleValue),x.shape)},mean:function(){var meanDer=mul(mul(oneOverSqrtVariance,scalar(-1)),dyTimesScaleValue);return 1===mean.rank&&(meanDer=sum$1(meanDer,reductionAxes)),reshape(meanDer,mean.shape)},variance:function(){var varianceDer=mul(mul(minusHalfRCube,xMinusMean),dyTimesScaleValue);return 1===mean.rank&&(varianceDer=sum$1(varianceDer,reductionAxes)),reshape(varianceDer,mean.shape)},scale:function(){var xMinusMean2TimesRsqrt=mul(xMinusMean,oneOverSqrtVariance),scaleDer=mul(dy,xMinusMean2TimesRsqrt);return 1===mean.rank&&(scaleDer=sum$1(scaleDer,reductionAxes)),reshape(scaleDer,mean.shape)},offset:function(){var offsetDer=dy;return 1===mean.rank&&(offsetDer=sum$1(offsetDer,reductionAxes)),reshape(offsetDer,mean.shape)}}}},{kernelName:Identity,gradFunc:function(dy){return{x:function(){return dy.toFloat()}}}},{kernelName:OneHot,inputsToSave:["indices"],gradFunc:function(dy,saved){var indices=saved[0];return{indices:function(){return zeros(indices.shape,"float32")}}}},{kernelName:PadV2,inputsToSave:["x"],gradFunc:function(dy,saved,attrs){var x=saved[0],paddings,begin=attrs.paddings.map(function(p){return p[0]});return{x:function(){return dy.slice(begin,x.shape)}}}},{kernelName:Square,inputsToSave:["x"],gradFunc:function(dy,saved){var x=saved[0];return{x:function(){return dy.mul(x.toFloat().mul(2))}}}},{kernelName:SquaredDifference,inputsToSave:["a","b"],gradFunc:function(dy,saved){var a=saved[0],b=saved[1],two=scalar(2),derA,derB;return{a:function(){return mul(dy,mul(two,sub(a,b)))},b:function(){return mul(dy,mul(two,sub(b,a)))}}}},{kernelName:Tile,inputsToSave:["x"],gradFunc:function(dy,saved,attrs){var x=saved[0],reps=attrs.reps,derX;return{x:function(){var xGrad=zerosLike(x);if(1===x.rank)for(var i=0;i<reps[0];++i)xGrad=xGrad.add(dy.slice([i*x.shape[0]],[x.shape[0]]));else if(2===x.rank)for(var i=0;i<reps[0];++i)for(var j=0;j<reps[1];++j)xGrad=xGrad.add(dy.slice([i*x.shape[0],j*x.shape[1]],[x.shape[0],x.shape[1]]));else if(3===x.rank)for(var i=0;i<reps[0];++i)for(var j=0;j<reps[1];++j)for(var k=0;k<reps[2];++k)xGrad=xGrad.add(dy.slice([i*x.shape[0],j*x.shape[1],k*x.shape[2]],[x.shape[0],x.shape[1],x.shape[2]]));else{if(4!==x.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+x.rank+" tensors yet.");for(var i=0;i<reps[0];++i)for(var j=0;j<reps[1];++j)for(var k=0;k<reps[2];++k)for(var l=0;l<reps[3];++l)xGrad=xGrad.add(dy.slice([i*x.shape[0],j*x.shape[1],k*x.shape[2],l*x.shape[3]],[x.shape[0],x.shape[1],x.shape[2],x.shape[3]]))}return xGrad}}}},{kernelName:Transpose,gradFunc:function(dy,saved,attrs){var transposeAttrs,perm,undoPerm=getUndoAxesPermutation(attrs.perm);return{x:function(){return transpose(dy,undoPerm)}}}}];_i$2<gradConfigs_1.length;_i$2++){var gradientConfig;registerGradient(gradConfigs_1[_i$2])}var PlatformBrowser=function(){function PlatformBrowser(){}return PlatformBrowser.prototype.fetch=function(path,init){return fetch(path,init)},PlatformBrowser.prototype.now=function(){return performance.now()},PlatformBrowser.prototype.encode=function(text,encoding){if("utf-8"!==encoding&&"utf8"!==encoding)throw new Error("Browser's encoder only supports utf-8, but got "+encoding);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(text)},PlatformBrowser.prototype.decode=function(bytes,encoding){return new TextDecoder(encoding).decode(bytes)},PlatformBrowser}();env().get("IS_BROWSER")&&env().setPlatform("browser",new PlatformBrowser);var getNodeFetch_importFetch=function(){return require("node-fetch")},systemFetch,PlatformNode=function(){function PlatformNode(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}return PlatformNode.prototype.fetch=function(path,requestInits){return null!=env().global.fetch?env().global.fetch(path,requestInits):(null==systemFetch&&(systemFetch=getNodeFetch_importFetch()),systemFetch(path,requestInits))},PlatformNode.prototype.now=function(){var time=process.hrtime();return 1e3*time[0]+time[1]/1e6},PlatformNode.prototype.encode=function(text,encoding){if("utf-8"!==encoding&&"utf8"!==encoding)throw new Error("Node built-in encoder only supports utf-8, but got "+encoding);return this.textEncoder.encode(text)},PlatformNode.prototype.decode=function(bytes,encoding){return 0===bytes.length?"":new this.util.TextDecoder(encoding).decode(bytes)},PlatformNode}();env().get("IS_NODE")&&env().setPlatform("node",new PlatformNode);var DTYPE_VALUE_SIZE_MAP={float32:4,int32:4,uint16:2,uint8:1,bool:1},NUM_BYTES_STRING_LENGTH=4;function encodeWeights(tensors,group){return __awaiter(this,void 0,void 0,function(){var specs,dataPromises,names,_loop_1,i,tensorValues,_this=this;return __generator(this,function(_a){switch(_a.label){case 0:for(specs=[],dataPromises=[],names=Array.isArray(tensors)?tensors.map(function(tensor){return tensor.name}):Object.keys(tensors),_loop_1=function(i){var name_1=names[i],t=Array.isArray(tensors)?tensors[i].tensor:tensors[name_1];if("float32"!==t.dtype&&"int32"!==t.dtype&&"bool"!==t.dtype&&"string"!==t.dtype)throw new Error("Unsupported dtype in weight '"+name_1+"': "+t.dtype);var spec={name:name_1,shape:t.shape,dtype:t.dtype};if("string"===t.dtype){var utf8bytes=new Promise(function(resolve){return __awaiter(_this,void 0,void 0,function(){var vals,totalNumBytes,bytes,offset,i_1,val,bytesOfLength;return __generator(this,function(_a){switch(_a.label){case 0:return[4,t.bytes()];case 1:for(vals=_a.sent(),totalNumBytes=vals.reduce(function(p,c){return p+c.length},0)+NUM_BYTES_STRING_LENGTH*vals.length,bytes=new Uint8Array(totalNumBytes),offset=0,i_1=0;i_1<vals.length;i_1++)val=vals[i_1],bytesOfLength=new Uint8Array(new Uint32Array([val.length]).buffer),bytes.set(bytesOfLength,offset),offset+=NUM_BYTES_STRING_LENGTH,bytes.set(val,offset),offset+=val.length;return resolve(bytes),[2]}})})});dataPromises.push(utf8bytes)}else dataPromises.push(t.data());null!=group&&(spec.group=group),specs.push(spec)},i=0;i<names.length;++i)_loop_1(i);return[4,Promise.all(dataPromises)];case 1:return[2,{data:concatenateTypedArrays(tensorValues=_a.sent()),specs:specs}]}})})}function decodeWeights(buffer,specs){for(var out={},offset=0,_loop_2=function(spec){var name_2=spec.name,dtype=spec.dtype,shape=spec.shape,size=sizeFromShape(shape),values=void 0;if("quantization"in spec){var quantization_1=spec.quantization;if("uint8"!==quantization_1.dtype&&"uint16"!==quantization_1.dtype)throw new Error("Weight "+spec.name+" has unknown quantization dtype "+quantization_1.dtype+". Supported quantization dtypes are: 'uint8' and 'uint16'.");var quantizationSizeFactor=DTYPE_VALUE_SIZE_MAP[quantization_1.dtype],byteBuffer=buffer.slice(offset,offset+size*quantizationSizeFactor),quantizedArray="uint8"===quantization_1.dtype?new Uint8Array(byteBuffer):new Uint16Array(byteBuffer);if("float32"===dtype)values=Float32Array.from(quantizedArray,function(v){return v*quantization_1.scale+quantization_1.min});else{if("int32"!==dtype)throw new Error("Unsupported dtype in weight '"+name_2+"': "+dtype);values=Int32Array.from(quantizedArray,function(v){return Math.round(v*quantization_1.scale+quantization_1.min)})}offset+=size*quantizationSizeFactor}else if("string"===dtype){var size_1=sizeFromShape(spec.shape);values=[];for(var i=0;i<size_1;i++){var byteLength=new Uint32Array(buffer.slice(offset,offset+NUM_BYTES_STRING_LENGTH))[0];offset+=NUM_BYTES_STRING_LENGTH;var bytes=new Uint8Array(buffer.slice(offset,offset+byteLength));values.push(bytes),offset+=byteLength}}else{var dtypeFactor=DTYPE_VALUE_SIZE_MAP[dtype],byteBuffer=buffer.slice(offset,offset+size*dtypeFactor);if("float32"===dtype)values=new Float32Array(byteBuffer);else if("int32"===dtype)values=new Int32Array(byteBuffer);else{if("bool"!==dtype)throw new Error("Unsupported dtype in weight '"+name_2+"': "+dtype);values=new Uint8Array(byteBuffer)}offset+=size*dtypeFactor}out[name_2]=tensor(values,shape,dtype)},_i=0,specs_1=specs;_i<specs_1.length;_i++){var spec;_loop_2(specs_1[_i])}return out}function concatenateTypedArrays(xs){if(null===xs)throw new Error("Invalid input value: "+JSON.stringify(xs));var totalByteLength=0,normalizedXs=[];xs.forEach(function(x){if(totalByteLength+=x.byteLength,normalizedXs.push(x.byteLength===x.buffer.byteLength?x:new x.constructor(x)),!(x instanceof Float32Array||x instanceof Int32Array||x instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+x.constructor.name)});var y=new Uint8Array(totalByteLength),offset=0;return normalizedXs.forEach(function(x){y.set(new Uint8Array(x.buffer),offset),offset+=x.byteLength}),y.buffer}var useNodeBuffer="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function stringByteLength(str){return useNodeBuffer?Buffer.byteLength(str):new Blob([str]).size}function arrayBufferToBase64String(buffer){if(useNodeBuffer)return Buffer.from(buffer).toString("base64");for(var buf=new Uint8Array(buffer),s="",i=0,l=buf.length;i<l;i++)s+=String.fromCharCode(buf[i]);return btoa(s)}function base64StringToArrayBuffer(str){if(useNodeBuffer){var buf=Buffer.from(str,"base64");return buf.buffer.slice(buf.byteOffset,buf.byteOffset+buf.byteLength)}for(var s=atob(str),buffer=new Uint8Array(s.length),i=0;i<s.length;++i)buffer.set([s.charCodeAt(i)],i);return buffer.buffer}function concatenateArrayBuffers(buffers){var totalByteLength=0;buffers.forEach(function(buffer){totalByteLength+=buffer.byteLength});var temp=new Uint8Array(totalByteLength),offset=0;return buffers.forEach(function(buffer){temp.set(new Uint8Array(buffer),offset),offset+=buffer.byteLength}),temp.buffer}function basename(path){var SEPARATOR="/";for(path=path.trim();path.endsWith("/");)path=path.slice(0,path.length-1);var items=path.split("/");return items[items.length-1]}function getModelArtifactsInfoForJSON(modelArtifacts){if(modelArtifacts.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==modelArtifacts.modelTopology?0:stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),weightSpecsBytes:null==modelArtifacts.weightSpecs?0:stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),weightDataBytes:null==modelArtifacts.weightData?0:modelArtifacts.weightData.byteLength}}var IORouterRegistry=function(){function IORouterRegistry(){this.saveRouters=[],this.loadRouters=[]}return IORouterRegistry.getInstance=function(){return null==IORouterRegistry.instance&&(IORouterRegistry.instance=new IORouterRegistry),IORouterRegistry.instance},IORouterRegistry.registerSaveRouter=function(saveRouter){IORouterRegistry.getInstance().saveRouters.push(saveRouter)},IORouterRegistry.registerLoadRouter=function(loadRouter){IORouterRegistry.getInstance().loadRouters.push(loadRouter)},IORouterRegistry.getSaveHandlers=function(url){return IORouterRegistry.getHandlers(url,"save")},IORouterRegistry.getLoadHandlers=function(url,onProgress){return IORouterRegistry.getHandlers(url,"load",onProgress)},IORouterRegistry.getHandlers=function(url,handlerType,onProgress){var validHandlers=[],routers;return("load"===handlerType?IORouterRegistry.getInstance().loadRouters:IORouterRegistry.getInstance().saveRouters).forEach(function(router){var handler=router(url,onProgress);null!==handler&&validHandlers.push(handler)}),validHandlers},IORouterRegistry}(),registerSaveRouter=function(loudRouter){return IORouterRegistry.registerSaveRouter(loudRouter)},registerLoadRouter=function(loudRouter){return IORouterRegistry.registerLoadRouter(loudRouter)},getSaveHandlers=function(url){return IORouterRegistry.getSaveHandlers(url)},getLoadHandlers=function(url,onProgress){return IORouterRegistry.getLoadHandlers(url,onProgress)},URL_SCHEME_SUFFIX="://",ModelStoreManagerRegistry=function(){function ModelStoreManagerRegistry(){this.managers={}}return ModelStoreManagerRegistry.getInstance=function(){return null==ModelStoreManagerRegistry.instance&&(ModelStoreManagerRegistry.instance=new ModelStoreManagerRegistry),ModelStoreManagerRegistry.instance},ModelStoreManagerRegistry.registerManager=function(scheme,manager){assert(null!=scheme,function(){return"scheme must not be undefined or null."}),scheme.endsWith(URL_SCHEME_SUFFIX)&&(scheme=scheme.slice(0,scheme.indexOf(URL_SCHEME_SUFFIX))),assert(scheme.length>0,function(){return"scheme must not be an empty string."});var registry=ModelStoreManagerRegistry.getInstance();assert(null==registry.managers[scheme],function(){return"A model store manager is already registered for scheme '"+scheme+"'."}),registry.managers[scheme]=manager},ModelStoreManagerRegistry.getManager=function(scheme){var manager=this.getInstance().managers[scheme];if(null==manager)throw new Error("Cannot find model manager for scheme '"+scheme+"'");return manager},ModelStoreManagerRegistry.getSchemes=function(){return Object.keys(this.getInstance().managers)},ModelStoreManagerRegistry}();function parseURL(url){if(-1===url.indexOf(URL_SCHEME_SUFFIX))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+ModelStoreManagerRegistry.getSchemes().join(","));return{scheme:url.split(URL_SCHEME_SUFFIX)[0],path:url.split(URL_SCHEME_SUFFIX)[1]}}function cloneModelInternal(sourceURL,destURL,deleteSource){return void 0===deleteSource&&(deleteSource=!1),__awaiter(this,void 0,void 0,function(){var loadHandlers,loadHandler,saveHandlers,saveHandler,sourceScheme,sourcePath,sameMedium,modelArtifacts,saveResult;return __generator(this,function(_a){switch(_a.label){case 0:return assert(sourceURL!==destURL,function(){return"Old path and new path are the same: '"+sourceURL+"'"}),assert((loadHandlers=IORouterRegistry.getLoadHandlers(sourceURL)).length>0,function(){return"Copying failed because no load handler is found for source URL "+sourceURL+"."}),assert(loadHandlers.length<2,function(){return"Copying failed because more than one ("+loadHandlers.length+") load handlers for source URL "+sourceURL+"."}),loadHandler=loadHandlers[0],assert((saveHandlers=IORouterRegistry.getSaveHandlers(destURL)).length>0,function(){return"Copying failed because no save handler is found for destination URL "+destURL+"."}),assert(saveHandlers.length<2,function(){return"Copying failed because more than one ("+loadHandlers.length+") save handlers for destination URL "+destURL+"."}),saveHandler=saveHandlers[0],sourceScheme=parseURL(sourceURL).scheme,sourcePath=parseURL(sourceURL).path,sameMedium=sourceScheme===parseURL(sourceURL).scheme,[4,loadHandler.load()];case 1:return modelArtifacts=_a.sent(),deleteSource&&sameMedium?[4,ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath)]:[3,3];case 2:_a.sent(),_a.label=3;case 3:return[4,saveHandler.save(modelArtifacts)];case 4:return saveResult=_a.sent(),!deleteSource||sameMedium?[3,6]:[4,ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath)];case 5:_a.sent(),_a.label=6;case 6:return[2,saveResult.modelArtifactsInfo]}})})}function listModels(){return __awaiter(this,void 0,void 0,function(){var schemes,out,_i,schemes_1,scheme,schemeOut,path,url;return __generator(this,function(_a){switch(_a.label){case 0:schemes=ModelStoreManagerRegistry.getSchemes(),out={},_i=0,schemes_1=schemes,_a.label=1;case 1:return _i<schemes_1.length?(scheme=schemes_1[_i],[4,ModelStoreManagerRegistry.getManager(scheme).listModels()]):[3,4];case 2:for(path in schemeOut=_a.sent())out[url=scheme+URL_SCHEME_SUFFIX+path]=schemeOut[path];_a.label=3;case 3:return _i++,[3,1];case 4:return[2,out]}})})}function removeModel(url){return __awaiter(this,void 0,void 0,function(){var schemeAndPath,manager;return __generator(this,function(_a){return schemeAndPath=parseURL(url),[2,(manager=ModelStoreManagerRegistry.getManager(schemeAndPath.scheme)).removeModel(schemeAndPath.path)]})})}function copyModel(sourceURL,destURL){return __awaiter(this,void 0,void 0,function(){var deleteSource;return __generator(this,function(_a){return[2,cloneModelInternal(sourceURL,destURL,deleteSource=!1)]})})}function moveModel(sourceURL,destURL){return __awaiter(this,void 0,void 0,function(){var deleteSource;return __generator(this,function(_a){return[2,cloneModelInternal(sourceURL,destURL,deleteSource=!0)]})})}var DATABASE_NAME="tensorflowjs",DATABASE_VERSION=1,MODEL_STORE_NAME="models_store",INFO_STORE_NAME="model_info_store";function getIndexedDBFactory(){if(!env().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var theWindow=window||self,factory=theWindow.indexedDB||theWindow.mozIndexedDB||theWindow.webkitIndexedDB||theWindow.msIndexedDB||theWindow.shimIndexedDB;if(null==factory)throw new Error("The current browser does not appear to support IndexedDB.");return factory}function setUpDatabase(openRequest){var db=openRequest.result;db.createObjectStore(MODEL_STORE_NAME,{keyPath:"modelPath"}),db.createObjectStore(INFO_STORE_NAME,{keyPath:"modelPath"})}var BrowserIndexedDB=function(){function BrowserIndexedDB(modelPath){if(this.indexedDB=getIndexedDBFactory(),null==modelPath||!modelPath)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=modelPath}return BrowserIndexedDB.prototype.save=function(modelArtifacts){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){if(modelArtifacts.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,modelArtifacts)]})})},BrowserIndexedDB.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2,this.databaseAction(this.modelPath)]})})},BrowserIndexedDB.prototype.databaseAction=function(modelPath,modelArtifacts){var _this=this;return new Promise(function(resolve,reject){var openRequest=_this.indexedDB.open(DATABASE_NAME,1);openRequest.onupgradeneeded=function(){return setUpDatabase(openRequest)},openRequest.onsuccess=function(){var db=openRequest.result;if(null==modelArtifacts){var modelTx=db.transaction(MODEL_STORE_NAME,"readonly"),modelStore,getRequest_1=modelTx.objectStore(MODEL_STORE_NAME).get(_this.modelPath);getRequest_1.onsuccess=function(){if(null==getRequest_1.result)return db.close(),reject(new Error("Cannot find model with path '"+_this.modelPath+"' in IndexedDB."));resolve(getRequest_1.result.modelArtifacts)},getRequest_1.onerror=function(error){return db.close(),reject(getRequest_1.error)},modelTx.oncomplete=function(){return db.close()}}else{var modelArtifactsInfo_1=getModelArtifactsInfoForJSON(modelArtifacts),infoTx_1=db.transaction(INFO_STORE_NAME,"readwrite"),infoStore_1=infoTx_1.objectStore(INFO_STORE_NAME),putInfoRequest_1=infoStore_1.put({modelPath:_this.modelPath,modelArtifactsInfo:modelArtifactsInfo_1}),modelTx_1;putInfoRequest_1.onsuccess=function(){var modelStore,putModelRequest=(modelTx_1=db.transaction(MODEL_STORE_NAME,"readwrite")).objectStore(MODEL_STORE_NAME).put({modelPath:_this.modelPath,modelArtifacts:modelArtifacts,modelArtifactsInfo:modelArtifactsInfo_1});putModelRequest.onsuccess=function(){return resolve({modelArtifactsInfo:modelArtifactsInfo_1})},putModelRequest.onerror=function(error){var deleteInfoRequest=(infoStore_1=infoTx_1.objectStore(INFO_STORE_NAME)).delete(_this.modelPath);deleteInfoRequest.onsuccess=function(){return db.close(),reject(putModelRequest.error)},deleteInfoRequest.onerror=function(error){return db.close(),reject(putModelRequest.error)}}},putInfoRequest_1.onerror=function(error){return db.close(),reject(putInfoRequest_1.error)},infoTx_1.oncomplete=function(){null==modelTx_1?db.close():modelTx_1.oncomplete=function(){return db.close()}}}},openRequest.onerror=function(error){return reject(openRequest.error)}})},BrowserIndexedDB.URL_SCHEME="indexeddb://",BrowserIndexedDB}(),indexedDBRouter=function(url){return env().getBool("IS_BROWSER")&&!Array.isArray(url)&&url.startsWith(BrowserIndexedDB.URL_SCHEME)?browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length)):null};function browserIndexedDB(modelPath){return new BrowserIndexedDB(modelPath)}function maybeStripScheme(key){return key.startsWith(BrowserIndexedDB.URL_SCHEME)?key.slice(BrowserIndexedDB.URL_SCHEME.length):key}IORouterRegistry.registerSaveRouter(indexedDBRouter),IORouterRegistry.registerLoadRouter(indexedDBRouter);var BrowserIndexedDBManager=function(){function BrowserIndexedDBManager(){this.indexedDB=getIndexedDBFactory()}return BrowserIndexedDBManager.prototype.listModels=function(){return __awaiter(this,void 0,void 0,function(){var _this=this;return __generator(this,function(_a){return[2,new Promise(function(resolve,reject){var openRequest=_this.indexedDB.open(DATABASE_NAME,1);openRequest.onupgradeneeded=function(){return setUpDatabase(openRequest)},openRequest.onsuccess=function(){var db=openRequest.result,tx=db.transaction(INFO_STORE_NAME,"readonly"),store,getAllInfoRequest=tx.objectStore(INFO_STORE_NAME).getAll();getAllInfoRequest.onsuccess=function(){for(var out={},_i=0,_a=getAllInfoRequest.result;_i<_a.length;_i++){var item=_a[_i];out[item.modelPath]=item.modelArtifactsInfo}resolve(out)},getAllInfoRequest.onerror=function(error){return db.close(),reject(getAllInfoRequest.error)},tx.oncomplete=function(){return db.close()}},openRequest.onerror=function(error){return reject(openRequest.error)}})]})})},BrowserIndexedDBManager.prototype.removeModel=function(path){return __awaiter(this,void 0,void 0,function(){var _this=this;return __generator(this,function(_a){return path=maybeStripScheme(path),[2,new Promise(function(resolve,reject){var openRequest=_this.indexedDB.open(DATABASE_NAME,1);openRequest.onupgradeneeded=function(){return setUpDatabase(openRequest)},openRequest.onsuccess=function(){var db=openRequest.result,infoTx=db.transaction(INFO_STORE_NAME,"readwrite"),infoStore=infoTx.objectStore(INFO_STORE_NAME),getInfoRequest=infoStore.get(path),modelTx;getInfoRequest.onsuccess=function(){if(null==getInfoRequest.result)return db.close(),reject(new Error("Cannot find model with path '"+path+"' in IndexedDB."));var deleteInfoRequest=infoStore.delete(path),deleteModelData_1=function(){var modelStore,deleteModelRequest=(modelTx=db.transaction(MODEL_STORE_NAME,"readwrite")).objectStore(MODEL_STORE_NAME).delete(path);deleteModelRequest.onsuccess=function(){return resolve(getInfoRequest.result.modelArtifactsInfo)},deleteModelRequest.onerror=function(error){return reject(getInfoRequest.error)}};deleteInfoRequest.onsuccess=deleteModelData_1,deleteInfoRequest.onerror=function(error){return deleteModelData_1(),db.close(),reject(getInfoRequest.error)}},getInfoRequest.onerror=function(error){return db.close(),reject(getInfoRequest.error)},infoTx.oncomplete=function(){null==modelTx?db.close():modelTx.oncomplete=function(){return db.close()}}},openRequest.onerror=function(error){return reject(openRequest.error)}})]})})},BrowserIndexedDBManager}();if(env().getBool("IS_BROWSER"))try{ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new BrowserIndexedDBManager)}catch(err){}var PATH_SEPARATOR="/",PATH_PREFIX="tensorflowjs_models",INFO_SUFFIX="info",MODEL_TOPOLOGY_SUFFIX="model_topology",WEIGHT_SPECS_SUFFIX="weight_specs",WEIGHT_DATA_SUFFIX="weight_data",MODEL_METADATA_SUFFIX="model_metadata";function getModelKeys(path){return{info:[PATH_PREFIX,path,INFO_SUFFIX].join(PATH_SEPARATOR),topology:[PATH_PREFIX,path,MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),weightSpecs:[PATH_PREFIX,path,WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),weightData:[PATH_PREFIX,path,WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),modelMetadata:[PATH_PREFIX,path,MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)}}function getModelPathFromKey(key){var items=key.split(PATH_SEPARATOR);if(items.length<3)throw new Error("Invalid key format: "+key);return items.slice(1,items.length-1).join(PATH_SEPARATOR)}function maybeStripScheme$1(key){return key.startsWith(BrowserLocalStorage.URL_SCHEME)?key.slice(BrowserLocalStorage.URL_SCHEME.length):key}var BrowserLocalStorage=function(){function BrowserLocalStorage(modelPath){if(!env().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==modelPath||!modelPath)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=modelPath,this.keys=getModelKeys(this.modelPath)}return BrowserLocalStorage.prototype.save=function(modelArtifacts){return __awaiter(this,void 0,void 0,function(){var topology,weightSpecs,modelArtifactsInfo;return __generator(this,function(_a){if(modelArtifacts.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");topology=JSON.stringify(modelArtifacts.modelTopology),weightSpecs=JSON.stringify(modelArtifacts.weightSpecs),modelArtifactsInfo=getModelArtifactsInfoForJSON(modelArtifacts);try{return this.LS.setItem(this.keys.info,JSON.stringify(modelArtifactsInfo)),this.LS.setItem(this.keys.topology,topology),this.LS.setItem(this.keys.weightSpecs,weightSpecs),this.LS.setItem(this.keys.weightData,arrayBufferToBase64String(modelArtifacts.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:modelArtifacts.format,generatedBy:modelArtifacts.generatedBy,convertedBy:modelArtifacts.convertedBy,userDefinedMetadata:modelArtifacts.userDefinedMetadata})),[2,{modelArtifactsInfo:modelArtifactsInfo}]}catch(err){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+modelArtifactsInfo.modelTopologyBytes+", weightSpecsBytes="+modelArtifactsInfo.weightSpecsBytes+", weightDataBytes="+modelArtifactsInfo.weightDataBytes+".")}return[2]})})},BrowserLocalStorage.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var info,out,topology,weightSpecs,metadataString,metadata,weightDataBase64;return __generator(this,function(_a){if(null==(info=JSON.parse(this.LS.getItem(this.keys.info))))throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if("JSON"!==info.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");if(out={},null==(topology=JSON.parse(this.LS.getItem(this.keys.topology))))throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");if(out.modelTopology=topology,null==(weightSpecs=JSON.parse(this.LS.getItem(this.keys.weightSpecs))))throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");if(out.weightSpecs=weightSpecs,null!=(metadataString=this.LS.getItem(this.keys.modelMetadata))&&(metadata=JSON.parse(metadataString),out.format=metadata.format,out.generatedBy=metadata.generatedBy,out.convertedBy=metadata.convertedBy,out.userDefinedMetadata=metadata.userDefinedMetadata),null==(weightDataBase64=this.LS.getItem(this.keys.weightData)))throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return out.weightData=base64StringToArrayBuffer(weightDataBase64),[2,out]})})},BrowserLocalStorage.URL_SCHEME="localstorage://",BrowserLocalStorage}(),localStorageRouter=function(url){return env().getBool("IS_BROWSER")&&!Array.isArray(url)&&url.startsWith(BrowserLocalStorage.URL_SCHEME)?browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length)):null};function browserLocalStorage(modelPath){return new BrowserLocalStorage(modelPath)}IORouterRegistry.registerSaveRouter(localStorageRouter),IORouterRegistry.registerLoadRouter(localStorageRouter);var BrowserLocalStorageManager=function(){function BrowserLocalStorageManager(){assert(env().getBool("IS_BROWSER"),function(){return"Current environment is not a web browser"}),assert("undefined"==typeof window||void 0!==window.localStorage,function(){return"Current browser does not appear to support localStorage"}),this.LS=window.localStorage}return BrowserLocalStorageManager.prototype.listModels=function(){return __awaiter(this,void 0,void 0,function(){var out,prefix,suffix,i,key,modelPath;return __generator(this,function(_a){for(out={},prefix=PATH_PREFIX+PATH_SEPARATOR,suffix=PATH_SEPARATOR+INFO_SUFFIX,i=0;i<this.LS.length;++i)(key=this.LS.key(i)).startsWith(prefix)&&key.endsWith(suffix)&&(modelPath=getModelPathFromKey(key),out[modelPath]=JSON.parse(this.LS.getItem(key)));return[2,out]})})},BrowserLocalStorageManager.prototype.removeModel=function(path){return __awaiter(this,void 0,void 0,function(){var keys,info;return __generator(this,function(_a){if(path=maybeStripScheme$1(path),keys=getModelKeys(path),null==this.LS.getItem(keys.info))throw new Error("Cannot find model at path '"+path+"'");return info=JSON.parse(this.LS.getItem(keys.info)),this.LS.removeItem(keys.info),this.LS.removeItem(keys.topology),this.LS.removeItem(keys.weightSpecs),this.LS.removeItem(keys.weightData),[2,info]})})},BrowserLocalStorageManager}();if(env().getBool("IS_BROWSER"))try{ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new BrowserLocalStorageManager)}catch(err){}var DEFAULT_FILE_NAME_PREFIX="model",DEFAULT_JSON_EXTENSION_NAME=".json",DEFAULT_WEIGHT_DATA_EXTENSION_NAME=".weights.bin";function defer(f){return new Promise(function(resolve){return setTimeout(resolve)}).then(f)}var BrowserDownloads=function(){function BrowserDownloads(fileNamePrefix){if(!env().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)&&(fileNamePrefix=fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length)),null!=fileNamePrefix&&0!==fileNamePrefix.length||(fileNamePrefix=DEFAULT_FILE_NAME_PREFIX),this.modelTopologyFileName=fileNamePrefix+DEFAULT_JSON_EXTENSION_NAME,this.weightDataFileName=fileNamePrefix+DEFAULT_WEIGHT_DATA_EXTENSION_NAME}return BrowserDownloads.prototype.save=function(modelArtifacts){return __awaiter(this,void 0,void 0,function(){var weightsURL,weightsManifest,modelTopologyAndWeightManifest,modelTopologyAndWeightManifestURL,jsonAnchor_1,weightDataAnchor_1;return __generator(this,function(_a){switch(_a.label){case 0:if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");if(weightsURL=window.URL.createObjectURL(new Blob([modelArtifacts.weightData],{type:"application/octet-stream"})),!(modelArtifacts.modelTopology instanceof ArrayBuffer))return[3,1];throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");case 1:return weightsManifest=[{paths:["./"+this.weightDataFileName],weights:modelArtifacts.weightSpecs}],modelTopologyAndWeightManifest={modelTopology:modelArtifacts.modelTopology,format:modelArtifacts.format,generatedBy:modelArtifacts.generatedBy,convertedBy:modelArtifacts.convertedBy,weightsManifest:weightsManifest},modelTopologyAndWeightManifestURL=window.URL.createObjectURL(new Blob([JSON.stringify(modelTopologyAndWeightManifest)],{type:"application/json"})),(jsonAnchor_1=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor).download=this.modelTopologyFileName,jsonAnchor_1.href=modelTopologyAndWeightManifestURL,[4,defer(function(){return jsonAnchor_1.dispatchEvent(new MouseEvent("click"))})];case 2:return _a.sent(),null==modelArtifacts.weightData?[3,4]:((weightDataAnchor_1=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor).download=this.weightDataFileName,weightDataAnchor_1.href=weightsURL,[4,defer(function(){return weightDataAnchor_1.dispatchEvent(new MouseEvent("click"))})]);case 3:_a.sent(),_a.label=4;case 4:return[2,{modelArtifactsInfo:getModelArtifactsInfoForJSON(modelArtifacts)}]}})})},BrowserDownloads.URL_SCHEME="downloads://",BrowserDownloads}(),BrowserFiles=function(){function BrowserFiles(files){if(null==files||files.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+files);this.files=files}return BrowserFiles.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var jsonFile,weightFiles,_this=this;return __generator(this,function(_a){return jsonFile=this.files[0],weightFiles=this.files.slice(1),[2,new Promise(function(resolve,reject){var jsonReader=new FileReader;jsonReader.onload=function(event){var modelJSON=JSON.parse(event.target.result),modelTopology=modelJSON.modelTopology;if(null!=modelTopology){0===weightFiles.length&&resolve({modelTopology:modelTopology});var weightsManifest=modelJSON.weightsManifest;if(null!=weightsManifest){var pathToFile;try{pathToFile=_this.checkManifestAndWeightFiles(weightsManifest,weightFiles)}catch(err){return void reject(err)}var weightSpecs=[],paths=[],perFileBuffers=[];weightsManifest.forEach(function(weightsGroup){weightsGroup.paths.forEach(function(path){paths.push(path),perFileBuffers.push(null)}),weightSpecs.push.apply(weightSpecs,weightsGroup.weights)}),weightsManifest.forEach(function(weightsGroup){weightsGroup.paths.forEach(function(path){var weightFileReader=new FileReader;weightFileReader.onload=function(event){var weightData=event.target.result,index=paths.indexOf(path);perFileBuffers[index]=weightData,-1===perFileBuffers.indexOf(null)&&resolve({modelTopology:modelTopology,weightSpecs:weightSpecs,weightData:concatenateArrayBuffers(perFileBuffers),format:modelJSON.format,generatedBy:modelJSON.generatedBy,convertedBy:modelJSON.convertedBy,userDefinedMetadata:modelJSON.userDefinedMetadata})},weightFileReader.onerror=function(error){return reject("Failed to weights data from file of path '"+path+"'.")},weightFileReader.readAsArrayBuffer(pathToFile[path])})})}else reject(new Error("weightManifest field is missing from file "+jsonFile.name))}else reject(new Error("modelTopology field is missing from file "+jsonFile.name))},jsonReader.onerror=function(error){return reject("Failed to read model topology and weights manifest JSON from file '"+jsonFile.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")},jsonReader.readAsText(jsonFile)})]})})},BrowserFiles.prototype.checkManifestAndWeightFiles=function(manifest,files){for(var basenames=[],fileNames=files.map(function(file){return basename(file.name)}),pathToFile={},_i=0,manifest_1=manifest;_i<manifest_1.length;_i++){var group;manifest_1[_i].paths.forEach(function(path){var pathBasename=basename(path);if(-1!==basenames.indexOf(pathBasename))throw new Error("Duplicate file basename found in weights manifest: '"+pathBasename+"'");if(basenames.push(pathBasename),-1===fileNames.indexOf(pathBasename))throw new Error("Weight file with basename '"+pathBasename+"' is not provided.");pathToFile[path]=files[fileNames.indexOf(pathBasename)]})}if(basenames.length!==files.length)throw new Error("Mismatch in the number of files in weights manifest ("+basenames.length+") and the number of weight files provided ("+files.length+").");return pathToFile},BrowserFiles}(),browserDownloadsRouter=function(url){return env().getBool("IS_BROWSER")&&!Array.isArray(url)&&url.startsWith(BrowserDownloads.URL_SCHEME)?browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length)):null};function browserDownloads(fileNamePrefix){return void 0===fileNamePrefix&&(fileNamePrefix="model"),new BrowserDownloads(fileNamePrefix)}function browserFiles(files){return new BrowserFiles(files)}function monitorPromisesProgress(promises,onProgress,startFraction,endFraction){checkPromises(promises),checkFraction(startFraction=null==startFraction?0:startFraction,endFraction=null==endFraction?1:endFraction);var resolvedPromise=0,registerMonitor=function(promise){return promise.then(function(value){var fraction=startFraction+ ++resolvedPromise/promises.length*(endFraction-startFraction);return onProgress(fraction),value}),promise};function checkPromises(promises){assert(null!=promises&&Array.isArray(promises)&&promises.length>0,function(){return"promises must be a none empty array"})}function checkFraction(startFraction,endFraction){assert(startFraction>=0&&startFraction<=1,function(){return"Progress fraction must be in range [0, 1], but got startFraction "+startFraction}),assert(endFraction>=0&&endFraction<=1,function(){return"Progress fraction must be in range [0, 1], but got endFraction "+endFraction}),assert(endFraction>=startFraction,function(){return"startFraction must be no more than endFraction, but got startFraction "+startFraction+" and endFraction "+endFraction})}return Promise.all(promises.map(registerMonitor))}function loadWeightsAsArrayBuffer(fetchURLs,loadOptions){return __awaiter(this,void 0,void 0,function(){var fetchFunc,requests,fetchStartFraction,fetchEndFraction,responses,_a,bufferPromises,bufferStartFraction,bufferEndFraction,buffers,_b;return __generator(this,function(_c){switch(_c.label){case 0:return null==loadOptions&&(loadOptions={}),fetchFunc=null==loadOptions.fetchFunc?env().platform.fetch:loadOptions.fetchFunc,requests=fetchURLs.map(function(fetchURL){return fetchFunc(fetchURL,loadOptions.requestInit,{isBinary:!0})}),fetchStartFraction=0,fetchEndFraction=.5,null!=loadOptions.onProgress?[3,2]:[4,Promise.all(requests)];case 1:return _a=_c.sent(),[3,4];case 2:return[4,monitorPromisesProgress(requests,loadOptions.onProgress,fetchStartFraction,fetchEndFraction)];case 3:_a=_c.sent(),_c.label=4;case 4:return bufferPromises=(responses=_a).map(function(response){return response.arrayBuffer()}),bufferStartFraction=.5,bufferEndFraction=1,null!=loadOptions.onProgress?[3,6]:[4,Promise.all(bufferPromises)];case 5:return _b=_c.sent(),[3,8];case 6:return[4,monitorPromisesProgress(bufferPromises,loadOptions.onProgress,bufferStartFraction,bufferEndFraction)];case 7:_b=_c.sent(),_c.label=8;case 8:return[2,buffers=_b]}})})}function loadWeights(manifest,filePathPrefix,weightNames,requestInit){return void 0===filePathPrefix&&(filePathPrefix=""),__awaiter(this,void 0,void 0,function(){var fetchWeights,loadWeights;return __generator(this,function(_a){return[2,(loadWeights=weightsLoaderFactory(fetchWeights=function(fetchUrls){return loadWeightsAsArrayBuffer(fetchUrls,{requestInit:requestInit})}))(manifest,filePathPrefix,weightNames)]})})}function weightsLoaderFactory(fetchWeightsFunction){var _this=this;return function(manifest,filePathPrefix,weightNames){return void 0===filePathPrefix&&(filePathPrefix=""),__awaiter(_this,void 0,void 0,function(){var groupIndicesToFetchMap,groupWeightsToFetch,weightsFound,allManifestWeightNames,weightsNotFound,groupIndicesToFetch,fetchUrls,buffers,weightsTensorMap,bufferIndexOffset;return __generator(this,function(_a){switch(_a.label){case 0:if(groupIndicesToFetchMap=manifest.map(function(){return!1}),groupWeightsToFetch={},weightsFound=null!=weightNames?weightNames.map(function(){return!1}):[],allManifestWeightNames=[],manifest.forEach(function(manifestGroupConfig,groupIndex){var groupOffset=0;manifestGroupConfig.weights.forEach(function(weightsEntry){var rawDtype="quantization"in weightsEntry?weightsEntry.quantization.dtype:weightsEntry.dtype,weightsBytes=DTYPE_VALUE_SIZE_MAP[rawDtype]*sizeFromShape(weightsEntry.shape),enqueueWeightsForFetchingFn=function(){groupIndicesToFetchMap[groupIndex]=!0,null==groupWeightsToFetch[groupIndex]&&(groupWeightsToFetch[groupIndex]=[]),groupWeightsToFetch[groupIndex].push({manifestEntry:weightsEntry,groupOffset:groupOffset,sizeBytes:weightsBytes})};null!=weightNames?weightNames.forEach(function(weightName,weightIndex){weightName===weightsEntry.name&&(enqueueWeightsForFetchingFn(),weightsFound[weightIndex]=!0)}):enqueueWeightsForFetchingFn(),allManifestWeightNames.push(weightsEntry.name),groupOffset+=weightsBytes})}),!weightsFound.every(function(found){return found}))throw weightsNotFound=weightNames.filter(function(_,i){return!weightsFound[i]}),new Error("Could not find weights in manifest with names: "+weightsNotFound.join(", ")+". \nManifest JSON has weights with names: "+allManifestWeightNames.join(", ")+".");return groupIndicesToFetch=groupIndicesToFetchMap.reduce(function(accumulator,shouldFetch,i){return shouldFetch&&accumulator.push(i),accumulator},[]),fetchUrls=[],groupIndicesToFetch.forEach(function(i){manifest[i].paths.forEach(function(filepath){var fetchUrl=filePathPrefix+(filePathPrefix.endsWith("/")?"":"/")+filepath;fetchUrls.push(fetchUrl)})}),[4,fetchWeightsFunction(fetchUrls)];case 1:return buffers=_a.sent(),weightsTensorMap={},bufferIndexOffset=0,groupIndicesToFetch.forEach(function(i){for(var numBuffers=manifest[i].paths.length,groupBytes=0,i_1=0;i_1<numBuffers;i_1++)groupBytes+=buffers[bufferIndexOffset+i_1].byteLength;for(var groupBuffer=new ArrayBuffer(groupBytes),groupByteBuffer=new Uint8Array(groupBuffer),groupBufferOffset=0,i_2=0;i_2<numBuffers;i_2++){var buffer=new Uint8Array(buffers[bufferIndexOffset+i_2]);groupByteBuffer.set(buffer,groupBufferOffset),groupBufferOffset+=buffer.byteLength}var weightsEntries;groupWeightsToFetch[i].forEach(function(weightsEntry){var byteBuffer,nameToTensorMap=decodeWeights(groupBuffer.slice(weightsEntry.groupOffset,weightsEntry.groupOffset+weightsEntry.sizeBytes),[weightsEntry.manifestEntry]);for(var name_1 in nameToTensorMap)weightsTensorMap[name_1]=nameToTensorMap[name_1]}),bufferIndexOffset+=numBuffers}),[2,weightsTensorMap]}})})}}IORouterRegistry.registerSaveRouter(browserDownloadsRouter);var OCTET_STREAM_MIME_TYPE="application/octet-stream",JSON_TYPE="application/json",HTTPRequest=function(){function HTTPRequest(path,loadOptions){if(this.DEFAULT_METHOD="POST",null==loadOptions&&(loadOptions={}),this.weightPathPrefix=loadOptions.weightPathPrefix,this.onProgress=loadOptions.onProgress,null!=loadOptions.fetchFunc?(assert("function"==typeof loadOptions.fetchFunc,function(){return"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"}),this.fetch=loadOptions.fetchFunc):this.fetch=env().platform.fetch,assert(null!=path&&path.length>0,function(){return"URL path for http must not be null, undefined or empty."}),Array.isArray(path)&&assert(2===path.length,function(){return"URL paths for http must have a length of 2, (actual length is "+path.length+")."}),this.path=path,null!=loadOptions.requestInit&&null!=loadOptions.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=loadOptions.requestInit||{}}return HTTPRequest.prototype.save=function(modelArtifacts){return __awaiter(this,void 0,void 0,function(){var init,weightsManifest,modelTopologyAndWeightManifest,response;return __generator(this,function(_a){switch(_a.label){case 0:if(modelArtifacts.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");return(init=Object.assign({method:this.DEFAULT_METHOD},this.requestInit)).body=new FormData,weightsManifest=[{paths:["./model.weights.bin"],weights:modelArtifacts.weightSpecs}],modelTopologyAndWeightManifest={modelTopology:modelArtifacts.modelTopology,format:modelArtifacts.format,generatedBy:modelArtifacts.generatedBy,convertedBy:modelArtifacts.convertedBy,userDefinedMetadata:modelArtifacts.userDefinedMetadata,weightsManifest:weightsManifest},init.body.append("model.json",new Blob([JSON.stringify(modelTopologyAndWeightManifest)],{type:JSON_TYPE}),"model.json"),null!=modelArtifacts.weightData&&init.body.append("model.weights.bin",new Blob([modelArtifacts.weightData],{type:OCTET_STREAM_MIME_TYPE}),"model.weights.bin"),[4,this.fetch(this.path,init)];case 1:if((response=_a.sent()).ok)return[2,{modelArtifactsInfo:getModelArtifactsInfoForJSON(modelArtifacts),responses:[response]}];throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+response.status+".")}})})},HTTPRequest.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var modelConfigRequest,modelConfig,e_1,message,modelTopology,weightsManifest,generatedBy,convertedBy,format,userDefinedMetadata,weightSpecs,weightData,results;return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.fetch(this.path,this.requestInit)];case 1:if(!(modelConfigRequest=_a.sent()).ok)throw new Error("Request to "+this.path+" failed with status code "+modelConfigRequest.status+". Please verify this URL points to the model JSON of the model to load.");_a.label=2;case 2:return _a.trys.push([2,4,,5]),[4,modelConfigRequest.json()];case 3:return modelConfig=_a.sent(),[3,5];case 4:throw e_1=_a.sent(),message="Failed to parse model JSON of response from "+this.path+".",this.path.endsWith(".pb")?message+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":message+=" Please make sure the server is serving valid JSON for this request.",new Error(message);case 5:if(modelTopology=modelConfig.modelTopology,weightsManifest=modelConfig.weightsManifest,generatedBy=modelConfig.generatedBy,convertedBy=modelConfig.convertedBy,format=modelConfig.format,userDefinedMetadata=modelConfig.userDefinedMetadata,null==modelTopology&&null==weightsManifest)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return null==weightsManifest?[3,7]:[4,this.loadWeights(weightsManifest)];case 6:results=_a.sent(),weightSpecs=results[0],weightData=results[1],_a.label=7;case 7:return[2,{modelTopology:modelTopology,weightSpecs:weightSpecs,weightData:weightData,userDefinedMetadata:userDefinedMetadata,generatedBy:generatedBy,convertedBy:convertedBy,format:format}]}})})},HTTPRequest.prototype.loadWeights=function(weightsManifest){return __awaiter(this,void 0,void 0,function(){var weightPath,_a,prefix,suffix,pathPrefix,weightSpecs,_i,weightsManifest_1,entry,fetchURLs,buffers;return __generator(this,function(_b){switch(_b.label){case 0:for(weightPath=Array.isArray(this.path)?this.path[1]:this.path,_a=parseUrl(weightPath),prefix=_a[0],suffix=_a[1],pathPrefix=this.weightPathPrefix||prefix,weightSpecs=[],_i=0,weightsManifest_1=weightsManifest;_i<weightsManifest_1.length;_i++)entry=weightsManifest_1[_i],weightSpecs.push.apply(weightSpecs,entry.weights);return fetchURLs=[],weightsManifest.forEach(function(weightsGroup){weightsGroup.paths.forEach(function(path){fetchURLs.push(pathPrefix+path+suffix)})}),[4,loadWeightsAsArrayBuffer(fetchURLs,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})];case 1:return buffers=_b.sent(),[2,[weightSpecs,concatenateArrayBuffers(buffers)]]}})})},HTTPRequest.URL_SCHEME_REGEX=/^https?:\/\//,HTTPRequest}();function parseUrl(url){var lastSlash=url.lastIndexOf("/"),lastSearchParam=url.lastIndexOf("?"),prefix,suffix;return[url.substring(0,lastSlash)+"/",lastSearchParam>lastSlash?url.substring(lastSearchParam):""]}function isHTTPScheme(url){return null!=url.match(HTTPRequest.URL_SCHEME_REGEX)}var httpRouter=function(url,onProgress){if("undefined"==typeof fetch)return null;var isHTTP=!0;return(isHTTP=Array.isArray(url)?url.every(function(urlItem){return isHTTPScheme(urlItem)}):isHTTPScheme(url))?http(url,{onProgress:onProgress}):null};function http(path,loadOptions){return new HTTPRequest(path,loadOptions)}function browserHTTPRequest(path,loadOptions){return http(path,loadOptions)}IORouterRegistry.registerSaveRouter(httpRouter),IORouterRegistry.registerLoadRouter(httpRouter);var PassthroughLoader=function(){function PassthroughLoader(modelArtifacts){this.modelArtifacts=modelArtifacts}return PassthroughLoader.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2,this.modelArtifacts]})})},PassthroughLoader}(),PassthroughSaver=function(){function PassthroughSaver(saveHandler){this.saveHandler=saveHandler}return PassthroughSaver.prototype.save=function(modelArtifacts){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2,this.saveHandler(modelArtifacts)]})})},PassthroughSaver}();function fromMemory(modelArtifacts,weightSpecs,weightData,trainingConfig){var isModelArtifacts;return 1===arguments.length?null!=modelArtifacts.modelTopology||null!=modelArtifacts.weightSpecs?new PassthroughLoader(modelArtifacts):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new PassthroughLoader({modelTopology:modelArtifacts})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new PassthroughLoader({modelTopology:modelArtifacts,weightSpecs:weightSpecs,weightData:weightData,trainingConfig:trainingConfig}))}function withSaveHandler(saveHandler){return new PassthroughSaver(saveHandler)}var io=Object.freeze({browserFiles:browserFiles,browserHTTPRequest:browserHTTPRequest,concatenateArrayBuffers:concatenateArrayBuffers,decodeWeights:decodeWeights,encodeWeights:encodeWeights,fromMemory:fromMemory,getLoadHandlers:getLoadHandlers,getModelArtifactsInfoForJSON:getModelArtifactsInfoForJSON,getSaveHandlers:getSaveHandlers,http:http,isHTTPScheme:isHTTPScheme,loadWeights:loadWeights,registerLoadRouter:registerLoadRouter,registerSaveRouter:registerSaveRouter,weightsLoaderFactory:weightsLoaderFactory,withSaveHandler:withSaveHandler,copyModel:copyModel,listModels:listModels,moveModel:moveModel,removeModel:removeModel});function confusionMatrix_(labels,predictions,numClasses){var $labels=convertToTensor(labels,"labels","confusionMatrix"),$predictions=convertToTensor(predictions,"predictions","confusionMatrix");assert(null==numClasses||numClasses>0&&Number.isInteger(numClasses),function(){return"If provided, numClasses must be a positive integer, but got "+numClasses}),assert(1===$labels.rank,function(){return"Expected the rank of labels to be 1, but got "+$labels.rank}),assert(1===$predictions.rank,function(){return"Expected the rank of predictions to be 1, but got "+$predictions.rank}),assert($labels.shape[0]===$predictions.shape[0],function(){return"Mismatch in the number of examples: "+$labels.shape[0]+" vs. "+$predictions.shape[0]+". Labels and predictions should have the same number of elements."}),assert(numClasses>0&&Number.isInteger(numClasses),function(){return"numClasses is required to be a positive integer, but got "+numClasses});var oneHotLabels=oneHot($labels.asType("int32"),numClasses),oneHotPredictions=oneHot($predictions.asType("int32"),numClasses),oneHotLabelsT;return oneHotLabels.transpose().matMul(oneHotPredictions).asType("int32")}var confusionMatrix=op({confusionMatrix_:confusionMatrix_}),math=Object.freeze({confusionMatrix:confusionMatrix}),fromPixels2DContext$1;function fromPixels_(pixels,numChannels){if(void 0===numChannels&&(numChannels=3),numChannels>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==pixels)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var isPixelData=!1,isImageData=!1,isVideo=!1,isImage=!1,isCanvasLike=!1,kernel;if(pixels.data instanceof Uint8Array)isPixelData=!0;else if("undefined"!=typeof ImageData&&pixels instanceof ImageData)isImageData=!0;else if("undefined"!=typeof HTMLVideoElement&&pixels instanceof HTMLVideoElement)isVideo=!0;else if("undefined"!=typeof HTMLImageElement&&pixels instanceof HTMLImageElement)isImage=!0;else{if(null==pixels.getContext)throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+pixels.constructor.name);isCanvasLike=!0}if(isVideo){var HAVE_CURRENT_DATA_READY_STATE=2;if(isVideo&&pixels.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=getKernel("FromPixels",ENGINE.backendName))return ENGINE.runKernel("FromPixels",{pixels:pixels},{numChannels:numChannels});var _a=isVideo?[pixels.videoWidth,pixels.videoHeight]:[pixels.width,pixels.height],width=_a[0],height=_a[1],vals,values,outShape;if(isCanvasLike?vals=pixels.getContext("2d").getImageData(0,0,width,height).data:isImageData||isPixelData?vals=pixels.data:(isImage||isVideo)&&(null==fromPixels2DContext$1&&(fromPixels2DContext$1=document.createElement("canvas").getContext("2d")),fromPixels2DContext$1.canvas.width=width,fromPixels2DContext$1.canvas.height=height,fromPixels2DContext$1.drawImage(pixels,0,0,width,height),vals=fromPixels2DContext$1.getImageData(0,0,width,height).data),4===numChannels)values=new Int32Array(vals);else{var numPixels=width*height;values=new Int32Array(numPixels*numChannels);for(var i=0;i<numPixels;i++)for(var channel=0;channel<numChannels;++channel)values[i*numChannels+channel]=vals[4*i+channel]}return tensor3d(values,[height,width,numChannels],"int32")}function toPixels(img,canvas){return __awaiter(this,void 0,void 0,function(){var $img,_a,height,width,depth,data,minTensor,maxTensor,vals,minVals,maxVals,min,max,multiplier,bytes,i,r,g,b,a,j,ctx,imageData;return __generator(this,function(_b){switch(_b.label){case 0:if($img=convertToTensor(img,"img","toPixels"),img instanceof Tensor||($img=$img.toInt()),2!==$img.rank&&3!==$img.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank "+$img.rank+".");if(_a=$img.shape.slice(0,2),height=_a[0],width=_a[1],(depth=2===$img.rank?1:$img.shape[2])>4||2===depth)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got "+depth);return[4,$img.data()];case 1:return data=_b.sent(),minTensor=$img.min(),maxTensor=$img.max(),[4,Promise.all([minTensor.data(),maxTensor.data()])];case 2:if(vals=_b.sent(),minVals=vals[0],maxVals=vals[1],min=minVals[0],max=maxVals[0],minTensor.dispose(),maxTensor.dispose(),"float32"===$img.dtype){if(min<0||max>1)throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range ["+min+" - "+max+"].")}else{if("int32"!==$img.dtype)throw new Error("Unsupported type for toPixels: "+$img.dtype+". Please use float32 or int32 tensors.");if(min<0||max>255)throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range ["+min+" - "+max+"].")}for(multiplier="float32"===$img.dtype?255:1,bytes=new Uint8ClampedArray(width*height*4),i=0;i<height*width;++i)r=void 0,g=void 0,b=void 0,a=void 0,1===depth?(r=data[i]*multiplier,g=data[i]*multiplier,b=data[i]*multiplier,a=255):3===depth?(r=data[3*i]*multiplier,g=data[3*i+1]*multiplier,b=data[3*i+2]*multiplier,a=255):4===depth&&(r=data[4*i]*multiplier,g=data[4*i+1]*multiplier,b=data[4*i+2]*multiplier,a=data[4*i+3]*multiplier),bytes[(j=4*i)+0]=Math.round(r),bytes[j+1]=Math.round(g),bytes[j+2]=Math.round(b),bytes[j+3]=Math.round(a);return null!=canvas&&(canvas.width=width,canvas.height=height,ctx=canvas.getContext("2d"),imageData=new ImageData(bytes,width,height),ctx.putImageData(imageData,0,0)),$img!==img&&$img.dispose(),[2,bytes]}})})}var fromPixels$1=op({fromPixels_:fromPixels_}),browser=Object.freeze({toPixels:toPixels,fromPixels:fromPixels$1}),Serializable=function(){function Serializable(){}return Serializable.prototype.getClassName=function(){return this.constructor.className},Serializable.fromConfig=function(cls,config){return new cls(config)},Serializable}(),SerializationMap=function(){function SerializationMap(){this.classNameMap={}}return SerializationMap.getMap=function(){return null==SerializationMap.instance&&(SerializationMap.instance=new SerializationMap),SerializationMap.instance},SerializationMap.register=function(cls){SerializationMap.getMap().classNameMap[cls.className]=[cls,cls.fromConfig]},SerializationMap}();function registerClass(cls){assert(null!=cls.className,function(){return"Class being registered does not have the static className property defined."}),assert("string"==typeof cls.className,function(){return"className is required to be a string, but got type "+typeof cls.className}),assert(cls.className.length>0,function(){return"Class being registered has an empty-string as its className, which is disallowed."}),SerializationMap.register(cls)}var serialization=Object.freeze({Serializable:Serializable,SerializationMap:SerializationMap,registerClass:registerClass}),version="1.7.4";function forceHalfFloat(){env().set("WEBGL_FORCE_F16_TEXTURES",!0)}var webgl=Object.freeze({gpgpu_util:gpgpu_util,webgl_util:webgl_util,forceHalfFloat:forceHalfFloat,MathBackendWebGL:MathBackendWebGL,setWebGLContext:setWebGLContext,GPGPUContext:GPGPUContext}),Optimizer=function(_super){function Optimizer(){return null!==_super&&_super.apply(this,arguments)||this}return __extends(Optimizer,_super),Optimizer.prototype.minimize=function(f,returnCost,varList){void 0===returnCost&&(returnCost=!1);var _a=this.computeGradients(f,varList),value=_a.value,grads=_a.grads;if(null!=varList){var gradArray=varList.map(function(v){return{name:v.name,tensor:grads[v.name]}});this.applyGradients(gradArray)}else this.applyGradients(grads);return dispose(grads),returnCost?value:(value.dispose(),null)},Object.defineProperty(Optimizer.prototype,"iterations",{get:function(){return null==this.iterations_&&(this.iterations_=0),this.iterations_},enumerable:!0,configurable:!0}),Optimizer.prototype.incrementIterations=function(){this.iterations_=this.iterations+1},Optimizer.prototype.computeGradients=function(f,varList){return variableGrads(f,varList)},Optimizer.prototype.dispose=function(){null!=this.iterations_&&dispose(this.iterations_)},Optimizer.prototype.saveIterations=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return null==this.iterations_&&(this.iterations_=0),[2,{name:"iter",tensor:scalar(this.iterations_,"int32")}]})})},Optimizer.prototype.getWeights=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){throw new Error("getWeights() is not implemented for this optimizer yet.")})})},Optimizer.prototype.setWeights=function(weightValues){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){throw new Error("setWeights() is not implemented for this optimizer class "+this.getClassName())})})},Optimizer.prototype.extractIterations=function(weightValues){return __awaiter(this,void 0,void 0,function(){var _a;return __generator(this,function(_b){switch(_b.label){case 0:return _a=this,[4,weightValues[0].tensor.data()];case 1:return _a.iterations_=_b.sent()[0],[2,weightValues.slice(1)]}})})},Optimizer}(Serializable);Object.defineProperty(Optimizer,Symbol.hasInstance,{value:function(instance){return null!=instance.minimize&&null!=instance.computeGradients&&null!=instance.applyGradients}});var AdadeltaOptimizer=function(_super){function AdadeltaOptimizer(learningRate,rho,epsilon){void 0===epsilon&&(epsilon=null);var _this=_super.call(this)||this;return _this.learningRate=learningRate,_this.rho=rho,_this.epsilon=epsilon,_this.accumulatedGrads=[],_this.accumulatedUpdates=[],null==epsilon&&(_this.epsilon=ENGINE.backend.epsilon()),_this}return __extends(AdadeltaOptimizer,_super),AdadeltaOptimizer.prototype.applyGradients=function(variableGradients){var _this=this,variableNames;(Array.isArray(variableGradients)?variableGradients.map(function(item){return item.name}):Object.keys(variableGradients)).forEach(function(name,i){var value=ENGINE.registeredVariables[name],trainable=!1;null==_this.accumulatedGrads[i]&&(_this.accumulatedGrads[i]={originalName:name+"/accum_grad",variable:tidy(function(){return zerosLike(value).variable(!1)})}),null==_this.accumulatedUpdates[i]&&(_this.accumulatedUpdates[i]={originalName:name+"/accum_var",variable:tidy(function(){return zerosLike(value).variable(!1)})});var gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(null!=gradient){var accumulatedGrad=_this.accumulatedGrads[i].variable,accumulatedUpdate=_this.accumulatedUpdates[i].variable;tidy(function(){var newAccumulatedGrad=accumulatedGrad.mul(_this.rho).add(gradient.square().mul(1-_this.rho)),updates=accumulatedUpdate.add(_this.epsilon).sqrt().div(accumulatedGrad.add(_this.epsilon).sqrt()).mul(gradient),newAccumulatedUpdate=accumulatedUpdate.mul(_this.rho).add(updates.square().mul(1-_this.rho));accumulatedGrad.assign(newAccumulatedGrad),accumulatedUpdate.assign(newAccumulatedUpdate);var newValue=updates.mul(-_this.learningRate).add(value);value.assign(newValue)})}}),this.incrementIterations()},AdadeltaOptimizer.prototype.dispose=function(){null!=this.accumulatedUpdates&&(dispose(this.accumulatedGrads.map(function(v){return v.variable})),dispose(this.accumulatedUpdates.map(function(v){return v.variable})))},AdadeltaOptimizer.prototype.getWeights=function(){return __awaiter(this,void 0,void 0,function(){var variables;return __generator(this,function(_a){switch(_a.label){case 0:return variables=this.accumulatedGrads.concat(this.accumulatedUpdates),[4,this.saveIterations()];case 1:return[2,[_a.sent()].concat(variables.map(function(v){return{name:v.originalName,tensor:v.variable}}))]}})})},AdadeltaOptimizer.prototype.setWeights=function(weightValues){return __awaiter(this,void 0,void 0,function(){var variableCount,trainable;return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.extractIterations(weightValues)];case 1:return weightValues=_a.sent(),variableCount=weightValues.length/2,trainable=!1,this.accumulatedGrads=weightValues.slice(0,variableCount).map(function(v){return{originalName:v.name,variable:v.tensor.variable(trainable)}}),this.accumulatedUpdates=weightValues.slice(variableCount,2*variableCount).map(function(v){return{originalName:v.name,variable:v.tensor.variable(trainable)}}),[2]}})})},AdadeltaOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},AdadeltaOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate,config.rho,config.epsilon)},AdadeltaOptimizer.className="Adadelta",AdadeltaOptimizer}(Optimizer);registerClass(AdadeltaOptimizer);var AdagradOptimizer=function(_super){function AdagradOptimizer(learningRate,initialAccumulatorValue){void 0===initialAccumulatorValue&&(initialAccumulatorValue=.1);var _this=_super.call(this)||this;return _this.learningRate=learningRate,_this.initialAccumulatorValue=initialAccumulatorValue,_this.accumulatedGrads=[],_this}return __extends(AdagradOptimizer,_super),AdagradOptimizer.prototype.applyGradients=function(variableGradients){var _this=this,variableNames;(Array.isArray(variableGradients)?variableGradients.map(function(item){return item.name}):Object.keys(variableGradients)).forEach(function(name,i){var value=ENGINE.registeredVariables[name];if(null==_this.accumulatedGrads[i]){var trainable_1=!1;_this.accumulatedGrads[i]={originalName:name+"/accumulator",variable:tidy(function(){return fill(value.shape,_this.initialAccumulatorValue).variable(!1)})}}var gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(null!=gradient){var accumulatedGrad=_this.accumulatedGrads[i].variable;tidy(function(){var newAccumulatedGrad=accumulatedGrad.add(gradient.square());accumulatedGrad.assign(newAccumulatedGrad);var newValue=gradient.div(newAccumulatedGrad.add(ENGINE.backend.epsilon()).sqrt()).mul(-_this.learningRate).add(value);value.assign(newValue)})}}),this.incrementIterations()},AdagradOptimizer.prototype.dispose=function(){null!=this.accumulatedGrads&&dispose(this.accumulatedGrads.map(function(v){return v.variable}))},AdagradOptimizer.prototype.getWeights=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.saveIterations()];case 1:return[2,[_a.sent()].concat(this.accumulatedGrads.map(function(v){return{name:v.originalName,tensor:v.variable}}))]}})})},AdagradOptimizer.prototype.setWeights=function(weightValues){return __awaiter(this,void 0,void 0,function(){var trainable;return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.extractIterations(weightValues)];case 1:return weightValues=_a.sent(),trainable=!1,this.accumulatedGrads=weightValues.map(function(v){return{originalName:v.name,variable:v.tensor.variable(trainable)}}),[2]}})})},AdagradOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},AdagradOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate,config.initialAccumulatorValue)},AdagradOptimizer.className="Adagrad",AdagradOptimizer}(Optimizer);registerClass(AdagradOptimizer);var AdamOptimizer=function(_super){function AdamOptimizer(learningRate,beta1,beta2,epsilon){void 0===epsilon&&(epsilon=null);var _this=_super.call(this)||this;return _this.learningRate=learningRate,_this.beta1=beta1,_this.beta2=beta2,_this.epsilon=epsilon,_this.accumulatedFirstMoment=[],_this.accumulatedSecondMoment=[],tidy(function(){_this.accBeta1=scalar(beta1).variable(),_this.accBeta2=scalar(beta2).variable()}),null==epsilon&&(_this.epsilon=ENGINE.backend.epsilon()),_this}return __extends(AdamOptimizer,_super),AdamOptimizer.prototype.applyGradients=function(variableGradients){var _this=this,varNames=Array.isArray(variableGradients)?variableGradients.map(function(v){return v.name}):Object.keys(variableGradients);tidy(function(){var oneMinusAccBeta1=sub(1,_this.accBeta1),oneMinusAccBeta2=sub(1,_this.accBeta2);varNames.forEach(function(name,i){var value=ENGINE.registeredVariables[name],trainable=!1;null==_this.accumulatedFirstMoment[i]&&(_this.accumulatedFirstMoment[i]={originalName:name+"/m",variable:tidy(function(){return zerosLike(value).variable(!1)})}),null==_this.accumulatedSecondMoment[i]&&(_this.accumulatedSecondMoment[i]={originalName:name+"/v",variable:tidy(function(){return zerosLike(value).variable(!1)})});var gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(null!=gradient){var firstMoment=_this.accumulatedFirstMoment[i].variable,secondMoment=_this.accumulatedSecondMoment[i].variable,newFirstMoment=firstMoment.mul(_this.beta1).add(gradient.mul(1-_this.beta1)),newSecondMoment=secondMoment.mul(_this.beta2).add(gradient.square().mul(1-_this.beta2)),biasCorrectedFirstMoment=newFirstMoment.div(oneMinusAccBeta1),biasCorrectedSecondMoment=newSecondMoment.div(oneMinusAccBeta2);firstMoment.assign(newFirstMoment),secondMoment.assign(newSecondMoment);var newValue=biasCorrectedFirstMoment.div(biasCorrectedSecondMoment.sqrt().add(_this.epsilon)).mul(-_this.learningRate).add(value);value.assign(newValue)}}),_this.accBeta1.assign(_this.accBeta1.mul(_this.beta1)),_this.accBeta2.assign(_this.accBeta2.mul(_this.beta2))}),this.incrementIterations()},AdamOptimizer.prototype.dispose=function(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&dispose(this.accumulatedFirstMoment.map(function(v){return v.variable})),null!=this.accumulatedSecondMoment&&dispose(this.accumulatedSecondMoment.map(function(v){return v.variable}))},AdamOptimizer.prototype.getWeights=function(){return __awaiter(this,void 0,void 0,function(){var variables;return __generator(this,function(_a){switch(_a.label){case 0:return variables=this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment),[4,this.saveIterations()];case 1:return[2,[_a.sent()].concat(variables.map(function(v){return{name:v.originalName,tensor:v.variable}}))]}})})},AdamOptimizer.prototype.setWeights=function(weightValues){return __awaiter(this,void 0,void 0,function(){var variableCount,trainable,_this=this;return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.extractIterations(weightValues)];case 1:return weightValues=_a.sent(),tidy(function(){_this.accBeta1.assign(pow(_this.beta1,_this.iterations_+1)),_this.accBeta2.assign(pow(_this.beta2,_this.iterations_+1))}),variableCount=weightValues.length/2,trainable=!1,this.accumulatedFirstMoment=weightValues.slice(0,variableCount).map(function(v){return{originalName:v.name,variable:v.tensor.variable(trainable)}}),this.accumulatedSecondMoment=weightValues.slice(variableCount,2*variableCount).map(function(v){return{originalName:v.name,variable:v.tensor.variable(trainable)}}),[2]}})})},AdamOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},AdamOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate,config.beta1,config.beta2,config.epsilon)},AdamOptimizer.className="Adam",AdamOptimizer}(Optimizer);registerClass(AdamOptimizer);var AdamaxOptimizer=function(_super){function AdamaxOptimizer(learningRate,beta1,beta2,epsilon,decay){void 0===epsilon&&(epsilon=null),void 0===decay&&(decay=0);var _this=_super.call(this)||this;return _this.learningRate=learningRate,_this.beta1=beta1,_this.beta2=beta2,_this.epsilon=epsilon,_this.decay=decay,_this.accumulatedFirstMoment=[],_this.accumulatedWeightedInfNorm=[],tidy(function(){_this.iteration=scalar(0).variable(),_this.accBeta1=scalar(beta1).variable()}),null==epsilon&&(_this.epsilon=ENGINE.backend.epsilon()),_this}return __extends(AdamaxOptimizer,_super),AdamaxOptimizer.prototype.applyGradients=function(variableGradients){var _this=this,variableNames=Array.isArray(variableGradients)?variableGradients.map(function(item){return item.name}):Object.keys(variableGradients);tidy(function(){var oneMinusAccBeta1=sub(1,_this.accBeta1),lr=div(-_this.learningRate,_this.iteration.mul(_this.decay).add(1));variableNames.forEach(function(name,i){var value=ENGINE.registeredVariables[name],trainable=!1;null==_this.accumulatedFirstMoment[i]&&(_this.accumulatedFirstMoment[i]={originalName:name+"/m",variable:zerosLike(value).variable(!1)}),null==_this.accumulatedWeightedInfNorm[i]&&(_this.accumulatedWeightedInfNorm[i]={originalName:name+"/v",variable:zerosLike(value).variable(!1)});var gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(null!=gradient){var firstMoment=_this.accumulatedFirstMoment[i].variable,weightedInfNorm=_this.accumulatedWeightedInfNorm[i].variable,newFirstMoment=firstMoment.mul(_this.beta1).add(gradient.mul(1-_this.beta1)),ut0=weightedInfNorm.mul(_this.beta2),ut1=gradient.abs(),newWeightedInfNorm=ut0.maximum(ut1);firstMoment.assign(newFirstMoment),weightedInfNorm.assign(newWeightedInfNorm);var newValue=lr.div(oneMinusAccBeta1).mul(newFirstMoment.div(newWeightedInfNorm.add(_this.epsilon))).add(value);value.assign(newValue)}}),_this.iteration.assign(_this.iteration.add(1)),_this.accBeta1.assign(_this.accBeta1.mul(_this.beta1))}),this.incrementIterations()},AdamaxOptimizer.prototype.dispose=function(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&dispose(this.accumulatedFirstMoment.map(function(v){return v.variable})),null!=this.accumulatedWeightedInfNorm&&dispose(this.accumulatedWeightedInfNorm.map(function(v){return v.variable}))},AdamaxOptimizer.prototype.getWeights=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){throw new Error("getWeights() is not implemented for Adamax yet.")})})},AdamaxOptimizer.prototype.setWeights=function(weightValues){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){throw new Error("setWeights() is not implemented for Adamax yet.")})})},AdamaxOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},AdamaxOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate,config.beta1,config.beta2,config.epsilon,config.decay)},AdamaxOptimizer.className="Adamax",AdamaxOptimizer}(Optimizer);registerClass(AdamaxOptimizer);var SGDOptimizer=function(_super){function SGDOptimizer(learningRate){var _this=_super.call(this)||this;return _this.learningRate=learningRate,_this.setLearningRate(learningRate),_this}return __extends(SGDOptimizer,_super),SGDOptimizer.prototype.applyGradients=function(variableGradients){var _this=this,varNames;(Array.isArray(variableGradients)?variableGradients.map(function(v){return v.name}):Object.keys(variableGradients)).forEach(function(name,i){var gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(null!=gradient){var value=ENGINE.registeredVariables[name];tidy(function(){var newValue=_this.c.mul(gradient).add(value);value.assign(newValue)})}}),this.incrementIterations()},SGDOptimizer.prototype.setLearningRate=function(learningRate){this.learningRate=learningRate,null!=this.c&&this.c.dispose(),this.c=keep(scalar(-learningRate))},SGDOptimizer.prototype.dispose=function(){this.c.dispose()},SGDOptimizer.prototype.getWeights=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.saveIterations()];case 1:return[2,[_a.sent()]]}})})},SGDOptimizer.prototype.setWeights=function(weightValues){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.extractIterations(weightValues)];case 1:if(0!==(weightValues=_a.sent()).length)throw new Error("SGD optimizer does not have settable weights.");return[2]}})})},SGDOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate}},SGDOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate)},SGDOptimizer.className="SGD",SGDOptimizer}(Optimizer);registerClass(SGDOptimizer);var MomentumOptimizer=function(_super){function MomentumOptimizer(learningRate,momentum,useNesterov){void 0===useNesterov&&(useNesterov=!1);var _this=_super.call(this,learningRate)||this;return _this.learningRate=learningRate,_this.momentum=momentum,_this.useNesterov=useNesterov,_this.accumulations=[],_this.m=scalar(_this.momentum),_this}return __extends(MomentumOptimizer,_super),MomentumOptimizer.prototype.applyGradients=function(variableGradients){var _this=this,variableNames;(Array.isArray(variableGradients)?variableGradients.map(function(item){return item.name}):Object.keys(variableGradients)).forEach(function(name,i){var value=ENGINE.registeredVariables[name];if(null==_this.accumulations[i]){var trainable_1=!1;_this.accumulations[i]={originalName:name+"/momentum",variable:tidy(function(){return zerosLike(value).variable(!1)})}}var accumulation=_this.accumulations[i].variable,gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];null!=gradient&&tidy(function(){var newValue,newAccumulation=_this.m.mul(accumulation).add(gradient);newValue=_this.useNesterov?_this.c.mul(gradient.add(newAccumulation.mul(_this.m))).add(value):_this.c.mul(newAccumulation).add(value),accumulation.assign(newAccumulation),value.assign(newValue)})}),this.incrementIterations()},MomentumOptimizer.prototype.dispose=function(){this.m.dispose(),null!=this.accumulations&&dispose(this.accumulations.map(function(v){return v.variable}))},MomentumOptimizer.prototype.setMomentum=function(momentum){this.momentum=momentum},MomentumOptimizer.prototype.getWeights=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.saveIterations()];case 1:return[2,[_a.sent()].concat(this.accumulations.map(function(v){return{name:v.originalName,tensor:v.variable}}))]}})})},MomentumOptimizer.prototype.setWeights=function(weightValues){return __awaiter(this,void 0,void 0,function(){var trainable;return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.extractIterations(weightValues)];case 1:return weightValues=_a.sent(),trainable=!1,this.accumulations=weightValues.map(function(v){return{originalName:v.name,variable:v.tensor.variable(trainable)}}),[2]}})})},MomentumOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},MomentumOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate,config.momentum,config.useNesterov)},MomentumOptimizer.className="Momentum",MomentumOptimizer}(SGDOptimizer);registerClass(MomentumOptimizer);var RMSPropOptimizer=function(_super){function RMSPropOptimizer(learningRate,decay,momentum,epsilon,centered){void 0===decay&&(decay=.9),void 0===momentum&&(momentum=0),void 0===epsilon&&(epsilon=null),void 0===centered&&(centered=!1);var _this=_super.call(this)||this;if(_this.learningRate=learningRate,_this.decay=decay,_this.momentum=momentum,_this.epsilon=epsilon,_this.accumulatedMeanSquares=[],_this.accumulatedMoments=[],_this.accumulatedMeanGrads=[],_this.centered=centered,null==epsilon&&(_this.epsilon=ENGINE.backend.epsilon()),null==learningRate)throw new Error("learningRate for RMSPropOptimizer must be defined.");return _this}return __extends(RMSPropOptimizer,_super),RMSPropOptimizer.prototype.applyGradients=function(variableGradients){var _this=this,variableNames;(Array.isArray(variableGradients)?variableGradients.map(function(item){return item.name}):Object.keys(variableGradients)).forEach(function(name,i){var value=ENGINE.registeredVariables[name],trainable=!1;null==_this.accumulatedMeanSquares[i]&&(_this.accumulatedMeanSquares[i]={originalName:name+"/rms",variable:tidy(function(){return zerosLike(value).variable(!1)})}),null==_this.accumulatedMoments[i]&&(_this.accumulatedMoments[i]={originalName:name+"/momentum",variable:tidy(function(){return zerosLike(value).variable(!1)})}),null==_this.accumulatedMeanGrads[i]&&_this.centered&&(_this.accumulatedMeanGrads[i]={originalName:name+"/mg",variable:tidy(function(){return zerosLike(value).variable(!1)})});var gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(null!=gradient){var accumulatedMeanSquare=_this.accumulatedMeanSquares[i].variable,accumulatedMoments=_this.accumulatedMoments[i].variable;tidy(function(){var newAccumulatedMeanSquare=accumulatedMeanSquare.mul(_this.decay).add(gradient.square().mul(1-_this.decay));if(_this.centered){var accumulatedMeanGrad=_this.accumulatedMeanGrads[i].variable,newAccumulatedMeanGrad=accumulatedMeanGrad.mul(_this.decay).add(gradient.mul(1-_this.decay)),newAccumulatedMoments=accumulatedMoments.mul(_this.momentum).add(gradient.mul(_this.learningRate).div(newAccumulatedMeanSquare.sub(newAccumulatedMeanGrad.square().add(_this.epsilon)).sqrt()));accumulatedMeanSquare.assign(newAccumulatedMeanSquare),accumulatedMeanGrad.assign(newAccumulatedMeanGrad),accumulatedMoments.assign(newAccumulatedMoments);var newValue=value.sub(newAccumulatedMoments);value.assign(newValue)}else{var newAccumulatedMeanSquare_1=accumulatedMeanSquare.mul(_this.decay).add(gradient.square().mul(1-_this.decay)),newAccumulatedMoments=accumulatedMoments.mul(_this.momentum).add(gradient.mul(_this.learningRate).div(newAccumulatedMeanSquare_1.add(_this.epsilon).sqrt()));accumulatedMeanSquare.assign(newAccumulatedMeanSquare_1),accumulatedMoments.assign(newAccumulatedMoments);var newValue=value.sub(newAccumulatedMoments);value.assign(newValue)}})}}),this.incrementIterations()},RMSPropOptimizer.prototype.dispose=function(){null!=this.accumulatedMeanSquares&&dispose(this.accumulatedMeanSquares.map(function(v){return v.variable})),null!=this.accumulatedMeanGrads&&this.centered&&dispose(this.accumulatedMeanGrads.map(function(v){return v.variable})),null!=this.accumulatedMoments&&dispose(this.accumulatedMoments.map(function(v){return v.variable}))},RMSPropOptimizer.prototype.getWeights=function(){return __awaiter(this,void 0,void 0,function(){var variables;return __generator(this,function(_a){switch(_a.label){case 0:return variables=this.accumulatedMeanSquares.concat(this.accumulatedMoments),this.centered&&variables.push.apply(variables,this.accumulatedMeanGrads),[4,this.saveIterations()];case 1:return[2,[_a.sent()].concat(variables.map(function(v){return{name:v.originalName,tensor:v.variable}}))]}})})},RMSPropOptimizer.prototype.setWeights=function(weightValues){return __awaiter(this,void 0,void 0,function(){var variableCount,trainable;return __generator(this,function(_a){switch(_a.label){case 0:return[4,this.extractIterations(weightValues)];case 1:return weightValues=_a.sent(),variableCount=this.centered?weightValues.length/3:weightValues.length/2,trainable=!1,this.accumulatedMeanSquares=weightValues.slice(0,variableCount).map(function(v){return{originalName:v.name,variable:v.tensor.variable(trainable)}}),this.accumulatedMoments=weightValues.slice(variableCount,2*variableCount).map(function(v){return{originalName:v.name,variable:v.tensor.variable(trainable)}}),this.centered&&(this.accumulatedMeanGrads=weightValues.slice(2*variableCount,3*variableCount).map(function(v){return{originalName:v.name,variable:v.tensor.variable(trainable)}})),[2]}})})},RMSPropOptimizer.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},RMSPropOptimizer.fromConfig=function(cls,config){return new cls(config.learningRate,config.decay,config.momentum,config.epsilon,config.centered)},RMSPropOptimizer.className="RMSProp",RMSPropOptimizer}(Optimizer);registerClass(RMSPropOptimizer);var OptimizerConstructors=function(){function OptimizerConstructors(){}return OptimizerConstructors.sgd=function(learningRate){return new SGDOptimizer(learningRate)},OptimizerConstructors.momentum=function(learningRate,momentum,useNesterov){return void 0===useNesterov&&(useNesterov=!1),new MomentumOptimizer(learningRate,momentum,useNesterov)},OptimizerConstructors.rmsprop=function(learningRate,decay,momentum,epsilon,centered){return void 0===decay&&(decay=.9),void 0===momentum&&(momentum=0),void 0===epsilon&&(epsilon=null),void 0===centered&&(centered=!1),new RMSPropOptimizer(learningRate,decay,momentum,epsilon,centered)},OptimizerConstructors.adam=function(learningRate,beta1,beta2,epsilon){return void 0===learningRate&&(learningRate=.001),void 0===beta1&&(beta1=.9),void 0===beta2&&(beta2=.999),void 0===epsilon&&(epsilon=null),new AdamOptimizer(learningRate,beta1,beta2,epsilon)},OptimizerConstructors.adadelta=function(learningRate,rho,epsilon){return void 0===learningRate&&(learningRate=.001),void 0===rho&&(rho=.95),void 0===epsilon&&(epsilon=null),new AdadeltaOptimizer(learningRate,rho,epsilon)},OptimizerConstructors.adamax=function(learningRate,beta1,beta2,epsilon,decay){return void 0===learningRate&&(learningRate=.002),void 0===beta1&&(beta1=.9),void 0===beta2&&(beta2=.999),void 0===epsilon&&(epsilon=null),void 0===decay&&(decay=0),new AdamaxOptimizer(learningRate,beta1,beta2,epsilon,decay)},OptimizerConstructors.adagrad=function(learningRate,initialAccumulatorValue){return void 0===initialAccumulatorValue&&(initialAccumulatorValue=.1),new AdagradOptimizer(learningRate,initialAccumulatorValue)},OptimizerConstructors}(),train={sgd:OptimizerConstructors.sgd,momentum:OptimizerConstructors.momentum,adadelta:OptimizerConstructors.adadelta,adagrad:OptimizerConstructors.adagrad,rmsprop:OptimizerConstructors.rmsprop,adamax:OptimizerConstructors.adamax,adam:OptimizerConstructors.adam},delayCallback="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:function(f){return f()};function nextFrame(){return new Promise(function(resolve){return delayCallback(function(){return resolve()})})}Tensor.prototype.add=function(b){return add(this,b)},Tensor.prototype.broadcastTo=function(shape){return broadcastTo(this,shape)},Tensor.prototype.div=function(b){return div(this,b)},Tensor.prototype.divNoNan=function(b){return divNoNan(this,b)},Tensor.prototype.squaredDifference=function(b){return squaredDifference(this,b)},Tensor.prototype.tile=function(reps){return tile$1(this,reps)},Tensor.prototype.oneHot=function(depth,onValue,offValue){return void 0===onValue&&(onValue=1),void 0===offValue&&(offValue=0),oneHot(this,depth,onValue,offValue)},Tensor.prototype.transpose=function(perm){return transpose(this,perm)},Tensor.prototype.pad=function(paddings,constantValue){return pad(this,paddings,constantValue)},Tensor.prototype.batchNorm=function(mean,variance,offset,scale,varianceEpsilon){return batchNorm(this,mean,variance,offset,scale,varianceEpsilon)},setOpHandler(ops),exports.AdadeltaOptimizer=AdadeltaOptimizer,exports.AdagradOptimizer=AdagradOptimizer,exports.AdamOptimizer=AdamOptimizer,exports.AdamaxOptimizer=AdamaxOptimizer,exports.Add=Add,exports.AddN=AddN,exports.BroadcastTo=BroadcastTo,exports.DataStorage=DataStorage,exports.Div=Div,exports.Environment=Environment,exports.FromPixels=FromPixels,exports.FusedBatchNorm=FusedBatchNorm,exports.Identity=Identity,exports.KernelBackend=KernelBackend,exports.MaxPoolWithArgmax=MaxPoolWithArgmax,exports.MomentumOptimizer=MomentumOptimizer,exports.NonMaxSuppressionV5=NonMaxSuppressionV5,exports.OneHot=OneHot,exports.Optimizer=Optimizer,exports.PadV2=PadV2,exports.RMSPropOptimizer=RMSPropOptimizer,exports.SGDOptimizer=SGDOptimizer,exports.Square=Square,exports.SquaredDifference=SquaredDifference,exports.Tensor=Tensor,exports.TensorBuffer=TensorBuffer,exports.Tile=Tile,exports.Transpose=Transpose,exports.Variable=Variable,exports.abs=abs,exports.acos=acos,exports.acosh=acosh,exports.add=add,exports.addN=addN,exports.addStrict=addStrict,exports.all=all,exports.any=any,exports.argMax=argMax,exports.argMin=argMin,exports.asin=asin,exports.asinh=asinh,exports.atan=atan,exports.atan2=atan2,exports.atanh=atanh,exports.avgPool=avgPool,exports.avgPool3d=avgPool3d,exports.backend=backend,exports.backend_util=backend_util,exports.basicLSTMCell=basicLSTMCell,exports.batchNorm=batchNorm,exports.batchNorm2d=batchNorm2d,exports.batchNorm3d=batchNorm3d,exports.batchNorm4d=batchNorm4d,exports.batchNormalization=batchNormalization,exports.batchNormalization2d=batchNormalization2d,exports.batchNormalization3d=batchNormalization3d,exports.batchNormalization4d=batchNormalization4d,exports.batchToSpaceND=batchToSpaceND,exports.booleanMaskAsync=booleanMaskAsync,exports.broadcastTo=broadcastTo,exports.browser=browser,exports.buffer=buffer,exports.cast=cast,exports.ceil=ceil,exports.clipByValue=clipByValue,exports.clone=clone,exports.complex=complex,exports.concat=concat,exports.concat1d=concat1d,exports.concat2d=concat2d,exports.concat3d=concat3d,exports.concat4d=concat4d,exports.conv1d=conv1d,exports.conv2d=conv2d,exports.conv2dTranspose=conv2dTranspose,exports.conv3d=conv3d,exports.conv3dTranspose=conv3dTranspose,exports.cos=cos,exports.cosh=cosh,exports.cumsum=cumsum,exports.customGrad=customGrad,exports.deprecationWarn=deprecationWarn,exports.depthToSpace=depthToSpace,exports.depthwiseConv2d=depthwiseConv2d,exports.diag=diag,exports.disableDeprecationWarnings=disableDeprecationWarnings,exports.dispose=dispose,exports.disposeVariables=disposeVariables,exports.div=div,exports.divNoNan=divNoNan,exports.divStrict=divStrict,exports.dot=dot,exports.dropout=dropout,exports.elu=elu,exports.enableDebugMode=enableDebugMode,exports.enableProdMode=enableProdMode,exports.engine=engine,exports.env=env,exports.equal=equal,exports.equalStrict=equalStrict,exports.erf=erf,exports.exp=exp,exports.expandDims=expandDims,exports.expm1=expm1,exports.eye=eye,exports.fft=fft,exports.fill=fill,exports.findBackend=findBackend,exports.findBackendFactory=findBackendFactory,exports.floor=floor,exports.floorDiv=floorDiv,exports.frame=frame,exports.fused=fused_ops,exports.gather=gather,exports.gatherND=gatherND,exports.gather_util=gather_nd_util,exports.getBackend=getBackend,exports.getGradient=getGradient,exports.getKernel=getKernel,exports.getKernelsForBackend=getKernelsForBackend,exports.grad=grad,exports.grads=grads,exports.greater=greater,exports.greaterEqual=greaterEqual,exports.greaterEqualStrict=greaterEqualStrict,exports.greaterStrict=greaterStrict,exports.hammingWindow=hammingWindow,exports.hannWindow=hannWindow,exports.ifft=ifft,exports.imag=imag,exports.image=image_ops,exports.inTopKAsync=inTopKAsync,exports.io=io,exports.irfft=irfft,exports.isFinite=isFinite$1,exports.isInf=isInf,exports.isNaN=isNaN$1,exports.keep=keep,exports.leakyRelu=leakyRelu,exports.less=less,exports.lessEqual=lessEqual,exports.lessEqualStrict=lessEqualStrict,exports.lessStrict=lessStrict,exports.linalg=linalg_ops,exports.linspace=linspace,exports.localResponseNormalization=localResponseNormalization,exports.log=log,exports.log1p=log1p,exports.logSigmoid=logSigmoid,exports.logSoftmax=logSoftmax,exports.logSumExp=logSumExp,exports.logicalAnd=logicalAnd,exports.logicalNot=logicalNot,exports.logicalOr=logicalOr,exports.logicalXor=logicalXor,exports.losses=loss_ops,exports.matMul=matMul,exports.math=math,exports.max=max,exports.maxPool=maxPool,exports.maxPool3d=maxPool3d,exports.maxPoolWithArgmax=maxPoolWithArgmax,exports.maximum=maximum,exports.maximumStrict=maximumStrict,exports.mean=mean,exports.memory=memory,exports.min=min,exports.minimum=minimum,exports.minimumStrict=minimumStrict,exports.mod=mod,exports.modStrict=modStrict,exports.moments=moments,exports.movingAverage=movingAverage,exports.mul=mul,exports.mulStrict=mulStrict,exports.multiRNNCell=multiRNNCell,exports.multinomial=multinomial,exports.neg=neg,exports.nextFrame=nextFrame,exports.norm=norm,exports.notEqual=notEqual,exports.notEqualStrict=notEqualStrict,exports.oneHot=oneHot,exports.ones=ones$1,exports.onesLike=onesLike,exports.op=op,exports.outerProduct=outerProduct,exports.pad=pad,exports.pad1d=pad1d,exports.pad2d=pad2d,exports.pad3d=pad3d,exports.pad4d=pad4d,exports.pool=pool,exports.pow=pow,exports.powStrict=powStrict,exports.prelu=prelu,exports.print=print,exports.prod=prod,exports.profile=profile,exports.rand=rand,exports.randomGamma=randomGamma,exports.randomNormal=randomNormal,exports.randomUniform=randomUniform,exports.range=range,exports.ready=ready,exports.real=real,exports.reciprocal=reciprocal,exports.registerBackend=registerBackend,exports.registerGradient=registerGradient,exports.registerKernel=registerKernel,exports.relu=relu,exports.relu6=relu6,exports.removeBackend=removeBackend,exports.reshape=reshape,exports.reverse=reverse,exports.reverse1d=reverse1d,exports.reverse2d=reverse2d,exports.reverse3d=reverse3d,exports.reverse4d=reverse4d,exports.rfft=rfft,exports.round=round,exports.rsqrt=rsqrt,exports.scalar=scalar,exports.scatterND=scatterND,exports.scatter_util=scatter_nd_util,exports.selu=selu,exports.separableConv2d=separableConv2d,exports.serialization=serialization,exports.setBackend=setBackend,exports.setPlatform=setPlatform,exports.setdiff1dAsync=setdiff1dAsync,exports.sigmoid=sigmoid,exports.sign=sign,exports.signal=signal_ops,exports.sin=sin,exports.sinh=sinh,exports.slice=slice,exports.slice1d=slice1d,exports.slice2d=slice2d,exports.slice3d=slice3d,exports.slice4d=slice4d,exports.slice_util=slice_util,exports.softmax=softmax,exports.softplus=softplus,exports.spaceToBatchND=spaceToBatchND,exports.sparseToDense=sparseToDense,exports.spectral=spectral_ops,exports.split=split,exports.sqrt=sqrt,exports.square=square,exports.squaredDifference=squaredDifference,exports.squaredDifferenceStrict=squaredDifferenceStrict,exports.squeeze=squeeze,exports.stack=stack,exports.step=step,exports.stft=stft,exports.stridedSlice=stridedSlice,exports.sub=sub,exports.subStrict=subStrict,exports.sum=sum$1,exports.sumOutType=sumOutType,exports.tan=tan,exports.tanh=tanh$1,exports.tensor=tensor,exports.tensor1d=tensor1d,exports.tensor2d=tensor2d,exports.tensor3d=tensor3d,exports.tensor4d=tensor4d,exports.tensor5d=tensor5d,exports.tensor6d=tensor6d,exports.tensor_util=tensor_util,exports.test_util=test_util,exports.tidy=tidy,exports.tile=tile$1,exports.time=time,exports.topk=topk,exports.train=train,exports.transpose=transpose,exports.truncatedNormal=truncatedNormal,exports.unregisterGradient=unregisterGradient,exports.unregisterKernel=unregisterKernel,exports.unsortedSegmentSum=unsortedSegmentSum,exports.unstack=unstack,exports.util=util,exports.valueAndGrad=valueAndGrad,exports.valueAndGrads=valueAndGrads,exports.variable=variable,exports.variableGrads=variableGrads,exports.version_core="1.7.4",exports.webgl=webgl,exports.where=where,exports.whereAsync=whereAsync,exports.zeros=zeros,exports.zerosLike=zerosLike,Object.defineProperty(exports,"__esModule",{value:!0})}),function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?factory(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],factory):factory(global.tf=global.tf||{},global.tf)}(this,function(exports,tfc){"use strict";var __assign=function(){return(__assign=Object.assign||function __assign(t){for(var s,i=1,n=arguments.length;i<n;i++)for(var p in s=arguments[i])Object.prototype.hasOwnProperty.call(s,p)&&(t[p]=s[p]);return t}).apply(this,arguments)},DataType,SaverDef;function __awaiter(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})}function __generator(thisArg,body){var _={label:0,sent:function(){if(1&t[0])throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),throw:verb(1),return:verb(2)},"function"==typeof Symbol&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");for(;_;)try{if(f=1,y&&(t=2&op[0]?y.return:op[0]?y.throw||((t=y.return)&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;switch(y=0,t&&(op=[2&op[0],t.value]),op[0]){case 0:case 1:t=op;break;case 4:return _.label++,{value:op[1],done:!1};case 5:_.label++,y=op[1],op=[0];continue;case 7:op=_.ops.pop(),_.trys.pop();continue;default:if(!(t=(t=_.trys).length>0&&t[t.length-1])&&(6===op[0]||2===op[0])){_=0;continue}if(3===op[0]&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(6===op[0]&&_.label<t[1]){_.label=t[1],t=op;break}if(t&&_.label<t[2]){_.label=t[2],_.ops.push(op);break}t[2]&&_.ops.pop(),_.trys.pop();continue}op=body.call(thisArg,_)}catch(e){op=[6,e],y=0}finally{f=t=0}if(5&op[0])throw op[1];return{value:op[0]?op[1]:void 0,done:!0}}}!function(DataType){DataType[DataType.DT_INVALID=0]="DT_INVALID",DataType[DataType.DT_FLOAT=1]="DT_FLOAT",DataType[DataType.DT_DOUBLE=2]="DT_DOUBLE",DataType[DataType.DT_INT32=3]="DT_INT32",DataType[DataType.DT_UINT8=4]="DT_UINT8",DataType[DataType.DT_INT16=5]="DT_INT16",DataType[DataType.DT_INT8=6]="DT_INT8",DataType[DataType.DT_STRING=7]="DT_STRING",DataType[DataType.DT_COMPLEX64=8]="DT_COMPLEX64",DataType[DataType.DT_INT64=9]="DT_INT64",DataType[DataType.DT_BOOL=10]="DT_BOOL",DataType[DataType.DT_QINT8=11]="DT_QINT8",DataType[DataType.DT_QUINT8=12]="DT_QUINT8",DataType[DataType.DT_QINT32=13]="DT_QINT32",DataType[DataType.DT_BFLOAT16=14]="DT_BFLOAT16",DataType[DataType.DT_FLOAT_REF=101]="DT_FLOAT_REF",DataType[DataType.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",DataType[DataType.DT_INT32_REF=103]="DT_INT32_REF",DataType[DataType.DT_UINT8_REF=104]="DT_UINT8_REF",DataType[DataType.DT_INT16_REF=105]="DT_INT16_REF",DataType[DataType.DT_INT8_REF=106]="DT_INT8_REF",DataType[DataType.DT_STRING_REF=107]="DT_STRING_REF",DataType[DataType.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",DataType[DataType.DT_INT64_REF=109]="DT_INT64_REF",DataType[DataType.DT_BOOL_REF=110]="DT_BOOL_REF",DataType[DataType.DT_QINT8_REF=111]="DT_QINT8_REF",DataType[DataType.DT_QUINT8_REF=112]="DT_QUINT8_REF",DataType[DataType.DT_QINT32_REF=113]="DT_QINT32_REF",DataType[DataType.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(DataType||(DataType={})),function(SaverDef){var CheckpointFormatVersion;!function(CheckpointFormatVersion){CheckpointFormatVersion[CheckpointFormatVersion.LEGACY=0]="LEGACY",CheckpointFormatVersion[CheckpointFormatVersion.V1=1]="V1",CheckpointFormatVersion[CheckpointFormatVersion.V2=2]="V2"}(CheckpointFormatVersion=SaverDef.CheckpointFormatVersion||(SaverDef.CheckpointFormatVersion={}))}(SaverDef||(SaverDef={}));var CUSTOM_OPS={};function registerOp(name,opFunc){var opMapper={tfOpName:name,category:"custom",inputs:[],attrs:[],customExecutor:opFunc};CUSTOM_OPS[name]=opMapper}function getRegisteredOp(name){return CUSTOM_OPS[name]}function deregisterOp(name){delete CUSTOM_OPS[name]}function getParamValue(paramName,node,tensorMap,context){var inputParam=node.inputParams[paramName];if(inputParam&&void 0!==inputParam.inputIndexStart){var start=inputParam.inputIndexStart,end=0===inputParam.inputIndexEnd?void 0:void 0===inputParam.inputIndexEnd?start+1:inputParam.inputIndexEnd,inputs;if("tensor"===inputParam.type)return getTensor(node.inputNames[inputParam.inputIndexStart],tensorMap,context);if("tensors"===inputParam.type)return node.inputNames.slice(start,end).map(function(name){return getTensor(name,tensorMap,context)});var data=Array.prototype.slice.call(getTensor(node.inputNames.slice(start)[0],tensorMap,context).dataSync());return"number"===inputParam.type?data[0]:data}var attrParam=node.attrParams[paramName];return attrParam&&attrParam.value}function getTensor(name,tensorsMap,context){var _a=parseNodeName(name),nodeName=_a[0],index=_a[1],contextId=context.currentContextIds.find(function(contextId){return!!tensorsMap[getNodeNameWithContextId(nodeName,contextId)]});return void 0!==contextId?tensorsMap[getNodeNameWithContextId(nodeName,contextId)][index]:void 0}function getTensorsForCurrentContenxt(name,tensorsMap,context){return tensorsMap[getNodeNameWithContextId(name,context.currentContextId)]}function getNodeNameAndIndex(inputName,context){var _a=parseNodeName(inputName),nodeName=_a[0],index=_a[1];return[getNodeNameWithContextId(nodeName,context&&context.currentContextId),index]}function getNodeNameWithContextId(name,contextId){return contextId?name+"-"+contextId:name}function parseNodeName(name){var index=name.lastIndexOf(":"),nodeName;return-1===index?[name,0]:[name.substring(0,index),Number(name.substring(index+1))]}function split(arr,size){for(var res=[],i=0;i<arr.length;i+=size)res.push(arr.slice(i,i+size));return res}var json=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],arithmetic=Object.freeze({json:json}),json$1=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],basicMath=Object.freeze({json:json$1}),json$2=[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"}]}],control=Object.freeze({json:json$2}),json$3=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]}],convolution=Object.freeze({json:json$3}),json$4=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],creation=Object.freeze({json:json$4}),json$5=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dynamic=Object.freeze({json:json$5}),json$6=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]}],evaluation=Object.freeze({json:json$6}),json$7=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],graph=Object.freeze({json:json$7}),json$8=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],image=Object.freeze({json:json$8}),json$9=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],logical=Object.freeze({json:json$9}),json$10=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],matrices=Object.freeze({json:json$10}),json$11=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],normalization=Object.freeze({json:json$11}),json$12=[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]}],reduction=Object.freeze({json:json$12}),json$13=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],sliceJoin=Object.freeze({json:json$13}),json$14=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],spectral=Object.freeze({json:json$14}),json$15=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]}],transformation=Object.freeze({json:json$15}),OperationMapper=function(){function OperationMapper(){var ops=[arithmetic,basicMath,control,convolution,creation,dynamic,evaluation,logical,image,graph,matrices,normalization,reduction,sliceJoin,spectral,transformation],mappersJson=[].concat.apply([],ops.map(function(op){return op.json}));this.opMappers=mappersJson.reduce(function(map,mapper){return map[mapper.tfOpName]=mapper,map},{})}return Object.defineProperty(OperationMapper,"Instance",{get:function(){return this._instance||(this._instance=new this)},enumerable:!0,configurable:!0}),OperationMapper.prototype.transformGraph=function(graph,signature){var _this=this;void 0===signature&&(signature={});var tfNodes,placeholders=[],weights=[],nodes=graph.node.reduce(function(map,node){return map[node.name]=_this.mapNode(node),node.op.startsWith("Placeholder")&&placeholders.push(map[node.name]),"Const"===node.op&&weights.push(map[node.name]),map},{}),inputs=[],outputs=[],inputNodeNameToKey={},outputNodeNameToKey={};null!=signature&&(inputNodeNameToKey=this.mapSignatureEntries(signature.inputs),outputNodeNameToKey=this.mapSignatureEntries(signature.outputs));var allNodes=Object.keys(nodes);return allNodes.forEach(function(key){var node=nodes[key];node.inputNames.forEach(function(name){var nodeName=getNodeNameAndIndex(name)[0];node.inputs.push(nodes[nodeName]),nodes[nodeName].children.push(node)})}),0===Object.keys(outputNodeNameToKey).length?allNodes.forEach(function(key){var node=nodes[key];0===node.children.length&&outputs.push(node)}):Object.keys(outputNodeNameToKey).forEach(function(name){var nodeName=getNodeNameAndIndex(name)[0],node=nodes[nodeName];null!=node&&(node.signatureKey=outputNodeNameToKey[name],outputs.push(node))}),Object.keys(inputNodeNameToKey).length>0?Object.keys(inputNodeNameToKey).forEach(function(name){var nodeName=getNodeNameAndIndex(name)[0],node=nodes[nodeName];node&&(node.signatureKey=inputNodeNameToKey[name],inputs.push(node))}):inputs=placeholders,{nodes:nodes,inputs:inputs,outputs:outputs,weights:weights,placeholders:placeholders,signature:signature}},OperationMapper.prototype.mapSignatureEntries=function(entries){return Object.keys(entries||{}).reduce(function(prev,curr){return prev[entries[curr].name]=curr,prev},{})},OperationMapper.prototype.mapNode=function(node){var mapper=getRegisteredOp(node.op)||this.opMappers[node.op]||{};null==node.attr&&(node.attr={});var newNode={name:node.name,op:node.op,category:mapper.category,inputNames:(node.input||[]).map(function(input){return input.startsWith("^")?input.substr(1):input}),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:node.attr};return null!=mapper.inputs&&(newNode.inputParams=mapper.inputs.reduce(function(map,param){return map[param.name]={type:param.type,inputIndexStart:param.start,inputIndexEnd:param.end},map},{})),null!=mapper.attrs&&(newNode.attrParams=mapper.attrs.reduce(function(map,param){var type=param.type,value=void 0;switch(param.type){case"string":void 0===(value=getStringParam(node.attr,param.tfName,param.defaultValue))&&param.tfDeprecatedName&&(value=getStringParam(node.attr,param.tfDeprecatedName,param.defaultValue));break;case"string[]":void 0===(value=getStringArrayParam(node.attr,param.tfName,param.defaultValue))&&param.tfDeprecatedName&&(value=getStringArrayParam(node.attr,param.tfDeprecatedName,param.defaultValue));break;case"number":void 0===(value=getNumberParam(node.attr,param.tfName,param.defaultValue||0))&&param.tfDeprecatedName&&(value=getNumberParam(node.attr,param.tfDeprecatedName,param.defaultValue));break;case"number[]":void 0===(value=getNumericArrayParam(node.attr,param.tfName,param.defaultValue))&&param.tfDeprecatedName&&(value=getNumericArrayParam(node.attr,param.tfDeprecatedName,param.defaultValue));break;case"bool":void 0===(value=getBoolParam(node.attr,param.tfName,param.defaultValue))&&param.tfDeprecatedName&&(value=getBoolParam(node.attr,param.tfDeprecatedName,param.defaultValue));break;case"bool[]":void 0===(value=getBoolArrayParam(node.attr,param.tfName,param.defaultValue))&&param.tfDeprecatedName&&(value=getBoolArrayParam(node.attr,param.tfDeprecatedName,param.defaultValue));break;case"shape":void 0===(value=getTensorShapeParam(node.attr,param.tfName,param.defaultValue))&&param.tfDeprecatedName&&(value=getTensorShapeParam(node.attr,param.tfDeprecatedName,param.defaultValue));break;case"shape[]":void 0===(value=getTensorShapeArrayParam(node.attr,param.tfName,param.defaultValue))&&param.tfDeprecatedName&&(value=getTensorShapeArrayParam(node.attr,param.tfDeprecatedName,param.defaultValue));break;case"dtype":void 0===(value=getDtypeParam(node.attr,param.tfName,param.defaultValue))&&param.tfDeprecatedName&&(value=getDtypeParam(node.attr,param.tfDeprecatedName,param.defaultValue));break;case"dtype[]":void 0===(value=getDtypeArrayParam(node.attr,param.tfName,param.defaultValue))&&param.tfDeprecatedName&&(value=getDtypeArrayParam(node.attr,param.tfDeprecatedName,param.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+param.type+" for op: "+node.op)}return map[param.name]={value:value,type:type},map},{})),newNode},OperationMapper}();function decodeBase64(text){var global=tfc.env().global;if(void 0!==global.atob)return global.atob(text);if("undefined"!=typeof Buffer)return new Buffer(text,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function parseStringParam(s,keepCase){var value=Array.isArray(s)?String.fromCharCode.apply(null,s):decodeBase64(s);return keepCase?value:value.toLowerCase()}function getStringParam(attrs,name,def,keepCase){void 0===keepCase&&(keepCase=!1);var param=attrs[name];return null!=param?parseStringParam(param.s,keepCase):def}function getBoolParam(attrs,name,def){var param=attrs[name];return param?param.b:def}function getNumberParam(attrs,name,def){var param=attrs[name]||{},value=null!=param.i?param.i:null!=param.f?param.f:def;return"number"==typeof value?value:parseInt(value,10)}function parseDtypeParam(value){switch("string"==typeof value&&(value=DataType[value]),value){case DataType.DT_FLOAT:return"float32";case DataType.DT_INT32:case DataType.DT_INT64:case DataType.DT_INT8:case DataType.DT_UINT8:return"int32";case DataType.DT_BOOL:return"bool";case DataType.DT_DOUBLE:return"float32";case DataType.DT_STRING:return"string";default:return null}}function getDtypeParam(attrs,name,def){var param=attrs[name];return param&&param.type?parseDtypeParam(param.type):def}function getDtypeArrayParam(attrs,name,def){var param=attrs[name];return param&&param.list&&param.list.type?param.list.type.map(function(v){return parseDtypeParam(v)}):def}function parseTensorShapeParam(shape){if(!shape.unknownRank)return null!=shape.dim?shape.dim.map(function(dim){return"number"==typeof dim.size?dim.size:parseInt(dim.size,10)}):[]}function getTensorShapeParam(attrs,name,def){var param=attrs[name];return param&&param.shape?parseTensorShapeParam(param.shape):def}function getNumericArrayParam(attrs,name,def){var param=attrs[name];return param?((param.list.f&&param.list.f.length?param.list.f:param.list.i)||[]).map(function(v){return"number"==typeof v?v:parseInt(v,10)}):def}function getStringArrayParam(attrs,name,def,keepCase){void 0===keepCase&&(keepCase=!1);var param=attrs[name];return param&&param.list&&param.list.s?param.list.s.map(function(v){return parseStringParam(v,keepCase)}):def}function getTensorShapeArrayParam(attrs,name,def){var param=attrs[name];return param&&param.list&&param.list.shape?param.list.shape.map(function(v){return parseTensorShapeParam(v)}):def}function getBoolArrayParam(attrs,name,def){var param=attrs[name];return param&&param.list&&param.list.b?param.list.b:def}var NodeValueImpl=function(){function NodeValueImpl(node,tensorMap,context){var _this=this;this.node=node,this.tensorMap=tensorMap,this.context=context,this.inputs=[],this.attrs={},this.inputs=node.inputNames.map(function(name){return _this.getInput(name)}),null!=node.rawAttrs&&(this.attrs=Object.keys(node.rawAttrs).reduce(function(attrs,key){return attrs[key]=_this.getAttr(key),attrs},{}))}return NodeValueImpl.prototype.getInput=function(name){return getTensor(name,this.tensorMap,this.context)},NodeValueImpl.prototype.getAttr=function(name,defaultValue){var value=this.node.rawAttrs[name];if(null!=value.tensor)return getTensor(name,this.tensorMap,this.context);if(null!=value.i||null!=value.f)return getNumberParam(this.node.rawAttrs,name,defaultValue);if(null!=value.s)return getStringParam(this.node.rawAttrs,name,defaultValue);if(null!=value.b)return getBoolParam(this.node.rawAttrs,name,defaultValue);if(null!=value.shape)return getTensorShapeParam(this.node.rawAttrs,name,defaultValue);if(null!=value.type)return getDtypeParam(this.node.rawAttrs,name,defaultValue);if(null!=value.list){if(null!=value.list.i||null!=value.list.f)return getNumericArrayParam(this.node.rawAttrs,name,defaultValue);if(null!=value.list.s)return getStringArrayParam(this.node.rawAttrs,name,defaultValue);if(null!=value.list.shape)return getTensorShapeArrayParam(this.node.rawAttrs,name,defaultValue);if(null!=value.list.b)return getBoolArrayParam(this.node.rawAttrs,name,defaultValue);if(null!=value.list.type)return getDtypeArrayParam(this.node.rawAttrs,name,defaultValue)}return defaultValue},NodeValueImpl}(),executeOp=function(node,tensorMap,context){switch(node.op){case"BiasAdd":case"AddV2":case"Add":return[tfc.add(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"AddN":return[tfc.addN(getParamValue("tensors",node,tensorMap,context))];case"FloorMod":case"Mod":return[tfc.mod(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"Mul":return[tfc.mul(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"RealDiv":case"Div":return[tfc.div(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"DivNoNan":return[tfc.divNoNan(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"FloorDiv":return[tfc.floorDiv(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"Sub":return[tfc.sub(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"Minimum":return[tfc.minimum(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"Maximum":return[tfc.maximum(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"Pow":return[tfc.pow(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"SquaredDifference":return[tfc.squaredDifference(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];default:throw TypeError("Node type "+node.op+" is not implemented")}},executeOp$1=function(node,tensorMap,context){switch(node.op){case"Abs":case"ComplexAbs":return[tfc.abs(getParamValue("x",node,tensorMap,context))];case"Acos":return[tfc.acos(getParamValue("x",node,tensorMap,context))];case"Acosh":return[tfc.acosh(getParamValue("x",node,tensorMap,context))];case"Asin":return[tfc.asin(getParamValue("x",node,tensorMap,context))];case"Asinh":return[tfc.asinh(getParamValue("x",node,tensorMap,context))];case"Atan":return[tfc.atan(getParamValue("x",node,tensorMap,context))];case"Atan2":return[tfc.atan2(getParamValue("x",node,tensorMap,context),getParamValue("y",node,tensorMap,context))];case"Atanh":return[tfc.atanh(getParamValue("x",node,tensorMap,context))];case"Ceil":return[tfc.ceil(getParamValue("x",node,tensorMap,context))];case"Complex":return[tfc.complex(getParamValue("real",node,tensorMap,context),getParamValue("imag",node,tensorMap,context))];case"Cos":return[tfc.cos(getParamValue("x",node,tensorMap,context))];case"Cosh":return[tfc.cosh(getParamValue("x",node,tensorMap,context))];case"Elu":return[tfc.elu(getParamValue("x",node,tensorMap,context))];case"Erf":return[tfc.erf(getParamValue("x",node,tensorMap,context))];case"Exp":return[tfc.exp(getParamValue("x",node,tensorMap,context))];case"Expm1":return[tfc.expm1(getParamValue("x",node,tensorMap,context))];case"Floor":return[tfc.floor(getParamValue("x",node,tensorMap,context))];case"Log":return[tfc.log(getParamValue("x",node,tensorMap,context))];case"Log1p":return[tfc.log1p(getParamValue("x",node,tensorMap,context))];case"Imag":return[tfc.imag(getParamValue("x",node,tensorMap,context))];case"Neg":return[tfc.neg(getParamValue("x",node,tensorMap,context))];case"Reciprocal":return[tfc.reciprocal(getParamValue("x",node,tensorMap,context))];case"Real":return[tfc.real(getParamValue("x",node,tensorMap,context))];case"Relu":return[tfc.relu(getParamValue("x",node,tensorMap,context))];case"Round":return[tfc.round(getParamValue("x",node,tensorMap,context))];case"Selu":return[tfc.selu(getParamValue("x",node,tensorMap,context))];case"Sigmoid":return[tfc.sigmoid(getParamValue("x",node,tensorMap,context))];case"Sin":return[tfc.sin(getParamValue("x",node,tensorMap,context))];case"Sign":return[tfc.sign(getParamValue("x",node,tensorMap,context))];case"Sinh":return[tfc.sinh(getParamValue("x",node,tensorMap,context))];case"Softplus":return[tfc.softplus(getParamValue("x",node,tensorMap,context))];case"Sqrt":return[tfc.sqrt(getParamValue("x",node,tensorMap,context))];case"Square":return[tfc.square(getParamValue("x",node,tensorMap,context))];case"Tanh":return[tfc.tanh(getParamValue("x",node,tensorMap,context))];case"Tan":return[tfc.tan(getParamValue("x",node,tensorMap,context))];case"Relu6":case"ClipByValue":return[tfc.clipByValue(getParamValue("x",node,tensorMap,context),getParamValue("clipValueMin",node,tensorMap,context),getParamValue("clipValueMax",node,tensorMap,context))];case"Rsqrt":return[tfc.rsqrt(getTensor(node.inputNames[0],tensorMap,context))];case"Prod":return[tfc.prod(getParamValue("x",node,tensorMap,context),getParamValue("axes",node,tensorMap,context))];case"LeakyRelu":return[tfc.leakyRelu(getParamValue("x",node,tensorMap,context),getParamValue("alpha",node,tensorMap,context))];case"Prelu":return[tfc.prelu(getParamValue("x",node,tensorMap,context),getParamValue("alpha",node,tensorMap,context))];default:throw TypeError("Node type "+node.op+" is not implemented")}},TensorArray=function(){function TensorArray(name,dtype,maxSize,elementShape,identicalElementShapes,dynamicSize,clearAfterRead){this.name=name,this.dtype=dtype,this.maxSize=maxSize,this.elementShape=elementShape,this.identicalElementShapes=identicalElementShapes,this.dynamicSize=dynamicSize,this.clearAfterRead=clearAfterRead,this.tensors=[],this.closed_=!1,this.id=TensorArray.nextId++}return Object.defineProperty(TensorArray.prototype,"closed",{get:function(){return this.closed_},enumerable:!0,configurable:!0}),TensorArray.prototype.clearAndClose=function(){this.tensors.forEach(function(tensor){return tensor.tensor.dispose()}),this.tensors=[],this.closed_=!0},TensorArray.prototype.size=function(){return this.tensors.length},TensorArray.prototype.read=function(index){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(index<0||index>=this.tensors.length)throw new Error("Tried to read from index "+index+", but array size is: "+this.tensors.length);var tensorWithState=this.tensors[index];if(tensorWithState.cleared)throw new Error("TensorArray "+this.name+": Could not read index "+index+" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(tensorWithState.cleared=!0),tensorWithState.read=!0,tensorWithState.tensor},TensorArray.prototype.readMany=function(indices){var _this=this;return indices.map(function(index){return _this.read(index)})},TensorArray.prototype.write=function(index,tensor){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(index<0||!this.dynamicSize&&index>=this.maxSize)throw new Error("Tried to write to index "+index+", but array is not resizeable and size is: "+this.maxSize);var t=this.tensors[index]||{};if(tensor.dtype!==this.dtype)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+index+",\n          because the value dtype is "+tensor.dtype+", but TensorArray dtype is "+this.dtype+".");if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=tensor.shape),this.assertShapesMatchAllowUndefinedSize(this.elementShape,tensor.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+index+"."),t&&t.read)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+index+", because it has already been read.");if(t&&t.written)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+index+", because it has already been written.");t.tensor=tensor,t.written=!0,this.tensors[index]=t},TensorArray.prototype.writeMany=function(indices,tensors){var _this=this;if(indices.length!==tensors.length)throw new Error("TensorArray "+this.name+": could not write multiple tensors,because the index size: "+indices.length+" is not the same as tensors size: "+tensors.length+".");indices.forEach(function(i,index){return _this.write(i,tensors[index])})},TensorArray.prototype.gather=function(indices,dtype){if(dtype&&dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+dtype);if(!indices){indices=[];for(var i=0;i<this.size();i++)indices.push(i)}if(0===indices.length)return tfc.tensor([],[0].concat(this.elementShape));var tensors=this.readMany(indices);return this.assertShapesMatchAllowUndefinedSize(this.elementShape,tensors[0].shape,"TensorArray shape mismatch: "),tfc.stack(tensors,0)},TensorArray.prototype.concat=function(dtype){if(dtype&&dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+dtype);if(0===this.size())return tfc.tensor([],[0].concat(this.elementShape));for(var indices=[],i=0;i<this.size();i++)indices.push(i);var tensors=this.readMany(indices);return this.assertShapesMatchAllowUndefinedSize(this.elementShape,tensors[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+tensors[0].shape+")"),tfc.concat(tensors,0)},TensorArray.prototype.scatter=function(indices,tensor){if(tensor.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+tensor.dtype);if(indices.length!==tensor.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+indices.length+" vs. "+tensor.shape[0]);var maxIndex=Math.max.apply(Math,indices);if(!this.dynamicSize&&maxIndex>=this.maxSize)throw new Error("Max index must be < array size ("+maxIndex+"  vs. "+this.maxSize+")");this.writeMany(indices,tfc.unstack(tensor,0))},TensorArray.prototype.split=function(length,tensor){var _this=this;if(tensor.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+tensor.dtype);var totalLength=0,cumulativeLengths=length.map(function(len){return totalLength+=len});if(totalLength!==tensor.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        "+totalLength+", and tensor's shape is: "+tensor.shape);if(!this.dynamicSize&&length.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+length.length+"), and the TensorArray is not marked as dynamically resizeable");var elementPerRow=0===totalLength?0:tensor.size/totalLength,tensors=[];tfc.tidy(function(){tensor=tensor.reshape([1,totalLength,elementPerRow]);for(var i=0;i<length.length;++i){var previousLength,indices_1=[0,0===i?0:cumulativeLengths[i-1],0],sizes=[1,length[i],elementPerRow];tensors[i]=tfc.slice(tensor,indices_1,sizes).reshape(_this.elementShape)}return tensors});for(var indices=[],i=0;i<length.length;i++)indices[i]=i;this.writeMany(indices,tensors)},TensorArray.prototype.assertShapesMatchAllowUndefinedSize=function(shapeA,shapeB,errorMessagePrefix){void 0===errorMessagePrefix&&(errorMessagePrefix=""),tfc.util.assert(this.shapesEqualAllowUndefinedSize(shapeA,shapeB),function(){return errorMessagePrefix+" Shapes "+shapeA+" and "+shapeB+" must match"})},TensorArray.prototype.shapesEqualAllowUndefinedSize=function(n1,n2){if(n1.length!==n2.length)return!1;for(var i=0;i<n1.length;i++)if(-1!==n1[i]&&-1!==n2[i]&&n1[i]!==n2[i])return!1;return!0},TensorArray.nextId=0,TensorArray}(),_this=void 0,executeOp$2=function(node,tensorMap,context){return __awaiter(_this,void 0,void 0,function(){var _a,pred,data_1,inputName,frameId,data,tensor,input,size,dtype,elementShape,dynamicSize,clearAfterRead,identicalElementShapes,name_1,tensorArray,id,index,writeTensor,writeTensorArray,readId,readIndex,readTensorArray,gatherId,gatherIndices,gatherDtype,gatherTensorArray,scatterId,scatterIndices,scatterTensor,scatterTensorArray,concatId,concatTensorArray,concatDtype,splitId,splitTensor,lengths,splitTensorArray,sizeId,sizeTensorArray,closeId,closeTensorArray;return __generator(this,function(_b){switch(_b.label){case 0:switch(_a=node.op){case"LoopCond":return[3,1];case"Switch":return[3,2];case"Merge":return[3,4];case"Enter":return[3,5];case"Exit":return[3,6];case"NextIteration":return[3,7];case"TensorArrayV3":return[3,8];case"TensorArrayWriteV3":return[3,9];case"TensorArrayReadV3":return[3,10];case"TensorArrayGatherV3":return[3,11];case"TensorArrayScatterV3":return[3,12];case"TensorArrayConcatV3":return[3,13];case"TensorArraySplitV3":return[3,14];case"TensorArraySizeV3":return[3,15];case"TensorArrayCloseV3":return[3,16]}return[3,17];case 1:return[2,[getParamValue("pred",node,tensorMap,context).clone()]];case 2:return pred=getParamValue("pred",node,tensorMap,context),data_1=getParamValue("data",node,tensorMap,context),[4,pred.data()];case 3:return[2,_b.sent()[0]?[void 0,data_1.clone()]:[data_1.clone(),void 0]];case 4:return[2,(inputName=node.inputNames.find(function(name){return void 0!==getTensor(name,tensorMap,context)}))?[getTensor(inputName,tensorMap,context).clone()]:void 0];case 5:return frameId=getParamValue("frameName",node,tensorMap,context),data=getParamValue("tensor",node,tensorMap,context),context.enterFrame(frameId),[2,[data.clone()]];case 6:return tensor=getParamValue("tensor",node,tensorMap,context),context.exitFrame(),[2,[tensor.clone()]];case 7:return input=getParamValue("tensor",node,tensorMap,context),context.nextIteration(),[2,[input.clone()]];case 8:return size=getParamValue("size",node,tensorMap,context),dtype=getParamValue("dtype",node,tensorMap,context),elementShape=getParamValue("elementShape",node,tensorMap,context),dynamicSize=getParamValue("dynamicSize",node,tensorMap,context),clearAfterRead=getParamValue("clearAfterRead",node,tensorMap,context),identicalElementShapes=getParamValue("identicalElementShapes",node,tensorMap,context),name_1=getParamValue("name",node,tensorMap,context),tensorArray=new TensorArray(name_1,dtype,size,elementShape,identicalElementShapes,dynamicSize,clearAfterRead),context.addTensorArray(tensorArray),[2,[tfc.scalar(tensorArray.id),tfc.scalar(1)]];case 9:return id=getParamValue("tensorArrayId",node,tensorMap,context),index=getParamValue("index",node,tensorMap,context),writeTensor=getParamValue("tensor",node,tensorMap,context),(writeTensorArray=context.getTensorArray(id)).write(index,writeTensor),[2,[tfc.scalar(1)]];case 10:return readId=getParamValue("tensorArrayId",node,tensorMap,context),readIndex=getParamValue("index",node,tensorMap,context),[2,[(readTensorArray=context.getTensorArray(readId)).read(readIndex)]];case 11:return gatherId=getParamValue("tensorArrayId",node,tensorMap,context),gatherIndices=getParamValue("indices",node,tensorMap,context),gatherDtype=getParamValue("dtype",node,tensorMap,context),[2,[(gatherTensorArray=context.getTensorArray(gatherId)).gather(gatherIndices,gatherDtype)]];case 12:return scatterId=getParamValue("tensorArrayId",node,tensorMap,context),scatterIndices=getParamValue("indices",node,tensorMap,context),scatterTensor=getParamValue("tensor",node,tensorMap,context),(scatterTensorArray=context.getTensorArray(scatterId)).scatter(scatterIndices,scatterTensor),[2,[tfc.scalar(1)]];case 13:return concatId=getParamValue("tensorArrayId",node,tensorMap,context),concatTensorArray=context.getTensorArray(concatId),concatDtype=getParamValue("dtype",node,tensorMap,context),[2,[concatTensorArray.concat(concatDtype)]];case 14:return splitId=getParamValue("tensorArrayId",node,tensorMap,context),splitTensor=getParamValue("tensor",node,tensorMap,context),lengths=getParamValue("lengths",node,tensorMap,context),(splitTensorArray=context.getTensorArray(splitId)).split(lengths,splitTensor),[2,[tfc.scalar(1)]];case 15:return sizeId=getParamValue("tensorArrayId",node,tensorMap,context),sizeTensorArray=context.getTensorArray(sizeId),[2,[tfc.scalar(sizeTensorArray.size(),"int32")]];case 16:return closeId=getParamValue("tensorArrayId",node,tensorMap,context),(closeTensorArray=context.getTensorArray(closeId)).clearAndClose(),[2,[tfc.scalar(0)]];case 17:throw TypeError("Node type "+node.op+" is not implemented")}})})},executeOp$3=function(node,tensorMap,context){switch(node.op){case"Conv1D":var stride=getParamValue("stride",node,tensorMap,context),pad=getParamValue("pad",node,tensorMap,context),dataFormat=getParamValue("dataFormat",node,tensorMap,context).toUpperCase(),dilation=getParamValue("dilation",node,tensorMap,context);return[tfc.conv1d(getParamValue("x",node,tensorMap,context),getParamValue("filter",node,tensorMap,context),stride,pad,dataFormat,dilation)];case"Conv2D":var stride=getParamValue("strides",node,tensorMap,context),pad=getParamValue("pad",node,tensorMap,context),dataFormat=getParamValue("dataFormat",node,tensorMap,context).toUpperCase(),dilations=getParamValue("dilations",node,tensorMap,context);return[tfc.conv2d(getParamValue("x",node,tensorMap,context),getParamValue("filter",node,tensorMap,context),[stride[1],stride[2]],pad,dataFormat,[dilations[1],dilations[2]])];case"_FusedConv2D":case"FusedDepthwiseConv2dNative":var _a=getParamValue("fusedOps",node,tensorMap,context),extraOp=_a[0],activationFunc=_a[1],isBiasAdd="biasadd"===extraOp,isPrelu="prelu"===activationFunc,isBatchNorm="fusedbatchnorm"===extraOp,numArgs=getParamValue("numArgs",node,tensorMap,context);if(isBiasAdd){if(isPrelu&&2!==numArgs)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!isPrelu&&1!==numArgs)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(isBatchNorm)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");var stride=getParamValue("strides",node,tensorMap,context),pad=getParamValue("pad",node,tensorMap,context),dataFormat=getParamValue("dataFormat",node,tensorMap,context).toUpperCase(),dilations=getParamValue("dilations",node,tensorMap,context),_b=getParamValue("args",node,tensorMap,context),biasArg=_b[0],preluArg=_b[1],kernelMethod;return[("_FusedConv2D"===node.op?tfc.fused.conv2d:tfc.fused.depthwiseConv2d)({x:getParamValue("x",node,tensorMap,context),filter:getParamValue("filter",node,tensorMap,context),strides:[stride[1],stride[2]],pad:pad,dataFormat:dataFormat,dilations:[dilations[1],dilations[2]],bias:biasArg,activation:activationFunc,preluActivationWeights:preluArg})];case"Conv2DBackpropInput":case"Conv2dTranspose":var shape=getParamValue("outputShape",node,tensorMap,context),stride=getParamValue("strides",node,tensorMap,context),pad=getParamValue("pad",node,tensorMap,context);return[tfc.conv2dTranspose(getParamValue("x",node,tensorMap,context),getParamValue("filter",node,tensorMap,context),shape,[stride[1],stride[2]],pad)];case"DepthwiseConv2dNative":case"DepthwiseConv2d":var stride=getParamValue("strides",node,tensorMap,context),pad=getParamValue("pad",node,tensorMap,context),dilations=getParamValue("dilations",node,tensorMap,context),dataFormat=getParamValue("dataFormat",node,tensorMap,context).toUpperCase();return[tfc.depthwiseConv2d(getParamValue("input",node,tensorMap,context),getParamValue("filter",node,tensorMap,context),[stride[1],stride[2]],pad,dataFormat,[dilations[1],dilations[2]])];case"Conv3D":var stride=getParamValue("strides",node,tensorMap,context),pad=getParamValue("pad",node,tensorMap,context),dataFormat=getParamValue("dataFormat",node,tensorMap,context).toUpperCase(),dilations=getParamValue("dilations",node,tensorMap,context);return[tfc.conv3d(getParamValue("x",node,tensorMap,context),getParamValue("filter",node,tensorMap,context),[stride[1],stride[2],stride[3]],pad,dataFormat,[dilations[1],dilations[2],dilations[3]])];case"AvgPool":var stride=getParamValue("strides",node,tensorMap,context),pad=getParamValue("pad",node,tensorMap,context),kernelSize=getParamValue("kernelSize",node,tensorMap,context);return[tfc.avgPool(getParamValue("x",node,tensorMap,context),[kernelSize[1],kernelSize[2]],[stride[1],stride[2]],pad)];case"MaxPool":var stride=getParamValue("strides",node,tensorMap,context),pad=getParamValue("pad",node,tensorMap,context),kernelSize=getParamValue("kernelSize",node,tensorMap,context);return[tfc.maxPool(getParamValue("x",node,tensorMap,context),[kernelSize[1],kernelSize[2]],[stride[1],stride[2]],pad)];case"MaxPoolWithArgmax":var stride=getParamValue("strides",node,tensorMap,context),pad=getParamValue("pad",node,tensorMap,context),kernelSize=getParamValue("kernelSize",node,tensorMap,context),includeBatchInIndex=getParamValue("includeBatchInIndex",node,tensorMap,context),_c=tfc.maxPoolWithArgmax(getParamValue("x",node,tensorMap,context),[kernelSize[1],kernelSize[2]],[stride[1],stride[2]],pad,includeBatchInIndex),result,indexes;return[_c.result,_c.indexes];case"AvgPool3D":var stride=getParamValue("strides",node,tensorMap,context),pad=getParamValue("pad",node,tensorMap,context),kernelSize=getParamValue("kernelSize",node,tensorMap,context);return[tfc.avgPool3d(getParamValue("x",node,tensorMap,context),[kernelSize[1],kernelSize[2],kernelSize[3]],[stride[1],stride[2],stride[3]],pad)];case"MaxPool3D":var stride=getParamValue("strides",node,tensorMap,context),pad=getParamValue("pad",node,tensorMap,context),kernelSize=getParamValue("kernelSize",node,tensorMap,context);return[tfc.maxPool3d(getParamValue("x",node,tensorMap,context),[kernelSize[1],kernelSize[2],kernelSize[3]],[stride[1],stride[2],stride[3]],pad)];default:throw TypeError("Node type "+node.op+" is not implemented")}},executeOp$4=function(node,tensorMap,context){switch(node.op){case"Fill":var shape=getParamValue("shape",node,tensorMap,context),dtype=getParamValue("dtype",node,tensorMap,context),value=getParamValue("value",node,tensorMap,context);return[tfc.fill(shape,value,dtype)];case"LinSpace":var start=getParamValue("start",node,tensorMap,context),stop_1=getParamValue("stop",node,tensorMap,context),num=getParamValue("num",node,tensorMap,context);return[tfc.linspace(start,stop_1,num)];case"Multinomial":var logits=getParamValue("logits",node,tensorMap,context),numSamples=getParamValue("numSamples",node,tensorMap,context),seed=getParamValue("seed",node,tensorMap,context);return[tfc.multinomial(logits,numSamples,seed)];case"OneHot":var indices=getParamValue("indices",node,tensorMap,context),depth=getParamValue("depth",node,tensorMap,context),onValue=getParamValue("onValue",node,tensorMap,context),offValue=getParamValue("offValue",node,tensorMap,context);return[tfc.oneHot(indices,depth,onValue,offValue)];case"Ones":return[tfc.ones(getParamValue("shape",node,tensorMap,context),getParamValue("dtype",node,tensorMap,context))];case"OnesLike":return[tfc.onesLike(getParamValue("x",node,tensorMap,context))];case"RandomUniform":return[tfc.randomUniform(getParamValue("shape",node,tensorMap,context),getParamValue("minval",node,tensorMap,context),getParamValue("maxval",node,tensorMap,context),getParamValue("dtype",node,tensorMap,context))];case"Range":var start=getParamValue("start",node,tensorMap,context),stop_2=getParamValue("stop",node,tensorMap,context),step=getParamValue("step",node,tensorMap,context);return[tfc.range(start,stop_2,step,getParamValue("dtype",node,tensorMap,context))];case"TruncatedNormal":var shape=getParamValue("shape",node,tensorMap,context),mean=getParamValue("mean",node,tensorMap,context),stdDev=getParamValue("stdDev",node,tensorMap,context),seed=getParamValue("seed",node,tensorMap,context);return[tfc.truncatedNormal(shape,mean,stdDev,getParamValue("dtype",node,tensorMap,context),seed)];case"Zeros":return[tfc.zeros(getParamValue("shape",node,tensorMap,context),getParamValue("dtype",node,tensorMap,context))];case"ZerosLike":return[tfc.zerosLike(getParamValue("x",node,tensorMap,context))];default:throw TypeError("Node type "+node.op+" is not implemented")}},_this$1=void 0,executeOp$5=function(node,tensorMap,context){return __awaiter(void 0,void 0,void 0,function(){var _a,boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma,result,condition,result;return __generator(this,function(_b){switch(_b.label){case 0:switch(_a=node.op){case"NonMaxSuppressionV5":case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":return[3,1];case"Where":return[3,5];case"ListDiff":return[3,7]}return[3,8];case 1:return boxes=getParamValue("boxes",node,tensorMap,context),scores=getParamValue("scores",node,tensorMap,context),maxOutputSize=getParamValue("maxOutputSize",node,tensorMap,context),iouThreshold=getParamValue("iouThreshold",node,tensorMap,context),scoreThreshold=getParamValue("scoreThreshold",node,tensorMap,context),"NonMaxSuppressionV5"!==node.op?[3,3]:(softNmsSigma=getParamValue("softNmsSigma",node,tensorMap,context),[4,tfc.image.nonMaxSuppressionWithScoreAsync(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma)]);case 2:return[2,[(result=_b.sent()).selectedIndices,result.selectedScores]];case 3:return[4,tfc.image.nonMaxSuppressionAsync(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold)];case 4:return[2,[_b.sent()]];case 5:return condition=getParamValue("condition",node,tensorMap,context).asType("bool"),[4,tfc.whereAsync(condition)];case 6:return result=[_b.sent()],condition.dispose(),[2,result];case 7:return[2,tfc.setdiff1dAsync(getParamValue("x",node,tensorMap,context),getParamValue("y",node,tensorMap,context))];case 8:throw TypeError("Node type "+node.op+" is not implemented")}})})},executeOp$6=function(node,tensorMap,context){switch(node.op){case"TopKV2":var x=getParamValue("x",node,tensorMap,context),k=getParamValue("k",node,tensorMap,context),sorted=getParamValue("sorted",node,tensorMap,context),result=tfc.topk(x,k,sorted);return[result.values,result.indices];default:throw TypeError("Node type "+node.op+" is not implemented")}},executeOp$7=function(node,tensorMap,context){switch(node.op){case"Const":return tensorMap[node.name];case"PlaceholderWithDefault":var def=getParamValue("default",node,tensorMap,context);return[getTensor(node.name,tensorMap,context)||def];case"Placeholder":return[getTensor(node.name,tensorMap,context)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[getParamValue("x",node,tensorMap,context).clone()];case"IdentityN":return getParamValue("x",node,tensorMap,context).map(function(t){return t.clone()});case"Snapshot":var snapshot;return[getParamValue("x",node,tensorMap,context).clone()];case"Shape":return[tfc.tensor1d(getParamValue("x",node,tensorMap,context).shape,"int32")];case"ShapeN":return getParamValue("x",node,tensorMap,context).map(function(t){return tfc.tensor1d(t.shape)});case"Size":return[tfc.scalar(getParamValue("x",node,tensorMap,context).size,"int32")];case"Rank":return[tfc.scalar(getParamValue("x",node,tensorMap,context).rank,"int32")];case"NoOp":return[tfc.scalar(1)];case"Print":var input=getParamValue("x",node,tensorMap,context),data=getParamValue("data",node,tensorMap,context),message=getParamValue("message",node,tensorMap,context),summarize=getParamValue("summarize",node,tensorMap,context);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(message);for(var i=0;i<data.length;i++)console.log(Array.prototype.slice.call(data[i].dataSync()).slice(0,summarize));return[input];default:throw TypeError("Node type "+node.op+" is not implemented")}},executeOp$8=function(node,tensorMap,context){switch(node.op){case"ResizeBilinear":var images=getParamValue("images",node,tensorMap,context),size=getParamValue("size",node,tensorMap,context),alignCorners=getParamValue("alignCorners",node,tensorMap,context);return[tfc.image.resizeBilinear(images,[size[0],size[1]],alignCorners)];case"ResizeNearestNeighbor":var images=getParamValue("images",node,tensorMap,context),size=getParamValue("size",node,tensorMap,context),alignCorners=getParamValue("alignCorners",node,tensorMap,context);return[tfc.image.resizeNearestNeighbor(images,[size[0],size[1]],alignCorners)];case"CropAndResize":var image=getParamValue("image",node,tensorMap,context),boxes=getParamValue("boxes",node,tensorMap,context),boxInd=getParamValue("boxInd",node,tensorMap,context),cropSize=getParamValue("cropSize",node,tensorMap,context),method=getParamValue("method",node,tensorMap,context),extrapolationValue=getParamValue("extrapolationValue",node,tensorMap,context);return[tfc.image.cropAndResize(image,boxes,boxInd,cropSize,method,extrapolationValue)];default:throw TypeError("Node type "+node.op+" is not implemented")}},executeOp$9=function(node,tensorMap,context){switch(node.op){case"Equal":return[tfc.equal(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"NotEqual":return[tfc.notEqual(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"Greater":return[tfc.greater(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"GreaterEqual":return[tfc.greaterEqual(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"Less":return[tfc.less(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"LessEqual":return[tfc.lessEqual(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"LogicalAnd":return[tfc.logicalAnd(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"LogicalNot":return[tfc.logicalNot(getParamValue("a",node,tensorMap,context))];case"LogicalOr":return[tfc.logicalOr(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];case"Select":case"SelectV2":return[tfc.where(getParamValue("condition",node,tensorMap,context),getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context))];default:throw TypeError("Node type "+node.op+" is not implemented")}},executeOp$10=function(node,tensorMap,context){switch(node.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[tfc.matMul(getParamValue("a",node,tensorMap,context),getParamValue("b",node,tensorMap,context),getParamValue("transposeA",node,tensorMap,context),getParamValue("transposeB",node,tensorMap,context))];case"Transpose":return[tfc.transpose(getParamValue("x",node,tensorMap,context),getParamValue("perm",node,tensorMap,context))];case"_FusedMatMul":var _a=getParamValue("fusedOps",node,tensorMap,context),extraOp=_a[0],activationFunc=_a[1],isBiasAdd="biasadd"===extraOp,isPrelu="prelu"===activationFunc,numArgs=getParamValue("numArgs",node,tensorMap,context);if(isBiasAdd){if(isPrelu&&2!==numArgs)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!isPrelu&&1!==numArgs)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}var _b=getParamValue("args",node,tensorMap,context),biasArg=_b[0],preluArg=_b[1];return[tfc.fused.matMul({a:getParamValue("a",node,tensorMap,context),b:getParamValue("b",node,tensorMap,context),transposeA:getParamValue("transposeA",node,tensorMap,context),transposeB:getParamValue("transposeB",node,tensorMap,context),bias:biasArg,activation:activationFunc,preluActivationWeights:preluArg})];default:throw TypeError("Node type "+node.op+" is not implemented")}},executeOp$11=function(node,tensorMap,context){switch(node.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[tfc.batchNorm(getParamValue("x",node,tensorMap,context),getParamValue("mean",node,tensorMap,context),getParamValue("variance",node,tensorMap,context),getParamValue("offset",node,tensorMap,context),getParamValue("scale",node,tensorMap,context),getParamValue("epsilon",node,tensorMap,context))];case"LRN":return[tfc.localResponseNormalization(getParamValue("x",node,tensorMap,context),getParamValue("radius",node,tensorMap,context),getParamValue("bias",node,tensorMap,context),getParamValue("alpha",node,tensorMap,context),getParamValue("beta",node,tensorMap,context))];case"Softmax":return[tfc.softmax(getParamValue("x",node,tensorMap,context))];case"LogSoftmax":return[tfc.logSoftmax(getParamValue("x",node,tensorMap,context))];case"SparseToDense":return[tfc.sparseToDense(getParamValue("sparseIndices",node,tensorMap,context),getParamValue("outputShape",node,tensorMap,context),getParamValue("sparseValues",node,tensorMap,context),getParamValue("defaultValue",node,tensorMap,context))];default:throw TypeError("Node type "+node.op+" is not implemented")}},executeOp$12=function(node,tensorMap,context){switch(node.op){case"Max":var axis=getParamValue("axis",node,tensorMap,context),keepDims=getParamValue("keepDims",node,tensorMap,context);return[tfc.max(getParamValue("x",node,tensorMap,context),axis,keepDims)];case"Mean":var axis=getParamValue("axis",node,tensorMap,context),keepDims=getParamValue("keepDims",node,tensorMap,context);return[tfc.mean(getParamValue("x",node,tensorMap,context),axis,keepDims)];case"Min":var axis=getParamValue("axis",node,tensorMap,context),keepDims=getParamValue("keepDims",node,tensorMap,context);return[tfc.min(getParamValue("x",node,tensorMap,context),axis,keepDims)];case"Sum":var axis=getParamValue("axis",node,tensorMap,context),keepDims=getParamValue("keepDims",node,tensorMap,context);return[tfc.sum(getParamValue("x",node,tensorMap,context),axis,keepDims)];case"All":var axis=getParamValue("axis",node,tensorMap,context),keepDims=getParamValue("keepDims",node,tensorMap,context);return[tfc.all(getParamValue("x",node,tensorMap,context),axis,keepDims)];case"Any":var axis=getParamValue("axis",node,tensorMap,context),keepDims=getParamValue("keepDims",node,tensorMap,context);return[tfc.any(getParamValue("x",node,tensorMap,context),axis,keepDims)];case"ArgMax":var axis=getParamValue("axis",node,tensorMap,context);return[tfc.argMax(getParamValue("x",node,tensorMap,context),axis)];case"ArgMin":var axis=getParamValue("axis",node,tensorMap,context);return[tfc.argMin(getParamValue("x",node,tensorMap,context),axis)];case"Prod":var axis=getParamValue("axis",node,tensorMap,context),keepDims=getParamValue("keepDims",node,tensorMap,context);return[tfc.prod(getParamValue("x",node,tensorMap,context),axis,keepDims)];default:throw TypeError("Node type "+node.op+" is not implemented")}},executeOp$13=function(node,tensorMap,context){switch(node.op){case"ConcatV2":case"Concat":var n=getParamValue("n",node,tensorMap,context),axis=getParamValue("axis",node,tensorMap,context),inputs=getParamValue("tensors",node,tensorMap,context);return inputs=inputs.slice(0,n),[tfc.concat(inputs,axis)];case"GatherV2":case"Gather":var axis=getParamValue("axis",node,tensorMap,context),input=getParamValue("x",node,tensorMap,context),indices=getParamValue("indices",node,tensorMap,context);return[tfc.gather(input,indices.asType("int32"),axis)];case"ReverseV2":case"Reverse":var axis=getParamValue("axis",node,tensorMap,context),input=getParamValue("x",node,tensorMap,context);return[tfc.reverse(input,axis)];case"Slice":var begin=getParamValue("begin",node,tensorMap,context),size=getParamValue("size",node,tensorMap,context);return[tfc.slice(getParamValue("x",node,tensorMap,context),begin,size)];case"StridedSlice":var begin=getParamValue("begin",node,tensorMap,context),end=getParamValue("end",node,tensorMap,context),strides=getParamValue("strides",node,tensorMap,context),beginMask=getParamValue("beginMask",node,tensorMap,context),endMask=getParamValue("endMask",node,tensorMap,context),ellipsisMask=getParamValue("ellipsisMask",node,tensorMap,context),newAxisMask=getParamValue("newAxisMask",node,tensorMap,context),shrinkAxisMask=getParamValue("shrinkAxisMask",node,tensorMap,context),tensor=getParamValue("x",node,tensorMap,context);if(1===begin.length&&tensor.shape.length>1)for(var i=1;i<tensor.shape.length;i++)begin.push(0),end.push(tensor.shape[i]),strides.push(strides[0]);return[tfc.stridedSlice(tensor,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask)];case"Pack":return tfc.tidy(function(){var axis=getParamValue("axis",node,tensorMap,context),tensors=getParamValue("tensors",node,tensorMap,context),shape=tensors[0].shape,squeezedShape=tensors[0].squeeze().shape,mapped=tensors.map(function(tensor){var sameShape=tfc.util.arraysEqual(tensor.shape,shape);if(!sameShape&&!tfc.util.arraysEqual(tensor.squeeze().shape,squeezedShape))throw new Error("the input tensors shape does not match");return sameShape?tensor:tensor.reshape(shape)});return[tfc.stack(mapped,axis)]});case"Unpack":return tfc.tidy(function(){var axis=getParamValue("axis",node,tensorMap,context),tensor=getParamValue("tensor",node,tensorMap,context);return tfc.unstack(tensor,axis)});case"Tile":var reps=getParamValue("reps",node,tensorMap,context);return[tfc.tile(getParamValue("x",node,tensorMap,context),reps)];case"Split":case"SplitV":var axis=getParamValue("axis",node,tensorMap,context),numOrSizeSplits=getParamValue("numOrSizeSplits",node,tensorMap,context);return tfc.split(getParamValue("x",node,tensorMap,context),numOrSizeSplits,axis);case"ScatterNd":var indices=getParamValue("indices",node,tensorMap,context),values=getParamValue("values",node,tensorMap,context),shape=getParamValue("shape",node,tensorMap,context);return[tfc.scatterND(indices,values,shape)];case"GatherNd":var x=getParamValue("x",node,tensorMap,context),indices=getParamValue("indices",node,tensorMap,context);return[tfc.gatherND(x,indices)];case"SparseToDense":var indices=getParamValue("sparseIndices",node,tensorMap,context),shape=getParamValue("outputShape",node,tensorMap,context),sparseValues=getParamValue("sparseValues",node,tensorMap,context),defaultValue=getParamValue("defaultValue",node,tensorMap,context);return[tfc.sparseToDense(indices,sparseValues,shape,sparseValues.dtype===defaultValue.dtype?defaultValue:defaultValue.asType(sparseValues.dtype))];default:throw TypeError("Node type "+node.op+" is not implemented")}},executeOp$14=function(node,tensorMap,context){switch(node.op){case"FFT":return[tfc.fft(getParamValue("x",node,tensorMap,context))];case"IFFT":return[tfc.ifft(getParamValue("x",node,tensorMap,context))];case"RFFT":return[tfc.rfft(getParamValue("x",node,tensorMap,context))];case"IRFFT":return[tfc.irfft(getParamValue("x",node,tensorMap,context))];default:throw TypeError("Node type "+node.op+" is not implemented")}},executeOp$15=function(node,tensorMap,context){switch(node.op){case"Cast":return[tfc.cast(getParamValue("x",node,tensorMap,context),getParamValue("dtype",node,tensorMap,context))];case"ExpandDims":var axis=getParamValue("axis",node,tensorMap,context);return[tfc.expandDims(getParamValue("x",node,tensorMap,context),axis)];case"Squeeze":var axis=getParamValue("axis",node,tensorMap,context);return[tfc.squeeze(getParamValue("x",node,tensorMap,context),axis)];case"Reshape":return[tfc.reshape(getParamValue("x",node,tensorMap,context),getParamValue("shape",node,tensorMap,context))];case"PadV2":case"Pad":return[tfc.pad(getParamValue("x",node,tensorMap,context),split(getParamValue("padding",node,tensorMap,context),2),getParamValue("constantValue",node,tensorMap,context))];case"SpaceToBatchND":var blockShape=getParamValue("blockShape",node,tensorMap,context),paddings=split(getParamValue("paddings",node,tensorMap,context),2);return[tfc.spaceToBatchND(getParamValue("x",node,tensorMap,context),blockShape,paddings)];case"BatchToSpaceND":var blockShape=getParamValue("blockShape",node,tensorMap,context),crops=split(getParamValue("crops",node,tensorMap,context),2);return[tfc.batchToSpaceND(getParamValue("x",node,tensorMap,context),blockShape,crops)];case"DepthToSpace":var blockSize=getParamValue("blockSize",node,tensorMap,context),dataFormat=getParamValue("dataFormat",node,tensorMap,context).toUpperCase();return[tfc.depthToSpace(getParamValue("x",node,tensorMap,context),blockSize,dataFormat)];default:throw TypeError("Node type "+node.op+" is not implemented")}};function executeOp$16(node,tensorMap,context){var value=function(node,tensorMap,context){switch(node.category){case"arithmetic":return tfc.tidy(function(){return executeOp(node,tensorMap,context)});case"basic_math":return tfc.tidy(function(){return executeOp$1(node,tensorMap,context)});case"control":return executeOp$2(node,tensorMap,context);case"convolution":return tfc.tidy(function(){return executeOp$3(node,tensorMap,context)});case"creation":return tfc.tidy(function(){return executeOp$4(node,tensorMap,context)});case"dynamic":return executeOp$5(node,tensorMap,context);case"evaluation":return tfc.tidy(function(){return executeOp$6(node,tensorMap,context)});case"image":return tfc.tidy(function(){return executeOp$8(node,tensorMap,context)});case"graph":return tfc.tidy(function(){return executeOp$7(node,tensorMap,context)});case"logical":return tfc.tidy(function(){return executeOp$9(node,tensorMap,context)});case"matrices":return tfc.tidy(function(){return executeOp$10(node,tensorMap,context)});case"normalization":return tfc.tidy(function(){return executeOp$11(node,tensorMap,context)});case"reduction":return tfc.tidy(function(){return executeOp$12(node,tensorMap,context)});case"slice_join":return tfc.tidy(function(){return executeOp$13(node,tensorMap,context)});case"spectral":return tfc.tidy(function(){return executeOp$14(node,tensorMap,context)});case"transformation":return tfc.tidy(function(){return executeOp$15(node,tensorMap,context)});case"custom":var opMapper=getRegisteredOp(node.op);if(opMapper&&opMapper.customExecutor)return opMapper.customExecutor(new NodeValueImpl(node,tensorMap,context));throw TypeError("Custom op "+node.op+" is not registered.");default:throw TypeError("Unknown op '"+node.op+"'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}}(node,tensorMap,context);return value instanceof Promise?value.then(function(data){return[].concat(data)}):[].concat(value)}var ExecutionContext=function(){function ExecutionContext(weightMap,tensorArrayMap){this.weightMap=weightMap,this.tensorArrayMap=tensorArrayMap,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}return ExecutionContext.prototype.newFrame=function(id,frameName){return{id:id,frameName:frameName,iterationId:0}},Object.defineProperty(ExecutionContext.prototype,"currentContext",{get:function(){return this.contexts},set:function(contexts){this.contexts!==contexts&&(this.contexts=contexts,this.generateCurrentContextIds())},enumerable:!0,configurable:!0}),Object.defineProperty(ExecutionContext.prototype,"currentContextId",{get:function(){return this._currentContextIds[0]},enumerable:!0,configurable:!0}),Object.defineProperty(ExecutionContext.prototype,"currentContextIds",{get:function(){return this._currentContextIds},enumerable:!0,configurable:!0}),ExecutionContext.prototype.generateCurrentContextIds=function(){for(var names=[],i=0;i<this.contexts.length-1;i++){var contexts=this.contexts.slice(0,this.contexts.length-i);names.push(this.contextIdforContexts(contexts))}names.push(""),this._currentContextIds=names},ExecutionContext.prototype.contextIdforContexts=function(contexts){return contexts?contexts.map(function(context){return 0===context.id&&0===context.iterationId?"":context.frameName+"-"+context.iterationId}).join("/"):""},ExecutionContext.prototype.enterFrame=function(frameId){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,frameId)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))},ExecutionContext.prototype.exitFrame=function(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()},ExecutionContext.prototype.nextIteration=function(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");this.contexts=this.contexts.slice(),this.lastId++;var context=Object.assign({},this.contexts[this.contexts.length-1]);context.iterationId+=1,context.id=this.lastId,this.contexts.splice(-1,1,context),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))},ExecutionContext.prototype.getWeight=function(name){return this.weightMap[name]},ExecutionContext.prototype.addTensorArray=function(tensorArray){this.tensorArrayMap[tensorArray.id]=tensorArray},ExecutionContext.prototype.getTensorArray=function(id){return this.tensorArrayMap[id]},ExecutionContext}();function getExecutionSubgraph(inputs,outputs,weightMap){for(var usedNodes=new Set,missingInputs=[],dynamicNode=null,syncInputs=null,seen=new Set,inputNodeNames=Object.keys(inputs).map(function(name){return parseNodeName(name)[0]}),frontier=outputs.slice();frontier.length>0;){var node=frontier.pop();(isControlFlow(node)||isDynamicShape(node))&&null==dynamicNode&&(syncInputs=(dynamicNode=node).children.map(function(child){return child.name}).filter(function(name){return usedNodes.has(name)})),usedNodes.add(node.name),null==weightMap[node.name]&&(-1===inputNodeNames.indexOf(node.name)&&(0!==node.inputs.length?node.inputs.forEach(function(input){seen.has(input.name)||(seen.add(input.name),frontier.push(input))}):missingInputs.push(node.name)))}return{inputs:inputs,outputs:outputs,usedNodes:usedNodes,missingInputs:missingInputs,dynamicNode:dynamicNode,syncInputs:syncInputs}}function getNodesInTopologicalOrder(graph,weightMap,executionInfo){var usedNodes=executionInfo.usedNodes,inputs=executionInfo.inputs,frontier=[],inputNodes;Object.keys(inputs).map(function(name){return parseNodeName(name)[0]}).map(function(name){return graph.nodes[name]}).forEach(function(input){usedNodes.has(input.name)&&frontier.push(input)}),graph.weights.forEach(function(weight){usedNodes.has(weight.name)&&frontier.push(weight)});for(var seen=new Set,orderedNodes=[];frontier.length>0;){var node=frontier.pop();seen.add(node.name),weightMap[node.name]||orderedNodes.push(node),node.children.forEach(function(child){!seen.has(child.name)&&usedNodes.has(child.name)&&child.inputs.every(function(input){return seen.has(input.name)})&&frontier.push(child)})}return orderedNodes}var CONTROL_FLOW_OPS=["Switch","Merge","Enter","Exit","NextIteration"],DYNAMIC_SHAPE_OPS=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"];function isControlFlow(node){return CONTROL_FLOW_OPS.indexOf(node.op)>=0}function isDynamicShape(node){return DYNAMIC_SHAPE_OPS.indexOf(node.op)>=0}var GraphExecutor=function(){function GraphExecutor(graph){this.graph=graph,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._outputs=graph.outputs,this._inputs=graph.inputs,this._signature=graph.signature}return Object.defineProperty(GraphExecutor.prototype,"weightMap",{get:function(){return this._weightMap},set:function(weightMap){var weightIds=Object.keys(weightMap).map(function(key){return weightMap[key].map(function(tensor){return tensor.id})});this.weightIds=[].concat.apply([],weightIds),this._weightMap=weightMap},enumerable:!0,configurable:!0}),Object.defineProperty(GraphExecutor.prototype,"inputs",{get:function(){return this._inputs.map(function(node){return{name:node.name,shape:node.attrParams.shape?node.attrParams.shape.value:void 0,dtype:node.attrParams.dtype?node.attrParams.dtype.value:void 0}})},enumerable:!0,configurable:!0}),Object.defineProperty(GraphExecutor.prototype,"outputs",{get:function(){return this._outputs.map(function(node){return{name:node.name,shape:node.attrParams.shape?node.attrParams.shape.value:void 0,dtype:node.attrParams.dtype?node.attrParams.dtype.value:void 0}})},enumerable:!0,configurable:!0}),Object.defineProperty(GraphExecutor.prototype,"inputNodes",{get:function(){return this._inputs.map(function(node){return node.signatureKey||node.name})},enumerable:!0,configurable:!0}),Object.defineProperty(GraphExecutor.prototype,"outputNodes",{get:function(){return this._outputs.map(function(node){return node.signatureKey||node.name})},enumerable:!0,configurable:!0}),GraphExecutor.prototype.getCompilationKey=function(inputs,outputs){var sortedInputs=inputs.map(function(node){return node.name}).sort(),sortedOutputs=outputs.map(function(node){return node.name}).sort();return sortedInputs.join(this.SEPERATOR)+"--"+sortedOutputs.join(this.SEPERATOR)},GraphExecutor.prototype.compile=function(inputs,outputs){var executionInfo=getExecutionSubgraph(inputs,outputs,this.weightMap),missingInputs=executionInfo.missingInputs,dynamicNode=executionInfo.dynamicNode,syncInputs=executionInfo.syncInputs;if(null!=dynamicNode)throw new Error("This execution contains the node '"+dynamicNode.name+"', which has the dynamic op '"+dynamicNode.op+"'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs ["+syncInputs+"]");if(missingInputs.length>0){var outNames=outputs.map(function(n){return n.name}),inNames=Object.keys(inputs);throw new Error("Cannot compute the outputs ["+outNames+"] from the provided inputs ["+inNames+"]. Missing the following inputs: ["+missingInputs+"]")}return getNodesInTopologicalOrder(this.graph,this.weightMap,executionInfo)},GraphExecutor.prototype.execute=function(inputs,outputs){var _this=this;inputs=this.mapInputs(inputs);var names=Object.keys(inputs).sort();this.checkInputs(inputs),this.checkInputShapeAndType(inputs),outputs=this.mapOutputs(outputs),this.checkOutputs(outputs);var inputNodes=names.map(function(name){return _this.graph.nodes[parseNodeName(name)[0]]}),outputNodes=outputs.map(function(name){return _this.graph.nodes[parseNodeName(name)[0]]}),compilationKey=this.getCompilationKey(inputNodes,outputNodes),orderedNodes=this.compiledMap.get(compilationKey);null==orderedNodes&&(orderedNodes=this.compile(inputs,outputNodes),this.compiledMap.set(compilationKey,orderedNodes));var tensorArrayMap={};return tfc.tidy(function(){var context=new ExecutionContext(_this._weightMap,tensorArrayMap),tensorsMap=__assign({},_this.weightMap);Object.keys(inputs).forEach(function(name){var _a=parseNodeName(name),nodeName=_a[0],index,tensors=[];tensors[_a[1]]=inputs[name],tensorsMap[nodeName]=tensors});for(var tensorsToKeep=_this.getFrozenTensorIds(tensorsMap),intermediateTensorConsumerCount={},i=0;i<orderedNodes.length;i++){var node=orderedNodes[i];if(!tensorsMap[node.name]){var tensors=executeOp$16(node,tensorsMap,context);if(tensors instanceof Promise)throw new Error("The execution of the op '"+node.op+"' returned a promise. Please use model.executeAsync() instead.");tensorsMap[node.name]=tensors,_this.checkTensorForDisposal(node.name,node,tensorsMap,context,tensorsToKeep,outputs,intermediateTensorConsumerCount)}}return outputs.map(function(name){return getTensor(name,tensorsMap,context)})})},GraphExecutor.prototype.getFrozenTensorIds=function(tensorMap){var ids=[].concat.apply([],Object.keys(tensorMap).map(function(key){return tensorMap[key]}).map(function(tensors){return tensors.map(function(tensor){return tensor.id})}));return new Set(ids)},GraphExecutor.prototype.checkTensorForDisposal=function(nodeName,node,tensorMap,context,tensorsToKeep,outputNames,intermediateTensorConsumerCount){"control"!==node.category&&-1===outputNames.indexOf(nodeName)&&(tensorMap[nodeName].forEach(function(tensor){null!=tensor&&(intermediateTensorConsumerCount[tensor.id]=(intermediateTensorConsumerCount[tensor.id]||0)+node.children.length)}),node.inputs.forEach(function(input){if("control"!==input.category){var tensors=getTensorsForCurrentContenxt(input.name,tensorMap,context);null!=tensors&&tensors.forEach(function(tensor){if(tensor&&!tensorsToKeep.has(tensor.id)){var count=intermediateTensorConsumerCount[tensor.id];1===count?(tensor.dispose(),delete intermediateTensorConsumerCount[tensor.id]):null!=count&&intermediateTensorConsumerCount[tensor.id]--}})}}))},GraphExecutor.prototype.executeAsync=function(inputs,outputs){return __awaiter(this,void 0,void 0,function(){var tensorArrayMap,context,tensorMap,results,outputIds,inputIds,_this=this;return __generator(this,function(_a){switch(_a.label){case 0:return inputs=this.mapInputs(inputs),this.checkInputs(inputs),this.checkInputShapeAndType(inputs),outputs=this.mapOutputs(outputs),this.checkOutputs(outputs),tensorArrayMap={},context=new ExecutionContext(this._weightMap,tensorArrayMap),[4,this.executeWithControlFlow(inputs,context,outputs)];case 1:return tensorMap=_a.sent(),results=outputs.map(function(name){return getTensor(name,tensorMap,context)}),outputIds=new Set(results.map(function(t){return t.id})),inputIds=new Set(Object.keys(inputs).map(function(name){return inputs[name].id})),Object.keys(tensorMap).forEach(function(key){var tensorArray;tensorMap[key].forEach(function(tensor){!tensor||tensor.isDisposed||outputIds.has(tensor.id)||inputIds.has(tensor.id)||-1!==_this.weightIds.indexOf(tensor.id)||tensor.dispose()})}),[2,results]}})})},GraphExecutor.prototype.executeWithControlFlow=function(inputs,context,outputNames){return __awaiter(this,void 0,void 0,function(){var names,inputNodes,outputNodes,_a,usedNodes,missingInputs,dynamicNode,syncInputs,stack,tensorsMap,intermediateTensorConsumerCount,tensorsToKeep,added,promises,missingOutputs,alternativeMsg,_this=this;return __generator(this,function(_b){switch(_b.label){case 0:names=Object.keys(inputs),inputNodes=names.map(function(name){return _this.graph.nodes[parseNodeName(name)[0]]}),outputNodes=outputNames.map(function(name){return _this.graph.nodes[parseNodeName(name)[0]]}),_a=getExecutionSubgraph(inputs,outputNodes,this.weightMap),usedNodes=_a.usedNodes,missingInputs=_a.missingInputs,dynamicNode=_a.dynamicNode,syncInputs=_a.syncInputs,stack=inputNodes.concat(this.graph.weights).map(function(node){return{node:node,contexts:context.currentContext}}),tensorsMap=__assign({},this.weightMap),Object.keys(inputs).forEach(function(name){var _a=parseNodeName(name),nodeName=_a[0],index,tensors=[];tensors[_a[1]]=inputs[name],tensorsMap[nodeName]=tensors}),intermediateTensorConsumerCount={},tensorsToKeep=this.getFrozenTensorIds(tensorsMap),added={},_b.label=1;case 1:return stack.length>0?(promises=this.processStack(inputNodes,stack,context,tensorsMap,added,tensorsToKeep,outputNames,intermediateTensorConsumerCount,usedNodes),[4,Promise.all(promises)]):[3,3];case 2:return _b.sent(),[3,1];case 3:if(null==dynamicNode&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."),(missingOutputs=outputNodes.filter(function(node){return!isControlFlow(node)&&!getTensor(node.name,tensorsMap,context)}).map(function(node){return node.name})).length>0)throw alternativeMsg="",null!=dynamicNode&&(alternativeMsg="Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs ["+syncInputs+"]"),new Error("Cannot compute the outputs ["+missingOutputs+"] from the provided inputs ["+names+"]. Consider providing the following inputs: ["+missingInputs+"]. "+alternativeMsg);return[2,tensorsMap]}})})},GraphExecutor.prototype.processStack=function(inputNodes,stack,context,tensorMap,added,tensorsToKeep,outputNames,intermediateTensorConsumerCount,usedNodes){for(var _this=this,promises=[],_loop_1=function(){var item=stack.pop();context.currentContext=item.contexts;var nodeName="";if("Enter"===item.node.op&&getParamValue("isConstant",item.node,tensorMap,context)&&(nodeName=getNodeNameAndIndex(item.node.name,context)[0]),-1===inputNodes.indexOf(item.node)){var tensors=executeOp$16(item.node,tensorMap,context);nodeName||(nodeName=getNodeNameAndIndex(item.node.name,context)[0]);var currentContext_1=context.currentContext;tensors instanceof Promise?promises.push(tensors.then(function(t){return tensorMap[nodeName]=t,context.currentContext=currentContext_1,_this.checkTensorForDisposal(nodeName,item.node,tensorMap,context,tensorsToKeep,outputNames,intermediateTensorConsumerCount),_this.processChildNodes(item.node,stack,context,tensorMap,added,usedNodes),t})):(tensorMap[nodeName]=tensors,this_1.checkTensorForDisposal(nodeName,item.node,tensorMap,context,tensorsToKeep,outputNames,intermediateTensorConsumerCount),this_1.processChildNodes(item.node,stack,context,tensorMap,added,usedNodes))}else this_1.processChildNodes(item.node,stack,context,tensorMap,added,usedNodes)},this_1=this;stack.length>0;)_loop_1();return promises},GraphExecutor.prototype.processChildNodes=function(node,stack,context,tensorMap,added,usedNodes){node.children.forEach(function(childNode){var nodeName=getNodeNameAndIndex(childNode.name,context)[0];!added[nodeName]&&usedNodes.has(childNode.name)&&("Merge"===childNode.op?childNode.inputNames.some(function(name){return!!getTensor(name,tensorMap,context)})&&(added[nodeName]=!0,stack.push({contexts:context.currentContext,node:childNode})):childNode.inputNames.every(function(name){return!!getTensor(name,tensorMap,context)})&&(added[nodeName]=!0,stack.push({contexts:context.currentContext,node:childNode})))})},GraphExecutor.prototype.dispose=function(){var _this=this;Object.keys(this.weightMap).forEach(function(key){return _this.weightMap[key].forEach(function(tensor){return tensor.dispose()})})},GraphExecutor.prototype.checkInputShapeAndType=function(inputs){var _this=this;Object.keys(inputs).forEach(function(name){var input=inputs[name],nodeName=parseNodeName(name)[0],node=_this.graph.nodes[nodeName];if(node.attrParams.shape&&node.attrParams.shape.value){var shape_1=node.attrParams.shape.value,match=shape_1.length===input.shape.length&&input.shape.every(function(dim,index){return-1===shape_1[index]||shape_1[index]===dim});tfc.util.assert(match,function(){return"The shape of dict['"+node.name+"'] provided in model.execute(dict) must be ["+shape_1+"], but was ["+input.shape+"]"})}node.attrParams.dtype&&node.attrParams.dtype.value&&tfc.util.assert(input.dtype===node.attrParams.dtype.value,function(){return"The dtype of dict['"+node.name+"'] provided in model.execute(dict) must be "+node.attrParams.dtype.value+", but was "+input.dtype})})},GraphExecutor.prototype.mapInputs=function(inputs){var result={};for(var inputName in inputs){var tensor;if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[inputName])result[this._signature.inputs[inputName].name]=inputs[inputName];else result[inputName]=inputs[inputName]}return result},GraphExecutor.prototype.checkInputs=function(inputs){var _this=this,notInGraph=Object.keys(inputs).filter(function(name){var nodeName=parseNodeName(name)[0];return null==_this.graph.nodes[nodeName]});if(notInGraph.length>0)throw new Error("The dict provided in model.execute(dict) has keys: ["+notInGraph+"] that are not part of graph")},GraphExecutor.prototype.mapOutputs=function(outputs){var _this=this;return outputs.map(function(name){var tensor;return null!=_this._signature&&null!=_this._signature.outputs&&null!=_this._signature.outputs[name]?_this._signature.outputs[name].name:name},{})},GraphExecutor.prototype.checkOutputs=function(outputs){var _this=this;outputs.forEach(function(name){var normalizedName=parseNodeName(name)[0];if(!_this.graph.nodes[normalizedName])throw new Error("The output '"+name+"' is not found in the graph")})},GraphExecutor}(),TFHUB_SEARCH_PARAM="?tfjs-format=file",DEFAULT_MODEL_NAME="model.json",GraphModel=function(){function GraphModel(modelUrl,loadOptions){void 0===loadOptions&&(loadOptions={}),this.modelUrl=modelUrl,this.loadOptions=loadOptions,this.version="n/a",null==loadOptions&&(this.loadOptions={})}return Object.defineProperty(GraphModel.prototype,"modelVersion",{get:function(){return this.version},enumerable:!0,configurable:!0}),Object.defineProperty(GraphModel.prototype,"inputNodes",{get:function(){return this.executor.inputNodes},enumerable:!0,configurable:!0}),Object.defineProperty(GraphModel.prototype,"outputNodes",{get:function(){return this.executor.outputNodes},enumerable:!0,configurable:!0}),Object.defineProperty(GraphModel.prototype,"inputs",{get:function(){return this.executor.inputs},enumerable:!0,configurable:!0}),Object.defineProperty(GraphModel.prototype,"outputs",{get:function(){return this.executor.outputs},enumerable:!0,configurable:!0}),Object.defineProperty(GraphModel.prototype,"weights",{get:function(){return this.executor.weightMap},enumerable:!0,configurable:!0}),GraphModel.prototype.findIOHandler=function(){var path=this.modelUrl;if(null!=path.load)this.handler=path;else if(null!=this.loadOptions.requestInit)this.handler=tfc.io.browserHTTPRequest(path,this.loadOptions);else{var handlers=tfc.io.getLoadHandlers(path,this.loadOptions.onProgress);if(0===handlers.length)handlers.push(tfc.io.browserHTTPRequest(path,this.loadOptions));else if(handlers.length>1)throw new Error("Found more than one ("+handlers.length+") load handlers for URL '"+[path]+"'");this.handler=handlers[0]}},GraphModel.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var _a,graph,signature,weightMap;return __generator(this,function(_b){switch(_b.label){case 0:if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return _a=this,[4,this.handler.load()];case 1:return _a.artifacts=_b.sent(),graph=this.artifacts.modelTopology,signature={},null!=this.artifacts.userDefinedMetadata&&(signature=this.artifacts.userDefinedMetadata.signature),this.version=graph.versions.producer+"."+graph.versions.minConsumer,weightMap=tfc.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs),this.executor=new GraphExecutor(OperationMapper.Instance.transformGraph(graph,signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(weightMap),[2,!0]}})})},GraphModel.prototype.save=function(handlerOrURL,config){return __awaiter(this,void 0,void 0,function(){var handlers;return __generator(this,function(_a){if("string"==typeof handlerOrURL){if(0===(handlers=tfc.io.getSaveHandlers(handlerOrURL)).length)throw new Error("Cannot find any save handlers for URL '"+handlerOrURL+"'");if(handlers.length>1)throw new Error("Found more than one ("+handlers.length+") save handlers for URL '"+handlerOrURL+"'");handlerOrURL=handlers[0]}if(null==handlerOrURL.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return[2,handlerOrURL.save(this.artifacts)]})})},GraphModel.prototype.predict=function(inputs,config){return this.execute(inputs,this.outputNodes)},GraphModel.prototype.normalizeInputs=function(inputs){if(!(inputs instanceof tfc.Tensor||Array.isArray(inputs)))return inputs;if((inputs=Array.isArray(inputs)?inputs:[inputs]).length!==this.inputNodes.length)throw new Error("Input tensor count mismatch,the graph model has "+this.inputNodes.length+" placeholders, while there are "+inputs.length+" input tensors.");return this.inputNodes.reduce(function(map,inputName,i){return map[inputName]=inputs[i],map},{})},GraphModel.prototype.normalizeOutputs=function(outputs){return outputs=outputs||this.outputNodes,Array.isArray(outputs)?outputs:[outputs]},GraphModel.prototype.execute=function(inputs,outputs){inputs=this.normalizeInputs(inputs),outputs=this.normalizeOutputs(outputs);var result=this.executor.execute(inputs,outputs);return result.length>1?result:result[0]},GraphModel.prototype.executeAsync=function(inputs,outputs){return __awaiter(this,void 0,void 0,function(){var result;return __generator(this,function(_a){switch(_a.label){case 0:return inputs=this.normalizeInputs(inputs),outputs=this.normalizeOutputs(outputs),[4,this.executor.executeAsync(inputs,outputs)];case 1:return[2,(result=_a.sent()).length>1?result:result[0]]}})})},GraphModel.prototype.convertTensorMapToTensorsMap=function(map){return Object.keys(map).reduce(function(newMap,key){return newMap[key]=[map[key]],newMap},{})},GraphModel.prototype.dispose=function(){this.executor.dispose()},GraphModel}();function loadGraphModel(modelUrl,options){return void 0===options&&(options={}),__awaiter(this,void 0,void 0,function(){var model;return __generator(this,function(_a){switch(_a.label){case 0:if(null==modelUrl)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");return null==options&&(options={}),options.fromTFHub&&null==modelUrl.load&&(modelUrl.endsWith("/")||(modelUrl+="/"),modelUrl=""+modelUrl+DEFAULT_MODEL_NAME+TFHUB_SEARCH_PARAM),[4,(model=new GraphModel(modelUrl,options)).load()];case 1:return _a.sent(),[2,model]}})})}var version="1.7.4";exports.GraphModel=GraphModel,exports.loadGraphModel=loadGraphModel,exports.deregisterOp=deregisterOp,exports.registerOp=registerOp,exports.version_converter="1.7.4",Object.defineProperty(exports,"__esModule",{value:!0})}),function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?factory(exports,require("@tensorflow/tfjs-core"),require("@tensorflow/tfjs-converter")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core","@tensorflow/tfjs-converter"],factory):factory(global.facemesh={},global.tf,global.tf)}(this,function(exports,tf,tfconv){"use strict";const disposeBox=t=>{t.startEndTensor.dispose(),t.startPoint.dispose(),t.endPoint.dispose()},createBox=t=>({startEndTensor:t,startPoint:tf.slice(t,[0,0],[-1,2]),endPoint:tf.slice(t,[0,2],[-1,2])}),scaleBox=(t,o)=>{const s=tf.mul(t.startPoint,o),e=tf.mul(t.endPoint,o),i=tf.concat2d([s,e],1);return createBox(i)},ANCHORS_CONFIG={strides:[8,16],anchors:[2,6]},NUM_LANDMARKS=6;function generateAnchors(t,o,s){const e=[];for(let i=0;i<s.strides.length;i++){const n=s.strides[i],a=Math.floor((o+n-1)/n),r=Math.floor((t+n-1)/n),c=s.anchors[i];for(let t=0;t<a;t++){const o=n*(t+.5);for(let t=0;t<r;t++){const s=n*(t+.5);for(let t=0;t<c;t++)e.push([s,o])}}}return e}function decodeBounds(t,o,s){const e=tf.slice(t,[0,1],[-1,2]),i=tf.add(e,o),n=tf.slice(t,[0,3],[-1,2]),a=tf.div(n,s),r=tf.div(i,s),c=tf.div(a,2),l=tf.sub(r,c),d=tf.add(r,c),h=tf.mul(l,s),p=tf.mul(d,s);return tf.concat2d([h,p],1)}function getInputTensorDimensions(t){return t instanceof tf.Tensor?[t.shape[0],t.shape[1]]:[t.height,t.width]}function flipFaceHorizontal(t,o){let s,e,i;if(t.topLeft instanceof tf.Tensor&&t.bottomRight instanceof tf.Tensor){const[n,a]=tf.tidy(()=>[tf.concat([tf.sub(o-1,t.topLeft.slice(0,1)),t.topLeft.slice(1,1)]),tf.concat([tf.sub(o-1,t.bottomRight.slice(0,1)),t.bottomRight.slice(1,1)])]);s=n,e=a,null!=t.landmarks&&(i=tf.tidy(()=>{const s=tf.sub(tf.tensor1d([o-1,0]),t.landmarks),e=tf.tensor1d([1,-1]);return tf.mul(s,e)}))}else{const[n,a]=t.topLeft,[r,c]=t.bottomRight;s=[o-1-n,a],e=[o-1-r,c],null!=t.landmarks&&(i=t.landmarks.map(t=>[o-1-t[0],t[1]]))}const n={topLeft:s,bottomRight:e};return null!=i&&(n.landmarks=i),null!=t.probability&&(n.probability=t.probability instanceof tf.Tensor?t.probability.clone():t.probability),n}function scaleBoxFromPrediction(t,o){return tf.tidy(()=>{let s;return s=t.hasOwnProperty("box")?t.box:t,scaleBox(s,o).startEndTensor.squeeze()})}class BlazeFaceModel{constructor(t,o,s,e,i,n){this.blazeFaceModel=t,this.width=o,this.height=s,this.maxFaces=e,this.anchorsData=generateAnchors(o,s,ANCHORS_CONFIG),this.anchors=tf.tensor2d(this.anchorsData),this.inputSizeData=[o,s],this.inputSize=tf.tensor1d([o,s]),this.iouThreshold=i,this.scoreThreshold=n}async getBoundingBoxes(t,o,s=!0){const[e,i,n]=tf.tidy(()=>{const o=t.resizeBilinear([this.width,this.height]),s=tf.mul(tf.sub(o.div(255),.5),2),e=this.blazeFaceModel.predict(s).squeeze(),i=decodeBounds(e,this.anchors,this.inputSize),n=tf.slice(e,[0,0],[-1,1]);return[e,i,tf.sigmoid(n).squeeze()]}),a=console.warn;console.warn=(()=>{});const r=tf.image.nonMaxSuppression(i,n,this.maxFaces,this.iouThreshold,this.scoreThreshold);console.warn=a;const c=await r.array();r.dispose();let l=c.map(t=>tf.slice(i,[t,0],[1,-1]));o||(l=await Promise.all(l.map(async t=>{const o=await t.array();return t.dispose(),o})));const d=t.shape[1],h=t.shape[2];let p;p=o?tf.div([h,d],this.inputSize):[h/this.inputSizeData[0],d/this.inputSizeData[1]];const u=[];for(let t=0;t<l.length;t++){const i=l[t],a=tf.tidy(()=>{const a=createBox(i instanceof tf.Tensor?i:tf.tensor2d(i));if(!s)return a;const r=c[t];let l;return l=o?this.anchors.slice([r,0],[1,2]):this.anchorsData[r],{box:a,landmarks:tf.slice(e,[r,NUM_LANDMARKS-1],[1,-1]).squeeze().reshape([NUM_LANDMARKS,-1]),probability:tf.slice(n,[r],[1]),anchor:l}});u.push(a)}return i.dispose(),n.dispose(),e.dispose(),{boxes:u,scaleFactor:p}}async estimateFaces(t,o=!1,s=!1,e=!0){const[,i]=getInputTensorDimensions(t),n=tf.tidy(()=>(t instanceof tf.Tensor||(t=tf.browser.fromPixels(t)),t.toFloat().expandDims(0))),{boxes:a,scaleFactor:r}=await this.getBoundingBoxes(n,o,e);return n.dispose(),o?a.map(t=>{const o=scaleBoxFromPrediction(t,r);let n={topLeft:o.slice([0],[2]),bottomRight:o.slice([2],[2])};if(e){const{landmarks:o,probability:s,anchor:e}=t,i=o.add(e).mul(r);n.landmarks=i,n.probability=s}return s&&(n=flipFaceHorizontal(n,i)),n}):Promise.all(a.map(async t=>{const o=scaleBoxFromPrediction(t,r);let n;if(e){const[s,e,i]=await Promise.all([t.landmarks,o,t.probability].map(async t=>t.array())),a=t.anchor,[c,l]=r,d=s.map(t=>[(t[0]+a[0])*c,(t[1]+a[1])*l]);n={topLeft:e.slice(0,2),bottomRight:e.slice(2),landmarks:d,probability:i},disposeBox(t.box),t.landmarks.dispose(),t.probability.dispose()}else{const t=await o.array();n={topLeft:t.slice(0,2),bottomRight:t.slice(2)}}return o.dispose(),s&&(n=flipFaceHorizontal(n,i)),n}))}}const BLAZEFACE_MODEL_URL="https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1";async function load({maxFaces:t=10,inputWidth:o=128,inputHeight:s=128,iouThreshold:e=.3,scoreThreshold:i=.75}={}){const n=await tfconv.loadGraphModel(BLAZEFACE_MODEL_URL,{fromTFHub:!0});return new BlazeFaceModel(n,o,s,t,e,i)}const MESH_ANNOTATIONS={silhouette:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyeUpper2:[113,225,224,223,222,221,189],rightEyeLower2:[226,31,228,229,230,231,232,233,244],rightEyeLower3:[143,111,117,118,119,120,121,128,245],rightEyebrowUpper:[156,70,63,105,66,107,55,193],rightEyebrowLower:[35,124,46,53,52,65],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyeUpper2:[342,445,444,443,442,441,413],leftEyeLower2:[446,261,448,449,450,451,452,453,464],leftEyeLower3:[372,340,346,347,348,349,350,357,465],leftEyebrowUpper:[383,300,293,334,296,336,285,417],leftEyebrowLower:[265,353,276,283,282,295],midwayBetweenEyes:[168],noseTip:[1],noseBottom:[2],noseRightCorner:[98],noseLeftCorner:[327],rightCheek:[205],leftCheek:[425]};function disposeBox$1(box){null!=box&&null!=box.startPoint&&(box.startEndTensor.dispose(),box.startPoint.dispose(),box.endPoint.dispose())}function createBox$1(startEndTensor,startPoint,endPoint){return{startEndTensor:startEndTensor,startPoint:null!=startPoint?startPoint:tf.slice(startEndTensor,[0,0],[-1,2]),endPoint:null!=endPoint?endPoint:tf.slice(startEndTensor,[0,2],[-1,2])}}function scaleBoxCoordinates(box,factor){const newStart=tf.mul(box.startPoint,factor),newEnd=tf.mul(box.endPoint,factor);return createBox$1(tf.concat2d([newStart,newEnd],1))}function getBoxSize(box){return tf.tidy(()=>{const diff=tf.sub(box.endPoint,box.startPoint);return tf.abs(diff)})}function getBoxCenter(box){return tf.tidy(()=>{const halfSize=tf.div(tf.sub(box.endPoint,box.startPoint),2);return tf.add(box.startPoint,halfSize)})}function cutBoxFromImageAndResize(box,image,cropSize){const height=image.shape[1],width=image.shape[2],xyxy=box.startEndTensor;return tf.tidy(()=>{const yxyx=tf.concat2d([xyxy.slice([0,1],[-1,1]),xyxy.slice([0,0],[-1,1]),xyxy.slice([0,3],[-1,1]),xyxy.slice([0,2],[-1,1])],0),roundedCoords=tf.div(yxyx.transpose(),[height,width,height,width]);return tf.image.cropAndResize(image,roundedCoords,[0],cropSize)})}function enlargeBox(box,factor=1.5){return tf.tidy(()=>{const center=getBoxCenter(box),size=getBoxSize(box),newSize=tf.mul(tf.div(size,2),factor),newStart=tf.sub(center,newSize),newEnd=tf.add(center,newSize);return createBox$1(tf.concat2d([newStart,newEnd],1),newStart,newEnd)})}const LANDMARKS_COUNT=468,UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD=.25;class Pipeline{constructor(boundingBoxDetector,meshDetector,meshWidth,meshHeight,maxContinuousChecks,maxFaces){this.regionsOfInterest=[],this.runsWithoutFaceDetector=0,this.boundingBoxDetector=boundingBoxDetector,this.meshDetector=meshDetector,this.meshWidth=meshWidth,this.meshHeight=meshHeight,this.maxContinuousChecks=maxContinuousChecks,this.maxFaces=maxFaces}async predict(input){if(this.shouldUpdateRegionsOfInterest()){const returnTensors=!0,annotateFace=!1,{boxes:boxes,scaleFactor:scaleFactor}=await this.boundingBoxDetector.getBoundingBoxes(input,returnTensors,annotateFace);if(0===boxes.length)return scaleFactor.dispose(),this.clearAllRegionsOfInterest(),null;const scaledBoxes=boxes.map(prediction=>enlargeBox(scaleBoxCoordinates(prediction,scaleFactor)));boxes.forEach(disposeBox$1),this.updateRegionsOfInterest(scaledBoxes),this.runsWithoutFaceDetector=0}else this.runsWithoutFaceDetector++;return tf.tidy(()=>this.regionsOfInterest.map((box,i)=>{const face=cutBoxFromImageAndResize(box,input,[this.meshHeight,this.meshWidth]).div(255),[,flag,coords]=this.meshDetector.predict(face),coordsReshaped=tf.reshape(coords,[-1,3]),normalizedBox=tf.div(getBoxSize(box),[this.meshWidth,this.meshHeight]),scaledCoords=tf.mul(coordsReshaped,normalizedBox.concat(tf.tensor2d([1],[1,1]),1)).add(box.startPoint.concat(tf.tensor2d([0],[1,1]),1)),landmarksBox=this.calculateLandmarksBoundingBox(scaledCoords),previousBox=this.regionsOfInterest[i];disposeBox$1(previousBox),this.regionsOfInterest[i]=landmarksBox;const prediction={coords:coordsReshaped,scaledCoords:scaledCoords,box:landmarksBox,flag:flag.squeeze()};return prediction}))}updateRegionsOfInterest(boxes){for(let i=0;i<boxes.length;i++){const box=boxes[i],previousBox=this.regionsOfInterest[i];let iou=0;if(previousBox&&previousBox.startPoint){const[boxStartX,boxStartY,boxEndX,boxEndY]=box.startEndTensor.arraySync()[0],[previousBoxStartX,previousBoxStartY,previousBoxEndX,previousBoxEndY]=previousBox.startEndTensor.arraySync()[0],xStartMax=Math.max(boxStartX,previousBoxStartX),yStartMax=Math.max(boxStartY,previousBoxStartY),xEndMin=Math.min(boxEndX,previousBoxEndX),yEndMin=Math.min(boxEndY,previousBoxEndY),intersection=(xEndMin-xStartMax)*(yEndMin-yStartMax),boxArea=(boxEndX-boxStartX)*(boxEndY-boxStartY),previousBoxArea=(previousBoxEndX-previousBoxStartX)*(previousBoxEndY-boxStartY);iou=intersection/(boxArea+previousBoxArea-intersection)}iou>UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD?disposeBox$1(box):(this.regionsOfInterest[i]=box,disposeBox$1(previousBox))}for(let i=boxes.length;i<this.regionsOfInterest.length;i++)disposeBox$1(this.regionsOfInterest[i]);this.regionsOfInterest=this.regionsOfInterest.slice(0,boxes.length)}clearRegionOfInterest(index){null!=this.regionsOfInterest[index]&&(disposeBox$1(this.regionsOfInterest[index]),this.regionsOfInterest=[...this.regionsOfInterest.slice(0,index),...this.regionsOfInterest.slice(index+1)])}clearAllRegionsOfInterest(){for(let i=0;i<this.regionsOfInterest.length;i++)disposeBox$1(this.regionsOfInterest[i]);this.regionsOfInterest=[]}shouldUpdateRegionsOfInterest(){const roisCount=this.regionsOfInterest.length,noROIs=0===roisCount;return 1===this.maxFaces||noROIs?noROIs:roisCount!==this.maxFaces&&this.runsWithoutFaceDetector>=this.maxContinuousChecks}calculateLandmarksBoundingBox(landmarks){const xs=landmarks.slice([0,0],[LANDMARKS_COUNT,1]),ys=landmarks.slice([0,1],[LANDMARKS_COUNT,1]),boxMinMax=tf.stack([xs.min(),ys.min(),xs.max(),ys.max()]),box=createBox$1(boxMinMax.expandDims(0));return enlargeBox(box)}}const FACEMESH_GRAPHMODEL_PATH="https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1",MESH_MODEL_INPUT_WIDTH=192,MESH_MODEL_INPUT_HEIGHT=192;async function load$1({maxContinuousChecks:maxContinuousChecks=5,detectionConfidence:detectionConfidence=.9,maxFaces:maxFaces=10,iouThreshold:iouThreshold=.3,scoreThreshold:scoreThreshold=.75}={}){const[blazeFace,blazeMeshModel]=await Promise.all([loadDetectorModel(maxFaces,iouThreshold,scoreThreshold),loadMeshModel()]),faceMesh=new FaceMesh(blazeFace,blazeMeshModel,maxContinuousChecks,detectionConfidence,maxFaces);return faceMesh}async function loadDetectorModel(maxFaces,iouThreshold,scoreThreshold){return load({maxFaces:maxFaces,iouThreshold:iouThreshold,scoreThreshold:scoreThreshold})}async function loadMeshModel(){return tfconv.loadGraphModel(FACEMESH_GRAPHMODEL_PATH,{fromTFHub:!0})}function getInputTensorDimensions$1(input){return input instanceof tf.Tensor?[input.shape[0],input.shape[1]]:[input.height,input.width]}function flipFaceHorizontal$1(face,imageWidth){if(face.mesh instanceof tf.Tensor){const[topLeft,bottomRight,mesh,scaledMesh]=tf.tidy(()=>{const subtractBasis=tf.tensor1d([imageWidth-1,0,0]),multiplyBasis=tf.tensor1d([1,-1,1]);return tf.tidy(()=>[tf.concat([tf.sub(imageWidth-1,face.boundingBox.topLeft.slice(0,1)),face.boundingBox.topLeft.slice(1,1)]),tf.concat([tf.sub(imageWidth-1,face.boundingBox.bottomRight.slice(0,1)),face.boundingBox.bottomRight.slice(1,1)]),tf.sub(subtractBasis,face.mesh).mul(multiplyBasis),tf.sub(subtractBasis,face.scaledMesh).mul(multiplyBasis)])});return Object.assign({},face,{boundingBox:{topLeft:topLeft,bottomRight:bottomRight},mesh:mesh,scaledMesh:scaledMesh})}return Object.assign({},face,{boundingBox:{topLeft:[imageWidth-1-face.boundingBox.topLeft[0],face.boundingBox.topLeft[1]],bottomRight:[imageWidth-1-face.boundingBox.bottomRight[0],face.boundingBox.bottomRight[1]]},mesh:face.mesh.map(coord=>{const flippedCoord=coord.slice(0);return flippedCoord[0]=imageWidth-1-coord[0],flippedCoord}),scaledMesh:face.scaledMesh.map(coord=>{const flippedCoord=coord.slice(0);return flippedCoord[0]=imageWidth-1-coord[0],flippedCoord})})}class FaceMesh{constructor(blazeFace,blazeMeshModel,maxContinuousChecks,detectionConfidence,maxFaces){this.pipeline=new Pipeline(blazeFace,blazeMeshModel,MESH_MODEL_INPUT_WIDTH,MESH_MODEL_INPUT_HEIGHT,maxContinuousChecks,maxFaces),this.detectionConfidence=detectionConfidence}static getAnnotations(){return MESH_ANNOTATIONS}async estimateFaces(input,returnTensors=!1,flipHorizontal=!1){const[,width]=getInputTensorDimensions$1(input),image=tf.tidy(()=>(input instanceof tf.Tensor||(input=tf.browser.fromPixels(input)),input.toFloat().expandDims(0))),savedWebglPackDepthwiseConvFlag=tf.env().get("WEBGL_PACK_DEPTHWISECONV");tf.env().set("WEBGL_PACK_DEPTHWISECONV",!0);const predictions=await this.pipeline.predict(image);return tf.env().set("WEBGL_PACK_DEPTHWISECONV",savedWebglPackDepthwiseConvFlag),image.dispose(),null!=predictions&&predictions.length>0?Promise.all(predictions.map(async(prediction,i)=>{const{coords:coords,scaledCoords:scaledCoords,box:box,flag:flag}=prediction;let tensorsToRead=[flag];returnTensors||(tensorsToRead=tensorsToRead.concat([coords,scaledCoords,box.startPoint,box.endPoint]));const tensorValues=await Promise.all(tensorsToRead.map(async d=>d.array())),flagValue=tensorValues[0];if(flag.dispose(),flagValue<this.detectionConfidence&&this.pipeline.clearRegionOfInterest(i),returnTensors){const annotatedPrediction={faceInViewConfidence:flagValue,mesh:coords,scaledMesh:scaledCoords,boundingBox:{topLeft:box.startPoint.squeeze(),bottomRight:box.endPoint.squeeze()}};return flipHorizontal?flipFaceHorizontal$1(annotatedPrediction,width):annotatedPrediction}const[coordsArr,coordsArrScaled,topLeft,bottomRight]=tensorValues.slice(1);scaledCoords.dispose(),coords.dispose();let annotatedPrediction={faceInViewConfidence:flagValue,boundingBox:{topLeft:topLeft,bottomRight:bottomRight},mesh:coordsArr,scaledMesh:coordsArrScaled};flipHorizontal&&(annotatedPrediction=flipFaceHorizontal$1(annotatedPrediction,width));const annotations={};for(const key in MESH_ANNOTATIONS)annotations[key]=MESH_ANNOTATIONS[key].map(index=>annotatedPrediction.scaledMesh[index]);return annotatedPrediction.annotations=annotations,annotatedPrediction})):[]}}exports.load=load$1,exports.FaceMesh=FaceMesh,Object.defineProperty(exports,"__esModule",{value:!0})}),window.requestAnimFrame=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(callback,element){return window.setTimeout(callback,1e3/60)},window.cancelRequestAnimFrame=window.cancelCancelRequestAnimationFrame||window.webkitCancelRequestAnimationFrame||window.mozCancelRequestAnimationFrame||window.oCancelRequestAnimationFrame||window.msCancelRequestAnimationFrame||window.clearTimeout,function(window){"use strict";window.webgazer=window.webgazer||{},webgazer.tracker=webgazer.tracker||{};var TFFaceMesh=function(){this.model=facemesh.load({maxFaces:1}),this.predictionReady=!1};webgazer.tracker.TFFaceMesh=TFFaceMesh,TFFaceMesh.prototype.positionsArray=null,TFFaceMesh.prototype.getEyePatches=async function(imageCanvas,width,height){if(0===imageCanvas.width)return null;const model=await this.model,predictions=await model.estimateFaces(imageCanvas);if(0==predictions.length)return!1;this.positionsArray=predictions[0].scaledMesh;const positions=this.positionsArray;var leftOriginX=Math.round(Math.min(positions[247][0],positions[130][0],positions[25][0])),leftOriginY=Math.round(Math.min(positions[247][1],positions[27][1],positions[190][1])),leftWidth=Math.round(Math.max(positions[190][0],positions[243][0],positions[233][0])-leftOriginX),leftHeight=Math.round(Math.max(positions[25][1],positions[23][1],positions[112][1])-leftOriginY),rightOriginX=Math.round(Math.min(positions[414][0],positions[463][0],positions[453][0])),rightOriginY=Math.round(Math.min(positions[414][1],positions[257][1],positions[467][1])),rightWidth=Math.round(Math.max(positions[467][0],positions[359][0],positions[255][0])-rightOriginX),rightHeight=Math.round(Math.max(positions[341][1],positions[253][1],positions[255][1])-rightOriginY);if(0===leftWidth||0===rightWidth)return console.log("an eye patch had zero width"),null;if(0===leftHeight||0===rightHeight)return console.log("an eye patch had zero height"),null;var eyeObjs={},leftImageData=imageCanvas.getContext("2d").getImageData(leftOriginX,leftOriginY,leftWidth,leftHeight);eyeObjs.left={patch:leftImageData,imagex:leftOriginX,imagey:leftOriginY,width:leftWidth,height:leftHeight};var rightImageData=imageCanvas.getContext("2d").getImageData(rightOriginX,rightOriginY,rightWidth,rightHeight);return eyeObjs.right={patch:rightImageData,imagex:rightOriginX,imagey:rightOriginY,width:rightWidth,height:rightHeight},this.predictionReady=!0,eyeObjs},TFFaceMesh.prototype.getPositions=function(){return this.positionsArray},TFFaceMesh.prototype.reset=function(){console.log("Unimplemented; Tracking.js has no obvious reset function")},TFFaceMesh.prototype.drawFaceOverlay=function(ctx,keypoints){if(keypoints){ctx.fillStyle="#32EEDB",ctx.strokeStyle="#32EEDB",ctx.lineWidth=.5;for(let i=0;i<keypoints.length;i++){const x=keypoints[i][0],y=keypoints[i][1];ctx.beginPath(),ctx.arc(x,y,1,0,2*Math.PI),ctx.closePath(),ctx.fill()}}},TFFaceMesh.prototype.name="TFFaceMesh"}(window),function(){"use strict";self.webgazer=self.webgazer||{},self.webgazer.mat=self.webgazer.mat||{},self.webgazer.mat.transpose=function(matrix){for(var m=matrix.length,n=matrix[0].length,transposedMatrix=new Array(n),i=0;i<m;i++)for(var j=0;j<n;j++)0===i&&(transposedMatrix[j]=new Array(m)),transposedMatrix[j][i]=matrix[i][j];return transposedMatrix},self.webgazer.mat.getMatrix=function(matrix,r,j0,j1){for(var X=new Array(r.length),m=j1-j0+1,i=0;i<r.length;i++){X[i]=new Array(m);for(var j=j0;j<=j1;j++)X[i][j-j0]=matrix[r[i]][j]}return X},self.webgazer.mat.getSubMatrix=function(matrix,i0,i1,j0,j1){for(var size=j1-j0+1,X=new Array(i1-i0+1),i=i0;i<=i1;i++){var subI=i-i0;X[subI]=new Array(size);for(var j=j0;j<=j1;j++)X[subI][j-j0]=matrix[i][j]}return X},self.webgazer.mat.mult=function(matrix1,matrix2){matrix2.length!=matrix1[0].length&&console.log("Matrix inner dimensions must agree:");for(var X=new Array(matrix1.length),Bcolj=new Array(matrix1[0].length),j=0;j<matrix2[0].length;j++){for(var k=0;k<matrix1[0].length;k++)Bcolj[k]=matrix2[k][j];for(var i=0;i<matrix1.length;i++){0===j&&(X[i]=new Array(matrix2[0].length));for(var Arowi=matrix1[i],s=0,k=0;k<matrix1[0].length;k++)s+=Arowi[k]*Bcolj[k];X[i][j]=s}}return X},self.webgazer.mat.LUDecomposition=function(A,B){for(var LU=new Array(A.length),i=0;i<A.length;i++){LU[i]=new Array(A[0].length);for(var j=0;j<A[0].length;j++)LU[i][j]=A[i][j]}for(var m=A.length,n=A[0].length,piv=new Array(m),i=0;i<m;i++)piv[i]=i;for(var pivsign=1,LUrowi=new Array,LUcolj=new Array(m),j=0;j<n;j++){for(var i=0;i<m;i++)LUcolj[i]=LU[i][j];for(var i=0;i<m;i++){LUrowi=LU[i];for(var kmax=Math.min(i,j),s=0,k=0;k<kmax;k++)s+=LUrowi[k]*LUcolj[k];LUrowi[j]=LUcolj[i]-=s}for(var p=j,i=j+1;i<m;i++)Math.abs(LUcolj[i])>Math.abs(LUcolj[p])&&(p=i);if(p!=j){for(var k=0;k<n;k++){var t=LU[p][k];LU[p][k]=LU[j][k],LU[j][k]=t}var k=piv[p];piv[p]=piv[j],piv[j]=k,pivsign=-pivsign}if(j<m&0!=LU[j][j])for(var i=j+1;i<m;i++)LU[i][j]/=LU[j][j]}B.length!=m&&console.log("Matrix row dimensions must agree.");for(var j=0;j<n;j++)0===LU[j][j]&&console.log("Matrix is singular.");for(var nx=B[0].length,X=self.webgazer.mat.getMatrix(B,piv,0,nx-1),k=0;k<n;k++)for(var i=k+1;i<n;i++)for(var j=0;j<nx;j++)X[i][j]-=X[k][j]*LU[i][k];for(var k=n-1;k>=0;k--){for(var j=0;j<nx;j++)X[k][j]/=LU[k][k];for(var i=0;i<k;i++)for(var j=0;j<nx;j++)X[i][j]-=X[k][j]*LU[i][k]}return X},self.webgazer.mat.QRDecomposition=function(A,B){for(var QR=new Array(A.length),i=0;i<A.length;i++){QR[i]=new Array(A[0].length);for(var j=0;j<A[0].length;j++)QR[i][j]=A[i][j]}for(var m=A.length,n=A[0].length,Rdiag=new Array(n),nrm,k=0;k<n;k++){nrm=0;for(var i=k;i<m;i++)nrm=Math.hypot(nrm,QR[i][k]);if(0!=nrm){QR[k][k]<0&&(nrm=-nrm);for(var i=k;i<m;i++)QR[i][k]/=nrm;QR[k][k]+=1;for(var j=k+1;j<n;j++){for(var s=0,i=k;i<m;i++)s+=QR[i][k]*QR[i][j];s=-s/QR[k][k];for(var i=k;i<m;i++)QR[i][j]+=s*QR[i][k]}}Rdiag[k]=-nrm}B.length!=m&&console.log("Matrix row dimensions must agree.");for(var j=0;j<n;j++)0===Rdiag[j]&&console.log("Matrix is rank deficient");for(var nx=B[0].length,X=new Array(B.length),i=0;i<B.length;i++)X[i]=new Array(B[0].length);for(var i=0;i<B.length;i++)for(var j=0;j<B[0].length;j++)X[i][j]=B[i][j];for(var k=0;k<n;k++)for(var j=0;j<nx;j++){for(var s=0,i=k;i<m;i++)s+=QR[i][k]*X[i][j];s=-s/QR[k][k];for(var i=k;i<m;i++)X[i][j]+=s*QR[i][k]}for(var k=n-1;k>=0;k--){for(var j=0;j<nx;j++)X[k][j]/=Rdiag[k];for(var i=0;i<k;i++)for(var j=0;j<nx;j++)X[i][j]-=X[k][j]*QR[i][k]}return self.webgazer.mat.getSubMatrix(X,0,n-1,0,nx-1)}}(),function(window){window.webgazer=window.webgazer||{},webgazer.pupil=webgazer.pupil||{};var getValue=function(pixels,x,y,width){return pixels[y*width+x]},getSumTable=function(pixels,width,height){for(var integralImage=new Array(width),sumx=0,sumy=0,i=0;i<width;i++)integralImage[i]=new Array(height),sumx+=getValue(pixels,i,0,width),integralImage[i][0]=sumx;for(var i=0;i<height;i++)sumy+=getValue(pixels,0,i,width),integralImage[0][i]=sumy;for(var x=1;x<width;x++)for(var y=1;y<height;y++)integralImage[x][y]=getValue(pixels,x,y,width)+integralImage[x-1][y]+integralImage[x][y-1]-integralImage[x-1][y-1];return integralImage},getSinglePupil=function(pixels,width,height){for(var summedAreaTable=getSumTable(pixels,width,height),bestAvgScore=999999,bestPoint=[0,0],bestHalfWidth=0,offset=Math.floor(width/10),halfWidth=Math.floor(height/10);halfWidth<width/2;halfWidth++)for(var x=halfWidth;x<width-offset;x++)for(var y=halfWidth;y<height-offset;y++){var irisArea=summedAreaTable[x+offset][y+offset]+summedAreaTable[x+offset-halfWidth][y+offset-halfWidth]-summedAreaTable[x+offset][y+offset-halfWidth]-summedAreaTable[x+offset-halfWidth][y+offset],avgScore=1*irisArea/((halfWidth+1)*(halfWidth+1))+1,scleraIrisArea=1*summedAreaTable[width-1-offset][y+offset]+summedAreaTable[0+offset][y+offset-halfWidth]-summedAreaTable[0+offset][y+offset]-summedAreaTable[width-1-offset][y+offset-halfWidth]-irisArea;avgScore/scleraIrisArea<bestAvgScore&&avgScore<150&&(bestAvgScore=avgScore/scleraIrisArea,bestPoint=[x+offset,y+offset],bestHalfWidth=halfWidth)}return[bestPoint,bestHalfWidth]};webgazer.pupil.getPupils=function(eyesObj){return eyesObj?(eyesObj.left.blink||(eyesObj.left.pupil=getSinglePupil(Array.prototype.slice.call(webgazer.util.grayscale(eyesObj.left.patch.data,eyesObj.left.width,eyesObj.left.height)),eyesObj.left.width,eyesObj.left.height),eyesObj.left.pupil[0][0]-=eyesObj.left.pupil[1],eyesObj.left.pupil[0][1]-=eyesObj.left.pupil[1]),eyesObj.right.blink||(eyesObj.right.pupil=getSinglePupil(Array.prototype.slice.call(webgazer.util.grayscale(eyesObj.right.patch.data,eyesObj.right.width,eyesObj.right.height)),eyesObj.right.width,eyesObj.right.height),eyesObj.right.pupil[0][0]-=eyesObj.right.pupil[1],eyesObj.right.pupil[0][1]-=eyesObj.right.pupil[1]),eyesObj):eyesObj}}(window),function(){"use strict";var gaussianElimination=function(a,o){var i=0,j=0,k=0,maxrow=0,tmp=0,n=a.length-1,x=new Array(o);for(i=0;i<n;i++){for(maxrow=i,j=i+1;j<n;j++)Math.abs(a[i][j])>Math.abs(a[i][maxrow])&&(maxrow=j);for(k=i;k<n+1;k++)tmp=a[k][i],a[k][i]=a[k][maxrow],a[k][maxrow]=tmp;for(j=i+1;j<n;j++)for(k=n;k>=i;k--)a[k][j]-=a[k][i]*a[i][j]/a[i][i]}for(j=n-1;j>=0;j--){for(tmp=0,k=j+1;k<n;k++)tmp+=a[k][j]*x[k];x[j]=(a[n][j]-tmp)/a[j][j]}return x},methods={linear:function(data){for(var sum=[0,0,0,0,0],n=0,results=[];n<data.length;n++)null!=data[n][1]&&(sum[0]+=data[n][0],sum[1]+=data[n][1],sum[2]+=data[n][0]*data[n][0],sum[3]+=data[n][0]*data[n][1],sum[4]+=data[n][1]*data[n][1]);for(var gradient=(n*sum[3]-sum[0]*sum[1])/(n*sum[2]-sum[0]*sum[0]),intercept=sum[1]/n-gradient*sum[0]/n,i=0,len=data.length;i<len;i++){var coordinate=[data[i][0],data[i][0]*gradient+intercept];results.push(coordinate)}var string;return{equation:[gradient,intercept],points:results,string:"y = "+Math.round(100*gradient)/100+"x + "+Math.round(100*intercept)/100}},linearThroughOrigin:function(data){for(var sum=[0,0],n=0,results=[];n<data.length;n++)null!=data[n][1]&&(sum[0]+=data[n][0]*data[n][0],sum[1]+=data[n][0]*data[n][1]);for(var gradient=sum[1]/sum[0],i=0,len=data.length;i<len;i++){var coordinate=[data[i][0],data[i][0]*gradient];results.push(coordinate)}var string;return{equation:[gradient],points:results,string:"y = "+Math.round(100*gradient)/100+"x"}},exponential:function(data){var sum=[0,0,0,0,0,0],n=0,results=[],string;for(len=data.length;n<len;n++)null!=data[n][1]&&(sum[0]+=data[n][0],sum[1]+=data[n][1],sum[2]+=data[n][0]*data[n][0]*data[n][1],sum[3]+=data[n][1]*Math.log(data[n][1]),sum[4]+=data[n][0]*data[n][1]*Math.log(data[n][1]),sum[5]+=data[n][0]*data[n][1]);for(var denominator=sum[1]*sum[2]-sum[5]*sum[5],A=Math.pow(Math.E,(sum[2]*sum[3]-sum[5]*sum[4])/denominator),B=(sum[1]*sum[4]-sum[5]*sum[3])/denominator,i=0,len=data.length;i<len;i++){var coordinate=[data[i][0],A*Math.pow(Math.E,B*data[i][0])];results.push(coordinate)}return{equation:[A,B],points:results,string:"y = "+Math.round(100*A)/100+"e^("+Math.round(100*B)/100+"x)"}},logarithmic:function(data){var sum=[0,0,0,0],n=0,results=[],string;for(len=data.length;n<len;n++)null!=data[n][1]&&(sum[0]+=Math.log(data[n][0]),sum[1]+=data[n][1]*Math.log(data[n][0]),sum[2]+=data[n][1],sum[3]+=Math.pow(Math.log(data[n][0]),2));for(var B=(n*sum[1]-sum[2]*sum[0])/(n*sum[3]-sum[0]*sum[0]),A=(sum[2]-B*sum[0])/n,i=0,len=data.length;i<len;i++){var coordinate=[data[i][0],A+B*Math.log(data[i][0])];results.push(coordinate)}return{equation:[A,B],points:results,string:"y = "+Math.round(100*A)/100+" + "+Math.round(100*B)/100+" ln(x)"}},power:function(data){var sum=[0,0,0,0],n=0,results=[],string;for(len=data.length;n<len;n++)null!=data[n][1]&&(sum[0]+=Math.log(data[n][0]),sum[1]+=Math.log(data[n][1])*Math.log(data[n][0]),sum[2]+=Math.log(data[n][1]),sum[3]+=Math.pow(Math.log(data[n][0]),2));for(var B=(n*sum[1]-sum[2]*sum[0])/(n*sum[3]-sum[0]*sum[0]),A=Math.pow(Math.E,(sum[2]-B*sum[0])/n),i=0,len=data.length;i<len;i++){var coordinate=[data[i][0],A*Math.pow(data[i][0],B)];results.push(coordinate)}return{equation:[A,B],points:results,string:"y = "+Math.round(100*A)/100+"x^"+Math.round(100*B)/100}},polynomial:function(data,order){void 0===order&&(order=2);for(var lhs=[],rhs=[],results=[],a=0,b=0,i=0,k=order+1;i<k;i++){for(var l=0,len=data.length;l<len;l++)null!=data[l][1]&&(a+=Math.pow(data[l][0],i)*data[l][1]);lhs.push(a),a=0;for(var c=[],j=0;j<k;j++){for(var l=0,len=data.length;l<len;l++)null!=data[l][1]&&(b+=Math.pow(data[l][0],i+j));c.push(b),b=0}rhs.push(c)}rhs.push(lhs);for(var equation=gaussianElimination(rhs,k),i=0,len=data.length;i<len;i++){for(var answer=0,w=0;w<equation.length;w++)answer+=equation[w]*Math.pow(data[i][0],w);results.push([data[i][0],answer])}for(var string="y = ",i=equation.length-1;i>=0;i--)string+=i>1?Math.round(equation[i]*Math.pow(10,i))/Math.pow(10,i)+"x^"+i+" + ":1===i?Math.round(100*equation[i])/100+"x + ":Math.round(100*equation[i])/100;return{equation:equation,points:results,string:string}},lastvalue:function(data){for(var results=[],lastvalue=null,i=0;i<data.length;i++)data[i][1]?(lastvalue=data[i][1],results.push([data[i][0],data[i][1]])):results.push([data[i][0],lastvalue]);return{equation:[lastvalue],points:results,string:""+lastvalue}}},regression=function(method,data,order){if("string"==typeof method)return methods[method](data,order)};"undefined"!=typeof exports?module.exports=regression:window.regression=regression}(),function(window){window.webgazer=window.webgazer||{},webgazer.reg=webgazer.reg||{},webgazer.mat=webgazer.mat||{},webgazer.util=webgazer.util||{},webgazer.params=webgazer.params||{};var ridgeParameter=Math.pow(10,-5),resizeWidth=10,resizeHeight=6,dataWindow=700,trailDataWindow=10;function ridge(y,X,k){var nc=X[0].length,m_Coefficients=new Array(nc),xt=webgazer.mat.transpose(X),solution=new Array,success=!0;do{for(var ss=webgazer.mat.mult(xt,X),i=0;i<nc;i++)ss[i][i]=ss[i][i]+k;for(var bb=webgazer.mat.mult(xt,y),i=0;i<nc;i++)m_Coefficients[i]=bb[i][0];try{var n=0!==m_Coefficients.length?m_Coefficients.length/m_Coefficients.length:0;m_Coefficients.length*n!==m_Coefficients.length&&console.log("Array length must be a multiple of m"),solution=ss.length===ss[0].length?numeric.LUsolve(numeric.LU(ss,!0),bb):webgazer.mat.QRDecomposition(ss,bb);for(var i=0;i<nc;i++)m_Coefficients[i]=solution[i];success=!0}catch(ex){k*=10,console.log(ex),success=!1}}while(!success);return m_Coefficients}function getEyeFeats(eyes){var resizedLeft=webgazer.util.resizeEye(eyes.left,resizeWidth,resizeHeight),resizedright=webgazer.util.resizeEye(eyes.right,resizeWidth,resizeHeight),leftGray=webgazer.util.grayscale(resizedLeft.data,resizedLeft.width,resizedLeft.height),rightGray=webgazer.util.grayscale(resizedright.data,resizedright.width,resizedright.height),histLeft=[];webgazer.util.equalizeHistogram(leftGray,5,histLeft);var histRight=[];webgazer.util.equalizeHistogram(rightGray,5,histRight);var leftGrayArray=Array.prototype.slice.call(histLeft),rightGrayArray=Array.prototype.slice.call(histRight);return leftGrayArray.concat(rightGrayArray)}function getCurrentFixationIndex(){for(var index=0,recentX=this.screenXTrailArray.get(0),recentY=this.screenYTrailArray.get(0),i=this.screenXTrailArray.length-1;i>=0;i--){var currX=this.screenXTrailArray.get(i),currY=this.screenYTrailArray.get(i),euclideanDistance;if(Math.sqrt(Math.pow(currX-recentX,2)+Math.pow(currY-recentY,2))>72)return i+1}return i}webgazer.reg.RidgeReg=function(){this.init()},webgazer.reg.RidgeReg.prototype.init=function(){this.screenXClicksArray=new webgazer.util.DataWindow(700),this.screenYClicksArray=new webgazer.util.DataWindow(700),this.eyeFeaturesClicks=new webgazer.util.DataWindow(700),this.trailTime=1e3,this.trailDataWindow=this.trailTime/webgazer.params.moveTickSize,this.screenXTrailArray=new webgazer.util.DataWindow(10),this.screenYTrailArray=new webgazer.util.DataWindow(10),this.eyeFeaturesTrail=new webgazer.util.DataWindow(10),this.trailTimes=new webgazer.util.DataWindow(10),this.dataClicks=new webgazer.util.DataWindow(700),this.dataTrail=new webgazer.util.DataWindow(10);var F=[[1,0,1,0],[0,1,0,1],[0,0,1,0],[0,0,0,1]],Q=[[.25,0,.5,0],[0,.25,0,.5],[.5,0,1,0],[0,.5,0,1]],delta_t=.1;Q=numeric.mul(Q,.1);var H=[[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,0,0]],H=[[1,0,0,0],[0,1,0,0]],pixel_error=47,R=numeric.mul(numeric.identity(2),47),P_initial=numeric.mul(numeric.identity(4),1e-4),x_initial=[[500],[500],[0],[0]];this.kalman=new self.webgazer.util.KalmanFilter(F,H,Q,R,P_initial,x_initial)},webgazer.reg.RidgeReg.prototype.addData=function(eyes,screenPos,type){eyes&&(eyes.left.blink||eyes.right.blink||("click"===type?(this.screenXClicksArray.push([screenPos[0]]),this.screenYClicksArray.push([screenPos[1]]),this.eyeFeaturesClicks.push(getEyeFeats(eyes)),this.dataClicks.push({eyes:eyes,screenPos:screenPos,type:type})):"move"===type&&(this.screenXTrailArray.push([screenPos[0]]),this.screenYTrailArray.push([screenPos[1]]),this.eyeFeaturesTrail.push(getEyeFeats(eyes)),this.trailTimes.push(performance.now()),this.dataTrail.push({eyes:eyes,screenPos:screenPos,type:type}))))},webgazer.reg.RidgeReg.prototype.predict=function(eyesObj){if(!eyesObj||0===this.eyeFeaturesClicks.length)return null;for(var acceptTime=performance.now()-this.trailTime,trailX=[],trailY=[],trailFeat=[],i=0;i<this.trailDataWindow;i++)this.trailTimes.get(i)>acceptTime&&(trailX.push(this.screenXTrailArray.get(i)),trailY.push(this.screenYTrailArray.get(i)),trailFeat.push(this.eyeFeaturesTrail.get(i)));for(var screenXArray=this.screenXClicksArray.data.concat(trailX),screenYArray=this.screenYClicksArray.data.concat(trailY),eyeFeatures=this.eyeFeaturesClicks.data.concat(trailFeat),coefficientsX=ridge(screenXArray,eyeFeatures,ridgeParameter),coefficientsY=ridge(screenYArray,eyeFeatures,ridgeParameter),eyeFeats=getEyeFeats(eyesObj),predictedX=0,i=0;i<eyeFeats.length;i++)predictedX+=eyeFeats[i]*coefficientsX[i];for(var predictedY=0,i=0;i<eyeFeats.length;i++)predictedY+=eyeFeats[i]*coefficientsY[i];if(predictedX=Math.floor(predictedX),predictedY=Math.floor(predictedY),window.applyKalmanFilter){var newGaze=[predictedX,predictedY];return{x:(newGaze=this.kalman.update(newGaze))[0],y:newGaze[1]}}return{x:predictedX,y:predictedY}},webgazer.reg.RidgeReg.prototype.setData=function(data){for(var i=0;i<data.length;i++){var leftData=new Uint8ClampedArray(data[i].eyes.left.patch.data),rightData=new Uint8ClampedArray(data[i].eyes.right.patch.data);data[i].eyes.left.patch=new ImageData(leftData,data[i].eyes.left.width,data[i].eyes.left.height),data[i].eyes.right.patch=new ImageData(rightData,data[i].eyes.right.width,data[i].eyes.right.height),this.addData(data[i].eyes,data[i].screenPos,data[i].type)}},webgazer.reg.RidgeReg.prototype.getData=function(){return this.dataClicks.data},webgazer.reg.RidgeReg.prototype.name="ridge"}(window),function(window){window.webgazer=window.webgazer||{},webgazer.reg=webgazer.reg||{},webgazer.mat=webgazer.mat||{},webgazer.util=webgazer.util||{},webgazer.params=webgazer.params||{};var ridgeParameter=Math.pow(10,-5),resizeWidth=10,resizeHeight=6,dataWindow=700,trailDataWindow=10;function ridge(y,X,k){var nc=X[0].length,m_Coefficients=new Array(nc),xt=webgazer.mat.transpose(X),solution=new Array,success=!0;do{for(var ss=webgazer.mat.mult(xt,X),i=0;i<nc;i++)ss[i][i]=ss[i][i]+k;for(var bb=webgazer.mat.mult(xt,y),i=0;i<nc;i++)m_Coefficients[i]=bb[i][0];try{var n=0!==m_Coefficients.length?m_Coefficients.length/m_Coefficients.length:0;m_Coefficients.length*n!==m_Coefficients.length&&console.log("Array length must be a multiple of m"),solution=ss.length===ss[0].length?numeric.LUsolve(numeric.LU(ss,!0),bb):webgazer.mat.QRDecomposition(ss,bb);for(var i=0;i<nc;i++)m_Coefficients[i]=solution[i];success=!0}catch(ex){k*=10,console.log(ex),success=!1}}while(!success);return m_Coefficients}function getEyeFeats(eyes){var resizedLeft=webgazer.util.resizeEye(eyes.left,resizeWidth,resizeHeight),resizedright=webgazer.util.resizeEye(eyes.right,resizeWidth,resizeHeight),leftGray=webgazer.util.grayscale(resizedLeft.data,resizedLeft.width,resizedLeft.height),rightGray=webgazer.util.grayscale(resizedright.data,resizedright.width,resizedright.height),histLeft=[];webgazer.util.equalizeHistogram(leftGray,5,histLeft);var histRight=[];webgazer.util.equalizeHistogram(rightGray,5,histRight);var leftGrayArray=Array.prototype.slice.call(histLeft),rightGrayArray=Array.prototype.slice.call(histRight);return leftGrayArray.concat(rightGrayArray)}function getCurrentFixationIndex(){for(var index=0,recentX=this.screenXTrailArray.get(0),recentY=this.screenYTrailArray.get(0),i=this.screenXTrailArray.length-1;i>=0;i--){var currX=this.screenXTrailArray.get(i),currY=this.screenYTrailArray.get(i),euclideanDistance;if(Math.sqrt(Math.pow(currX-recentX,2)+Math.pow(currY-recentY,2))>72)return i+1}return i}webgazer.reg.RidgeWeightedReg=function(){this.init()},webgazer.reg.RidgeReg.prototype.init=function(){this.screenXClicksArray=new webgazer.util.DataWindow(700),this.screenYClicksArray=new webgazer.util.DataWindow(700),this.eyeFeaturesClicks=new webgazer.util.DataWindow(700),this.trailTime=1e3,this.trailDataWindow=this.trailTime/webgazer.params.moveTickSize,this.screenXTrailArray=new webgazer.util.DataWindow(10),this.screenYTrailArray=new webgazer.util.DataWindow(10),this.eyeFeaturesTrail=new webgazer.util.DataWindow(10),this.trailTimes=new webgazer.util.DataWindow(10),this.dataClicks=new webgazer.util.DataWindow(700),this.dataTrail=new webgazer.util.DataWindow(10);var F=[[1,0,1,0],[0,1,0,1],[0,0,1,0],[0,0,0,1]],Q=[[.25,0,.5,0],[0,.25,0,.5],[.5,0,1,0],[0,.5,0,1]],delta_t=.1;Q=numeric.mul(Q,.1);var H=[[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,0,0]],H=[[1,0,0,0],[0,1,0,0]],pixel_error=47,R=numeric.mul(numeric.identity(2),47),P_initial=numeric.mul(numeric.identity(4),1e-4),x_initial=[[500],[500],[0],[0]];this.kalman=new self.webgazer.util.KalmanFilter(F,H,Q,R,P_initial,x_initial)},webgazer.reg.RidgeWeightedReg.prototype.addData=function(eyes,screenPos,type){eyes&&(eyes.left.blink||eyes.right.blink||("click"===type?(this.screenXClicksArray.push([screenPos[0]]),this.screenYClicksArray.push([screenPos[1]]),this.eyeFeaturesClicks.push(getEyeFeats(eyes)),this.dataClicks.push({eyes:eyes,screenPos:screenPos,type:type})):"move"===type&&(this.screenXTrailArray.push([screenPos[0]]),this.screenYTrailArray.push([screenPos[1]]),this.eyeFeaturesTrail.push(getEyeFeats(eyes)),this.trailTimes.push(performance.now()),this.dataTrail.push({eyes:eyes,screenPos:screenPos,type:type}))))},webgazer.reg.RidgeWeightedReg.prototype.predict=function(eyesObj){if(!eyesObj||0===this.eyeFeaturesClicks.length)return null;for(var acceptTime=performance.now()-this.trailTime,trailX=[],trailY=[],trailFeat=[],i=0;i<this.trailDataWindow;i++)this.trailTimes.get(i)>acceptTime&&(trailX.push(this.screenXTrailArray.get(i)),trailY.push(this.screenYTrailArray.get(i)),trailFeat.push(this.eyeFeaturesTrail.get(i)));for(var len=this.eyeFeaturesClicks.data.length,weightedEyeFeats=Array(len),weightedXArray=Array(len),weightedYArray=Array(len),i=0;i<len;i++){for(var weight=Math.sqrt(1/(len-i)),trueIndex=this.eyeFeaturesClicks.getTrueIndex(i),j=0;j<this.eyeFeaturesClicks.data[trueIndex].length;j++){var val=this.eyeFeaturesClicks.data[trueIndex][j]*weight;void 0!==weightedEyeFeats[trueIndex]?weightedEyeFeats[trueIndex].push(val):weightedEyeFeats[trueIndex]=[val]}weightedXArray[trueIndex]=this.screenXClicksArray.get(i).slice(0,this.screenXClicksArray.get(i).length),weightedYArray[trueIndex]=this.screenYClicksArray.get(i).slice(0,this.screenYClicksArray.get(i).length),weightedXArray[i][0]=weightedXArray[i][0]*weight,weightedYArray[i][0]=weightedYArray[i][0]*weight}for(var screenXArray=weightedXArray.concat(trailX),screenYArray=weightedYArray.concat(trailY),eyeFeatures=weightedEyeFeats.concat(trailFeat),coefficientsX=ridge(screenXArray,eyeFeatures,ridgeParameter),coefficientsY=ridge(screenYArray,eyeFeatures,ridgeParameter),eyeFeats=getEyeFeats(eyesObj),predictedX=0,i=0;i<eyeFeats.length;i++)predictedX+=eyeFeats[i]*coefficientsX[i];for(var predictedY=0,i=0;i<eyeFeats.length;i++)predictedY+=eyeFeats[i]*coefficientsY[i];if(predictedX=Math.floor(predictedX),predictedY=Math.floor(predictedY),window.applyKalmanFilter){var newGaze=[predictedX,predictedY];return{x:(newGaze=this.kalman.update(newGaze))[0],y:newGaze[1]}}return{x:predictedX,y:predictedY}},webgazer.reg.RidgeWeightedReg.prototype.setData=function(data){for(var i=0;i<data.length;i++){var leftData=new Uint8ClampedArray(data[i].eyes.left.patch.data),rightData=new Uint8ClampedArray(data[i].eyes.right.patch.data);data[i].eyes.left.patch=new ImageData(leftData,data[i].eyes.left.width,data[i].eyes.left.height),data[i].eyes.right.patch=new ImageData(rightData,data[i].eyes.right.width,data[i].eyes.right.height),this.addData(data[i].eyes,data[i].screenPos,data[i].type)}},webgazer.reg.RidgeWeightedReg.prototype.getData=function(){return this.dataClicks.data},webgazer.reg.RidgeWeightedReg.prototype.name="ridge"}(window),function(window){window.webgazer=window.webgazer||{},webgazer.reg=webgazer.reg||{},webgazer.mat=webgazer.mat||{},webgazer.util=webgazer.util||{};var ridgeParameter=Math.pow(10,-5),resizeWidth=10,resizeHeight=6,dataWindow=700,weights={X:[0],Y:[0]},trailDataWindow=10;function getEyeFeats(eyes){var resizedLeft=webgazer.util.resizeEye(eyes.left,resizeWidth,resizeHeight),resizedright=webgazer.util.resizeEye(eyes.right,resizeWidth,resizeHeight),leftGray=webgazer.util.grayscale(resizedLeft.data,resizedLeft.width,resizedLeft.height),rightGray=webgazer.util.grayscale(resizedright.data,resizedright.width,resizedright.height),histLeft=[];webgazer.util.equalizeHistogram(leftGray,5,histLeft);var histRight=[];webgazer.util.equalizeHistogram(rightGray,5,histRight);var leftGrayArray=Array.prototype.slice.call(histLeft),rightGrayArray=Array.prototype.slice.call(histRight);return leftGrayArray.concat(rightGrayArray)}webgazer.reg.RidgeRegThreaded=function(){this.init()},webgazer.reg.RidgeRegThreaded.prototype.init=function(){this.screenXClicksArray=new webgazer.util.DataWindow(700),this.screenYClicksArray=new webgazer.util.DataWindow(700),this.eyeFeaturesClicks=new webgazer.util.DataWindow(700),this.screenXTrailArray=new webgazer.util.DataWindow(10),this.screenYTrailArray=new webgazer.util.DataWindow(10),this.eyeFeaturesTrail=new webgazer.util.DataWindow(10),this.dataClicks=new webgazer.util.DataWindow(700),this.dataTrail=new webgazer.util.DataWindow(700),this.worker=new Worker("ridgeWorker.js"),this.worker.onerror=function(err){console.log(err.message)},this.worker.onmessage=function(evt){weights.X=evt.data.X,weights.Y=evt.data.Y};var F=[[1,0,1,0],[0,1,0,1],[0,0,1,0],[0,0,0,1]],Q=[[.25,0,.5,0],[0,.25,0,.5],[.5,0,1,0],[0,.5,0,1]],delta_t=.1;Q=numeric.mul(Q,.1);var H=[[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,0,0]],H=[[1,0,0,0],[0,1,0,0]],pixel_error=47,R=numeric.mul(numeric.identity(2),47),P_initial=numeric.mul(numeric.identity(4),1e-4),x_initial=[[500],[500],[0],[0]];this.kalman=new self.webgazer.util.KalmanFilter(F,H,Q,R,P_initial,x_initial)},webgazer.reg.RidgeRegThreaded.prototype.addData=function(eyes,screenPos,type){eyes&&(eyes.left.blink||eyes.right.blink||this.worker.postMessage({eyes:getEyeFeats(eyes),screenPos:screenPos,type:type}))},webgazer.reg.RidgeRegThreaded.prototype.predict=function(eyesObj){if(console.log("LOGGING.."),!eyesObj)return null;for(var coefficientsX=weights.X,coefficientsY=weights.Y,eyeFeats=getEyeFeats(eyesObj),predictedX=0,predictedY=0,i=0;i<eyeFeats.length;i++)predictedX+=eyeFeats[i]*coefficientsX[i],predictedY+=eyeFeats[i]*coefficientsY[i];if(predictedX=Math.floor(predictedX),predictedY=Math.floor(predictedY),window.applyKalmanFilter){var newGaze=[predictedX,predictedY];return newGaze=this.kalman.update(newGaze),console.log("Filtered Predicted X,Y"),console.log(newGaze[0]),console.log(newGaze[1]),{x:newGaze[0],y:newGaze[1]}}return console.log("Predicted X,Y"),console.log(predictedX),console.log(predictedY),{x:predictedX,y:predictedY}},webgazer.reg.RidgeRegThreaded.prototype.setData=function(data){for(var i=0;i<data.length;i++){var leftData=new Uint8ClampedArray(data[i].eyes.left.patch.data),rightData=new Uint8ClampedArray(data[i].eyes.right.patch.data);data[i].eyes.left.patch=new ImageData(leftData,data[i].eyes.left.width,data[i].eyes.left.height),data[i].eyes.right.patch=new ImageData(rightData,data[i].eyes.right.width,data[i].eyes.right.height),this.addData(data[i].eyes,data[i].screenPos,data[i].type)}},webgazer.reg.RidgeRegThreaded.prototype.getData=function(){return this.dataClicks.data},webgazer.reg.RidgeRegThreaded.prototype.name="ridge"}(window),function(){function debugBoxWrite(para,stats){var str="";for(var key in stats)str+=key+": "+stats[key]+"\n";para.innerText=str}self.webgazer=self.webgazer||{},self.webgazer.util=self.webgazer.util||{},self.webgazer.mat=self.webgazer.mat||{},self.webgazer.util.Eye=function(patch,imagex,imagey,width,height){this.patch=patch,this.imagex=imagex,this.imagey=imagey,this.width=width,this.height=height},self.webgazer.util.DataWindow=function(windowSize,data){this.data=[],this.windowSize=windowSize,this.index=0,this.length=0,data&&(this.data=data.slice(data.length-windowSize,data.length),this.length=this.data.length)},self.webgazer.util.DataWindow.prototype.push=function(entry){return this.data.length<this.windowSize?(this.data.push(entry),this.length=this.data.length,this):(this.data[this.index]=entry,this.index=(this.index+1)%this.windowSize,this)},self.webgazer.util.DataWindow.prototype.get=function(ind){return this.data[this.getTrueIndex(ind)]},self.webgazer.util.DataWindow.prototype.getTrueIndex=function(ind){return this.data.length<this.windowSize?ind:(ind+this.index)%this.windowSize},self.webgazer.util.DataWindow.prototype.addAll=function(data){for(var i=0;i<data.length;i++)this.push(data[i])},self.webgazer.util.grayscale=function(pixels,width,height){for(var gray=new Uint8ClampedArray(pixels.length>>2),p=0,w=0,i=0;i<height;i++)for(var j=0;j<width;j++){var value=.299*pixels[w]+.587*pixels[w+1]+.114*pixels[w+2];gray[p++]=value,w+=4}return gray},self.webgazer.util.equalizeHistogram=function(src,step,dst){var srcLength=src.length;dst||(dst=src),step||(step=5);for(var hist=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],i=0;i<srcLength;i+=step)++hist[src[i]];for(var norm=255*step/srcLength,prev=0,i=0;i<256;++i){var h=hist[i];prev=h+=prev,hist[i]=h*norm}for(var i=0;i<srcLength;++i)dst[i]=hist[src[i]];return dst},self.webgazer.util.threshold=function(data,threshold){for(let i=0;i<data.length;i++)data[i]=data[i]>threshold?255:0;return data},self.webgazer.util.correlation=function(data1,data2){const length=Math.min(data1.length,data2.length);let count=0;for(let i=0;i<length;i++)data1[i]===data2[i]&&count++;return count/Math.max(data1.length,data2.length)},self.webgazer.util.resizeEye=function(eye,resizeWidth,resizeHeight){var canvas=document.createElement("canvas");canvas.width=eye.width,canvas.height=eye.height,canvas.getContext("2d").putImageData(eye.patch,0,0);var tempCanvas=document.createElement("canvas");return tempCanvas.width=resizeWidth,tempCanvas.height=resizeHeight,tempCanvas.getContext("2d").drawImage(canvas,0,0,canvas.width,canvas.height,0,0,resizeWidth,resizeHeight),tempCanvas.getContext("2d").getImageData(0,0,resizeWidth,resizeHeight)},self.webgazer.util.bound=function(prediction){prediction.x<0&&(prediction.x=0),prediction.y<0&&(prediction.y=0);var w=Math.max(document.documentElement.clientWidth,window.innerWidth||0),h=Math.max(document.documentElement.clientHeight,window.innerHeight||0);prediction.x>w&&(prediction.x=w),prediction.y>h&&(prediction.y=h),prediction.filterx<0&&(prediction.filterx=0),prediction.filtery<0&&(prediction.filtery=0);var w=Math.max(document.documentElement.clientWidth,window.innerWidth||0),h=Math.max(document.documentElement.clientHeight,window.innerHeight||0);return prediction.filterx>w&&(prediction.filterx=w),prediction.filtery>h&&(prediction.filtery=h),prediction},self.webgazer.util.DebugBox=function(interval){var updateInterval,localThis;this.para=document.createElement("p"),this.div=document.createElement("div"),this.div.appendChild(this.para),document.body.appendChild(this.div),this.buttons={},this.canvas={},this.stats={},localThis=this,setInterval(function(){debugBoxWrite(localThis.para,localThis.stats)},interval||300)},self.webgazer.util.DebugBox.prototype.set=function(key,value){this.stats[key]=value},self.webgazer.util.DebugBox.prototype.inc=function(key,incBy,init){this.stats[key]||(this.stats[key]=init||0),this.stats[key]+=incBy||1},self.webgazer.util.DebugBox.prototype.addButton=function(name,func){this.buttons[name]||(this.buttons[name]=document.createElement("button"),this.div.appendChild(this.buttons[name]));var button=this.buttons[name];this.buttons[name]=button,button.addEventListener("click",func),button.innerText=name},self.webgazer.util.DebugBox.prototype.show=function(name,func){this.canvas[name]||(this.canvas[name]=document.createElement("canvas"),this.div.appendChild(this.canvas[name]));var canvas=this.canvas[name];canvas.getContext("2d").clearRect(0,0,canvas.width,canvas.height),func(canvas)},self.webgazer.util.KalmanFilter=function(F,H,Q,R,P_initial,X_initial){this.F=F,this.Q=Q,this.H=H,this.R=R,this.P=P_initial,this.X=X_initial},self.webgazer.util.KalmanFilter.prototype.update=function(z){for(var add=numeric.add,sub=numeric.sub,inv=numeric.inv,identity=numeric.identity,mult=webgazer.mat.mult,transpose=webgazer.mat.transpose,X_p=mult(this.F,this.X),P_p=add(mult(mult(this.F,this.P),transpose(this.F)),this.Q),y=sub(z,mult(this.H,X_p)),S=add(mult(mult(this.H,P_p),transpose(this.H)),this.R),K=mult(P_p,mult(transpose(this.H),inv(S))),i=0;i<y.length;i++)y[i]=[y[i]];return this.X=add(X_p,mult(K,y)),this.P=mult(sub(identity(K.length),mult(K,this.H)),P_p),transpose(mult(this.H,this.X))[0]}}();var store_points_var=!1,xPast50=new Array(50),yPast50=new Array(50);function store_points(x,y,k){xPast50[k]=x,yPast50[k]=y}!function(window,undefined){class LowPassFilter{setAlpha(alpha){(alpha<=0||alpha>1)&&console.log("alpha should be in (0.0., 1.0]"),this.a=alpha}constructor(alpha,initval=0){this.y=this.s=initval,this.setAlpha(alpha),this.initialized=!1}filter(value){var result;return this.initialized?result=this.a*value+(1-this.a)*this.s:(result=value,this.initialized=!0),this.y=value,this.s=result,result}filterWithAlpha(value,alpha){return this.setAlpha(alpha),this.filter(value)}hasLastRawValue(){return this.initialized}lastRawValue(){return this.y}reset(){this.initialized=!1}}class OneEuroFilter{alpha(cutoff){var te=1/this.freq,tau;return 1/(1+1/(2*Math.PI*cutoff)/te)}setFrequency(f){f<=0&&console.log("freq should be >0"),this.freq=f}setMinCutoff(mc){mc<=0&&console.log("mincutoff should be >0"),this.mincutoff=mc}setBeta(b){this.beta_=b}setDerivateCutoff(dc){dc<=0&&console.log("dcutoff should be >0"),this.dcutoff=dc}constructor(freq,mincutoff=1,beta_=0,dcutoff=1){this.setFrequency(freq),this.setMinCutoff(mincutoff),this.setBeta(beta_),this.setDerivateCutoff(dcutoff),this.x=new LowPassFilter(this.alpha(mincutoff)),this.dx=new LowPassFilter(this.alpha(dcutoff)),this.lasttime=undefined}reset(){this.x.reset(),this.dx.reset(),this.lasttime=undefined}filter(value,timestamp=undefined){this.lasttime!=undefined&&timestamp!=undefined&&(this.freq=1/(timestamp-this.lasttime)),this.lasttime=timestamp;var dvalue=this.x.hasLastRawValue()?(value-this.x.lastRawValue())*this.freq:0,edvalue=this.dx.filterWithAlpha(dvalue,this.alpha(this.dcutoff)),cutoff=this.mincutoff+this.beta_*Math.abs(edvalue);return this.x.filterWithAlpha(value,this.alpha(cutoff))}}var freqhz=120;window.euroFilterX=new OneEuroFilter(120,.3,.3,.005),window.euroFilterY=new OneEuroFilter(120,.3,.3,.005),window.updateMincutoff=function(mcf){console.log("[hehe] call updateMincutoff"),window.euroFilterX.setMinCutoff(mcf),window.euroFilterY.setMinCutoff(mcf)},window.updateBeta=function(bta){console.log("[hehe] call updateBeta"),window.euroFilterX.setBeta(bta),window.euroFilterY.setBeta(bta)},console.log("initializing webgazer"),window.webgazer=window.webgazer||{},webgazer=webgazer||{},webgazer.tracker=webgazer.tracker||{},webgazer.reg=webgazer.reg||{},webgazer.params=webgazer.params||{};var videoStream=null,videoElement=null,videoElementCanvas=null,faceOverlay=null,faceFeedbackBox=null,gazeDot=null,gazeFilterDot=null,gazeTobii=null;webgazer.params.videoElementId="webgazerVideoFeed",webgazer.params.videoElementCanvasId="webgazerVideoCanvas",webgazer.params.faceOverlayId="webgazerFaceOverlay",webgazer.params.faceFeedbackBoxId="webgazerFaceFeedbackBox",webgazer.params.gazeDotId="webgazerGazeDot",webgazer.params.videoViewerWidth=320,webgazer.params.videoViewerHeight=240,webgazer.params.faceFeedbackBoxRatio=.66;var dpi=document.createElement("div");dpi.setAttribute("id","dpi"),dpi.setAttribute("class","dpi"),document.body.appendChild(dpi),dpi_x=Math.max(1,dpi.offsetWidth),window.inch_width=screen.width/dpi_x,webgazer.params.eyesDistance=1050/window.inch_width,console.log("eye distance:"+webgazer.params.eyesDistance),webgazer.params.showVideo=!0,webgazer.params.showFaceOverlay=!0,webgazer.params.showFaceFeedbackBox=!0,webgazer.params.showGazeDot=!0,window.maxVideoWidth=320,webgazer.params.clmParams=webgazer.params.clmParams||{useWebGL:!0},webgazer.params.camConstraints=webgazer.params.camConstraints||{video:{width:{min:320,ideal:320,max:window.maxVideoWidth},height:{min:240,ideal:240,max:240},frameRate:{max:30},facingMode:"user"}},webgazer.params.smoothEyeBB=webgazer.params.smoothEyeBB||!1;var debugVideoLoc="",clockStart=performance.now();webgazer.params.dataTimestep=50;var latestEyeFeatures=null,latestGazeData=null,paused=!1,nopCallback=function(data,time){},callback=nopCallback,eventTypes=["click","move"],moveClock=performance.now();webgazer.params.moveTickSize=50;var curTracker=new webgazer.tracker.TFFaceMesh,regs=[new webgazer.reg.RidgeReg],curTrackerMap={TFFacemesh:function(){return new webgazer.tracker.TFFaceMesh}},regressionMap={ridge:function(){return new webgazer.reg.RidgeReg},weightedRidge:function(){return new webgazer.reg.RidgeWeightedReg},threadedRidge:function(){return new webgazer.reg.RidgeRegThreaded}},localstorageDataLabel="webgazerGlobalData",localstorageSettingsLabel="webgazerGlobalSettings",settings={},data=[],defaults={data:[],settings:{}};function checkEyesInValidationBox(){if(null!=faceFeedbackBox&&latestEyeFeatures){var w=videoElement.videoWidth,h=videoElement.videoHeight,smaller,boxSize=Math.min(w,h)*webgazer.params.faceFeedbackBoxRatio,topBound=(h-boxSize)/2,leftBound=(w-boxSize)/2,rightBound=leftBound+boxSize,bottomBound=topBound+boxSize,eyeLX=latestEyeFeatures.left.imagex,eyeLY=latestEyeFeatures.left.imagey,eyeRX=latestEyeFeatures.right.imagex,eyeRY=latestEyeFeatures.right.imagey,xPositions=!1,yPositions=!1,eyeDistance=!1;eyeLX>leftBound&&eyeLX<rightBound&&eyeRX>leftBound&&eyeRX<rightBound&&(xPositions=!0),eyeLY>topBound&&eyeLY<bottomBound&&eyeRY>topBound&&eyeRY<bottomBound&&(yPositions=!0),eyeRX-eyeLX>webgazer.params.eyesDistance*window.maxVideoWidth/640&&(eyeDistance=!0),webgazer.params.showFaceFeedbackBox&&xPositions&&yPositions&&eyeDistance?faceFeedbackBox.style.border="solid green":xPositions&&yPositions&&eyeDistance&&window.fi?faceFeedbackBox.style.border="none":faceFeedbackBox.style.border="solid red"}else faceFeedbackBox.style.border="solid black"}function checkCursor(){alert("Cursor at: "+cursorX+", "+cursorY)}function drawCoordinates(colour,x,y){var ctx=document.getElementById("plotting_canvas").getContext("2d");ctx.fillStyle=colour,ctx.beginPath(),ctx.arc(x,y,5,0,2*Math.PI,!0),ctx.fill()}function getPupilFeatures(canvas,width,height){if(canvas)try{return curTracker.getEyePatches(canvas,width,height)}catch(err){return console.log(err),null}}function paintCurrentFrame(canvas,width,height){var ctx;canvas.width!=width&&(canvas.width=width),canvas.height!=height&&(canvas.height=height),canvas.getContext("2d").drawImage(videoElement,0,0,canvas.width,canvas.height)}async function getPrediction(regModelIndex){var predictions=[];if(latestEyeFeatures=await getPupilFeatures(videoElementCanvas,videoElementCanvas.width,videoElementCanvas.height),0===regs.length)return console.log("regression not set, call setRegression()"),null;for(var reg in regs)predictions.push(regs[reg].predict(latestEyeFeatures));var output={};if(regModelIndex!==undefined){if(null!=predictions[regModelIndex]){var curTime=performance.now(),curPred=JSON.parse(JSON.stringify(predictions[regModelIndex]));output.x=euroFilterX.filter(curPred.x/window.innerWidth,curTime/1e3)*window.innerWidth,output.y=euroFilterY.filter(curPred.y/window.innerHeight,curTime/1e3)*window.innerHeight}return window.selfGazeCoord=output,null===predictions[regModelIndex]?null:{x:predictions[regModelIndex].x,y:predictions[regModelIndex].y,filterx:output.x,filtery:output.y,eyeFeatures:latestEyeFeatures}}var output={};if(null!=predictions[0]){var curTime=performance.now(),curPred=JSON.parse(JSON.stringify(predictions[0]));output.x=euroFilterX.filter(curPred.x/window.innerWidth,curTime/1e3)*window.innerWidth,output.y=euroFilterY.filter(curPred.y/window.innerHeight,curTime/1e3)*window.innerHeight}return window.selfGazeCoord=output,0===predictions.length||null===predictions[0]?null:{x:predictions[0].x,y:predictions[0].y,filterx:output.x,filtery:output.y,eyeFeatures:latestEyeFeatures,all:predictions}}webgazer.computeValidationBoxSize=function(){var vw=videoElement.videoWidth,vh=videoElement.videoHeight,pw=parseInt(videoElement.style.width),ph=parseInt(videoElement.style.height),smaller=Math.min(vw,vh),larger,scalar=vw==Math.max(vw,vh)?pw/vw:ph/vh,boxSize=smaller*webgazer.params.faceFeedbackBoxRatio*scalar,topVal,leftVal;return[(ph-boxSize)/2,(pw-boxSize)/2,boxSize,boxSize]};var smoothingVals=new webgazer.util.DataWindow(4),k=0;async function loop(){if(!paused){paintCurrentFrame(videoElementCanvas,videoElementCanvas.width,videoElementCanvas.height),latestGazeData=getPrediction();var elapsedTime=performance.now()-clockStart;if(latestGazeData=await latestGazeData,callback(latestGazeData,elapsedTime),webgazer.params.showFaceOverlay){var tracker=webgazer.getTracker();faceOverlay.getContext("2d").clearRect(0,0,videoElement.videoWidth,videoElement.videoHeight),tracker.drawFaceOverlay(faceOverlay.getContext("2d"),tracker.getPositions());var dialog=document.getElementById("help");document.getElementById("loading").style.display="none",dialog.open||setTimeout(function(){var dialog=document.getElementById("help");dialog.open||dialog.showModal()},100)}if(checkEyesInValidationBox(),latestGazeData){smoothingVals.push(latestGazeData);var x=0,y=0,filterx=0,filtery=0,len=smoothingVals.length;for(var d in smoothingVals.data)x+=smoothingVals.get(d).x,y+=smoothingVals.get(d).y,filterx+=smoothingVals.get(d).filterx,filtery+=smoothingVals.get(d).filtery;var pred=webgazer.util.bound({x:x/len,y:y/len,filterx:filterx/len,filtery:filtery/len});if(store_points_var&&(console.log("[hehe] store_points_var",store_points_var),store_points(pred.x,pred.y,k),50==++k&&(k=0)),gazeDot.style.transform="translate3d("+pred.x+"px,"+pred.y+"px,0)",gazeFilterDot.style.transform="translate3d("+pred.filterx+"px,"+pred.filtery+"px,0)",window.gaze=pred,"photo3d"==window.vizOption){var gazedAreaUuid=getGazedScreenDes(pred.filterx,pred.filtery);window.serverConnection&&1==window.serverConnection.readyState&&-1!=gazedAreaUuid?window.serverConnection.send(JSON.stringify({gaze:gazedAreaUuid,uuid:window.localUuid,gazeCoordX:pred.filterx,gazeCoordY:pred.filtery,dest:"all"})):window.serverConnection&&1==window.serverConnection.readyState&&window.serverConnection.send(JSON.stringify({gaze:"none",uuid:window.localUuid,gazeCoordX:pred.filterx,gazeCoordY:pred.filtery,dest:"all"}))}}else webgazer.params.showGazeDot=!1,gazeDot.style.display="none";requestAnimationFrame(loop)}}var getGazedDestination=function(x,y){var xRatio=x/window.innerWidth,yRatio=y/window.innerHeight;if(Object.keys(window.peerConnections).length>0){if(xRatio>.1&&xRatio<.49&&yRatio<.49)return 0;if(xRatio<.9&&xRatio>.51&&yRatio<.49)return 1;if(xRatio>.1&&xRatio<.49&&yRatio>.51)return 2;if(xRatio<.9&&xRatio>.51&&yRatio>.51)return 3}return-1},getGazedScreenDes=function(x,y){var dis=window.innerWidth/5,gazeDst=-1;for(let i in window.myCharList){var dx=window.myCharList[i].screenPosX-x,dy=window.myCharList[i].screenPosY-y,curDis=Math.sqrt(dx*dx+dy*dy);curDis<dis&&(gazeDst=window.myCharList[i].uuid.substring(12),dis=curDis)}return gazeDst},recordScreenPosition=function(x,y,eventType){if(!paused){if(0===regs.length)return console.log("regression not set, call setRegression()"),null;for(var reg in regs)latestEyeFeatures&&regs[reg].addData(latestEyeFeatures,[x,y],eventType)}},clickListener=async function(event){recordScreenPosition(event.clientX,event.clientY,eventTypes[0]),window.saveDataAcrossSessions&&await setGlobalData()},moveListener=function(event){if(!paused){var now=performance.now();now<moveClock+webgazer.params.moveTickSize||(moveClock=now,recordScreenPosition(event.clientX,event.clientY,eventTypes[1]))}},addMouseEventListeners=function(){document.addEventListener("click",clickListener,!0),document.addEventListener("mousemove",moveListener,!0)},removeMouseEventListeners=function(){document.removeEventListener("click",clickListener,!0),document.removeEventListener("mousemove",moveListener,!0)};async function loadGlobalData(){settings=(settings=await localforage.getItem(localstorageSettingsLabel))||defaults;var loadData=await localforage.getItem(localstorageDataLabel);for(var reg in data=loadData=loadData||defaults,regs)regs[reg].setData(loadData)}async function setGlobalData(){var storeData=regs[0].getData()||data;localforage.setItem(localstorageSettingsLabel,settings),localforage.setItem(localstorageDataLabel,storeData)}function clearData(){for(var reg in localforage.clear(),regs)regs[reg].init()}async function init(videoStream){var topDist="0px",leftDist="0px";function setupPreviewVideo(e){setInternalVideoBufferSizes(videoElement.videoWidth,videoElement.videoHeight),webgazer.setVideoViewerSize(webgazer.params.videoViewerWidth,webgazer.params.videoViewerHeight),document.body.appendChild(videoElementCanvas),document.body.appendChild(faceOverlay),document.body.appendChild(faceFeedbackBox),document.body.appendChild(gazeDot),document.body.appendChild(gazeFilterDot),document.body.appendChild(gazeTobii),e.target.removeEventListener(e.type,setupPreviewVideo)}(videoElement=document.createElement("video")).id=webgazer.params.videoElementId,videoElement.srcObject=videoStream,videoElement.autoplay=!0,videoElement.style.display=webgazer.params.showVideo?"block":"none",videoElement.style.position="fixed",videoElement.style.top="0px",videoElement.style.left="0px",videoElement.style.zIndex=2,videoElement.style.width=webgazer.params.videoViewerWidth+"px",videoElement.style.height=webgazer.params.videoViewerHeight+"px",(videoElementCanvas=document.createElement("canvas")).id=webgazer.params.videoElementCanvasId,videoElementCanvas.style.display="none",(faceOverlay=document.createElement("canvas")).id=webgazer.params.faceOverlayId,faceOverlay.style.display=webgazer.params.showFaceOverlay?"block":"none",faceOverlay.style.position="fixed",faceOverlay.style.top="0px",faceOverlay.style.left="0px",faceOverlay.style.zIndex=2,videoElement.style.setProperty("-moz-transform","scale(-1, 1)"),videoElement.style.setProperty("-webkit-transform","scale(-1, 1)"),videoElement.style.setProperty("-o-transform","scale(-1, 1)"),videoElement.style.setProperty("transform","scale(-1, 1)"),videoElement.style.setProperty("filter","FlipH"),faceOverlay.style.setProperty("-moz-transform","scale(-1, 1)"),faceOverlay.style.setProperty("-webkit-transform","scale(-1, 1)"),faceOverlay.style.setProperty("-o-transform","scale(-1, 1)"),faceOverlay.style.setProperty("transform","scale(-1, 1)"),faceOverlay.style.setProperty("filter","FlipH"),(faceFeedbackBox=document.createElement("canvas")).id=webgazer.params.faceFeedbackBoxId,faceFeedbackBox.style.display=webgazer.params.showFaceFeedbackBox?"block":"none",faceFeedbackBox.style.position="fixed",faceFeedbackBox.style.border="solid",faceFeedbackBox.style.zIndex=2,(gazeDot=document.createElement("div")).id=webgazer.params.gazeDotId,gazeDot.style.display="none",gazeDot.style.position="fixed",gazeDot.style.zIndex=99999,gazeDot.style.left="-5px",gazeDot.style.top="-5px",gazeDot.style.background="red",gazeDot.style.borderRadius="100%",gazeDot.style.opacity="0.7",gazeDot.style.width="10px",gazeDot.style.height="10px",(gazeFilterDot=document.createElement("div")).id=webgazer.params.gazeDotId+"filter",gazeFilterDot.style.display=webgazer.params.showGazeDot?"block":"none",gazeFilterDot.style.position="fixed",gazeFilterDot.style.zIndex=99998,gazeFilterDot.style.left="-5px",gazeFilterDot.style.top="-5px",gazeFilterDot.style.background="green",gazeFilterDot.style.borderRadius="100%",gazeFilterDot.style.opacity="0.5",gazeFilterDot.style.width="10px",gazeFilterDot.style.height="10px",(gazeTobii=document.createElement("div")).id=webgazer.params.gazeDotId+"tobii",gazeTobii.style.display="none",gazeTobii.style.position="fixed",gazeTobii.style.zIndex=99997,gazeTobii.style.left="-10px",gazeTobii.style.top="-10px",gazeTobii.style.background="blue",gazeTobii.style.borderRadius="100%",gazeTobii.style.opacity="0.3",gazeTobii.style.width="20px",gazeTobii.style.height="20px",document.body.appendChild(videoElement),videoElement.addEventListener("timeupdate",setupPreviewVideo),addMouseEventListeners(),paused=!1,clockStart=performance.now(),await loop()}function setUserMediaVariable(){navigator.mediaDevices===undefined&&(navigator.mediaDevices={}),navigator.mediaDevices.enumerateDevices().then(function(devices){devices.forEach(function(device){})}),navigator.mediaDevices.getUserMedia===undefined&&(navigator.mediaDevices.getUserMedia=function(constraints){var getUserMedia=navigator.webkitGetUserMedia||navigator.mozGetUserMedia;return getUserMedia?new Promise(function(resolve,reject){getUserMedia.call(navigator,constraints,resolve,reject)}):Promise.reject(new Error("Unfortunately, your browser does not support access to the webcam through the getUserMedia API. Try to use the latest version of Google Chrome, Mozilla Firefox, Opera, or Microsoft Edge instead."))})}function setInternalVideoBufferSizes(width,height){videoElementCanvas&&(videoElementCanvas.width=width,videoElementCanvas.height=height),faceOverlay&&(faceOverlay.width=width,faceOverlay.height=height)}webgazer.begin=function(onFail){return"https:"!==window.location.protocol&&"localhost"!==window.location.hostname&&window.chrome&&alert("WebGazer works only over https. If you are doing local development you need to run a local server."),window.saveDataAcrossSessions&&loadGlobalData(),onFail=onFail||function(){console.log("No stream")},debugVideoLoc?(init(debugVideoLoc),webgazer):(setUserMediaVariable(),(async()=>{let videoStream;try{init(videoStream=await navigator.mediaDevices.getUserMedia(webgazer.params.camConstraints))}catch(err){return onFail(),console.log(err),videoElement=null,videoStream=null,null}})(),webgazer)},webgazer.isReady=function(){return null!==videoElementCanvas&&videoElementCanvas.width>0},webgazer.pause=function(){return paused=!0,webgazer},webgazer.resume=async function(){return paused?(paused=!1,await loop(),webgazer):webgazer},webgazer.end=function(){return paused=!0,document.body.removeChild(videoElement),document.body.removeChild(videoElementCanvas),webgazer},webgazer.stopVideo=function(){return null.getTracks()[0].stop(),document.body.removeChild(faceOverlay),document.body.removeChild(faceFeedbackBox),webgazer},webgazer.detectCompatibility=function(){var getUserMedia;return(navigator.mediaDevices.getUserMedia||navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia)!==undefined},webgazer.showVideo=function(val){return webgazer.params.showVideo=val,videoElement&&(videoElement.style.display=val?"block":"none"),webgazer},webgazer.showFaceOverlay=function(val){return webgazer.params.showFaceOverlay=val,faceOverlay&&(faceOverlay.style.display=val?"block":"none"),webgazer},webgazer.showFaceFeedbackBox=function(val){return webgazer.params.showFaceFeedbackBox=val,webgazer},webgazer.showPredictionPoints=function(val){return webgazer.params.showGazeDot=val,gazeDot&&(gazeFilterDot.style.display=val?"block":"none"),webgazer},webgazer.setCameraConstraints=async function(constraints){webgazer.params.camConstraints=constraints},webgazer.setStaticVideo=function(videoLoc){return debugVideoLoc=videoLoc,webgazer},webgazer.setVideoViewerSize=function(w,h){webgazer.params.videoViewerWidth=w,webgazer.params.videoViewerHeight=h,videoElement.style.width=w+"px",videoElement.style.height=h+"px",faceOverlay.style.width=w+"px",faceOverlay.style.height=h+"px";var tlwh=webgazer.computeValidationBoxSize();faceFeedbackBox.style.top=tlwh[0]+"px",faceFeedbackBox.style.left=tlwh[1]+"px",faceFeedbackBox.style.width=tlwh[2]+"px",faceFeedbackBox.style.height=tlwh[3]+"px"},webgazer.addMouseEventListeners=function(){return addMouseEventListeners(),webgazer},webgazer.removeMouseEventListeners=function(){return removeMouseEventListeners(),webgazer},webgazer.recordScreenPosition=function(x,y){return recordScreenPosition(x,y,eventTypes[0]),webgazer},webgazer.recordScreenPosition=function(x,y,eventType){return recordScreenPosition(x,y,eventType),webgazer},webgazer.setTracker=function(name){if(curTrackerMap[name]===undefined){for(var t in console.log("Invalid tracker selection"),console.log("Options are: "),curTrackerMap)console.log(t);return webgazer}return curTracker=curTrackerMap[name](),webgazer},webgazer.setRegression=function(name){if(regressionMap[name]===undefined){for(var reg in console.log("Invalid regression selection"),console.log("Options are: "),regressionMap)console.log(reg);return webgazer}return data=regs[0].getData(),(regs=[regressionMap[name]()])[0].setData(data),webgazer},webgazer.addTrackerModule=function(name,constructor){curTrackerMap[name]=function(){return new constructor}},webgazer.addRegressionModule=function(name,constructor){regressionMap[name]=function(){return new constructor}},webgazer.addRegression=function(name){var newReg=regressionMap[name]();return data=regs[0].getData(),newReg.setData(data),regs.push(newReg),webgazer},webgazer.setGazeListener=function(listener){return callback=listener,webgazer},webgazer.clearGazeListener=function(){return callback=nopCallback,webgazer},webgazer.setVideoElementCanvas=function(canvas){videoElementCanvas=canvas},webgazer.clearData=async function(){clearData()},webgazer.getTracker=function(){return curTracker},webgazer.getRegression=function(){return regs},webgazer.getCurrentPrediction=function(){return getPrediction()},webgazer.params.getEventTypes=function(){return eventTypes.slice()},webgazer.getVideoElementCanvas=function(){return videoElementCanvas},webgazer.getVideoPreviewToCameraResolutionRatio=function(){return[webgazer.params.videoViewerWidth/videoElement.videoWidth,webgazer.params.videoViewerHeight/videoElement.videoHeight]}}(window);
//# sourceMappingURL=webgazer-compiled.min.js.map